<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++刷题 | Roger-Lv's space</title><meta name="author" content="Roger-Lv"><meta name="copyright" content="Roger-Lv"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构与算法[(459条消息) 【C语言】程序运行过程：预处理&#x2F;编译&#x2F;汇编&#x2F;链接_预处理编译汇编链接_慕雪华年的博客-CSDN博客](https:&#x2F;&#x2F;blog.csdn.net&#x2F;muxuen&#x2F;article&#x2F;details&#x2F;123227200?ops_request_misc&#x3D;%7B%22request%5Fid%22%3A%22168596052316800182">
<meta property="og:type" content="article">
<meta property="og:title" content="C++刷题">
<meta property="og:url" content="http://example.com/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Roger-Lv&#39;s space">
<meta property="og:description" content="数据结构与算法[(459条消息) 【C语言】程序运行过程：预处理&#x2F;编译&#x2F;汇编&#x2F;链接_预处理编译汇编链接_慕雪华年的博客-CSDN博客](https:&#x2F;&#x2F;blog.csdn.net&#x2F;muxuen&#x2F;article&#x2F;details&#x2F;123227200?ops_request_misc&#x3D;%7B%22request%5Fid%22%3A%22168596052316800182">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/c++.png">
<meta property="article:published_time" content="2024-06-23T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-13T03:53:24.324Z">
<meta property="article:author" content="Roger-Lv">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/c++.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++刷题",
  "url": "http://example.com/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/",
  "image": "http://example.com/img/cover/c++.png",
  "datePublished": "2024-06-23T16:00:00.000Z",
  "dateModified": "2025-08-13T03:53:24.324Z",
  "author": [
    {
      "@type": "Person",
      "name": "Roger-Lv",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://example.com/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.4.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++刷题',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">102</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Roger-Lv's space</span></a><a class="nav-page-title" href="/"><span class="site-name">C++刷题</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++刷题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-23T16:00:00.000Z" title="发表于 2024-06-24 00:00:00">2024-06-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-13T03:53:24.324Z" title="更新于 2025-08-13 11:53:24">2025-08-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" data-flag-title="C++刷题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p>[(459条消息) 【C语言】程序运行过程：预处理&#x2F;编译&#x2F;汇编&#x2F;链接_预处理编译汇编链接_慕雪华年的博客-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/123227200?ops_request_misc=%7B%22request_id%22:%22168596052316800182799736%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168596052316800182799736&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123227200-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E9%A2%84%E5%A4%84%E7%90%86">https://blog.csdn.net/muxuen/article/details/123227200?ops_request_misc=%7B%22request%5Fid%22%3A%22168596052316800182799736%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168596052316800182799736&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123227200-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=预处理</a> 编译 汇编 链接&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_54338498/article/details/126953046?ops_request_misc=%7B%22request_id%22:%22168175034116800197040062%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168175034116800197040062&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-126953046-null-null.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&utm_term=%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95&spm=1018.2226.3001.4187">(443条消息) 保研机试——1基础算法（排序、哈希、模拟（日期、图形、查找、进制、字符串）、递归与分治、贪心）_Yuezero_的博客-CSDN博客</a></p>
<p>[(425条消息) 数据结构保研面试题整理（自用）_保研数据结构常温问题_乌鸡摸鱼的博客-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52571748/article/details/120505195?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">https://blog.csdn.net/m0_52571748/article/details/120505195?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=数据结构</a> 保研&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-120505195.142^v73^pc_search_v2,201^v4^add_ask,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_53524653/article/details/121522229?ops_request_misc=%7B%22request_id%22:%22168740926216782425172942%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168740926216782425172942&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121522229-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187">(463条消息) 插入排序–折半插入排序（来一来，看一看，走过路过，不要错过）_老 胡的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/385907273">P问题、NP问题、NPC问题、NP-hard问题详解 - 知乎 (zhihu.com)</a></p>
<p>[保研机试整理 - 知乎 (zhihu.com)</p>
<p>什么时候才考虑用二分答案的技巧？<br>正向求出答案不好入手，求解答案远远没有验证答案简单。</p>
<p>已知前序后序算中序有多少种：</p>
<p>[<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37437983/article/details/79613947">(441条消息) 二叉树遍历（已知前序和后序遍历，求中序遍历的可能的序列数）_已知二叉树的前序遍历和后序遍历_我要出家当道士的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/40915131"></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yizhiniu_xuyw/article/details/109596961?ops_request_misc=%7B%22request_id%22:%22168707250016800213049573%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168707250016800213049573&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-109596961-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%A0%86%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1018.2226.3001.4187">(462条消息) 堆排序的时间复杂度分析_一只牛_007的博客-CSDN博客</a></p>
<p>建立索引树：[(462条消息) 2020北航计算机夏令营机试题目个人理解_北航夏令营 机试_四处碰壁嘤嘤怪的博客-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request_id%22:%22168715279416800185829257%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168715279416800185829257&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%8C%97%E8%88%AA%E5%A4%8F%E4%BB%A4%E8%90%A5">https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request%5Fid%22%3A%22168715279416800185829257%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168715279416800185829257&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=北航夏令营</a> 机试&amp;spm&#x3D;1018.2226.3001.4187)</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>scanf后，用getchar()吃掉回车</p>
<p>表示最大 INT_MAX(climits)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//malloc</span></span><br><span class="line"><span class="type">int</span> *nums;</span><br><span class="line">nums=(*<span class="type">int</span>)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//long long int 别用cin cout</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>scanf还会返回成功输入的变量的个数,因此可判定EOF</p>
<p>Floyd判圈法很吊</p>
<p>1.lower_bound(v.begin(), v.end(), key)-v.begin()返回有序序列中大于等于key的第一个值的位置<br>2.upper_bound(v.begin(), v.end(), key)-v.begin()返回有序序列中大于key的第一个值的位置<br>3.lower_bound(v.begin(), v.end(), key, greater<int>())-v.begin()返回有序序列中小于等于key的第一个值的位置<br>4.upper_bound(v.begin(), v.end(), key, greater<int>())-v.begin()返回有序序列中小于key的第一个值的位置<br>5.上述四个函数，若无满足条件的值，则返回v.size() </p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br></pre></td></tr></table></figure>



<h2 id="一些常用的库"><a href="#一些常用的库" class="headerlink" title="一些常用的库"></a>一些常用的库</h2><ol>
<li>algorithm</li>
<li>vector</li>
<li>map</li>
<li>queue</li>
<li>iostream</li>
<li>string</li>
<li>bits&#x2F;stdc++.h（带上就对了）</li>
<li>cmath(sqrt之类的)</li>
<li>climits（INT_MAX INT_MIN）</li>
</ol>
<p><strong>STL内置find()复杂度</strong>：<br><code>algorithm的find</code> 复杂度是<code>O(n)</code>，对vector，string等 顺序查询。<br><code>map::find</code> 和 <code>set::find</code> 复杂度是<code>O(logn)</code>，因为map和set底层都是红黑树。</p>
<hr>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector:"></a><strong>vector:</strong></h3><p>下面是一些常用的vector方法：</p>
<ol>
<li><p><code>push_back</code>：在vector的末尾添加一个元素。</p>
</li>
<li><p><code>pop_back</code>：删除vector末尾的一个元素。</p>
</li>
<li><p><code>size</code>：返回vector中元素的个数。</p>
</li>
<li><p><code>clear</code>：删除vector中所有的元素。</p>
</li>
<li><p><code>empty</code>：判断vector是否为空。</p>
</li>
<li><p><code>at</code>：返回vector中指定位置的元素。</p>
</li>
<li><p><code>front</code>：返回第一个元素。</p>
</li>
<li><p><code>back</code>：返回最后一个元素。</p>
</li>
<li><p><code>erase</code>：删除vector中指定位置的元素。</p>
</li>
<li><p><code>insert</code>：在vector中指定位置插入一个元素或多个元素。</p>
</li>
<li><p><code>resize</code>：改变vector的大小。</p>
</li>
<li><p><code>reserve</code>：为vector预留一定的空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>swap</code>：交换两个vector中的元素。</p>
</li>
<li><p><code>begin</code>：返回指向vector第一个元素的迭代器。</p>
</li>
<li><p><code>end</code>：返回指向vector最后一个元素之后的迭代器。 这些方法能够满足大部分情况下的需求，可以根据具体的使用场景选择合适的方法进行操作。</p>
</li>
</ol>
<p>要取迭代器的值，直接*指针取值</p>
<p>对于向量(vector)，它是一种支持随机访问的容器，因此<strong>可以直接通过下标访问向量中的元素</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 使用auto关键字定义迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vector不能直接使用sort函数进行排序，需要传入一个迭代器指定排序的范围。修改代码如下：</p>
<p>sort(v.begin(),v.end(),com);</p>
<hr>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h3><p>以下是C++中map类的常用方法：</p>
<ol>
<li><p>insert(make_pair&lt;key, value&gt;)：向map中插入一个键值对。</p>
</li>
<li><p>erase(key)：删除map中指定键的元素。</p>
</li>
<li><p>clear()：清空map中所有元素。</p>
</li>
<li><p>size()：返回map中元素的个数。</p>
</li>
<li><p>empty()：返回map是否为空。</p>
</li>
<li><p>find(key)：查找map中是否存在指定键的元素，如果存在则返回指向该元素的迭代器，否则返回end()迭代器。</p>
<p>常常和end联合起来用判断找到没。(<strong>这个适合动态查找，底层红黑树实现</strong>)</p>
</li>
<li><p>count(key)：返回指定键在map中出现的次数，如果不存在则返回0或1。</p>
</li>
<li><p>begin()：返回指向map第一个元素的迭代器。</p>
</li>
<li><p>end()：返回指向map最后一个元素后面的位置的迭代器。</p>
</li>
<li><p>operator[]：通过键访问map中的元素，如果键不存在，则自动插入一个新的键值对并返回对应的值。</p>
</li>
<li><p>lower_bound(key)：返回第一个大于或等于指定键的元素的迭代器。</p>
</li>
<li><p>upper_bound(key)：返回第一个大于指定键的元素的迭代器。</p>
</li>
<li><p>equal_range(key)：返回一个pair对象，其中包含lower_bound和upper_bound返回的迭代器。</p>
</li>
<li><p>swap(map2)：交换当前map和map2的元素。 C++中的map类是一种关联式容器，用于存储键值对，其中每个键都唯一，并且按照一定的顺序排列。map的底层实现通常是红黑树，因此查找、插入和删除操作的时间复杂度为O(log n)，其中n是map中元素的个数。map类提供了丰富的方法，可以方便地进行键值对的操作，例如插入、删除、查找、排序等。同时，由于map使用键值对来存储数据，因此可以将map看作是一种特殊的数组，其下标为键，对应的值为数组元素。因此，可以通过下标来访问和修改map中的元素。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;&#123;<span class="string">&quot;apple&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 使用auto关键字定义迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a><strong>stack</strong></h3><p>C++ 中的 stack 库提供了以下常用的方法：</p>
<ul>
<li>push(elem)：将元素 elem 压入栈顶。</li>
<li>pop()：弹出栈顶元素。</li>
<li>top()：返回栈顶元素，但不弹出。</li>
<li>empty()：判断栈是否为空。</li>
<li>size()：返回栈中元素的个数。 除此之外，stack 还支持以下操作：</li>
<li>emplace(args…)：构造一个新元素并将其压入栈顶。</li>
<li>swap(stack)：交换两个 stack 的元素。</li>
<li>operator&#x3D;&#x3D;、operator!&#x3D;、operator&lt;、operator&lt;&#x3D;、operator&gt;、operator&gt;&#x3D;：比较两个 stack 是否相等、不相等、小于、小于等于、大于、大于等于。 具体用法可以参考下面的示例代码</li>
</ul>
<p>stack元素可以是任何类型。</p>
<hr>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a><strong>queue</strong></h3><p>C++中的queue是一种容器适配器，用于实现“先进先出”（FIFO）的数据结构。queue基于deque或list进行实现，提供了一些方法来操作队列，包括入队、出队、获取队首元素、获取队列大小等。以下是queue的常用方法：</p>
<ol>
<li>push(element)：将一个元素加入队列的尾部。</li>
<li>pop()：将队列头部的元素弹出，但没有返回值。</li>
<li>front()：返回队列头部的元素。</li>
<li>top():返回队列头部元素（和front一样）</li>
<li>back()：返回队列尾部的元素。</li>
<li>empty()：判断队列是否为空。</li>
<li>size()：返回队列中元素的个数。 使用queue需要包含头文件，可以通过以下方式创建一个queue对象：</li>
</ol>
<p>对于队列(queue)，由于它是一种先进先出(FIFO)的数据结构，因此只能通过front()和back()函数来访问队列的头部和尾部元素，<strong>而不能直接通过下标访问</strong>。如果要使用下标访问队列元素，需要先将队列转换为数组或向量。 </p>
<hr>
<h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a><strong>priority_queue</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;string&gt; b;</span><br></pre></td></tr></table></figure>



<p>对于优先队列，复杂结构类型要重载运算符<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27278957/article/details/85269245?ops_request_misc=%7B%22request_id%22:%22168033538216800213097640%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168033538216800213097640&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-85269245-null-null.142%5Ev80%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=c++%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1018.2226.3001.4187">(436条消息) C++ 运算符重载_c 重载运算符_高祥xiang的博客-CSDN博客</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="type">int</span> real;</span><br><span class="line"><span class="type">int</span> imag;</span><br><span class="line">......</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Complex c)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> real*real+imag*imag&lt;c.real*c.real+c.imag*c.imag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面这个const是必须要有的</p>
<hr>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a><strong>string</strong></h3><p>C++中的string类是一个封装了字符串操作的类，提供了一系列方法来处理和操作字符串。以下是常用的string类方法：</p>
<ol>
<li><p>length()：返回字符串的长度。</p>
</li>
<li><p>size()：返回字符串的长度。</p>
</li>
<li><p>clear()：清空字符串。</p>
</li>
<li><p>empty()：判断字符串是否为空。</p>
</li>
<li><p>assign(str)：将字符串的值设置为str。</p>
</li>
<li><p>assign(str, pos, len)：将字符串的值设置为str中从pos位置开始的长度为len的子串。</p>
</li>
<li><p>append(str)：在字符串的末尾添加str。</p>
</li>
<li><p>append(str, pos, len)：在字符串的末尾添加str中从pos位置开始的长度为len的子串。</p>
</li>
<li><p>push_back(ch)：在字符串的末尾添加一个字符。</p>
</li>
<li><p>insert(pos, str)：在字符串的pos位置插入str。</p>
</li>
<li><p>erase(pos, len)：删除从pos位置开始长度为len的子串。</p>
<p>erase(n):删除indexn后面的字符</p>
</li>
<li><p>replace(pos, len, str)：替换从pos位置开始长度为len的子串为str。</p>
</li>
<li><p><strong>substr(pos, len)：返回从pos位置开始长度为len的子串。</strong></p>
</li>
<li><p><strong>find(str)：查找str在字符串中第一次出现的位置，返回该位置的索引值。</strong>(找不到就是-1)</p>
</li>
<li><p>rfind(str)：查找str在字符串中最后一次出现的位置，返回该位置的索引值。</p>
</li>
<li><p>compare(str)：比较字符串和str的大小，返回0（相等）、1（大于）或-1（小于）。 除了以上列举的方法，string类还支持重载运算符，例如+（字符串拼接）、+&#x3D;（字符串拼接赋值）、&#x3D;&#x3D;（字符串相等判断）、[]（访问字符串中指定位置的字符）等。string类的使用非常方便，可以像使用普通变量一样对字符串进行赋值、拼接、查找、替换等操作。例如：</p>
</li>
</ol>
<p>注意string s，其s[i]类型为char，char强制类型转换可以这样转换</p>
<p>string(1,s[i])，1表示char长度</p>
<p>s[i]可以直接比较</p>
<p>输入str1,如果str1为空则退出</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\11505\AppData\Roaming\Typora\typora-user-images\image-20230313213418581.png" alt="image-20230313213418581"></p>
<p>scanf不会读回车，如果下一行是gets会直接读取缓冲区中的回车，所有会用一个getchar()在中间把缓冲区中的回车抵消掉</p>
<p>stoi(str) 将其转换为整数，注意，如果是”04”,直接变成4</p>
<p>string::npos用于判断结尾（其实找不到直接-1也行）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find函数返回 jk 在 s 中的下标位置</span></span><br><span class="line">	position = s.<span class="built_in">find</span>(<span class="string">&quot;jk&quot;</span>);</span><br><span class="line">	<span class="comment">// 如果没找到，返回一个特别的标志</span></span><br><span class="line">	<span class="comment">// c++中用npos表示，我这里npos取值是4294967295</span></span><br><span class="line">	<span class="keyword">if</span>(position != s.npos)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;position: &quot;</span> &lt;&lt; position &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Not found the flag&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果输入的字符串有空格，那么用如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin,str)</span><br></pre></td></tr></table></figure>

<p>可以直接通过下标修改字符</p>
<p>删除字符串内重复字符:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;aadfgggh&quot;</span>;</span><br><span class="line"><span class="comment">//去重复</span></span><br><span class="line"><span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="built_in">unique</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>()),str.<span class="built_in">end</span>());  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除字符串内某个指定字符:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;aadfgggh&quot;</span>;</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>(),<span class="string">&#x27;a&#x27;</span>),str.<span class="built_in">end</span>()); <span class="comment">//在容器中, 删除[begin,end)之间的所有值等于&#x27;a&#x27;的值.</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line">string::<span class="built_in">erase</span>(begin,end)：删除[begin,end)之间的所有值c</span><br></pre></td></tr></table></figure>



<p>在Find the Smallest Number中，我发现string的超出index一位的位置依然可以访问，但是没有数</p>
<hr>
<h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a><strong>algorithm</strong></h3><p>C++标准库中的algorithm库提供了许多常用的算法，这些算法可以用于处理容器中的数据，例如排序、查找、遍历等。以下是algorithm库中常用的方法：</p>
<ol>
<li>sort(first, last, func)：对[first, last)区间内的元素进行升&#x2F;降序排序（取决于func返回）。</li>
<li>reverse(first, last)：对[first, last)区间内的元素进行翻转。</li>
<li>find(first, last, val)：在[first, last)区间内查找值为val的元素，返回该元素的迭代器。如果没有找到，返回last。</li>
<li>find_if(first, last, pred)：在[first, last)区间内查找满足条件pred的第一个元素，返回该元素的迭代器。如果没有找到，返回last。</li>
<li>count(first, last, val)：统计[first, last)区间内值为val的元素个数。</li>
<li>count_if(first, last, pred)：统计[first, last)区间内满足条件pred的元素个数。</li>
<li>accumulate(first, last, init)：对[first, last)区间内的元素进行累加，初始值为init。</li>
<li>max_element(first, last)：返回[first, last)区间内的最大元素的迭代器。</li>
<li>min_element(first, last)：返回[first, last)区间内的最小元素的迭代器。</li>
<li>unique(first, last)：对[first, last)区间内的元素去重，返回去重后的末尾迭代器。</li>
<li>remove(first, last, val)：删除[first, last)区间内值为val的元素，返回删除后的末尾迭代器。</li>
<li>remove_if(first, last, pred)：删除[first, last)区间内满足条件pred的元素，返回删除后的末尾迭代器。</li>
<li>for_each(first, last, func)：对[first, last)区间内的元素执行操作func。</li>
<li>transform(first1, last1, first2, result, op)：将[first1, last1)区间内的元素和[first2, …)区间内的元素进行op操作，并将结果存储到[result, …)区间内。</li>
</ol>
<h3 id="climits"><a href="#climits" class="headerlink" title="climits"></a>climits</h3><p><climits>中定义的常量主要有以下几种：</p>
<ol>
<li>整数类型的最大值和最小值：INT_MAX、INT_MIN、LONG_MAX、LONG_MIN、SHRT_MAX、SHRT_MIN等等。</li>
<li>字符类型的最大值和最小值：CHAR_MAX、CHAR_MIN、SCHAR_MAX、SCHAR_MIN、UCHAR_MAX等等。</li>
<li>位数相关的常量：CHAR_BIT、INT_BIT、LONG_BIT等等。</li>
<li>其他常量：MB_LEN_MAX表示一个多字节字符的最大长度，FLT_MAX、FLT_MIN、DBL_MAX、DBL_MIN等等表示浮点类型的最大值和最小值。</li>
</ol>
<h2 id="设置输出精度"><a href="#设置输出精度" class="headerlink" title="设置输出精度"></a>设置输出精度</h2><p>设置输出精度为1位小数</p>
<p>cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; ans &lt;&lt; endl</p>
<h2 id="设置输出位数"><a href="#设置输出位数" class="headerlink" title="设置输出位数"></a>设置输出位数</h2><p>printf(“%02d”,&amp;)</p>
<p>前面补零，两位，不够两位就补零</p>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83334559">KMP 算法详解 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/v_JULY_v/article/details/7041827?ops_request_misc=%7B%22request_id%22:%22167957843316800227474381%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167957843316800227474381&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-7041827-null-null.142%5Ev76%5Epc_new_rank,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=KMP&spm=1018.2226.3001.4187">(427条消息) 从头到尾彻底理解KMP（2014年8月22日版）_kmp算法难吗是什么级别_v_JULY_v的博客-CSDN博客</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(<span class="type">char</span>* p,<span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k]) </span><br><span class="line">		&#123;</span><br><span class="line">			++k;</span><br><span class="line">			++j;</span><br><span class="line">			next[j] = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kmp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">	<span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    </span></span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    </span></span><br><span class="line">			<span class="comment">//next[j]即为j所对应的next值      </span></span><br><span class="line">			j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j == pLen)</span><br><span class="line">		<span class="keyword">return</span> i - j;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="最大连续子序列"><a href="#最大连续子序列" class="headerlink" title="最大连续子序列"></a>最大连续子序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> nums[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> N;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;N)&#123;</span><br><span class="line">		<span class="keyword">if</span> (N==EOF)<span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> maxnum=INT_MIN;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			cin&gt;&gt;nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">		dp[<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (N==<span class="number">1</span>)&#123;</span><br><span class="line">			cout&lt;&lt;dp[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			dp[i]=<span class="built_in">max</span>(nums[i],dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">			maxnum=<span class="built_in">max</span>(dp[i],maxnum);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="最大子矩阵"><a href="#最大子矩阵" class="headerlink" title="最大子矩阵"></a>最大子矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> matrix[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> support[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hangmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxnum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		dp[i]=<span class="built_in">max</span>(arr[i],dp[i<span class="number">-1</span>]+arr[i]);</span><br><span class="line">		maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">allmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxnum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (i==<span class="number">1</span>)&#123;</span><br><span class="line">					arr[k]=support[j][k];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					arr[k]=support[j][k]-support[i<span class="number">-1</span>][k];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			maxnum=<span class="built_in">max</span>(<span class="built_in">hangmax</span>(n),maxnum);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			cin&gt;&gt;matrix[i][j];</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (i==<span class="number">1</span>)support[i][j]=matrix[i][j];</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				support[i][j]=matrix[i][j]+support[i<span class="number">-1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> maxnum;</span><br><span class="line">	maxnum=<span class="built_in">allmax</span>(n);</span><br><span class="line">	cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长递增-减序列"><a href="#最长递增-减序列" class="headerlink" title="最长递增&#x2F;减序列"></a>最长递增&#x2F;减序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> daodan[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxnum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		dp[i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (daodan[i]&lt;=daodan[j])</span><br><span class="line">			dp[i]=<span class="built_in">max</span>(<span class="number">1</span>,dp[j]<span class="number">+1</span>);</span><br><span class="line">			maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;daodan[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> maxnum;</span><br><span class="line">	maxnum=<span class="built_in">countmax</span>(n);</span><br><span class="line">	cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大上升子序列和（O-N-2-）"><a href="#最大上升子序列和（O-N-2-）" class="headerlink" title="最大上升子序列和（O(N^2)）"></a>最大上升子序列和（O(N^2)）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> nums[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxsum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		dp[i]=nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i]&gt;nums[j])</span><br><span class="line">			dp[i]=<span class="built_in">max</span>(nums[i],dp[j]+nums[i]);</span><br><span class="line">			maxsum=<span class="built_in">max</span>(maxsum,dp[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> maxsum;</span><br><span class="line">	<span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">		cout&lt;&lt;nums[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	maxsum=<span class="built_in">countmax</span>(n);</span><br><span class="line">	cout&lt;&lt;maxsum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h3><p>1<br>7<br>3<br>5<br>9<br>4<br>8<br>3</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lxt_Lucia/article/details/81209962?ops_request_misc=%7B%22request_id%22:%22168639963816800225544693%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168639963816800225544693&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81209962-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=LCS&spm=1018.2226.3001.4187">(461条消息) 最长公共子序列 (LCS) 详解+例题模板（全）_lxt_Lucia的博客-CSDN博客</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s1;</span><br><span class="line">string s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(string s1,string s2)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> length1=s<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> length2=s<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> dp[length1][length2];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;length1;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;length2;j++)&#123;</span><br><span class="line">			dp[i][j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> maxnum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;length1;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;length2;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (s1[i]==s2[j])&#123;</span><br><span class="line">				<span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">					dp[i][j]=<span class="number">1</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">					dp[i][j]=<span class="number">0</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			maxnum=<span class="built_in">max</span>(maxnum,dp[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;s1&gt;&gt;s2)&#123;</span><br><span class="line">		<span class="type">int</span> maxnum=<span class="built_in">countmax</span>(s1,s2);</span><br><span class="line">		cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LIS（Nlogn）"><a href="#LIS（Nlogn）" class="headerlink" title="LIS（Nlogn）"></a>LIS（Nlogn）</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lxt_Lucia/article/details/81206439?ops_request_misc=%7B%22request_id%22:%22168766303316800185860492%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168766303316800185860492&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81206439-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97&spm=1018.2226.3001.4187">(465条消息) 最长上升子序列 (LIS) 详解+例题模板 (全)_lxt_Lucia的博客-CSDN博客</a></p>
<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">d</span>&#123;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> C,N;</span><br><span class="line">	<span class="keyword">while</span> (cin&gt;&gt;C&gt;&gt;N)&#123;</span><br><span class="line">		<span class="keyword">if</span> (C==<span class="number">0</span>&amp;&amp;N==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> dp[C<span class="number">+1</span>];</span><br><span class="line">		d deal[N];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=C;i++)&#123;</span><br><span class="line">			dp[i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">			<span class="type">int</span> price;</span><br><span class="line">			<span class="type">int</span> score;</span><br><span class="line">			cin&gt;&gt;price&gt;&gt;score;</span><br><span class="line">			deal[i].price=price;</span><br><span class="line">			deal[i].score=score;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=C;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">				<span class="keyword">if</span> (j&gt;=deal[i].price)&#123;</span><br><span class="line">					dp[j]=<span class="built_in">max</span>(dp[j-deal[i].price]+deal[i].score,dp[j]);</span><br><span class="line">				&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		cout&lt;&lt;dp[C]&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有个背包的变种</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41994332/article/details/115829716?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-115829716-blog-109011034.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-115829716-blog-109011034.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=1">(465条消息) 复旦大学2021年计算机学院机试题解_复旦oj_PyKt的博客-CSDN博客</a></p>
<p>这里是直接顺序的</p>
<h2 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS BFS"></a>DFS BFS</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> hight)</span>  <span class="comment">//合并函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>[hight - low + <span class="number">1</span>];  <span class="comment">//用 new 申请一个辅助函数</span></span><br><span class="line">	<span class="type">int</span> i = low, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;    <span class="comment">// k为 b 数组的小标</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= hight)  </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">		&#123;</span><br><span class="line">			b[k++] = a[i++];  <span class="comment">//按从小到大存放在 b 数组里面</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			b[k++] = a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid)  <span class="comment">// j 序列结束，将剩余的 i 序列补充在 b 数组中 </span></span><br><span class="line">	&#123;</span><br><span class="line">		b[k++] = a[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= hight)<span class="comment">// i 序列结束，将剩余的 j 序列补充在 b 数组中 </span></span><br><span class="line">	&#123;</span><br><span class="line">		b[k++] = a[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	k = <span class="number">0</span>;  <span class="comment">//从小标为 0 开始传送</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= hight; i++)  <span class="comment">//将 b 数组的值传递给数组 a</span></span><br><span class="line">	&#123;</span><br><span class="line">		a[i] = b[k++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[]b;     <span class="comment">// 辅助数组用完后，将其的空间进行释放（销毁）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> hight)</span> <span class="comment">//归并排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; hight)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid = (low + hight) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">mergesort</span>(a, low, mid);          <span class="comment">//对 a[low,mid]进行排序</span></span><br><span class="line">		<span class="built_in">mergesort</span>(a, mid + <span class="number">1</span>, hight);    <span class="comment">//对 a[mid+1,hight]进行排序</span></span><br><span class="line">		<span class="built_in">merge</span>(a, low, mid, hight);       <span class="comment">//进行合并操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, a[<span class="number">100</span>];</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入数列中的元素个数 n 为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请依次输入数列中的元素：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">mergesort</span>(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;归并排序结果&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> m=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quickpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="comment">//与运算，可判断奇偶，详细见注释</span></span><br><span class="line">		sum=sum*a%m;<span class="comment">//取模运算</span></span><br><span class="line">		a=a*a%m;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;<span class="comment">//位运算，右移，相当于除以2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="模拟问题"><a href="#模拟问题" class="headerlink" title="模拟问题"></a>模拟问题</h2><p>就是找规律，还行</p>
<h2 id="日期问题"><a href="#日期问题" class="headerlink" title="日期问题"></a>日期问题</h2><p>要预处理</p>
<h2 id="最大公因数-最小公倍数"><a href="#最大公因数-最小公倍数" class="headerlink" title="最大公因数&#x2F;最小公倍数"></a>最大公因数&#x2F;最小公倍数</h2><p>最小公倍数&#x3D;a*b&#x2F;c</p>
<p>c为最大公因数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大公因数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">biggest</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b!=<span class="number">0</span>?<span class="built_in">biggest</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最小公倍数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">smallest</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">   	<span class="type">int</span> big=<span class="built_in">biggest</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> a*b/big;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (cin&gt;&gt;n)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (n==<span class="number">2</span>)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">bool</span> sushu[n<span class="number">+1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			sushu[i]=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (sushu[i]==<span class="literal">false</span>)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=i;j*i&lt;=n;j++)&#123; <span class="comment">//j直接从i开始，提高效率</span></span><br><span class="line">				<span class="keyword">if</span> (j*i&lt;n)&#123;</span><br><span class="line">					sushu[j*i]=<span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (sushu[i])&#123;</span><br><span class="line">				<span class="keyword">if</span> (i%<span class="number">10</span>==<span class="number">1</span>)&#123;</span><br><span class="line">					cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个数n，其质因数最多只有一个大于其平方根！</p>
<h2 id="矩阵乘法（构造函数）"><a href="#矩阵乘法（构造函数）" class="headerlink" title="矩阵乘法（构造函数）"></a>矩阵乘法（构造函数）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">	<span class="type">int</span> matrix[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> row;</span><br><span class="line">	<span class="type">int</span> col;</span><br><span class="line">	<span class="built_in">Matrix</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">row</span>(a),<span class="built_in">col</span>(b)&#123;&#125;<span class="comment">//注意构造函数的写法</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Matrix <span class="title">Multiply</span><span class="params">(Matrix a,Matrix b)</span></span>&#123;</span><br><span class="line">	Matrix ans=<span class="built_in">Matrix</span>(a.row,b.col);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.row;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;b.col;j++)&#123;</span><br><span class="line">			<span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;a.col;k++)&#123;</span><br><span class="line">				temp+=a.matrix[i][k]*b.matrix[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">			ans.matrix[i][j]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMatrix</span><span class="params">(Matrix m)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> row=m.row;</span><br><span class="line">	<span class="type">int</span> col=m.col;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (j!=<span class="number">0</span>)&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;m.matrix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Matrix a=<span class="built_in">Matrix</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">	Matrix b=<span class="built_in">Matrix</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">			cin&gt;&gt;a.matrix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">			cin&gt;&gt;b.matrix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Matrix c=<span class="built_in">Multiply</span>(a,b);</span><br><span class="line">	<span class="built_in">printMatrix</span>(c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?spm=1000.2115.3001.4498&q=prim%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91&t=&u=">prim算法求最小生成树- CSDN搜索</a></p>
<p>kruscal</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&gt;(edge c)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> weight&gt;c.weight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">edge</span>(<span class="type">int</span> q,<span class="type">int</span> w,<span class="type">int</span> e):<span class="built_in">a</span>(q),<span class="built_in">b</span>(w),<span class="built_in">weight</span>(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;edge,vector&lt;edge&gt;,greater&lt;edge&gt;&gt;edges;</span><br><span class="line"><span class="type">int</span> graph[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (graph[x]==<span class="number">-1</span>)<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> temp;</span><br><span class="line">	temp=<span class="built_in">find</span>(graph[x]);</span><br><span class="line">	graph[x]=temp;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (cin&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> a,b,weight;</span><br><span class="line">		<span class="type">int</span> num=n*(n<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">memset</span>(graph,<span class="number">-1</span>,<span class="built_in">sizeof</span>(graph));</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			graph[i]=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (num--)&#123;</span><br><span class="line">			cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">			edge edge1=<span class="built_in">edge</span>(a,b,weight);</span><br><span class="line">			edges.<span class="built_in">push</span>(edge1);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (!edges.<span class="built_in">empty</span>()&amp;&amp;count&lt;n<span class="number">-1</span>)&#123;</span><br><span class="line">			edge temp=edges.<span class="built_in">top</span>();</span><br><span class="line">			edges.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="type">int</span> a=<span class="built_in">find</span>(temp.a);</span><br><span class="line">			<span class="type">int</span> b=<span class="built_in">find</span>(temp.b);</span><br><span class="line">			<span class="type">int</span> weight=temp.weight;</span><br><span class="line">			<span class="keyword">if</span> (a!=b)&#123;</span><br><span class="line">				graph[a]=b;</span><br><span class="line">				count++;</span><br><span class="line">				sum+=weight;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="弗洛伊德"><a href="#弗洛伊德" class="headerlink" title="弗洛伊德"></a>弗洛伊德</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;k ++) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++) &#123; </span><br><span class="line"> <span class="keyword">if</span> (ans[i][k] == 无穷 || ans[k][j] == 无穷) <span class="keyword">continue</span>; </span><br><span class="line"> <span class="keyword">if</span> (ans[i][j] == 无穷 || ans[i][k] + ans[k][j] &lt; ans[i][j]) </span><br><span class="line"> ans[i][j] = ans[i][k] + ans[k][j]; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<h2 id="迪杰斯特拉"><a href="#迪杰斯特拉" class="headerlink" title="迪杰斯特拉"></a>迪杰斯特拉</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123; <span class="comment">//初始化</span></span><br><span class="line"> Dis[i] = <span class="number">-1</span>; <span class="comment">//所有距离为-1，即不可达</span></span><br><span class="line"> mark[i] = <span class="literal">false</span>; <span class="comment">//所有结点不属于集合K</span></span><br><span class="line"> &#125; </span><br><span class="line"> Dis[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//得到最近的点为结点1,长度为0</span></span><br><span class="line"> mark[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//将结点1加入集合K</span></span><br><span class="line"> <span class="type">int</span> newP = <span class="number">1</span>; <span class="comment">//集合K中新加入的点为结点1 </span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i ++) &#123; <span class="comment">//循环n-1次,按照最短路径递增的顺序确定其他n-1个点的最短路径长度</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; edge[newP].<span class="built_in">size</span>();j ++) &#123; <span class="comment">//遍历与该新加入集合</span></span><br><span class="line">K中的结点直接相邻的边</span><br><span class="line"> <span class="type">int</span> t = edge[newP][j].next; <span class="comment">//该边的另一个结点</span></span><br><span class="line"> <span class="type">int</span> c = edge[newP][j].c; <span class="comment">//该边的长度</span></span><br><span class="line"> <span class="keyword">if</span> (mark[t] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">//若另一个结点也属于集合K,则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[t] == - <span class="number">1</span> || Dis[t] &gt; Dis[newP] + c) <span class="comment">//若该结点尚不可</span></span><br><span class="line">达,或者该结点从新加入的结点经过一条边到达时比以往距离更短</span><br><span class="line"> Dis[t] = Dis[newP] + c; <span class="comment">//更新其距离信息</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="type">int</span> min = <span class="number">123123123</span>; <span class="comment">//最小值初始化为一个大整数,为找最小值做准备</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++) &#123; <span class="comment">//遍历所有结点</span></span><br><span class="line"> <span class="keyword">if</span> (mark[j] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">//若其属于集合K则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[j] == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">//若该结点仍不可达则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[j] &lt; min) &#123; <span class="comment">//若该结点经由结点1至集合K中的某点在经过一条</span></span><br><span class="line">边到达时距离小于当前最小值</span><br><span class="line"> min = Dis[j]; <span class="comment">//更新其为最小值</span></span><br><span class="line"> newP = j; <span class="comment">//新加入的点暂定为该点</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉回路（hierholzer）"><a href="#欧拉回路（hierholzer）" class="headerlink" title="欧拉回路（hierholzer）"></a>欧拉回路（hierholzer）</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44316314/article/details/96898445?ops_request_misc=%7B%22request_id%22:%22168707940816800182775723%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168707940816800182775723&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-96898445-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E7%9A%84%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(462条消息) 欧拉回路（hierholzer算法）_逐步插入回路法_run around的博客-CSDN博客</a></p>
<h2 id="关键路径（AOE网）"><a href="#关键路径（AOE网）" class="headerlink" title="关键路径（AOE网）"></a>关键路径（AOE网）</h2><p>最早开始时间&#x3D;最晚开始时间</p>
<p>用拓扑图</p>
<p>最早开始时间（所有先序活动的最晚完成时间）</p>
<p>最晚开始时间（所有后续活动的最早开始时间减去该活动花费的时间）</p>
<p>注意源点的最早开始时间不一定为0，要初始化</p>
<p>汇点的最晚开始时间初始化为totalTime-该汇点任务的时间</p>
<p>非汇点的最晚开始时间为无穷</p>
<p>如果只是要求关键路径的长度，其实在earliest[i]初始化的时候就设置为任务的时间就行，但如果要算其他的，就还是设置为0</p>
<p>7 5<br>11 20 17 10 11 17 17<br>5 4<br>6 1<br>7 3<br>2 4<br>2 1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yushu 1e9+7</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;zero;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;re;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> in[<span class="number">100001</span>];</span><br><span class="line">vector&lt;edge&gt;edges[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> task[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> earliest[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> latest[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		in[i]=<span class="number">0</span>;</span><br><span class="line">		cin&gt;&gt;task[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> num=m;</span><br><span class="line">	<span class="type">int</span> allTime=<span class="number">0</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;input edge&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">while</span> (num--)&#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		in[b]++;</span><br><span class="line">		edge temp;</span><br><span class="line">		temp.to=b;</span><br><span class="line">		temp.weight=task[b];</span><br><span class="line">		edges[a].<span class="built_in">push_back</span>(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;input finished.&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[i]&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">if</span> (in[i]==<span class="number">0</span>)&#123;</span><br><span class="line">			zero.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!zero.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> node=zero.<span class="built_in">front</span>();</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;zero:&quot;</span>&lt;&lt;node&lt;&lt;endl;</span><br><span class="line">		zero.<span class="built_in">pop</span>();</span><br><span class="line">		re.<span class="built_in">push_back</span>(node);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;edges[node].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">			<span class="type">int</span> to=edges[node][i].to;</span><br><span class="line">			<span class="type">int</span> weight=edges[node][i].weight;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;edge:&quot;</span>&lt;&lt;node&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;to&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;weight&lt;&lt;endl;</span><br><span class="line">			earliest[to]=<span class="built_in">max</span>(earliest[to],earliest[node]+task[node]);</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;to&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[to]&lt;&lt;endl;</span><br><span class="line">			in[to]--;</span><br><span class="line">			<span class="keyword">if</span> (in[to]==<span class="number">0</span>)&#123;</span><br><span class="line">				zero.<span class="built_in">push</span>(to);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		allTime=<span class="built_in">max</span>(allTime,earliest[i]+task[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;reverse:&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=re.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="type">int</span> u=re[i];</span><br><span class="line">		<span class="keyword">if</span> (edges[u].<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">			latest[u]=allTime-task[u];</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;latest:[&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[u]&lt;&lt;endl;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			latest[u]=<span class="number">99999999</span>;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;edges[u].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">			<span class="type">int</span> to=edges[u][j].to;</span><br><span class="line">			<span class="type">int</span> weight=edges[u][j].weight;</span><br><span class="line">			latest[u]=<span class="built_in">min</span>(latest[u],latest[to]-task[u]);</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;latest:[&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[u]&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[i]&lt;&lt;endl;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;latest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		sum*=(latest[i]-earliest[i]<span class="number">+1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;allTime&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011240016/article/details/53171808?ops_request_misc=%7B%22request_id%22:%22168784579716782425186584%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168784579716782425186584&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-53171808-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=AOE&spm=1018.2226.3001.4187">(466条消息) AOE问题总结_DrCrypto的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44880154/article/details/114380592?ops_request_misc=&request_id=&biz_id=102&utm_term=AOE%E9%A2%98&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-114380592.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(466条消息) AOE网关键路径求解例题_关键路径例题图解_HardyDragon_CC的博客-CSDN博客</a></p>
<h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yc_cy1999/article/details/104580701?ops_request_misc=&request_id=&biz_id=102&utm_term=%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95%E9%A2%98%E5%8D%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104580701.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(443条消息) 2019年南京大学计算机考研复试机试真题_南大计算机专业考研机试_yc_cy1999的博客-CSDN博客</a></p>
<p>一个整数可以变为多少个整数相加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//存所有状态</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j ++)<span class="comment">//j是容量</span></span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq12323qweeqwe/article/details/123083331?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-123083331.nonecase&spm=1018.2226.3001.4187">(462条消息) 291. 蒙德里安的梦想（状压dp）_seez的博客-CSDN博客</a></p>
<p>[(462条消息) <a target="_blank" rel="noopener" href="https://blog.csdn.net/yl_puyu/article/details/109631735?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-109631735.nonecase&spm=1018.2226.3001.4187">状压dp] 蒙德里安的梦想(模板题+状压dp)_状压dp模板题_Ypuyu的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27262727/article/details/105700957?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B4%AA%E5%BF%83%E9%A2%98%E7%9B%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105700957.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(462条消息) C++笔试题模版汇总(五)动态规划&#x2F;贪心_c++笔试题 考动态规划么_ai_XZP_master的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hzf0701/article/details/117430400?ops_request_misc=&request_id=&biz_id=102&utm_term=%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-117430400.142%5Ev100%5Epc_search_result_base8&spm=1018.2226.3001.4187">状态压缩DP学习总结+经典例题精解_状压dp-CSDN博客</a></p>
<h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p>结论：把i个盘子移到另一个柱面上，需要2^i-1步</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/392523306">关于汉诺塔问题 - 知乎 (zhihu.com)</a></p>
<h2 id="放置街灯（Placing-Lampposts-UVa-10859）-star"><a href="#放置街灯（Placing-Lampposts-UVa-10859）-star" class="headerlink" title="放置街灯（Placing Lampposts, UVa 10859）:star:"></a>放置街灯（Placing Lampposts, UVa 10859）:star:</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\11505\AppData\Roaming\Typora\typora-user-images\image-20230515221130204.png" alt="image-20230515221130204"></p>
<h2 id="经典贪心"><a href="#经典贪心" class="headerlink" title="经典贪心"></a>经典贪心</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/KXL5180/article/details/82824003?ops_request_misc=%7B%22request_id%22:%22168424305316800227456811%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168424305316800227456811&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-82824003-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=UVa10382&spm=1018.2226.3001.4187">(450条消息) UVA-10382经典贪心问题，区间覆盖_uva 10382_KXL5180的博客-CSDN博客</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//酸奶工程</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="comment">//定义long long，防止爆int</span></span><br><span class="line">ll n,s;</span><br><span class="line">ll c[<span class="number">10010</span>],y[<span class="number">10010</span>];<span class="comment">//存储费用和交互数量</span></span><br><span class="line">ll f[<span class="number">10010</span>];</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;c[i],&amp;y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            f[i]=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[i]=<span class="built_in">min</span>(c[i],f[i<span class="number">-1</span>]+s);</span><br><span class="line">        &#125;</span><br><span class="line">        sum=sum+f[i]*y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="跳跃问题"><a href="#跳跃问题" class="headerlink" title="跳跃问题"></a>跳跃问题</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41570890/article/details/110795229?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%982&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-110795229.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(462条消息) Leetcode——跳跃问题II_跳跃问题2_Purple.’’的博客-CSDN博客</a></p>
<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/youngyangyang04/article/details/111190664?ops_request_misc=%7B%22request_id%22:%22168647702416800197016860%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168647702416800197016860&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-111190664-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C&spm=1018.2226.3001.4187">(462条消息) 「leetcode」135.分发糖果【贪心算法】详细图解_代码随想录的博客-CSDN博客</a></p>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45697774/article/details/104274713?ops_request_misc=%7B%22request_id%22:%22168667245116800197028500%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168667245116800197028500&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104274713-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E7%BA%BF%E6%AE%B5%E6%A0%91&spm=1018.2226.3001.4187">(462条消息) 线段树 从入门到进阶（超清晰，简单易懂）_线段树进阶_繁凡さん的博客-CSDN博客</a></p>
<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lemonxiaoxiao/article/details/108672039?ops_request_misc=%7B%22request_id%22:%22168667270816800222874127%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168667270816800222874127&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108672039-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(462条消息) 匈牙利算法详解_Amelie_xiao的博客-CSDN博客</a></p>
<p><strong>一个二分图中的最大匹配数等于这个图中的最小点覆盖数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> M, N;            <span class="comment">//M, N分别表示左、右侧集合的元素数量</span></span><br><span class="line"><span class="type">int</span> Map[MAXM][MAXN]; <span class="comment">//邻接矩阵存图</span></span><br><span class="line"><span class="type">int</span> p[MAXN];         <span class="comment">//记录当前右侧元素所对应的左侧元素</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN];      <span class="comment">//记录右侧元素是否已被访问过</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        <span class="keyword">if</span> (Map[i][j] &amp;&amp; !vis[j]) <span class="comment">//有边且未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[j] = <span class="literal">true</span>;                 <span class="comment">//记录状态为访问过</span></span><br><span class="line">            <span class="keyword">if</span> (p[j] == <span class="number">0</span> || <span class="built_in">match</span>(p[j])) <span class="comment">//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                p[j] = i;    <span class="comment">//当前左侧元素成为当前右侧元素的新匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回匹配成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//循环结束，仍未找到匹配，返回匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hungarian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)); <span class="comment">//重置vis数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">match</span>(i))</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>[(462条消息) 2018南京大学计算机夏令营机试第二题（回溯）_只会写臭虫的博客-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43175029/article/details/94670710?ops_request_misc=&request_id=&biz_id=102&utm_term=Missing">https://blog.csdn.net/weixin_43175029/article/details/94670710?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Missing</a> number  Given a positi&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-94670710.142^v88^control_2,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p>回溯就是dfs，并且在每次dfs时记得恢复原状态；如果只需要输出一种状态，设置flag标志位</p>
<p>N皇后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// bool数组用来判断搜索的下一个位置是否可行</span></span><br><span class="line"><span class="comment">// col列，dg对角线，udg反对角线</span></span><br><span class="line"><span class="comment">// g[N][N]用来存路径</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// u == n 表示已经搜了n行，故输出这条路径</span></span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);   <span class="comment">// 等价于cout &lt;&lt; g[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);  <span class="comment">// 换行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 枚举u这一行，搜索合法的列</span></span><br><span class="line">    <span class="type">int</span> x = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; y ++ )</span><br><span class="line">        <span class="comment">// 剪枝(对于不满足要求的点，不再继续往下搜索)  </span></span><br><span class="line">        <span class="comment">// 这里y-x+n是左上角到右下角,y+x是左下角到右上角</span></span><br><span class="line">        <span class="keyword">if</span> (col[y] == <span class="literal">false</span> &amp;&amp; dg[y - x + n] == <span class="literal">false</span> &amp;&amp; udg[y + x] == <span class="literal">false</span>) &#123;</span><br><span class="line">            col[y] = dg[y - x + n] = udg[y + x] = <span class="literal">true</span>;</span><br><span class="line">            g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">            g[x][y] = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">// 恢复现场</span></span><br><span class="line">            col[y] = dg[y - x + n] = udg[y + x] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h2 id="建立索引树"><a href="#建立索引树" class="headerlink" title="建立索引树"></a>建立索引树</h2><p>[(462条消息) 2020北航计算机夏令营机试题目个人理解_北航夏令营 机试_四处碰壁嘤嘤怪的博客-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request_id%22:%22168715279416800185829257%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168715279416800185829257&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%8C%97%E8%88%AA%E5%A4%8F%E4%BB%A4%E8%90%A5">https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request%5Fid%22%3A%22168715279416800185829257%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168715279416800185829257&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=北航夏令营</a> 机试&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p>注意 建树不一定要指针，数组也可</p>
<p>4 5<br>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Roger-Lv</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">http://example.com/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Roger-Lv's space</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/c++.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/06/24/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%E6%80%A7%E4%BB%B7%E6%AF%94%E9%97%AE%E9%A2%98%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/" title="关于动态规划/性价比/背包问题的思考"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/c++.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">关于动态规划/性价比/背包问题的思考</div></div><div class="info-2"><div class="info-item-1">关于动态规划&#x2F;性价比&#x2F;背包问题的思考01背包本质上就可以用空间换时间，动规本质上也是那空间换时间，本身也就是一个贪心算法，所以01背包&lt;–&gt;贪心&lt;–&gt;动态规划 如果说是0-1背包问题，需要逆序更新，原因是东西只有一个，不能影响之前的部分 如果是东西有无数个，则直接顺序更新 如果东西是牛奶之类的，有性价比，并且可以买非整数数量的，可以退化为贪心来做，结构体：数量，价格，性价比，sort一下就完事儿了。 讲究序列（排列问题），先遍历背包，不要求序列（组合问题），先遍历物品 滚动数组 另外，0-1背包要求倒序，若要求组合而非排列，即为先物品，再背包，且倒顺序，滚动数组添加 而且，如果是算有多少种，直接加就行,dp[0]&#x3D;1，其他为0 123dp[j]+=dp[j-nums[i]]    //这里怎么去理解呢，会导致重复吗？    //不会重复  如果是要算最多&#x2F;最少，还要min和max比较 1dp[j]=max(dp[j],dp[j-nums[i]]+value[i])  [(425条消息) 背包问题（背包九讲）_你好世界...</div></div></div></a><a class="pagination-related" href="/2024/06/24/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/" title="保研经验贴"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/BJ.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">保研经验贴</div></div><div class="info-2"><div class="info-item-1">保研经验贴背景今天被两三个25届的同学问到保研的事 尘封许久的记忆再次打开 再次汇总了之前收到的所有信息和仅存的记忆 给一点模板上的参考注:是疫情解封后第一次线下 故之前很多经验贴没有参考性 bg: 985本SE rank: 3&#x2F;181 3.99&#x2F;4.00 论文: 无 竞赛: 双国三 双省一 一省三 n校奖 奖学金: 两年国奖 方向: 分布式系统&#x2F;存储 偏架构和系统设计方向 实习: 某自驾公司地图存储系统&#x2F;字节抖音电商开发岗 由于夏令营已经上岸 故没有参加后续预推免 入营: 夏令营: ①北大计算机 直博（放弃且意愿不强 真不想读博） ②北大软微 硕士（计算机学院组➕老师 最终去向） ③中国科学院计算所 硕士 ④上海交通大学电院 硕士 ⑤南京大学计算机学院 硕士 ⑥北京航空航天大学计算机学院 硕士（放弃） ⑦中国人民大学信院 硕士 ⑧西安交通大学计算机学院 硕士 被拒: ①复旦大学计算机学院（只要第一我也没办法） 参加: 由于在实习真抽不开时间去其他地方参营 ①北大软微 ②北航计算机 ③南大计算机（参加了部分 获得软件所的通过了但后面不是很想...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/07/18/2024-06-24-%E7%8A%B6%E5%8E%8BDP%E7%AE%97%E6%B3%95/" title="状压DP算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/c++.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-18</div><div class="info-item-2">状压DP算法</div></div><div class="info-2"><div class="info-item-1">状压DP使用状压DP的原因我们知道状态压缩，顾名思义，就是需要考虑的状态非常多，我们如果用平常的思想去表示状态，那是非常不现实的，在时间和空间上都不允许，我们使用某种方法，以最小的代价表示某种状态。 那么，这通常是用进制来表示状态的，而选择几进制则根据要求使用的对象的点的状态有几种。一般来说，只有0和1，我们则是用二进制来表示，当然也有其他进制的题，在例题中会列举，需要我们灵活变通，主要谈二进制。 那么如何用二进制表示状态呢？我们发现，二进制上是按位分的，那么我们每一位可以看成一个点，而点上的取值则为该点的状态或者选择。例如00001001这个状态则表示第一个点和第四个点状态为1，其余的点状态为0。所以按照这种思想，能抽象的表示出一个很复杂的状态，实现了时间和空间的优化。 状压DP的适用条件状态压缩其实是有适用环境的：  状态需要有一定的状态单元。 即一个状态应该是保存一个集合，其中的元素值对应着0或1，例如我们常见的棋盘，我们可以用0或1来表示棋子的放置状态。而整个集合即是一个01串，即二进制数，我们通常用十进制表示。那么我们再进行状态转移或者判断的时候，需要先将十进制转化为二...</div></div></div></a><a class="pagination-related" href="/2024/06/24/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%E6%80%A7%E4%BB%B7%E6%AF%94%E9%97%AE%E9%A2%98%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/" title="关于动态规划&#x2F;性价比&#x2F;背包问题的思考"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/c++.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-24</div><div class="info-item-2">关于动态规划&#x2F;性价比&#x2F;背包问题的思考</div></div><div class="info-2"><div class="info-item-1">关于动态规划&#x2F;性价比&#x2F;背包问题的思考01背包本质上就可以用空间换时间，动规本质上也是那空间换时间，本身也就是一个贪心算法，所以01背包&lt;–&gt;贪心&lt;–&gt;动态规划 如果说是0-1背包问题，需要逆序更新，原因是东西只有一个，不能影响之前的部分 如果是东西有无数个，则直接顺序更新 如果东西是牛奶之类的，有性价比，并且可以买非整数数量的，可以退化为贪心来做，结构体：数量，价格，性价比，sort一下就完事儿了。 讲究序列（排列问题），先遍历背包，不要求序列（组合问题），先遍历物品 滚动数组 另外，0-1背包要求倒序，若要求组合而非排列，即为先物品，再背包，且倒顺序，滚动数组添加 而且，如果是算有多少种，直接加就行,dp[0]&#x3D;1，其他为0 123dp[j]+=dp[j-nums[i]]    //这里怎么去理解呢，会导致重复吗？    //不会重复  如果是要算最多&#x2F;最少，还要min和max比较 1dp[j]=max(dp[j],dp[j-nums[i]]+value[i])  [(425条消息) 背包问题（背包九讲）_你好世界...</div></div></div></a><a class="pagination-related" href="/2024/09/08/2024-09-08-%E7%BA%BF%E6%AE%B5%E6%A0%91/" title="线段树"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/c++.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-08</div><div class="info-item-2">线段树</div></div><div class="info-2"><div class="info-item-1">线段树线段树是一种二叉树，也就是对于一个线段，我们会用一个二叉树来表示。 性质：节点 i 的权值 &#x3D; 她的左儿子权值 + 她的右儿子权值。 1. 建树根据这个思路，我们就可以建树了，我们设一个结构体 tree，tree[i].l 与 tree[i].r 分别表示这个点代表的线段的左右下标，tree[i].sum 表示这个节点表示的线段和。 我们知道，一颗从1开始编号的二叉树，结点 i 的左儿子和右儿子编号分别是 2×i 和 2×i+1。 再根据刚才的性质，得到式子：tree[ i ].sum &#x3D; tree[i∗2].sum + tree [i∗2+1].sum ，就可以建一颗线段树了！代码如下（这里以区间求和的查询为例）： 12345678910111213void build(int i,int l,int r)&#123;//递归建树    tree[i].l=l;tree[i].r=r;    if(l==r)&#123;//如果这个节点是叶子节点        tree[i].sum=input[l];        return ;    &#125...</div></div></div></a><a class="pagination-related" href="/2024/06/24/Java%20algo/" title="Java刷题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/java.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-24</div><div class="info-item-2">Java刷题</div></div><div class="info-2"><div class="info-item-1">Java2024年 Java 面试八股文（20w字）_java八股文2023-CSDN博客 SQLSQL 50 题（MySQL 版，包括建库建表、插入数据等完整过程，适合复习 SQL 知识点）_sql50题-CSDN博客 SQL常见语句及用法_sql语句大全及用法-CSDN博客 SQL中的 聚合函数 ,where ,having_where后面可以跟聚合函数吗-CSDN博客 Spring面试被问了几百遍的 IOC 和 AOP ，一篇文章带你搞清楚！！！_ioc和aop的原理面试-CSDN博客 Sentinelsentinel （史上最全）-CSDN博客 Gradle&amp;Mavengradle中的build script详解_gradle buildscript-CSDN博客 [Gradle和Maven的区别-CSDN博客](https://blog.csdn.net/weixin_45626288/article/details/131973787?ops_request_misc=%7B%22request%5Fid%22%3A%221720243058168001858...</div></div></div></a><a class="pagination-related" href="/2024/06/24/%E4%BF%9D%E7%A0%94/" title="保研复习准备"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/BJ.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-24</div><div class="info-item-2">保研复习准备</div></div><div class="info-2"><div class="info-item-1">保研(453条消息) 2021年计算机保研面试题_一个主机将两个端口接到网络上是否会提升吞吐量_Challow的博客-CSDN博客 (453条消息) 吐血整理，20个计算机保研常见问题及回答模板_计算机专业20个面试常见问题_Baoyan_cs的博客-CSDN博客 [(453条消息) 2021计算机保研经历(清软, 北深, 浙大, 南大, 中科大, 北航, 哈深, 南开, 华科, 武大, 中大)_inicho的博客-CSDN博客](https://blog.csdn.net/qq_43280818/article/details/123450451?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=计算机网络 保研&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-9-123450451.142^v87^insert_down28,239^v2^insert_chatgpt&amp;sp...</div></div></div></a><a class="pagination-related" href="/2024/08/14/2024-08-14-Java%E5%AE%9E%E7%8E%B0LRU%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/" title="Java实现LRU的两种方式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/java.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-14</div><div class="info-item-2">Java实现LRU的两种方式</div></div><div class="info-2"><div class="info-item-1">Java实现LRU的两种方式1. 直接继承LinkedHashMap12345678910111213141516171819202122class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;&#123;    private int capacity;        public LRUCache(int capacity) &#123;        super(capacity, 0.75F, true);        this.capacity = capacity;    &#125;    public int get(int key) &#123;        return super.getOrDefault(key, -1);    &#125;    public void put(int key, int value) &#123;        super.put(key, value);    &#125;    @Override    protected boolean remov...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Roger-Lv</div><div class="author-info-description">Send a flare and light the way.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">102</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Roger-Lv"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Roger-Lv" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1150568956@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/zhongrenjie-lv-5588a928a/" target="_blank" title="LinkedIn"><i class="iconfont icon-linkedin-fill"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">1.1.</span> <span class="toc-text">注意</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.1.</span> <span class="toc-text">文件操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BA%93"><span class="toc-number">1.2.</span> <span class="toc-text">一些常用的库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-number">1.2.1.</span> <span class="toc-text">vector:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">1.2.2.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack"><span class="toc-number">1.2.3.</span> <span class="toc-text">stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue"><span class="toc-number">1.2.4.</span> <span class="toc-text">queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#priority-queue"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">priority_queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-number">1.2.5.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#algorithm"><span class="toc-number">1.2.6.</span> <span class="toc-text">algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#climits"><span class="toc-number">1.2.7.</span> <span class="toc-text">climits</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%87%BA%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">设置输出精度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%87%BA%E4%BD%8D%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">设置输出位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP"><span class="toc-number">1.5.</span> <span class="toc-text">KMP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.6.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.6.1.</span> <span class="toc-text">最大连续子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5"><span class="toc-number">1.6.2.</span> <span class="toc-text">最大子矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E-%E5%87%8F%E5%BA%8F%E5%88%97"><span class="toc-number">1.6.3.</span> <span class="toc-text">最长递增&#x2F;减序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%EF%BC%88O-N-2-%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">最大上升子序列和（O(N^2)）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LCS%EF%BC%89"><span class="toc-number">1.6.5.</span> <span class="toc-text">最长公共子序列（LCS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LIS%EF%BC%88Nlogn%EF%BC%89"><span class="toc-number">1.6.6.</span> <span class="toc-text">LIS（Nlogn）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85"><span class="toc-number">1.6.7.</span> <span class="toc-text">01背包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS-BFS"><span class="toc-number">1.7.</span> <span class="toc-text">DFS BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6"><span class="toc-number">1.8.1.</span> <span class="toc-text">归并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">1.9.</span> <span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.</span> <span class="toc-text">模拟问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.</span> <span class="toc-text">日期问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="toc-number">1.12.</span> <span class="toc-text">最大公因数&#x2F;最小公倍数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95"><span class="toc-number">1.13.</span> <span class="toc-text">素数筛法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%EF%BC%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.14.</span> <span class="toc-text">矩阵乘法（构造函数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.15.</span> <span class="toc-text">高精度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.16.</span> <span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7"><span class="toc-number">1.17.</span> <span class="toc-text">弗洛伊德</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89"><span class="toc-number">1.18.</span> <span class="toc-text">迪杰斯特拉</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%EF%BC%88hierholzer%EF%BC%89"><span class="toc-number">1.19.</span> <span class="toc-text">欧拉回路（hierholzer）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%88AOE%E7%BD%91%EF%BC%89"><span class="toc-number">1.20.</span> <span class="toc-text">关键路径（AOE网）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E4%BD%8Ddp"><span class="toc-number">1.21.</span> <span class="toc-text">数位dp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E5%8E%8BDP"><span class="toc-number">1.22.</span> <span class="toc-text">状压DP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="toc-number">1.23.</span> <span class="toc-text">汉诺塔问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BE%E7%BD%AE%E8%A1%97%E7%81%AF%EF%BC%88Placing-Lampposts-UVa-10859%EF%BC%89-star"><span class="toc-number">1.24.</span> <span class="toc-text">放置街灯（Placing Lampposts, UVa 10859）:star:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E8%B4%AA%E5%BF%83"><span class="toc-number">1.25.</span> <span class="toc-text">经典贪心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98"><span class="toc-number">1.26.</span> <span class="toc-text">跳跃问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number">1.27.</span> <span class="toc-text">分发糖果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.28.</span> <span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="toc-number">1.29.</span> <span class="toc-text">匈牙利算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">1.30.</span> <span class="toc-text">回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E6%A0%91"><span class="toc-number">1.31.</span> <span class="toc-text">建立索引树</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/13/2025-08-13-Shall-We-Pretrain-Autoregressive-Language-Models-with-Retrieval/" title="Shall We Pretrain Autoregressive Language Models with Retrieval"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/LLM.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Shall We Pretrain Autoregressive Language Models with Retrieval"/></a><div class="content"><a class="title" href="/2025/08/13/2025-08-13-Shall-We-Pretrain-Autoregressive-Language-Models-with-Retrieval/" title="Shall We Pretrain Autoregressive Language Models with Retrieval">Shall We Pretrain Autoregressive Language Models with Retrieval</a><time datetime="2025-08-12T16:00:00.000Z" title="发表于 2025-08-13 00:00:00">2025-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/13/2025-08-13-%E6%BC%AB%E8%B0%88%20LLM%20%E8%A7%A3%E7%A0%81%E7%AD%96%E7%95%A5%EF%BC%9A%E9%87%87%E6%A0%B7%E7%AD%96%E7%95%A5%EF%BC%88%E8%B4%AA%E5%BF%83%E8%A7%A3%E7%A0%81%E3%80%81%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7%E3%80%81Top-K%20%E9%87%87%E6%A0%B7%E3%80%81Top-P%20%E9%87%87%E6%A0%B7%E3%80%81%E6%A0%B8%E9%87%87%E6%A0%B7%EF%BC%89%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5%EF%BC%88%20Beam%20Search%EF%BC%89/" title="漫谈 LLM 解码策略-采样策略 贪心解码、随机采样、Top-K 采样、Top-P 采样、核采样 和搜索策略Beam Search"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/LLM.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="漫谈 LLM 解码策略-采样策略 贪心解码、随机采样、Top-K 采样、Top-P 采样、核采样 和搜索策略Beam Search"/></a><div class="content"><a class="title" href="/2025/08/13/2025-08-13-%E6%BC%AB%E8%B0%88%20LLM%20%E8%A7%A3%E7%A0%81%E7%AD%96%E7%95%A5%EF%BC%9A%E9%87%87%E6%A0%B7%E7%AD%96%E7%95%A5%EF%BC%88%E8%B4%AA%E5%BF%83%E8%A7%A3%E7%A0%81%E3%80%81%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7%E3%80%81Top-K%20%E9%87%87%E6%A0%B7%E3%80%81Top-P%20%E9%87%87%E6%A0%B7%E3%80%81%E6%A0%B8%E9%87%87%E6%A0%B7%EF%BC%89%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5%EF%BC%88%20Beam%20Search%EF%BC%89/" title="漫谈 LLM 解码策略-采样策略 贪心解码、随机采样、Top-K 采样、Top-P 采样、核采样 和搜索策略Beam Search">漫谈 LLM 解码策略-采样策略 贪心解码、随机采样、Top-K 采样、Top-P 采样、核采样 和搜索策略Beam Search</a><time datetime="2025-08-12T16:00:00.000Z" title="发表于 2025-08-13 00:00:00">2025-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/13/FAISS/" title="Faiss入门及应用经验记录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/LLM.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Faiss入门及应用经验记录"/></a><div class="content"><a class="title" href="/2025/08/13/FAISS/" title="Faiss入门及应用经验记录">Faiss入门及应用经验记录</a><time datetime="2025-08-12T16:00:00.000Z" title="发表于 2025-08-13 00:00:00">2025-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/03/TCP%E8%BF%9E%E6%8E%A5%E4%B8%ADACK,SEQ%E5%8F%98%E5%8C%96/" title="TCP连接中ACK,SEQ变化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/tcp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TCP连接中ACK,SEQ变化"/></a><div class="content"><a class="title" href="/2025/08/03/TCP%E8%BF%9E%E6%8E%A5%E4%B8%ADACK,SEQ%E5%8F%98%E5%8C%96/" title="TCP连接中ACK,SEQ变化">TCP连接中ACK,SEQ变化</a><time datetime="2025-08-02T16:00:00.000Z" title="发表于 2025-08-03 00:00:00">2025-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/25/2025-06-25KL%E6%95%A3%E5%BA%A6/" title="KL散度"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/KL%E6%95%A3%E5%BA%A6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="KL散度"/></a><div class="content"><a class="title" href="/2025/06/25/2025-06-25KL%E6%95%A3%E5%BA%A6/" title="KL散度">KL散度</a><time datetime="2025-06-24T16:00:00.000Z" title="发表于 2025-06-25 00:00:00">2025-06-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2024 - 2025 By Roger-Lv</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.2"></script><script src="/js/main.js?v=5.4.2"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.8.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'smA3tZdRGodG2VgnMubBQjLm-gzGzoHsz',
      appKey: 'biCDxj0lSBtZTMie2kNIKErd',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.3/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><div class="aplayer no-destroy" data-id="8674547170" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>