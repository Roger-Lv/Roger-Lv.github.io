<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构与算法 | Roger-Lv's space</title><meta name="author" content="Roger-Lv"><meta name="copyright" content="Roger-Lv"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构与算法 [(459条消息) 【C语言】程序运行过程：预处理&#x2F;编译&#x2F;汇编&#x2F;链接_预处理编译汇编链接_慕雪华年的博客-CSDN博客](https:&#x2F;&#x2F;blog.csdn.net&#x2F;muxuen&#x2F;article&#x2F;details&#x2F;123227200?ops_request_misc&#x3D;{&quot;request_id&quot;%3A&quot;168596052316800182799736&amp;qu">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://example.com/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Roger-Lv&#39;s space">
<meta property="og:description" content="数据结构与算法 [(459条消息) 【C语言】程序运行过程：预处理&#x2F;编译&#x2F;汇编&#x2F;链接_预处理编译汇编链接_慕雪华年的博客-CSDN博客](https:&#x2F;&#x2F;blog.csdn.net&#x2F;muxuen&#x2F;article&#x2F;details&#x2F;123227200?ops_request_misc&#x3D;{&quot;request_id&quot;%3A&quot;168596052316800182799736&amp;qu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/c++.png">
<meta property="article:published_time" content="2024-06-23T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-19T15:20:12.307Z">
<meta property="article:author" content="Roger-Lv">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/c++.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据结构与算法",
  "url": "http://example.com/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/",
  "image": "http://example.com/img/cover/c++.png",
  "datePublished": "2024-06-23T16:00:00.000Z",
  "dateModified": "2025-09-19T15:20:12.307Z",
  "author": [
    {
      "@type": "Person",
      "name": "Roger-Lv",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://example.com/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.4.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">149</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">128</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">41</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Roger-Lv's space</span></a><a class="nav-page-title" href="/"><span class="site-name">数据结构与算法</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div><!-- 添加搜索按钮 ↓--><span class="search-button"><i class="fas fa-search" aria-hidden="true"></i></span></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-23T16:00:00.000Z" title="发表于 2024-06-24 00:00:00">2024-06-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-19T15:20:12.307Z" title="更新于 2025-09-19 23:20:12">2025-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" data-flag-title="数据结构与算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>数据结构与算法</h1>
<p>[(459条消息) 【C语言】程序运行过程：预处理/编译/汇编/链接_预处理编译汇编链接_慕雪华年的博客-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/muxuen/article/details/123227200?ops_request_misc=%7B%22request%5Fid%22%3A%22168596052316800182799736%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168596052316800182799736&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123227200-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E9%A2%84%E5%A4%84%E7%90%86">https://blog.csdn.net/muxuen/article/details/123227200?ops_request_misc={&quot;request_id&quot;%3A&quot;168596052316800182799736&quot;%2C&quot;scm&quot;%3A&quot;20140713.130102334..&quot;}&amp;request_id=168596052316800182799736&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123227200-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=预处理</a> 编译 汇编 链接&amp;spm=1018.2226.3001.4187)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_54338498/article/details/126953046?ops_request_misc=%7B%22request%5Fid%22%3A%22168175034116800197040062%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168175034116800197040062&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-126953046-null-null.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95&amp;spm=1018.2226.3001.4187">(443条消息) 保研机试——1基础算法（排序、哈希、模拟（日期、图形、查找、进制、字符串）、递归与分治、贪心）_Yuezero_的博客-CSDN博客</a></p>
<p>[(425条消息) 数据结构保研面试题整理（自用）_保研数据结构常温问题_乌鸡摸鱼的博客-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52571748/article/details/120505195?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">https://blog.csdn.net/m0_52571748/article/details/120505195?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=数据结构</a> 保研&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-120505195.142^v73^pc_search_v2,201^v4^add_ask,239^v2^insert_chatgpt&amp;spm=1018.2226.3001.4187)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_53524653/article/details/121522229?ops_request_misc=%7B%22request%5Fid%22%3A%22168740926216782425172942%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168740926216782425172942&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121522229-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&amp;spm=1018.2226.3001.4187">(463条消息) 插入排序–折半插入排序（来一来，看一看，走过路过，不要错过）_老 胡的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/385907273">P问题、NP问题、NPC问题、NP-hard问题详解 - 知乎 (zhihu.com)</a></p>
<p>[保研机试整理 - 知乎 (<a target="_blank" rel="noopener" href="http://zhihu.com">zhihu.com</a>)</p>
<p>什么时候才考虑用二分答案的技巧？<br>
正向求出答案不好入手，求解答案远远没有验证答案简单。</p>
<p>已知前序后序算中序有多少种：</p>
<p>[<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37437983/article/details/79613947">(441条消息) 二叉树遍历（已知前序和后序遍历，求中序遍历的可能的序列数）_已知二叉树的前序遍历和后序遍历_我要出家当道士的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/40915131"></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yizhiniu_xuyw/article/details/109596961?ops_request_misc=%7B%22request%5Fid%22%3A%22168707250016800213049573%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168707250016800213049573&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-109596961-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E5%A0%86%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;spm=1018.2226.3001.4187">(462条消息) 堆排序的时间复杂度分析_一只牛_007的博客-CSDN博客</a></p>
<p>建立索引树：[(462条消息) 2020北航计算机夏令营机试题目个人理解_北航夏令营 机试_四处碰壁嘤嘤怪的博客-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request%5Fid%22%3A%22168715279416800185829257%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168715279416800185829257&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E5%8C%97%E8%88%AA%E5%A4%8F%E4%BB%A4%E8%90%A5">https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc={&quot;request_id&quot;%3A&quot;168715279416800185829257&quot;%2C&quot;scm&quot;%3A&quot;20140713.130102334..&quot;}&amp;request_id=168715279416800185829257&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=北航夏令营</a> 机试&amp;spm=1018.2226.3001.4187)</p>
<h2 id="注意">注意</h2>
<p>scanf后，用getchar()吃掉回车</p>
<p>表示最大 INT_MAX(climits)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//malloc</span></span><br><span class="line"><span class="type">int</span> *nums;</span><br><span class="line">nums=(*<span class="type">int</span>)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//long long int 别用cin cout</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>scanf还会返回成功输入的变量的个数,因此可判定EOF</p>
<p>Floyd判圈法很吊</p>
<p>1.lower_bound(v.begin(), v.end(), key)-v.begin()返回有序序列中大于等于key的第一个值的位置<br>
2.upper_bound(v.begin(), v.end(), key)-v.begin()返回有序序列中大于key的第一个值的位置<br>
3.lower_bound(v.begin(), v.end(), key, greater<int>())-v.begin()返回有序序列中小于等于key的第一个值的位置<br>
4.upper_bound(v.begin(), v.end(), key, greater<int>())-v.begin()返回有序序列中小于key的第一个值的位置<br>
5.上述四个函数，若无满足条件的值，则返回v.size()</p>
<h3 id="文件操作">文件操作</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br></pre></td></tr></table></figure>
<h2 id="lint-formatter">lint&amp;formatter</h2>
<p>vscode记得装一个clang-format, ctrl+s能够自动保存</p>
<h2 id="strcut初始化的例子：">strcut初始化的例子：</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line"> *     <span class="type">int</span> val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"> *     <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"> *     <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="一些常用的库">一些常用的库</h2>
<ol>
<li>algorithm</li>
<li>vector</li>
<li>map</li>
<li>queue</li>
<li>iostream</li>
<li>string</li>
<li>bits/stdc++.h（带上就对了，不过mac的clang不支持，GCC支持）</li>
<li>cmath(sqrt之类的)</li>
<li>climits（INT_MAX INT_MIN）</li>
</ol>
<p><strong>STL内置find()复杂度</strong>：<br>
<code>algorithm的find</code> 复杂度是<code>O(n)</code>，对vector，string等 顺序查询。<br>
<code>map::find</code> 和 <code>set::find</code> 复杂度是<code>O(logn)</code>，因为map和set底层都是红黑树。</p>
<hr>
<h3 id="vector"><strong>vector:</strong></h3>
<p>下面是一些常用的vector方法：</p>
<ol>
<li>
<p><code>push_back</code>：在vector的末尾添加一个元素。</p>
</li>
<li>
<p><code>pop_back</code>：删除vector末尾的一个元素。</p>
</li>
<li>
<p><code>size</code>：返回vector中元素的个数。</p>
</li>
<li>
<p><code>clear</code>：删除vector中所有的元素。</p>
</li>
<li>
<p><code>empty</code>：判断vector是否为空。</p>
</li>
<li>
<p><code>at</code>：返回vector中指定位置的元素。</p>
</li>
<li>
<p><code>front</code>：返回第一个元素。</p>
</li>
<li>
<p><code>back</code>：返回最后一个元素。</p>
</li>
<li>
<p><code>erase</code>：删除vector中指定位置的元素。</p>
</li>
<li>
<p><code>insert</code>：在vector中指定位置插入一个元素或多个元素。</p>
</li>
<li>
<p><code>resize</code>：改变vector的大小。</p>
</li>
<li>
<p><code>reserve</code>：为vector预留一定的空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>swap</code>：交换两个vector中的元素。</p>
</li>
<li>
<p><code>begin</code>：返回指向vector第一个元素的迭代器。</p>
</li>
<li>
<p><code>end</code>：返回指向vector最后一个元素之后的迭代器。 这些方法能够满足大部分情况下的需求，可以根据具体的使用场景选择合适的方法进行操作。</p>
</li>
</ol>
<p>要取迭代器的值，直接*指针取值</p>
<p>对于向量(vector)，它是一种支持随机访问的容器，因此<strong>可以直接通过下标访问向量中的元素</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 使用auto关键字定义迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vector不能直接使用sort函数进行排序，需要传入一个迭代器指定排序的范围。修改代码如下：</p>
<p>sort(v.begin(),v.end(),com);</p>
<hr>
<h3 id="map"><strong>map</strong></h3>
<p>以下是C++中map类的常用方法：</p>
<ol>
<li>
<p>insert(make_pair&lt;key, value&gt;)：向map中插入一个键值对。</p>
</li>
<li>
<p>erase(key)：删除map中指定键的元素。</p>
</li>
<li>
<p>clear()：清空map中所有元素。</p>
</li>
<li>
<p>size()：返回map中元素的个数。</p>
</li>
<li>
<p>empty()：返回map是否为空。</p>
</li>
<li>
<p>find(key)：查找map中是否存在指定键的元素，如果存在则返回指向该元素的迭代器，否则返回end()迭代器。</p>
<p>常常和end联合起来用判断找到没。(<strong>这个适合动态查找，底层红黑树实现</strong>)</p>
<p>e.g. if (m.find(key)!=m.end())</p>
</li>
<li>
<p>count(key)：返回指定键在map中出现的次数，如果不存在则返回0或1。</p>
</li>
<li>
<p>begin()：返回指向map第一个元素的迭代器。</p>
</li>
<li>
<p>end()：返回指向map最后一个元素后面的位置的迭代器。</p>
</li>
<li>
<p>operator[]：通过键访问map中的元素，如果键不存在，则自动插入一个新的键值对并返回对应的值。</p>
</li>
<li>
<p>lower_bound(key)：返回第一个大于或等于指定键的元素的迭代器。</p>
</li>
<li>
<p>upper_bound(key)：返回第一个大于指定键的元素的迭代器。</p>
</li>
<li>
<p>equal_range(key)：返回一个pair对象，其中包含lower_bound和upper_bound返回的迭代器。</p>
</li>
<li>
<p>swap(map2)：交换当前map和map2的元素。 C++中的map类是一种关联式容器，用于存储键值对，其中每个键都唯一，并且按照一定的顺序排列。map的底层实现通常是红黑树，因此查找、插入和删除操作的时间复杂度为O(log n)，其中n是map中元素的个数。map类提供了丰富的方法，可以方便地进行键值对的操作，例如插入、删除、查找、排序等。同时，由于map使用键值对来存储数据，因此可以将map看作是一种特殊的数组，其下标为键，对应的值为数组元素。因此，可以通过下标来访问和修改map中的元素。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;&#123;<span class="string">&quot;apple&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 使用auto关键字定义迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="stack"><strong>stack</strong></h3>
<p>C++ 中的 stack 库提供了以下常用的方法：</p>
<ul>
<li>push(elem)：将元素 elem 压入栈顶。</li>
<li>pop()：弹出栈顶元素。</li>
<li>top()：返回栈顶元素，但不弹出。</li>
<li>empty()：判断栈是否为空。</li>
<li>size()：返回栈中元素的个数。 除此之外，stack 还支持以下操作：</li>
<li>emplace(args…)：构造一个新元素并将其压入栈顶。</li>
<li>swap(stack)：交换两个 stack 的元素。</li>
<li>operator==、operator!=、operator&lt;、operator&lt;=、operator&gt;、operator&gt;=：比较两个 stack 是否相等、不相等、小于、小于等于、大于、大于等于。 具体用法可以参考下面的示例代码</li>
</ul>
<p>stack元素可以是任何类型。</p>
<hr>
<h3 id="queue"><strong>queue</strong></h3>
<p>C++中的queue是一种容器适配器，用于实现“先进先出”（FIFO）的数据结构。queue基于deque或list进行实现，提供了一些方法来操作队列，包括入队、出队、获取队首元素、获取队列大小等。以下是queue的常用方法：</p>
<ol>
<li>push(element)：将一个元素加入队列的尾部。</li>
<li>pop()：将队列头部的元素弹出，但没有返回值。</li>
<li>front()：返回队列头部的元素。</li>
<li>top():返回队列头部元素（和front一样）</li>
<li>back()：返回队列尾部的元素。</li>
<li>empty()：判断队列是否为空。</li>
<li>size()：返回队列中元素的个数。 使用queue需要包含头文件，可以通过以下方式创建一个queue对象：</li>
</ol>
<p>对于队列(queue)，由于它是一种先进先出(FIFO)的数据结构，因此只能通过front()和back()函数来访问队列的头部和尾部元素，<strong>而不能直接通过下标访问</strong>。如果要使用下标访问队列元素，需要先将队列转换为数组或向量。</p>
<hr>
<h4 id="priority-queue"><strong>priority_queue</strong></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;string&gt; b;</span><br></pre></td></tr></table></figure>
<p>对于优先队列，复杂结构类型要重载运算符<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27278957/article/details/85269245?ops_request_misc=%7B%22request%5Fid%22%3A%22168033538216800213097640%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168033538216800213097640&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-85269245-null-null.142%5Ev80%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=c%2B%2B%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6&amp;spm=1018.2226.3001.4187">(436条消息) C++ 运算符重载_c 重载运算符_高祥xiang的博客-CSDN博客</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="type">int</span> real;</span><br><span class="line"><span class="type">int</span> imag;</span><br><span class="line">......</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Complex c)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> real*real+imag*imag&lt;c.real*c.real+c.imag*c.imag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面这个const是必须要有的</p>
<hr>
<h3 id="string"><strong>string</strong></h3>
<p>C++中的string类是一个封装了字符串操作的类，提供了一系列方法来处理和操作字符串。以下是常用的string类方法：</p>
<ol>
<li>
<p>length()：返回字符串的长度。</p>
</li>
<li>
<p>size()：返回字符串的长度。</p>
</li>
<li>
<p>clear()：清空字符串。</p>
</li>
<li>
<p>empty()：判断字符串是否为空。</p>
</li>
<li>
<p>assign(str)：将字符串的值设置为str。</p>
</li>
<li>
<p>assign(str, pos, len)：将字符串的值设置为str中从pos位置开始的长度为len的子串。</p>
</li>
<li>
<p>append(str)：在字符串的末尾添加str。</p>
</li>
<li>
<p>append(str, pos, len)：在字符串的末尾添加str中从pos位置开始的长度为len的子串。</p>
</li>
<li>
<p>push_back(ch)：在字符串的末尾添加一个字符。</p>
</li>
<li>
<p>insert(pos, str)：在字符串的pos位置插入str。</p>
</li>
<li>
<p>erase(pos, len)：删除从pos位置开始长度为len的子串。</p>
<p>erase(n):删除indexn后面的字符</p>
</li>
<li>
<p>replace(pos, len, str)：替换从pos位置开始长度为len的子串为str。</p>
</li>
<li>
<p><strong>substr(pos, len)：返回从pos位置开始长度为len的子串。</strong></p>
</li>
<li>
<p><strong>find(str)：查找str在字符串中第一次出现的位置，返回该位置的索引值。</strong>(找不到就是-1)</p>
</li>
<li>
<p>rfind(str)：查找str在字符串中最后一次出现的位置，返回该位置的索引值。</p>
</li>
<li>
<p>compare(str)：比较字符串和str的大小，返回0（相等）、1（大于）或-1（小于）。 除了以上列举的方法，string类还支持重载运算符，例如+（字符串拼接）、+=（字符串拼接赋值）、==（字符串相等判断）、[]（访问字符串中指定位置的字符）等。string类的使用非常方便，可以像使用普通变量一样对字符串进行赋值、拼接、查找、替换等操作。例如：</p>
</li>
</ol>
<p>注意string s，其s[i]类型为char，char强制类型转换可以这样转换</p>
<p>string(1,s[i])，1表示char长度</p>
<p>s[i]可以直接比较</p>
<p>输入str1,如果str1为空则退出</p>
<p>scanf不会读回车，如果下一行是gets会直接读取缓冲区中的回车，所有会用一个getchar()在中间把缓冲区中的回车抵消掉</p>
<p>stoi(str) 将其转换为整数，注意，如果是&quot;04&quot;,直接变成4</p>
<p>string::npos用于判断结尾（其实找不到直接-1也行）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find函数返回 jk 在 s 中的下标位置</span></span><br><span class="line">	position = s.<span class="built_in">find</span>(<span class="string">&quot;jk&quot;</span>);</span><br><span class="line">	<span class="comment">// 如果没找到，返回一个特别的标志</span></span><br><span class="line">	<span class="comment">// c++中用npos表示，我这里npos取值是4294967295</span></span><br><span class="line">	<span class="keyword">if</span>(position != s.npos)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;position: &quot;</span> &lt;&lt; position &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Not found the flag&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果输入的字符串有空格，那么用如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin,str)</span><br></pre></td></tr></table></figure>
<p>可以直接通过下标修改字符</p>
<p>删除字符串内重复字符:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;aadfgggh&quot;</span>;</span><br><span class="line"><span class="comment">//去重复</span></span><br><span class="line"><span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="built_in">unique</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>()),str.<span class="built_in">end</span>());  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>删除字符串内某个指定字符:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;aadfgggh&quot;</span>;</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>(),<span class="string">&#x27;a&#x27;</span>),str.<span class="built_in">end</span>()); <span class="comment">//在容器中, 删除[begin,end)之间的所有值等于&#x27;a&#x27;的值.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line">string::<span class="built_in">erase</span>(begin,end)：删除[begin,end)之间的所有值c</span><br></pre></td></tr></table></figure>
<p>在Find the Smallest Number中，我发现string的超出index一位的位置依然可以访问，但是没有数</p>
<hr>
<h3 id="algorithm"><strong>algorithm</strong></h3>
<p>C++标准库中的algorithm库提供了许多常用的算法，这些算法可以用于处理容器中的数据，例如排序、查找、遍历等。以下是algorithm库中常用的方法：</p>
<ol>
<li>sort(first, last, func)：对[first, last)区间内的元素进行升/降序排序（取决于func返回）。</li>
<li>reverse(first, last)：对[first, last)区间内的元素进行翻转。</li>
<li>find(first, last, val)：在[first, last)区间内查找值为val的元素，返回该元素的迭代器。如果没有找到，返回last。</li>
<li>find_if(first, last, pred)：在[first, last)区间内查找满足条件pred的第一个元素，返回该元素的迭代器。如果没有找到，返回last。</li>
<li>count(first, last, val)：统计[first, last)区间内值为val的元素个数。</li>
<li>count_if(first, last, pred)：统计[first, last)区间内满足条件pred的元素个数。</li>
<li>accumulate(first, last, init)：对[first, last)区间内的元素进行累加，初始值为init。</li>
<li>max_element(first, last)：返回[first, last)区间内的最大元素的迭代器。</li>
<li>min_element(first, last)：返回[first, last)区间内的最小元素的迭代器。</li>
<li>unique(first, last)：对[first, last)区间内的元素去重，返回去重后的末尾迭代器。</li>
<li>remove(first, last, val)：删除[first, last)区间内值为val的元素，返回删除后的末尾迭代器。</li>
<li>remove_if(first, last, pred)：删除[first, last)区间内满足条件pred的元素，返回删除后的末尾迭代器。</li>
<li>for_each(first, last, func)：对[first, last)区间内的元素执行操作func。</li>
<li>transform(first1, last1, first2, result, op)：将[first1, last1)区间内的元素和[first2, …)区间内的元素进行op操作，并将结果存储到[result, …)区间内。</li>
</ol>
<h3 id="climits">climits</h3>
<p><climits>中定义的常量主要有以下几种：</p>
<ol>
<li>整数类型的最大值和最小值：INT_MAX、INT_MIN、LONG_MAX、LONG_MIN、SHRT_MAX、SHRT_MIN等等。</li>
<li>字符类型的最大值和最小值：CHAR_MAX、CHAR_MIN、SCHAR_MAX、SCHAR_MIN、UCHAR_MAX等等。</li>
<li>位数相关的常量：CHAR_BIT、INT_BIT、LONG_BIT等等。</li>
<li>其他常量：MB_LEN_MAX表示一个多字节字符的最大长度，FLT_MAX、FLT_MIN、DBL_MAX、DBL_MIN等等表示浮点类型的最大值和最小值。</li>
</ol>
<h3 id="set">set</h3>
<hr>
<p><code>set</code> 是C++ STL中的关联容器，具有以下特点：</p>
<ul>
<li><strong>自动排序</strong>：元素按升序排列（默认）</li>
<li><strong>唯一性</strong>：不允许重复元素</li>
<li><strong>高效查找</strong>：基于红黑树实现，查找、插入、删除时间复杂度为 O(log n)</li>
</ul>
<p><strong>头文件和声明</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本声明</span></span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数</span></span><br><span class="line">std::set&lt;<span class="type">int</span>, std::greater&lt;<span class="type">int</span>&gt;&gt; descendingSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line">std::set&lt;std::string&gt; stringSet;</span><br></pre></td></tr></table></figure>
<p><strong>基本操作</strong></p>
<p><strong>1. 插入元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// insert方法</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">10</span>);  <span class="comment">// 重复元素不会插入</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入多个元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果：1 3 5 7 9 10 20（自动排序且去重）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 查找元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// find方法 - 返回迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;找到元素: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// count方法 - 返回0或1</span></span><br><span class="line">    <span class="keyword">if</span>(mySet.<span class="built_in">count</span>(<span class="number">7</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素7存在&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// contains方法 (C++20)</span></span><br><span class="line">    <span class="comment">// if(mySet.contains(7)) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; &quot;元素7存在&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 删除元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除指定值</span></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除迭代器指向的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        mySet.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除范围</span></span><br><span class="line">    <span class="keyword">auto</span> first = mySet.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> last = mySet.<span class="built_in">find</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(first != mySet.<span class="built_in">end</span>() &amp;&amp; last != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        mySet.<span class="built_in">erase</span>(first, last);  <span class="comment">// 删除[1,5)范围</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="utility">utility:</h3>
<p>在 C++ 中，<strong><code>pair</code></strong> 是标准模板库（STL）中的一种<strong>模板类</strong>，定义在头文件 <code>&lt;utility&gt;</code> 中，用于<strong>将两个值（可以是不同类型）组合成一个单元</strong>。</p>
<hr>
<p>🧩 一、基本定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// 必须包含的头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">pair&lt;T1, T2&gt; p;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T1</code>：第一个元素的类型</li>
<li><code>T2</code>：第二个元素的类型</li>
<li><code>p.first</code>：访问第一个元素</li>
<li><code>p.second</code>：访问第二个元素</li>
</ul>
<hr>
<p>✅ 二、创建 pair 的几种方式</p>
<ol>
<li>直接初始化</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用 <code>make_pair</code>（自动推导类型）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p2 = <span class="built_in">make_pair</span>(<span class="number">20</span>, <span class="string">&quot;world&quot;</span>);  <span class="comment">// 类型自动推导为 pair&lt;int, const char*&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>✅ 推荐使用 <code>make_pair</code>，简洁且避免手动写类型。</p>
</blockquote>
<ol start="3">
<li>使用花括号初始化（C++11 起）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p3&#123;<span class="number">30</span>, <span class="number">3.14</span>&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>赋值构造</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, <span class="type">int</span>&gt; p4;</span><br><span class="line">p4 = <span class="built_in">make_pair</span>(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure>
<hr>
<p>🔍 三、访问元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; p<span class="number">1.f</span>irst &lt;&lt; endl;   <span class="comment">// 输出: 10</span></span><br><span class="line">cout &lt;&lt; p<span class="number">1.</span>second &lt;&lt; endl;  <span class="comment">// 输出: hello</span></span><br></pre></td></tr></table></figure>
<hr>
<p>🔄 四、比较操作</p>
<p><code>pair</code> 支持 <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>，比较规则是：</p>
<ol>
<li>先比较 <code>first</code></li>
<li>如果 <code>first</code> 相等，再比较 <code>second</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, string&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, string&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;banana&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, string&gt; <span class="title">c</span><span class="params">(<span class="number">2</span>, <span class="string">&quot;apple&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &lt; b) &lt;&lt; endl; <span class="comment">// true —— first 相同，&quot;apple&quot; &lt; &quot;banana&quot;</span></span><br><span class="line">cout &lt;&lt; (a &lt; c) &lt;&lt; endl; <span class="comment">// true —— 1 &lt; 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>✅ 这使得 <code>pair</code> 非常适合用作 <code>map</code> 的键、或在 <code>set</code>、<code>priority_queue</code> 中排序。</p>
</blockquote>
<hr>
<p>📦 五、常用场景</p>
<ol>
<li>作为函数返回多个值</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">getMinMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minVal = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> maxVal = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(minVal, maxVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">getMinMax</span>(&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Min: &quot;</span> &lt;&lt; result.first &lt;&lt; <span class="string">&quot;, Max: &quot;</span> &lt;&lt; result.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在 map 中遍历键值对</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; ages = &#123;&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : ages) &#123;</span><br><span class="line">    cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Alice is 30 years old.</span></span><br><span class="line"><span class="comment">// Bob is 25 years old.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>💡 <code>map::value_type</code> 就是 <code>pair&lt;const Key, T&gt;</code></p>
</blockquote>
<ol start="3">
<li>优先队列中自定义优先级</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, string&gt;&gt; pq; <span class="comment">// 默认按 first 降序</span></span><br><span class="line">pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="string">&quot;low&quot;</span>));</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">30</span>, <span class="string">&quot;high&quot;</span>));</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">20</span>, <span class="string">&quot;medium&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; pq.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pq.<span class="built_in">top</span>().second &lt;&lt; endl;</span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 30: high</span></span><br><span class="line"><span class="comment">// 20: medium</span></span><br><span class="line"><span class="comment">// 10: low</span></span><br></pre></td></tr></table></figure>
<hr>
<p>🆚 六、pair vs tuple</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>pair&lt;T1, T2&gt;</code></th>
<th><code>tuple&lt;T1, T2, T3, ...&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>元素个数</td>
<td>固定 2 个</td>
<td>任意多个</td>
</tr>
<tr>
<td>访问方式</td>
<td><code>.first</code>, <code>.second</code></td>
<td><code>get&lt;0&gt;(t)</code>, <code>get&lt;1&gt;(t)</code>…</td>
</tr>
<tr>
<td>使用场景</td>
<td>简单二元组（键值对、坐标等）</td>
<td>多返回值、复杂组合</td>
</tr>
</tbody>
</table>
<p>✅ 如果只需要两个值，优先用 <code>pair</code> —— 语义清晰、访问方便。</p>
<hr>
<p>🧠 七、小技巧</p>
<h3 id="结构化绑定（C-17-起）">结构化绑定（C++17 起）</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_pair</span>(<span class="number">100</span>, <span class="string">&quot;OK&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> [value, message] = p;  <span class="comment">// 解构赋值</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; value &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; message &lt;&lt; endl; <span class="comment">// 输出: 100, OK</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>✅ 非常适合用于循环或函数返回值解包：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, val] : myMap) &#123;</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>📚 八、完整示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 pair</span></span><br><span class="line">    pair&lt;<span class="type">int</span>, string&gt; p1 = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    pair&lt;<span class="type">int</span>, string&gt; p2&#123;<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问</span></span><br><span class="line">    cout &lt;&lt; p<span class="number">1.f</span>irst &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; p<span class="number">1.</span>second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较</span></span><br><span class="line">    <span class="keyword">if</span> (p1 &lt; p2) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 &lt; p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用在 vector 中</span></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, string&gt;&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序（默认按 first 升序）</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : vec) &#123;</span><br><span class="line">        cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++17 结构化绑定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [id, name] : vec) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>✅ 总结</p>
<blockquote>
<p><strong><code>pair</code> 是 C++ 中轻量级的“二元组”容器，用于捆绑两个相关值，广泛用于返回多值、map 遍历、排序、优先队列等场景。</strong></p>
</blockquote>
<p>📌 记住：</p>
<ul>
<li>包含头文件：<code>#include &lt;utility&gt;</code></li>
<li>创建：<code>make_pair(a, b)</code> 或 <code>&#123;a, b&#125;</code></li>
<li>访问：<code>.first</code>, <code>.second</code></li>
<li>支持比较、可作 map 键</li>
<li>C++17 支持结构化绑定：<code>auto [x, y] = p;</code></li>
</ul>
<p>掌握 <code>pair</code>，是用好 STL 和现代 C++ 的基础技能之一！</p>
<h2 id="迭代器操作">迭代器操作</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正向遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;正向遍历: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反向遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;反向遍历: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = mySet.<span class="built_in">rbegin</span>(); it != mySet.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 范围for循环</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;范围循环: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容量和属性">容量和属性</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;大小: &quot;</span> &lt;&lt; mySet.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否为空</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;是否为空: &quot;</span> &lt;&lt; (mySet.<span class="built_in">empty</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最大大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最大大小: &quot;</span> &lt;&lt; mySet.<span class="built_in">max_size</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义比较函数">自定义比较函数</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：函数对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; a, <span class="type">const</span> std::string&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">length</span>() &lt; b.<span class="built_in">length</span>();  <span class="comment">// 按长度排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：函数指针</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareLength</span><span class="params">(<span class="type">const</span> std::string&amp; a, <span class="type">const</span> std::string&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">length</span>() &lt; b.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按字符串长度排序</span></span><br><span class="line">    std::set&lt;std::string, Compare&gt; lengthSet;</span><br><span class="line">    lengthSet.<span class="built_in">insert</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    lengthSet.<span class="built_in">insert</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    lengthSet.<span class="built_in">insert</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    lengthSet.<span class="built_in">insert</span>(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出: hi cat apple banana (按长度排序)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; str : lengthSet) &#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实际应用示例">实际应用示例</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除vector中的重复元素</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">removeDuplicates</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::set&lt;<span class="type">int</span>&gt; <span class="title">uniqueSet</span><span class="params">(vec.begin(), vec.end())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(uniqueSet.<span class="built_in">begin</span>(), uniqueSet.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找两个集合的交集</span></span><br><span class="line"><span class="function">std::set&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="type">const</span> std::set&lt;<span class="type">int</span>&gt;&amp; set1, <span class="type">const</span> std::set&lt;<span class="type">int</span>&gt;&amp; set2)</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    std::<span class="built_in">set_intersection</span>(set<span class="number">1.</span><span class="built_in">begin</span>(), set<span class="number">1.</span><span class="built_in">end</span>(),</span><br><span class="line">                         set<span class="number">2.</span><span class="built_in">begin</span>(), set<span class="number">2.</span><span class="built_in">end</span>(),</span><br><span class="line">                         std::<span class="built_in">inserter</span>(result, result.<span class="built_in">begin</span>()));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 去重示例</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; uniqueNumbers = <span class="built_in">removeDuplicates</span>(numbers);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;去重后: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : uniqueNumbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交集示例</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; intersect = <span class="built_in">intersection</span>(set1, set2);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;交集: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : intersect) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="multiset-简介">multiset 简介</h2>
<p>如果需要允许重复元素，可以使用 <code>multiset</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; multiSet;</span><br><span class="line">    </span><br><span class="line">    multiSet.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    multiSet.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    multiSet.<span class="built_in">insert</span>(<span class="number">10</span>);  <span class="comment">// 允许重复</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;multiset大小: &quot;</span> &lt;&lt; multiSet.<span class="built_in">size</span>() &lt;&lt; std::endl;  <span class="comment">// 输出: 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计特定元素出现次数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10出现次数: &quot;</span> &lt;&lt; multiSet.<span class="built_in">count</span>(<span class="number">10</span>) &lt;&lt; std::endl;  <span class="comment">// 输出: 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能特点">性能特点</h2>
<ul>
<li><strong>插入</strong>: O(log n)</li>
<li><strong>删除</strong>: O(log n)</li>
<li><strong>查找</strong>: O(log n)</li>
<li><strong>空间复杂度</strong>: O(n)</li>
</ul>
<p><code>set</code> 是处理需要排序且唯一性要求的场景的理想选择！</p>
<h2 id="设置输出精度">设置输出精度</h2>
<p>设置输出精度为1位小数</p>
<p>cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; ans &lt;&lt; endl</p>
<h2 id="设置输出位数">设置输出位数</h2>
<p>printf(“%02d”,&amp;)</p>
<p>前面补零，两位，不够两位就补零</p>
<h2 id="KMP">KMP</h2>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83334559">KMP 算法详解 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/v_JULY_v/article/details/7041827?ops_request_misc=%7B%22request%5Fid%22%3A%22167957843316800227474381%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167957843316800227474381&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-7041827-null-null.142%5Ev76%5Epc_new_rank,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=KMP&amp;spm=1018.2226.3001.4187">(427条消息) 从头到尾彻底理解KMP（2014年8月22日版）_kmp算法难吗是什么级别_v_JULY_v的博客-CSDN博客</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(<span class="type">char</span>* p,<span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k]) </span><br><span class="line">		&#123;</span><br><span class="line">			++k;</span><br><span class="line">			++j;</span><br><span class="line">			next[j] = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kmp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">	<span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    </span></span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    </span></span><br><span class="line">			<span class="comment">//next[j]即为j所对应的next值      </span></span><br><span class="line">			j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j == pLen)</span><br><span class="line">		<span class="keyword">return</span> i - j;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划">动态规划</h2>
<h3 id="最大连续子序列">最大连续子序列</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> nums[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> N;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;N)&#123;</span><br><span class="line">		<span class="keyword">if</span> (N==EOF)<span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> maxnum=INT_MIN;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			cin&gt;&gt;nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">		dp[<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (N==<span class="number">1</span>)&#123;</span><br><span class="line">			cout&lt;&lt;dp[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			dp[i]=<span class="built_in">max</span>(nums[i],dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">			maxnum=<span class="built_in">max</span>(dp[i],maxnum);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="最大子矩阵">最大子矩阵</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> matrix[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> support[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hangmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxnum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		dp[i]=<span class="built_in">max</span>(arr[i],dp[i<span class="number">-1</span>]+arr[i]);</span><br><span class="line">		maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">allmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxnum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (i==<span class="number">1</span>)&#123;</span><br><span class="line">					arr[k]=support[j][k];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					arr[k]=support[j][k]-support[i<span class="number">-1</span>][k];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			maxnum=<span class="built_in">max</span>(<span class="built_in">hangmax</span>(n),maxnum);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			cin&gt;&gt;matrix[i][j];</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (i==<span class="number">1</span>)support[i][j]=matrix[i][j];</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				support[i][j]=matrix[i][j]+support[i<span class="number">-1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> maxnum;</span><br><span class="line">	maxnum=<span class="built_in">allmax</span>(n);</span><br><span class="line">	cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长递增-减序列">最长递增/减序列</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> daodan[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxnum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		dp[i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (daodan[i]&lt;=daodan[j])</span><br><span class="line">			dp[i]=<span class="built_in">max</span>(<span class="number">1</span>,dp[j]<span class="number">+1</span>);</span><br><span class="line">			maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;daodan[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> maxnum;</span><br><span class="line">	maxnum=<span class="built_in">countmax</span>(n);</span><br><span class="line">	cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大上升子序列和（O-N-2-）">最大上升子序列和（O(N^2)）</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> nums[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxsum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		dp[i]=nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i]&gt;nums[j])</span><br><span class="line">			dp[i]=<span class="built_in">max</span>(nums[i],dp[j]+nums[i]);</span><br><span class="line">			maxsum=<span class="built_in">max</span>(maxsum,dp[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> maxsum;</span><br><span class="line">	<span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">		cout&lt;&lt;nums[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	maxsum=<span class="built_in">countmax</span>(n);</span><br><span class="line">	cout&lt;&lt;maxsum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="最长公共子序列（LCS）">最长公共子序列（LCS）</h3>
<p>1<br>
7<br>
3<br>
5<br>
9<br>
4<br>
8<br>
3</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lxt_Lucia/article/details/81209962?ops_request_misc=%7B%22request%5Fid%22%3A%22168639963816800225544693%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168639963816800225544693&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81209962-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=LCS&amp;spm=1018.2226.3001.4187">(461条消息) 最长公共子序列 (LCS) 详解+例题模板（全）_lxt_Lucia的博客-CSDN博客</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s1;</span><br><span class="line">string s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(string s1,string s2)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> length1=s<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> length2=s<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> dp[length1][length2];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;length1;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;length2;j++)&#123;</span><br><span class="line">			dp[i][j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> maxnum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;length1;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;length2;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (s1[i]==s2[j])&#123;</span><br><span class="line">				<span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">					dp[i][j]=<span class="number">1</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">					dp[i][j]=<span class="number">0</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			maxnum=<span class="built_in">max</span>(maxnum,dp[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;s1&gt;&gt;s2)&#123;</span><br><span class="line">		<span class="type">int</span> maxnum=<span class="built_in">countmax</span>(s1,s2);</span><br><span class="line">		cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LIS（Nlogn）">LIS（Nlogn）</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lxt_Lucia/article/details/81206439?ops_request_misc=%7B%22request%5Fid%22%3A%22168766303316800185860492%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168766303316800185860492&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81206439-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97&amp;spm=1018.2226.3001.4187">(465条消息) 最长上升子序列 (LIS) 详解+例题模板 (全)_lxt_Lucia的博客-CSDN博客</a></p>
<h3 id="01背包">01背包</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">d</span>&#123;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> C,N;</span><br><span class="line">	<span class="keyword">while</span> (cin&gt;&gt;C&gt;&gt;N)&#123;</span><br><span class="line">		<span class="keyword">if</span> (C==<span class="number">0</span>&amp;&amp;N==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> dp[C<span class="number">+1</span>];</span><br><span class="line">		d deal[N];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=C;i++)&#123;</span><br><span class="line">			dp[i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">			<span class="type">int</span> price;</span><br><span class="line">			<span class="type">int</span> score;</span><br><span class="line">			cin&gt;&gt;price&gt;&gt;score;</span><br><span class="line">			deal[i].price=price;</span><br><span class="line">			deal[i].score=score;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=C;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">				<span class="keyword">if</span> (j&gt;=deal[i].price)&#123;</span><br><span class="line">					dp[j]=<span class="built_in">max</span>(dp[j-deal[i].price]+deal[i].score,dp[j]);</span><br><span class="line">				&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		cout&lt;&lt;dp[C]&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有个背包的变种</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41994332/article/details/115829716?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-115829716-blog-109011034.235%5Ev38%5Epc_relevant_anti_t3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-115829716-blog-109011034.235%5Ev38%5Epc_relevant_anti_t3&amp;utm_relevant_index=1">(465条消息) 复旦大学2021年计算机学院机试题解_复旦oj_PyKt的博客-CSDN博客</a></p>
<p>这里是直接顺序的</p>
<h2 id="DFS-BFS">DFS BFS</h2>
<h2 id="排序">排序</h2>
<h3 id="归并">归并</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> hight)</span>  <span class="comment">//合并函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>[hight - low + <span class="number">1</span>];  <span class="comment">//用 new 申请一个辅助函数</span></span><br><span class="line">	<span class="type">int</span> i = low, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;    <span class="comment">// k为 b 数组的小标</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= hight)  </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">		&#123;</span><br><span class="line">			b[k++] = a[i++];  <span class="comment">//按从小到大存放在 b 数组里面</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			b[k++] = a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid)  <span class="comment">// j 序列结束，将剩余的 i 序列补充在 b 数组中 </span></span><br><span class="line">	&#123;</span><br><span class="line">		b[k++] = a[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= hight)<span class="comment">// i 序列结束，将剩余的 j 序列补充在 b 数组中 </span></span><br><span class="line">	&#123;</span><br><span class="line">		b[k++] = a[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	k = <span class="number">0</span>;  <span class="comment">//从小标为 0 开始传送</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= hight; i++)  <span class="comment">//将 b 数组的值传递给数组 a</span></span><br><span class="line">	&#123;</span><br><span class="line">		a[i] = b[k++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[]b;     <span class="comment">// 辅助数组用完后，将其的空间进行释放（销毁）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> hight)</span> <span class="comment">//归并排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; hight)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid = (low + hight) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">mergesort</span>(a, low, mid);          <span class="comment">//对 a[low,mid]进行排序</span></span><br><span class="line">		<span class="built_in">mergesort</span>(a, mid + <span class="number">1</span>, hight);    <span class="comment">//对 a[mid+1,hight]进行排序</span></span><br><span class="line">		<span class="built_in">merge</span>(a, low, mid, hight);       <span class="comment">//进行合并操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, a[<span class="number">100</span>];</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入数列中的元素个数 n 为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请依次输入数列中的元素：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">mergesort</span>(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;归并排序结果&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序">快速排序</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//只有一个数或者区间不存在时</span></span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> left = begin;</span><br><span class="line">    <span class="type">int</span> right = end;</span><br><span class="line">    <span class="comment">//选取左边第一个为key</span></span><br><span class="line">    <span class="type">int</span> key = begin;</span><br><span class="line">    <span class="keyword">while</span> (begin&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//右边选小</span></span><br><span class="line">        <span class="keyword">while</span> (arr[end] &gt;= arr[key] &amp;&amp; begin &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左边选大</span></span><br><span class="line">        <span class="keyword">while</span> (arr[begin] &lt;= arr[key] &amp;&amp; begin &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[begin], arr[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时left和right指针已经相遇</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[key], arr[end]);</span><br><span class="line">    <span class="comment">//递归左右区间</span></span><br><span class="line">    key = end;</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, left, key - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, key + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速幂">快速幂</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> m=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quickpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="comment">//与运算，可判断奇偶，详细见注释</span></span><br><span class="line">		sum=sum*a%m;<span class="comment">//取模运算</span></span><br><span class="line">		a=a*a%m;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;<span class="comment">//位运算，右移，相当于除以2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="模拟问题">模拟问题</h2>
<p>就是找规律，还行</p>
<h2 id="日期问题">日期问题</h2>
<p>要预处理</p>
<h2 id="最大公因数-最小公倍数">最大公因数/最小公倍数</h2>
<p>最小公倍数=a*b/c</p>
<p>c为最大公因数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大公因数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">biggest</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b!=<span class="number">0</span>?<span class="built_in">biggest</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最小公倍数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">smallest</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">   	<span class="type">int</span> big=<span class="built_in">biggest</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> a*b/big;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="素数筛法">素数筛法</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (cin&gt;&gt;n)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (n==<span class="number">2</span>)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">bool</span> sushu[n<span class="number">+1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			sushu[i]=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (sushu[i]==<span class="literal">false</span>)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=i;j*i&lt;=n;j++)&#123; <span class="comment">//j直接从i开始，提高效率</span></span><br><span class="line">				<span class="keyword">if</span> (j*i&lt;n)&#123;</span><br><span class="line">					sushu[j*i]=<span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (sushu[i])&#123;</span><br><span class="line">				<span class="keyword">if</span> (i%<span class="number">10</span>==<span class="number">1</span>)&#123;</span><br><span class="line">					cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个数n，其质因数最多只有一个大于其平方根！</p>
<h2 id="矩阵乘法（构造函数）">矩阵乘法（构造函数）</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">	<span class="type">int</span> matrix[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> row;</span><br><span class="line">	<span class="type">int</span> col;</span><br><span class="line">	<span class="built_in">Matrix</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">row</span>(a),<span class="built_in">col</span>(b)&#123;&#125;<span class="comment">//注意构造函数的写法</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Matrix <span class="title">Multiply</span><span class="params">(Matrix a,Matrix b)</span></span>&#123;</span><br><span class="line">	Matrix ans=<span class="built_in">Matrix</span>(a.row,b.col);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.row;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;b.col;j++)&#123;</span><br><span class="line">			<span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;a.col;k++)&#123;</span><br><span class="line">				temp+=a.matrix[i][k]*b.matrix[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">			ans.matrix[i][j]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMatrix</span><span class="params">(Matrix m)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> row=m.row;</span><br><span class="line">	<span class="type">int</span> col=m.col;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (j!=<span class="number">0</span>)&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;m.matrix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Matrix a=<span class="built_in">Matrix</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">	Matrix b=<span class="built_in">Matrix</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">			cin&gt;&gt;a.matrix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">			cin&gt;&gt;b.matrix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Matrix c=<span class="built_in">Multiply</span>(a,b);</span><br><span class="line">	<span class="built_in">printMatrix</span>(c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度">高精度</h2>
<h2 id="最小生成树">最小生成树</h2>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?spm=1000.2115.3001.4498&amp;q=prim%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91&amp;t=&amp;u=">prim算法求最小生成树- CSDN搜索</a></p>
<p>kruscal</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&gt;(edge c)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> weight&gt;c.weight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">edge</span>(<span class="type">int</span> q,<span class="type">int</span> w,<span class="type">int</span> e):<span class="built_in">a</span>(q),<span class="built_in">b</span>(w),<span class="built_in">weight</span>(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;edge,vector&lt;edge&gt;,greater&lt;edge&gt;&gt;edges;</span><br><span class="line"><span class="type">int</span> graph[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (graph[x]==<span class="number">-1</span>)<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> temp;</span><br><span class="line">	temp=<span class="built_in">find</span>(graph[x]);</span><br><span class="line">	graph[x]=temp;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (cin&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> a,b,weight;</span><br><span class="line">		<span class="type">int</span> num=n*(n<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">memset</span>(graph,<span class="number">-1</span>,<span class="built_in">sizeof</span>(graph));</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			graph[i]=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (num--)&#123;</span><br><span class="line">			cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">			edge edge1=<span class="built_in">edge</span>(a,b,weight);</span><br><span class="line">			edges.<span class="built_in">push</span>(edge1);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (!edges.<span class="built_in">empty</span>()&amp;&amp;count&lt;n<span class="number">-1</span>)&#123;</span><br><span class="line">			edge temp=edges.<span class="built_in">top</span>();</span><br><span class="line">			edges.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="type">int</span> a=<span class="built_in">find</span>(temp.a);</span><br><span class="line">			<span class="type">int</span> b=<span class="built_in">find</span>(temp.b);</span><br><span class="line">			<span class="type">int</span> weight=temp.weight;</span><br><span class="line">			<span class="keyword">if</span> (a!=b)&#123;</span><br><span class="line">				graph[a]=b;</span><br><span class="line">				count++;</span><br><span class="line">				sum+=weight;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="弗洛伊德">弗洛伊德</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;k ++) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++) &#123; </span><br><span class="line"> <span class="keyword">if</span> (ans[i][k] == 无穷 || ans[k][j] == 无穷) <span class="keyword">continue</span>; </span><br><span class="line"> <span class="keyword">if</span> (ans[i][j] == 无穷 || ans[i][k] + ans[k][j] &lt; ans[i][j]) </span><br><span class="line"> ans[i][j] = ans[i][k] + ans[k][j]; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<h2 id="迪杰斯特拉">迪杰斯特拉</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123; <span class="comment">//初始化</span></span><br><span class="line"> Dis[i] = <span class="number">-1</span>; <span class="comment">//所有距离为-1，即不可达</span></span><br><span class="line"> mark[i] = <span class="literal">false</span>; <span class="comment">//所有结点不属于集合K</span></span><br><span class="line"> &#125; </span><br><span class="line"> Dis[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//得到最近的点为结点1,长度为0</span></span><br><span class="line"> mark[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//将结点1加入集合K</span></span><br><span class="line"> <span class="type">int</span> newP = <span class="number">1</span>; <span class="comment">//集合K中新加入的点为结点1 </span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i ++) &#123; <span class="comment">//循环n-1次,按照最短路径递增的顺序确定其他n-1个点的最短路径长度</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; edge[newP].<span class="built_in">size</span>();j ++) &#123; <span class="comment">//遍历与该新加入集合</span></span><br><span class="line">K中的结点直接相邻的边</span><br><span class="line"> <span class="type">int</span> t = edge[newP][j].next; <span class="comment">//该边的另一个结点</span></span><br><span class="line"> <span class="type">int</span> c = edge[newP][j].c; <span class="comment">//该边的长度</span></span><br><span class="line"> <span class="keyword">if</span> (mark[t] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">//若另一个结点也属于集合K,则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[t] == - <span class="number">1</span> || Dis[t] &gt; Dis[newP] + c) <span class="comment">//若该结点尚不可</span></span><br><span class="line">达,或者该结点从新加入的结点经过一条边到达时比以往距离更短</span><br><span class="line"> Dis[t] = Dis[newP] + c; <span class="comment">//更新其距离信息</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="type">int</span> min = <span class="number">123123123</span>; <span class="comment">//最小值初始化为一个大整数,为找最小值做准备</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++) &#123; <span class="comment">//遍历所有结点</span></span><br><span class="line"> <span class="keyword">if</span> (mark[j] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">//若其属于集合K则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[j] == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">//若该结点仍不可达则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[j] &lt; min) &#123; <span class="comment">//若该结点经由结点1至集合K中的某点在经过一条</span></span><br><span class="line">边到达时距离小于当前最小值</span><br><span class="line"> min = Dis[j]; <span class="comment">//更新其为最小值</span></span><br><span class="line"> newP = j; <span class="comment">//新加入的点暂定为该点</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉回路（hierholzer）">欧拉回路（hierholzer）</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44316314/article/details/96898445?ops_request_misc=%7B%22request%5Fid%22%3A%22168707940816800182775723%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168707940816800182775723&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-96898445-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E7%9A%84%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187">(462条消息) 欧拉回路（hierholzer算法）_逐步插入回路法_run around的博客-CSDN博客</a></p>
<h2 id="关键路径（AOE网）">关键路径（AOE网）</h2>
<p>最早开始时间=最晚开始时间</p>
<p>用拓扑图</p>
<p>最早开始时间（所有先序活动的最晚完成时间）</p>
<p>最晚开始时间（所有后续活动的最早开始时间减去该活动花费的时间）</p>
<p>注意源点的最早开始时间不一定为0，要初始化</p>
<p>汇点的最晚开始时间初始化为totalTime-该汇点任务的时间</p>
<p>非汇点的最晚开始时间为无穷</p>
<p>如果只是要求关键路径的长度，其实在earliest[i]初始化的时候就设置为任务的时间就行，但如果要算其他的，就还是设置为0</p>
<p>7 5<br>
11 20 17 10 11 17 17<br>
5 4<br>
6 1<br>
7 3<br>
2 4<br>
2 1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yushu 1e9+7</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;zero;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;re;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> in[<span class="number">100001</span>];</span><br><span class="line">vector&lt;edge&gt;edges[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> task[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> earliest[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> latest[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		in[i]=<span class="number">0</span>;</span><br><span class="line">		cin&gt;&gt;task[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> num=m;</span><br><span class="line">	<span class="type">int</span> allTime=<span class="number">0</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;input edge&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">while</span> (num--)&#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		in[b]++;</span><br><span class="line">		edge temp;</span><br><span class="line">		temp.to=b;</span><br><span class="line">		temp.weight=task[b];</span><br><span class="line">		edges[a].<span class="built_in">push_back</span>(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;input finished.&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[i]&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">if</span> (in[i]==<span class="number">0</span>)&#123;</span><br><span class="line">			zero.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!zero.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> node=zero.<span class="built_in">front</span>();</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;zero:&quot;</span>&lt;&lt;node&lt;&lt;endl;</span><br><span class="line">		zero.<span class="built_in">pop</span>();</span><br><span class="line">		re.<span class="built_in">push_back</span>(node);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;edges[node].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">			<span class="type">int</span> to=edges[node][i].to;</span><br><span class="line">			<span class="type">int</span> weight=edges[node][i].weight;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;edge:&quot;</span>&lt;&lt;node&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;to&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;weight&lt;&lt;endl;</span><br><span class="line">			earliest[to]=<span class="built_in">max</span>(earliest[to],earliest[node]+task[node]);</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;to&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[to]&lt;&lt;endl;</span><br><span class="line">			in[to]--;</span><br><span class="line">			<span class="keyword">if</span> (in[to]==<span class="number">0</span>)&#123;</span><br><span class="line">				zero.<span class="built_in">push</span>(to);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		allTime=<span class="built_in">max</span>(allTime,earliest[i]+task[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;reverse:&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=re.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="type">int</span> u=re[i];</span><br><span class="line">		<span class="keyword">if</span> (edges[u].<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">			latest[u]=allTime-task[u];</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;latest:[&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[u]&lt;&lt;endl;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			latest[u]=<span class="number">99999999</span>;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;edges[u].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">			<span class="type">int</span> to=edges[u][j].to;</span><br><span class="line">			<span class="type">int</span> weight=edges[u][j].weight;</span><br><span class="line">			latest[u]=<span class="built_in">min</span>(latest[u],latest[to]-task[u]);</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;latest:[&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[u]&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[i]&lt;&lt;endl;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;latest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		sum*=(latest[i]-earliest[i]<span class="number">+1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;allTime&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011240016/article/details/53171808?ops_request_misc=%7B%22request%5Fid%22%3A%22168784579716782425186584%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168784579716782425186584&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-53171808-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=AOE&amp;spm=1018.2226.3001.4187">(466条消息) AOE问题总结_DrCrypto的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44880154/article/details/114380592?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=AOE%E9%A2%98&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-114380592.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;spm=1018.2226.3001.4187">(466条消息) AOE网关键路径求解例题_关键路径例题图解_HardyDragon_CC的博客-CSDN博客</a></p>
<h2 id="数位dp">数位dp</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yc_cy1999/article/details/104580701?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95%E9%A2%98%E5%8D%95&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104580701.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&amp;spm=1018.2226.3001.4187">(443条消息) 2019年南京大学计算机考研复试机试真题_南大计算机专业考研机试_yc_cy1999的博客-CSDN博客</a></p>
<p>一个整数可以变为多少个整数相加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//存所有状态</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j ++)<span class="comment">//j是容量</span></span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状压DP">状压DP</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq12323qweeqwe/article/details/123083331?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-123083331.nonecase&amp;spm=1018.2226.3001.4187">(462条消息) 291. 蒙德里安的梦想（状压dp）_seez的博客-CSDN博客</a></p>
<p>[(462条消息) <a target="_blank" rel="noopener" href="https://blog.csdn.net/yl_puyu/article/details/109631735?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-109631735.nonecase&amp;spm=1018.2226.3001.4187">状压dp] 蒙德里安的梦想(模板题+状压dp)_状压dp模板题_Ypuyu的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27262727/article/details/105700957?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B4%AA%E5%BF%83%E9%A2%98%E7%9B%AE&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105700957.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;spm=1018.2226.3001.4187">(462条消息) C++笔试题模版汇总(五)动态规划/贪心_c++笔试题 考动态规划么_ai_XZP_master的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hzf0701/article/details/117430400?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-117430400.142%5Ev100%5Epc_search_result_base8&amp;spm=1018.2226.3001.4187">状态压缩DP学习总结+经典例题精解_状压dp-CSDN博客</a></p>
<h2 id="汉诺塔问题">汉诺塔问题</h2>
<p>结论：把i个盘子移到另一个柱面上，需要2^i-1步</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/392523306">关于汉诺塔问题 - 知乎 (zhihu.com)</a></p>
<h2 id="放置街灯（Placing-Lampposts-UVa-10859）-star">放置街灯（Placing Lampposts, UVa 10859）:star:</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C11505%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230515221130204.png" alt="image-20230515221130204"></p>
<h2 id="经典贪心">经典贪心</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/KXL5180/article/details/82824003?ops_request_misc=%7B%22request%5Fid%22%3A%22168424305316800227456811%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168424305316800227456811&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-82824003-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&amp;utm_term=UVa10382&amp;spm=1018.2226.3001.4187">(450条消息) UVA-10382经典贪心问题，区间覆盖_uva 10382_KXL5180的博客-CSDN博客</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//酸奶工程</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="comment">//定义long long，防止爆int</span></span><br><span class="line">ll n,s;</span><br><span class="line">ll c[<span class="number">10010</span>],y[<span class="number">10010</span>];<span class="comment">//存储费用和交互数量</span></span><br><span class="line">ll f[<span class="number">10010</span>];</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;c[i],&amp;y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            f[i]=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[i]=<span class="built_in">min</span>(c[i],f[i<span class="number">-1</span>]+s);</span><br><span class="line">        &#125;</span><br><span class="line">        sum=sum+f[i]*y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳跃问题">跳跃问题</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41570890/article/details/110795229?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%982&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-110795229.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;spm=1018.2226.3001.4187">(462条消息) Leetcode——跳跃问题II_跳跃问题2_Purple.''的博客-CSDN博客</a></p>
<h2 id="分发糖果">分发糖果</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/youngyangyang04/article/details/111190664?ops_request_misc=%7B%22request%5Fid%22%3A%22168647702416800197016860%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168647702416800197016860&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-111190664-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C&amp;spm=1018.2226.3001.4187">(462条消息) 「leetcode」135.分发糖果【贪心算法】详细图解_代码随想录的博客-CSDN博客</a></p>
<h2 id="线段树">线段树</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45697774/article/details/104274713?ops_request_misc=%7B%22request%5Fid%22%3A%22168667245116800197028500%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168667245116800197028500&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104274713-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E7%BA%BF%E6%AE%B5%E6%A0%91&amp;spm=1018.2226.3001.4187">(462条消息) 线段树 从入门到进阶（超清晰，简单易懂）_线段树进阶_繁凡さん的博客-CSDN博客</a></p>
<h2 id="匈牙利算法">匈牙利算法</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lemonxiaoxiao/article/details/108672039?ops_request_misc=%7B%22request%5Fid%22%3A%22168667270816800222874127%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168667270816800222874127&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108672039-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187">(462条消息) 匈牙利算法详解_Amelie_xiao的博客-CSDN博客</a></p>
<p><strong>一个二分图中的最大匹配数等于这个图中的最小点覆盖数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> M, N;            <span class="comment">//M, N分别表示左、右侧集合的元素数量</span></span><br><span class="line"><span class="type">int</span> Map[MAXM][MAXN]; <span class="comment">//邻接矩阵存图</span></span><br><span class="line"><span class="type">int</span> p[MAXN];         <span class="comment">//记录当前右侧元素所对应的左侧元素</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN];      <span class="comment">//记录右侧元素是否已被访问过</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        <span class="keyword">if</span> (Map[i][j] &amp;&amp; !vis[j]) <span class="comment">//有边且未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[j] = <span class="literal">true</span>;                 <span class="comment">//记录状态为访问过</span></span><br><span class="line">            <span class="keyword">if</span> (p[j] == <span class="number">0</span> || <span class="built_in">match</span>(p[j])) <span class="comment">//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                p[j] = i;    <span class="comment">//当前左侧元素成为当前右侧元素的新匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回匹配成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//循环结束，仍未找到匹配，返回匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hungarian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)); <span class="comment">//重置vis数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">match</span>(i))</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="回溯">回溯</h2>
<p>[(462条消息) 2018南京大学计算机夏令营机试第二题（回溯）_只会写臭虫的博客-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43175029/article/details/94670710?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Missing">https://blog.csdn.net/weixin_43175029/article/details/94670710?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Missing</a> number  Given a positi&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-94670710.142^v88^control_2,239^v2^insert_chatgpt&amp;spm=1018.2226.3001.4187)</p>
<p>回溯就是dfs，并且在每次dfs时记得恢复原状态；如果只需要输出一种状态，设置flag标志位</p>
<p>N皇后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// bool数组用来判断搜索的下一个位置是否可行</span></span><br><span class="line"><span class="comment">// col列，dg对角线，udg反对角线</span></span><br><span class="line"><span class="comment">// g[N][N]用来存路径</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// u == n 表示已经搜了n行，故输出这条路径</span></span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);   <span class="comment">// 等价于cout &lt;&lt; g[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);  <span class="comment">// 换行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 枚举u这一行，搜索合法的列</span></span><br><span class="line">    <span class="type">int</span> x = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; y ++ )</span><br><span class="line">        <span class="comment">// 剪枝(对于不满足要求的点，不再继续往下搜索)  </span></span><br><span class="line">        <span class="comment">// 这里y-x+n是左上角到右下角,y+x是左下角到右上角</span></span><br><span class="line">        <span class="keyword">if</span> (col[y] == <span class="literal">false</span> &amp;&amp; dg[y - x + n] == <span class="literal">false</span> &amp;&amp; udg[y + x] == <span class="literal">false</span>) &#123;</span><br><span class="line">            col[y] = dg[y - x + n] = udg[y + x] = <span class="literal">true</span>;</span><br><span class="line">            g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">            g[x][y] = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">// 恢复现场</span></span><br><span class="line">            col[y] = dg[y - x + n] = udg[y + x] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="建立索引树">建立索引树</h2>
<p>[(462条消息) 2020北航计算机夏令营机试题目个人理解_北航夏令营 机试_四处碰壁嘤嘤怪的博客-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request%5Fid%22%3A%22168715279416800185829257%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168715279416800185829257&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E5%8C%97%E8%88%AA%E5%A4%8F%E4%BB%A4%E8%90%A5">https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc={&quot;request_id&quot;%3A&quot;168715279416800185829257&quot;%2C&quot;scm&quot;%3A&quot;20140713.130102334..&quot;}&amp;request_id=168715279416800185829257&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=北航夏令营</a> 机试&amp;spm=1018.2226.3001.4187)</p>
<p>注意 建树不一定要指针，数组也可</p>
<p>4 5<br>
1 0 1 0 0<br>
1 0 1 1 1<br>
1 1 1 1 1<br>
1 0 0 1 0</p>
<h2 id="hot-100">hot 100</h2>
<h3 id="49-字母异位词分组"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    map&lt;string, vector&lt;string&gt;&gt; mapSet;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    <span class="keyword">for</span> (string s : strs) &#123;</span><br><span class="line">        string temp = s;</span><br><span class="line">        <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (mapSet.<span class="built_in">find</span>(temp) != mapSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            mapSet[temp].<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mapSet[temp] = vector&lt;string&gt;&#123;s&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历map，以key作为一个list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item = mapSet.<span class="built_in">begin</span>(); item != mapSet.<span class="built_in">end</span>(); item++) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(item-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加函数来打印结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printResult</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;string&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; result[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; result[i][j] &lt;&lt; <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; list = &#123;<span class="string">&quot;eat&quot;</span>, <span class="string">&quot;tea&quot;</span>, <span class="string">&quot;tan&quot;</span>, <span class="string">&quot;ate&quot;</span>, <span class="string">&quot;nat&quot;</span>, <span class="string">&quot;bat&quot;</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans = <span class="built_in">groupAnagrams</span>(list);</span><br><span class="line">    <span class="built_in">printResult</span>(ans);  <span class="comment">// 使用自定义函数打印</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="763-划分字母区间"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> last[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> length = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        last[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; partition;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        end = <span class="built_in">max</span>(end, last[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            partition.<span class="built_in">push_back</span>(end - start + <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> partition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans = <span class="built_in">partitionLabels</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : ans) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="32-最长有效括号">32. 最长有效括号</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    stk.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num = i - stk.<span class="built_in">top</span>();</span><br><span class="line">                ans = <span class="built_in">max</span>(num, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;)()())&quot;</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">longestValidParentheses</span>(s);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="84-矩形图中的最大面积">84. 矩形图中的最大面积</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || heights[i] &gt; heights[stk.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; heights[stk.<span class="built_in">top</span>()] &gt; heights[i]) &#123;</span><br><span class="line">                <span class="type">int</span> length = heights[stk.<span class="built_in">top</span>()];</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> weight = i;</span><br><span class="line">                <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    weight = i - stk.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, length * weight);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> right = heights.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> h = heights[stk.<span class="built_in">top</span>()];</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> left = stk.<span class="built_in">top</span>();</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, h * (right - left - <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(right * h, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heights = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">largestRectangleArea</span>(heights);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LCR-153-二叉树中和为目标值的路径"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">LCR 153. 二叉树中和为目标值的路径</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathTarget</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">cur</span>(root,target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cur</span><span class="params">(TreeNode* node,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        target = target-node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (target==<span class="number">0</span>&amp;&amp;node-&gt;left==<span class="literal">nullptr</span>&amp;&amp;node-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cur</span>(node-&gt;left,target);</span><br><span class="line">        <span class="built_in">cur</span>(node-&gt;right,target);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="153-寻找旋转排序数组中的最小值"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int i =0;</span><br><span class="line">        int j = nums.size()-1;</span><br><span class="line">        while(i&lt;j)&#123;</span><br><span class="line">            int middle = (i+j)/2;</span><br><span class="line">            if (nums[middle]&lt;nums[j])&#123;</span><br><span class="line">                j = middle;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                i = middle+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="33-搜索旋转排序数组"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = (<span class="type">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="76-最小覆盖子串"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m1,m2;</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=s.<span class="built_in">size</span>()<span class="number">+100</span>;</span><br><span class="line">        <span class="type">int</span> ans_left = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right =<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            m1[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (m<span class="number">1.f</span>ind(s[++right])!=m<span class="number">1.</span><span class="built_in">end</span>())&#123;</span><br><span class="line">                m2[s[right]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">checkReady</span>()&amp;&amp;left&lt;=right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(right-left<span class="number">+1</span>&lt;len)&#123;</span><br><span class="line">                    len = right-left<span class="number">+1</span>;</span><br><span class="line">                    ans_left = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (m<span class="number">1.f</span>ind(s[left])!=m<span class="number">1.</span><span class="built_in">end</span>())&#123;</span><br><span class="line">                    m2[s[left]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans_left!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s.<span class="built_in">substr</span>(ans_left,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkReady</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it=m<span class="number">1.</span><span class="built_in">begin</span>();it!=m<span class="number">1.</span><span class="built_in">end</span>();it++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m2[it-&gt;first]&lt;it-&gt;second)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LRU">LRU</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> key, value;</span><br><span class="line">        Node* prev;</span><br><span class="line">        Node* next;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> k, <span class="type">int</span> v) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, Node*&gt; cache;</span><br><span class="line">    Node* head;</span><br><span class="line">    Node* tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在头部添加节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToHead</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动节点到头部</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToHead</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="built_in">addToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除尾部节点</span></span><br><span class="line">    <span class="function">Node* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node* node = tail-&gt;prev;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.<span class="built_in">find</span>(key) == cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Node* node = cache[key];</span><br><span class="line">        <span class="comment">// 移动到头部</span></span><br><span class="line">        <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.<span class="built_in">find</span>(key) == cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 新节点</span></span><br><span class="line">            Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">            cache[key] = node;</span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cache.<span class="built_in">size</span>() &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 超出容量，删除尾部节点</span></span><br><span class="line">                Node* tail = <span class="built_in">removeTail</span>();</span><br><span class="line">                cache.<span class="built_in">erase</span>(tail-&gt;key);</span><br><span class="line">                <span class="keyword">delete</span> tail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 更新现有节点</span></span><br><span class="line">            Node* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="三数之和">三数之和</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="comment">// 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> first = <span class="number">0</span>; first &lt; n; ++first) &#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// c 对应的指针初始指向数组的最右端</span></span><br><span class="line">            <span class="type">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> target = -nums[first];</span><br><span class="line">            <span class="comment">// 枚举 b</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> second = first + <span class="number">1</span>; second &lt; n; ++second) &#123;</span><br><span class="line">                <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">                <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">                <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;</span><br><span class="line">                    --third;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">                <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (second == third) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[second] + nums[third] == target) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="无重复字符的最长子串">无重复字符的最长子串</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;m;</span><br><span class="line">        <span class="type">int</span> left =<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right&amp;&amp;right&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            m[s[right]]++;</span><br><span class="line">            <span class="keyword">if</span> (m[s[right]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">                    m[s[left]]--;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">if</span> (m[s[right]]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,right-left<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="和为k的子数组">和为k的子数组</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">prifix_sum</span>(nums.<span class="built_in">size</span>()<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            prifix_sum[i<span class="number">+1</span>] = prifix_sum[i]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;prifix_sum.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(prifix_sum[i]-k)!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                ans =ans+m[prifix_sum[i]-k];</span><br><span class="line">            &#125;</span><br><span class="line">            m[prifix_sum[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的最近公共祖先">二叉树的最近公共祖先</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> lson = <span class="built_in">dfs</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="type">bool</span> rson = <span class="built_in">dfs</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="每日一题">每日一题</h2>
<h3 id="3227-字符串元音游戏">3227.字符串元音游戏</h3>
<p>感觉就是个博弈问题。</p>
<p>如果当前剩下的所有的字符中包含元音个数为奇数个，她直接赢，反之就是小明赢。</p>
<h3 id="1935-可以输入的最大单词数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-number-of-words-you-can-type/">1935. 可以输入的最大单词数</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canBeTypedWords</span><span class="params">(string text, string brokenLetters)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;brokenLetters.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(brokenLetters[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> ans =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;text.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (text[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">find</span>(text[i])!=s.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2197-替换数组中的非互质数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/">2197. 替换数组中的非互质数</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">replaceNonCoprimes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 持续合并非互质相邻元素</span></span><br><span class="line">            <span class="keyword">while</span> (ans.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> g = <span class="built_in">gcd</span>(ans[ans.<span class="built_in">size</span>()<span class="number">-1</span>], ans[ans.<span class="built_in">size</span>()<span class="number">-2</span>]);</span><br><span class="line">                <span class="keyword">if</span> (g &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> lcm = (<span class="type">long</span> <span class="type">long</span>)ans[ans.<span class="built_in">size</span>()<span class="number">-1</span>] * ans[ans.<span class="built_in">size</span>()<span class="number">-2</span>] / g;</span><br><span class="line">                    ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(lcm);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2349-设计数字容器系统"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-a-number-container-system/">2349. 设计数字容器系统</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberContainers</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; nums;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, set&lt;<span class="type">int</span>&gt;&gt; us;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumberContainers</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] != <span class="number">0</span>) &#123;</span><br><span class="line">            us[nums[index]].<span class="built_in">erase</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line">        us[number].<span class="built_in">insert</span>(index);</span><br><span class="line">        nums[index] = number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (us[number].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *us[number].<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另一个办法是优先队列</p>
<h3 id="3408-设计任务管理器"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-task-manager/">3408. 设计任务管理器</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; taskInfo;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskManager</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; tasks) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; task : tasks) &#123;</span><br><span class="line">            <span class="type">int</span> userId = task[<span class="number">0</span>], taskId = task[<span class="number">1</span>], priority = task[<span class="number">2</span>];</span><br><span class="line">            taskInfo[taskId] = &#123;priority, userId&#125;;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p &#123;priority,taskId&#125;;</span><br><span class="line">            heap.<span class="built_in">push</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> taskId, <span class="type">int</span> priority)</span> </span>&#123;</span><br><span class="line">        taskInfo[taskId] = &#123;priority, userId&#125;;</span><br><span class="line">        pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p &#123;priority,taskId&#125;;</span><br><span class="line">        heap.<span class="built_in">push</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">edit</span><span class="params">(<span class="type">int</span> taskId, <span class="type">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (taskInfo.<span class="built_in">find</span>(taskId) != taskInfo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            taskInfo[taskId].first = newPriority;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p &#123;newPriority,taskId&#125;;</span><br><span class="line">            heap.<span class="built_in">push</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rmv</span><span class="params">(<span class="type">int</span> taskId)</span> </span>&#123;</span><br><span class="line">        taskInfo.<span class="built_in">erase</span>(taskId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">execTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [priority, taskId] = heap.<span class="built_in">top</span>();</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (taskInfo.<span class="built_in">find</span>(taskId) != taskInfo.<span class="built_in">end</span>() &amp;&amp; </span><br><span class="line">                taskInfo[taskId].first == priority) &#123;</span><br><span class="line">                <span class="type">int</span> userId = taskInfo[taskId].second;</span><br><span class="line">                taskInfo.<span class="built_in">erase</span>(taskId);</span><br><span class="line">                <span class="keyword">return</span> userId;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Roger-Lv</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">http://example.com/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Roger-Lv's space</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/c++.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/06/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B/" title="深入理解分布式系统（二）分布式系统模型"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">深入理解分布式系统（二）分布式系统模型</div></div><div class="info-2"><div class="info-item-1">分布式系统模型 2.1 两将军问题 “两将军问题”是一个经典的分布式系统问题，旨在研究在存在故障节点的情况下如何协调两个进程之间的通信。 问题场景是两个将军分别率领一支军队进攻敌方城市。两个将军之间必须达成一致，以确定进攻时间和策略。但是，将军们分别位于两个不同的营地，只能通过信使进行通信。此外，有可能存在恶劣的天气或其它因素干扰通信，或者其中一个将军的信使被敌人抓住并修改了消息。 该问题的关键是如何确保将军之间的通信可靠，并避免消息的丢失和篡改。经典的解决方案是使用拜占庭将军问题中的拜占庭容错算法，该算法可以容忍部分节点的故障和恶意攻击。 具体实现上，将军们需要达成共识，以决定进攻时间和策略。首先，每个将军向所有其他将军发送一个决策信息，并等待回复。如果将军收到的回复都是一致的，他就可以确定其他将军的决策，并做出相应的行动。如果将军收到的回复不一致，他会将这些信息再次发送给所有其他将军，直到收到一致的回复。 在该问题中，每个将军需要知道有多少其他将军参与协调，并且需要容忍其他将军的可能失败和恶意行为。这需要设计合适的算法和协议来保证将军之间的协作和共识。 总之，“两将军问题”是...</div></div></div></a><a class="pagination-related" href="/2024/06/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" title="深入理解分布式系统（一）认识分布式系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">深入理解分布式系统（一）认识分布式系统</div></div><div class="info-2"><div class="info-item-1">认识分布式系统 1.1 什么是分布式系统 定义： 分布式系统指的是由多台计算机组成的系统，这些计算机通过网络连接起来，协同工作以实现共同的目标。在分布式系统中，各个计算机之间相互独立，同时也需要协同工作来处理大量的数据和任务。分布式系统可以包括不同类型的计算机，包括服务器、台式机、移动设备等等。 分布式系统的一个主要特点是其高度的可扩展性，可以随着需求增长而增加计算机的数量。分布式系统还具有高可靠性，因为即使其中一个计算机发生故障，系统也可以继续运行，不会因为单一点的故障而完全崩溃。分布式系统还可以提供更好的性能和更快的响应时间，因为可以将任务分配给多个计算机并行处理，而不是依靠单个计算机来处理所有任务。 分布式系统的应用非常广泛，包括云计算、大数据处理、分布式数据库、分布式存储系统、分布式搜索引擎等等。 1.2 为什么需要分布式系统 分布式系统是由多个独立计算机组成的网络，这些计算机通过网络互相通信和协调，共同完成某些任务或提供某些服务。分布式系统之所以重要，是因为它可以带来以下几个好处：  可靠性：分布式系统可以提高系统的可靠性，因为它可以在某个节点或多个节点发生故障的情况下...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/07/18/2024-06-24-%E7%8A%B6%E5%8E%8BDP%E7%AE%97%E6%B3%95/" title="状压DP算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/c++.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-18</div><div class="info-item-2">状压DP算法</div></div><div class="info-2"><div class="info-item-1">状压DP 使用状压DP的原因 我们知道状态压缩，顾名思义，就是需要考虑的状态非常多，我们如果用平常的思想去表示状态，那是非常不现实的，在时间和空间上都不允许，我们使用某种方法，以最小的代价表示某种状态。 那么，这通常是用进制来表示状态的，而选择几进制则根据要求使用的对象的点的状态有几种。一般来说，只有0和1，我们则是用二进制来表示，当然也有其他进制的题，在例题中会列举，需要我们灵活变通，主要谈二进制。 那么如何用二进制表示状态呢？我们发现，二进制上是按位分的，那么我们每一位可以看成一个点，而点上的取值则为该点的状态或者选择。例如00001001这个状态则表示第一个点和第四个点状态为1，其余的点状态为0。所以按照这种思想，能抽象的表示出一个很复杂的状态，实现了时间和空间的优化。 状压DP的适用条件 状态压缩其实是有适用环境的：  状态需要有一定的状态单元。 即一个状态应该是保存一个集合，其中的元素值对应着0或1，例如我们常见的棋盘，我们可以用0或1来表示棋子的放置状态。而整个集合即是一个01串，即二进制数，我们通常用十进制表示。那么我们再进行状态转移或者判断的时候，需要先将十进制转...</div></div></div></a><a class="pagination-related" href="/2024/06/24/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%E6%80%A7%E4%BB%B7%E6%AF%94%E9%97%AE%E9%A2%98%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/" title="关于动态规划&#x2F;性价比&#x2F;背包问题的思考"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/c++.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-24</div><div class="info-item-2">关于动态规划&#x2F;性价比&#x2F;背包问题的思考</div></div><div class="info-2"><div class="info-item-1">关于动态规划/性价比/背包问题的思考 01背包本质上就可以用空间换时间，动规本质上也是那空间换时间，本身也就是一个贪心算法，所以 01背包&lt;–&gt;贪心&lt;–&gt;动态规划 如果说是0-1背包问题，需要逆序更新，原因是东西只有一个，不能影响之前的部分 如果是东西有无数个，则直接顺序更新 如果东西是牛奶之类的，有性价比，并且可以买非整数数量的，可以退化为贪心来做，结构体：数量，价格，性价比，sort一下就完事儿了。 讲究序列（排列问题），先遍历背包，不要求序列（组合问题），先遍历物品 滚动数组 另外，0-1背包要求倒序，若要求组合而非排列，即为先物品，再背包，且倒顺序，滚动数组添加 而且，如果是算有多少种，直接加就行,dp[0]=1，其他为0 123dp[j]+=dp[j-nums[i]]    //这里怎么去理解呢，会导致重复吗？    //不会重复 如果是要算最多/最少，还要min和max比较 1dp[j]=max(dp[j],dp[j-nums[i]]+value[i]) [(425条消息) 背包问题（背包九讲）_你好世界wxx的博客-CSDN博客](https...</div></div></div></a><a class="pagination-related" href="/2024/09/08/2024-09-08-%E7%BA%BF%E6%AE%B5%E6%A0%91/" title="线段树"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/c++.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-08</div><div class="info-item-2">线段树</div></div><div class="info-2"><div class="info-item-1">线段树 线段树是一种二叉树，也就是对于一个线段，我们会用一个二叉树来表示。 性质：节点 i 的权值 = 她的左儿子权值 + 她的右儿子权值。 1. 建树 根据这个思路，我们就可以建树了，我们设一个结构体 tree，tree[i].l 与 tree[i].r 分别表示这个点代表的线段的左右下标，tree[i].sum 表示这个节点表示的线段和。 我们知道，一颗从1开始编号的二叉树，结点 i 的左儿子和右儿子编号分别是 2×i 和 2×i+1。 再根据刚才的性质，得到式子：tree[ i ].sum = tree[i∗2].sum + tree [i∗2+1].sum ，就可以建一颗线段树了！代码如下（这里以区间求和的查询为例）： 12345678910111213void build(int i,int l,int r)&#123;//递归建树    tree[i].l=l;tree[i].r=r;    if(l==r)&#123;//如果这个节点是叶子节点        tree[i].sum=input[l];        return ;    &#125;    //二...</div></div></div></a><a class="pagination-related" href="/2024/06/24/%E4%BF%9D%E7%A0%94/" title="保研复习准备"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/BJ.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-24</div><div class="info-item-2">保研复习准备</div></div><div class="info-2"><div class="info-item-1">保研 (453条消息) 2021年计算机保研面试题_一个主机将两个端口接到网络上是否会提升吞吐量_Challow的博客-CSDN博客 (453条消息) 吐血整理，20个计算机保研常见问题及回答模板_计算机专业20个面试常见问题_Baoyan_cs的博客-CSDN博客 [(453条消息) 2021计算机保研经历(清软, 北深, 浙大, 南大, 中科大, 北航, 哈深, 南开, 华科, 武大, 中大)_inicho的博客-CSDN博客](https://blog.csdn.net/qq_43280818/article/details/123450451?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=计算机网络 保研&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-9-123450451.142^v87^insert_down28,239^v2^insert_chatgpt&amp;spm=...</div></div></div></a><a class="pagination-related" href="/2024/06/24/Java%20algo/" title="Java刷题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/java.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-24</div><div class="info-item-2">Java刷题</div></div><div class="info-2"><div class="info-item-1">Java 2024年 Java 面试八股文（20w字）_java八股文2023-CSDN博客 SQL SQL 50 题（MySQL 版，包括建库建表、插入数据等完整过程，适合复习 SQL 知识点）_sql50题-CSDN博客 SQL常见语句及用法_sql语句大全及用法-CSDN博客 SQL中的 聚合函数 ,where ,having_where后面可以跟聚合函数吗-CSDN博客 Spring 面试被问了几百遍的 IOC 和 AOP ，一篇文章带你搞清楚！！！_ioc和aop的原理面试-CSDN博客 Sentinel sentinel （史上最全）-CSDN博客 Gradle&amp;Maven gradle中的build script详解_gradle buildscript-CSDN博客 [Gradle和Maven的区别-CSDN博客](https://blog.csdn.net/weixin_45626288/article/details/131973787?ops_request_misc={&quot;request_id&quot;%3A&quot;172024305...</div></div></div></a><a class="pagination-related" href="/2024/08/14/2024-08-14-Java%E5%AE%9E%E7%8E%B0LRU%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/" title="Java实现LRU的两种方式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/java.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-14</div><div class="info-item-2">Java实现LRU的两种方式</div></div><div class="info-2"><div class="info-item-1">Java实现LRU的两种方式 1. 直接继承LinkedHashMap 12345678910111213141516171819202122class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;&#123;    private int capacity;        public LRUCache(int capacity) &#123;        super(capacity, 0.75F, true);        this.capacity = capacity;    &#125;    public int get(int key) &#123;        return super.getOrDefault(key, -1);    &#125;    public void put(int key, int value) &#123;        super.put(key, value);    &#125;    @Override    protected boolean rem...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Roger-Lv</div><div class="author-info-description">Send a flare and light the way.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">149</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">128</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">41</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Roger-Lv"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Roger-Lv" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1150568956@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/zhongrenjie-lv-5588a928a/" target="_blank" title="LinkedIn"><i class="iconfont icon-linkedin-fill"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">1.1.</span> <span class="toc-text">注意</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.1.</span> <span class="toc-text">文件操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lint-formatter"><span class="toc-number">1.2.</span> <span class="toc-text">lint&amp;formatter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strcut%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">strcut初始化的例子：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BA%93"><span class="toc-number">1.4.</span> <span class="toc-text">一些常用的库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-number">1.4.1.</span> <span class="toc-text">vector:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">1.4.2.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack"><span class="toc-number">1.4.3.</span> <span class="toc-text">stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue"><span class="toc-number">1.4.4.</span> <span class="toc-text">queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#priority-queue"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">priority_queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-number">1.4.5.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#algorithm"><span class="toc-number">1.4.6.</span> <span class="toc-text">algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#climits"><span class="toc-number">1.4.7.</span> <span class="toc-text">climits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-number">1.4.8.</span> <span class="toc-text">set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#utility"><span class="toc-number">1.4.9.</span> <span class="toc-text">utility:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%EF%BC%88C-17-%E8%B5%B7%EF%BC%89"><span class="toc-number">1.4.10.</span> <span class="toc-text">结构化绑定（C++17 起）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.</span> <span class="toc-text">迭代器操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-number">1.6.</span> <span class="toc-text">容量和属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">自定义比较函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.</span> <span class="toc-text">实际应用示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multiset-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.9.</span> <span class="toc-text">multiset 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%89%B9%E7%82%B9"><span class="toc-number">1.10.</span> <span class="toc-text">性能特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%87%BA%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.11.</span> <span class="toc-text">设置输出精度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%87%BA%E4%BD%8D%E6%95%B0"><span class="toc-number">1.12.</span> <span class="toc-text">设置输出位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP"><span class="toc-number">1.13.</span> <span class="toc-text">KMP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.14.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.14.1.</span> <span class="toc-text">最大连续子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5"><span class="toc-number">1.14.2.</span> <span class="toc-text">最大子矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E-%E5%87%8F%E5%BA%8F%E5%88%97"><span class="toc-number">1.14.3.</span> <span class="toc-text">最长递增&#x2F;减序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%EF%BC%88O-N-2-%EF%BC%89"><span class="toc-number">1.14.4.</span> <span class="toc-text">最大上升子序列和（O(N^2)）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LCS%EF%BC%89"><span class="toc-number">1.14.5.</span> <span class="toc-text">最长公共子序列（LCS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LIS%EF%BC%88Nlogn%EF%BC%89"><span class="toc-number">1.14.6.</span> <span class="toc-text">LIS（Nlogn）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85"><span class="toc-number">1.14.7.</span> <span class="toc-text">01背包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS-BFS"><span class="toc-number">1.15.</span> <span class="toc-text">DFS BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.16.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6"><span class="toc-number">1.16.1.</span> <span class="toc-text">归并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.16.2.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">1.17.</span> <span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E9%97%AE%E9%A2%98"><span class="toc-number">1.18.</span> <span class="toc-text">模拟问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98"><span class="toc-number">1.19.</span> <span class="toc-text">日期问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="toc-number">1.20.</span> <span class="toc-text">最大公因数&#x2F;最小公倍数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95"><span class="toc-number">1.21.</span> <span class="toc-text">素数筛法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%EF%BC%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.22.</span> <span class="toc-text">矩阵乘法（构造函数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.23.</span> <span class="toc-text">高精度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.24.</span> <span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7"><span class="toc-number">1.25.</span> <span class="toc-text">弗洛伊德</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89"><span class="toc-number">1.26.</span> <span class="toc-text">迪杰斯特拉</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%EF%BC%88hierholzer%EF%BC%89"><span class="toc-number">1.27.</span> <span class="toc-text">欧拉回路（hierholzer）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%88AOE%E7%BD%91%EF%BC%89"><span class="toc-number">1.28.</span> <span class="toc-text">关键路径（AOE网）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E4%BD%8Ddp"><span class="toc-number">1.29.</span> <span class="toc-text">数位dp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E5%8E%8BDP"><span class="toc-number">1.30.</span> <span class="toc-text">状压DP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="toc-number">1.31.</span> <span class="toc-text">汉诺塔问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BE%E7%BD%AE%E8%A1%97%E7%81%AF%EF%BC%88Placing-Lampposts-UVa-10859%EF%BC%89-star"><span class="toc-number">1.32.</span> <span class="toc-text">放置街灯（Placing Lampposts, UVa 10859）:star:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E8%B4%AA%E5%BF%83"><span class="toc-number">1.33.</span> <span class="toc-text">经典贪心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98"><span class="toc-number">1.34.</span> <span class="toc-text">跳跃问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number">1.35.</span> <span class="toc-text">分发糖果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.36.</span> <span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="toc-number">1.37.</span> <span class="toc-text">匈牙利算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">1.38.</span> <span class="toc-text">回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E6%A0%91"><span class="toc-number">1.39.</span> <span class="toc-text">建立索引树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hot-100"><span class="toc-number">1.40.</span> <span class="toc-text">hot 100</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-number">1.40.1.</span> <span class="toc-text">49. 字母异位词分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="toc-number">1.40.2.</span> <span class="toc-text">763. 划分字母区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.40.3.</span> <span class="toc-text">32. 最长有效括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84-%E7%9F%A9%E5%BD%A2%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="toc-number">1.40.4.</span> <span class="toc-text">84. 矩形图中的最大面积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LCR-153-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.40.5.</span> <span class="toc-text">LCR 153. 二叉树中和为目标值的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">1.40.6.</span> <span class="toc-text">153. 寻找旋转排序数组中的最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">1.40.7.</span> <span class="toc-text">33. 搜索旋转排序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">1.40.8.</span> <span class="toc-text">76. 最小覆盖子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU"><span class="toc-number">1.40.9.</span> <span class="toc-text">LRU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.40.10.</span> <span class="toc-text">三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">1.40.11.</span> <span class="toc-text">无重复字符的最长子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.40.12.</span> <span class="toc-text">和为k的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">1.40.13.</span> <span class="toc-text">二叉树的最近公共祖先</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98"><span class="toc-number">1.41.</span> <span class="toc-text">每日一题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3227-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%83%E9%9F%B3%E6%B8%B8%E6%88%8F"><span class="toc-number">1.41.1.</span> <span class="toc-text">3227.字符串元音游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1935-%E5%8F%AF%E4%BB%A5%E8%BE%93%E5%85%A5%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E6%95%B0"><span class="toc-number">1.41.2.</span> <span class="toc-text">1935. 可以输入的最大单词数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2197-%E6%9B%BF%E6%8D%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9D%9E%E4%BA%92%E8%B4%A8%E6%95%B0"><span class="toc-number">1.41.3.</span> <span class="toc-text">2197. 替换数组中的非互质数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2349-%E8%AE%BE%E8%AE%A1%E6%95%B0%E5%AD%97%E5%AE%B9%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.41.4.</span> <span class="toc-text">2349. 设计数字容器系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3408-%E8%AE%BE%E8%AE%A1%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.41.5.</span> <span class="toc-text">3408. 设计任务管理器</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/10/12/2025-10-12-Rust-just%E5%AE%89%E8%A3%85/" title="Rust-just安装"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/rust.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Rust-just安装"/></a><div class="content"><a class="title" href="/2025/10/12/2025-10-12-Rust-just%E5%AE%89%E8%A3%85/" title="Rust-just安装">Rust-just安装</a><time datetime="2025-10-11T16:00:00.000Z" title="发表于 2025-10-12 00:00:00">2025-10-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/30/2025-09-30-Langfuse-%E5%92%8C-ClickHouse-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/" title="Langfuse 和 ClickHouse 结合使用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/tencent.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Langfuse 和 ClickHouse 结合使用"/></a><div class="content"><a class="title" href="/2025/09/30/2025-09-30-Langfuse-%E5%92%8C-ClickHouse-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/" title="Langfuse 和 ClickHouse 结合使用">Langfuse 和 ClickHouse 结合使用</a><time datetime="2025-09-29T16:00:00.000Z" title="发表于 2025-09-30 00:00:00">2025-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/24/2025-09-24-Intern-%E5%BF%AB%E9%80%9F-Landing+%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="Intern 快速 Landing+环境搭建"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/tencent.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Intern 快速 Landing+环境搭建"/></a><div class="content"><a class="title" href="/2025/09/24/2025-09-24-Intern-%E5%BF%AB%E9%80%9F-Landing+%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="Intern 快速 Landing+环境搭建">Intern 快速 Landing+环境搭建</a><time datetime="2025-09-23T16:00:00.000Z" title="发表于 2025-09-24 00:00:00">2025-09-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/20/2025-09-14-Autogen%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E4%BA%A4%E6%8E%A5/" title="Autogen多智能体交接"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/agent.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Autogen多智能体交接"/></a><div class="content"><a class="title" href="/2025/09/20/2025-09-14-Autogen%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E4%BA%A4%E6%8E%A5/" title="Autogen多智能体交接">Autogen多智能体交接</a><time datetime="2025-09-19T16:00:00.000Z" title="发表于 2025-09-20 00:00:00">2025-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/18/2025-09-17-GPU%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%8A%A2%E5%8D%A0/" title="GPU资源共享/抢占"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GPU资源共享/抢占"/></a><div class="content"><a class="title" href="/2025/09/18/2025-09-17-GPU%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%8A%A2%E5%8D%A0/" title="GPU资源共享/抢占">GPU资源共享/抢占</a><time datetime="2025-09-17T16:00:00.000Z" title="发表于 2025-09-18 00:00:00">2025-09-18</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2024 - 2025 By Roger-Lv</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.2"></script><script src="/js/main.js?v=5.4.2"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.8.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'smA3tZdRGodG2VgnMubBQjLm-gzGzoHsz',
      appKey: 'biCDxj0lSBtZTMie2kNIKErd',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.3/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><div class="aplayer no-destroy" data-id="8674547170" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.4.2"></script></div></div></body></html>