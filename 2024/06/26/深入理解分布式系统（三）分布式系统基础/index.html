<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>深入理解分布式系统（三）分布式系统基础 | Roger-Lv's space</title><meta name="author" content="Roger-Lv"><meta name="copyright" content="Roger-Lv"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="分布式系统基础 3.1 分区 在分布式系统中，分区是指将数据分成若干个部分，分别存储在不同的节点上，以达到提高系统性能和可扩展性的目的。分区是分布式系统中数据管理的基础。 在分区中，通常采用哈希算法对数据进行划分。具体来说，首先根据数据的某个属性进行哈希计算，得到一个哈希值，然后将这个哈希值映射到某个节点上，将对应的数据存储到这个节点上。通过这种方式，相同属性的数据会被分配到同一个节点上，从而提高">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解分布式系统（三）分布式系统基础">
<meta property="og:url" content="http://example.com/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Roger-Lv&#39;s space">
<meta property="og:description" content="分布式系统基础 3.1 分区 在分布式系统中，分区是指将数据分成若干个部分，分别存储在不同的节点上，以达到提高系统性能和可扩展性的目的。分区是分布式系统中数据管理的基础。 在分区中，通常采用哈希算法对数据进行划分。具体来说，首先根据数据的某个属性进行哈希计算，得到一个哈希值，然后将这个哈希值映射到某个节点上，将对应的数据存储到这个节点上。通过这种方式，相同属性的数据会被分配到同一个节点上，从而提高">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B0%81%E9%9D%A2.png">
<meta property="article:published_time" content="2024-06-25T16:00:00.000Z">
<meta property="article:modified_time" content="2025-07-27T03:05:27.921Z">
<meta property="article:author" content="Roger-Lv">
<meta property="article:tag" content="分布式系统">
<meta property="article:tag" content="深入理解分布式系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B0%81%E9%9D%A2.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "深入理解分布式系统（三）分布式系统基础",
  "url": "http://example.com/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/",
  "image": "http://example.com/img/cover/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B0%81%E9%9D%A2.png",
  "datePublished": "2024-06-25T16:00:00.000Z",
  "dateModified": "2025-07-27T03:05:27.921Z",
  "author": [
    {
      "@type": "Person",
      "name": "Roger-Lv",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://example.com/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.4.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '深入理解分布式系统（三）分布式系统基础',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">147</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">126</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Roger-Lv's space</span></a><a class="nav-page-title" href="/"><span class="site-name">深入理解分布式系统（三）分布式系统基础</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div><!-- 添加搜索按钮 ↓--><span class="search-button"><i class="fas fa-search" aria-hidden="true"></i></span></div></nav><div id="post-info"><h1 class="post-title">深入理解分布式系统（三）分布式系统基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-25T16:00:00.000Z" title="发表于 2024-06-26 00:00:00">2024-06-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-27T03:05:27.921Z" title="更新于 2025-07-27 11:05:27">2025-07-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" data-flag-title="深入理解分布式系统（三）分布式系统基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>分布式系统基础</h1>
<h2 id="3-1-分区">3.1 分区</h2>
<p>在分布式系统中，分区是指将数据分成若干个部分，分别存储在不同的节点上，以达到提高系统性能和可扩展性的目的。分区是分布式系统中数据管理的基础。</p>
<p>在分区中，通常采用哈希算法对数据进行划分。具体来说，首先根据数据的某个属性进行哈希计算，得到一个哈希值，然后将这个哈希值映射到某个节点上，将对应的数据存储到这个节点上。通过这种方式，相同属性的数据会被分配到同一个节点上，从而提高数据访问的效率。</p>
<p>分区可以带来以下好处：</p>
<ol>
<li>提高系统的可扩展性：由于数据被分割成多个部分，每个部分可以分别存储在不同的节点上，因此可以更容易地进行横向扩展，增加节点数量来提高系统的处理能力。</li>
<li>提高系统的性能：由于相同属性的数据被分配到同一个节点上，因此可以更快地访问这些数据，从而提高系统的处理效率。</li>
<li>提高系统的容错性：当某个节点发生故障时，只有该节点上的数据会受到影响，而其他节点上的数据仍然可以正常访问，从而提高了系统的容错性。</li>
</ol>
<p>但是，分区也会带来一些挑战和问题，如数据的一致性和分区策略的选择等。因此，在设计分布式系统时，需要仔细考虑分区策略和数据一致性等问题，以确保系统的正确性和稳定性。</p>
<p>水平分区、垂直分区、列式数据库和行式数据库是关系型数据库的四种常见的数据分区和存储方式。</p>
<ol>
<li><strong>水平分区</strong></li>
</ol>
<p>水平分区是指将数据按照行进行切分，将每个分区的数据存储在不同的节点上。每个节点独立维护一个数据子集，这些数据子集之间相互独立。通常，水平分区的数据切分依据是数据的关键字或者某个属性，以便于查询时能够快速地定位数据。</p>
<p>使用场景：水平分区通常适用于<strong>数据访问压力比较大的场景</strong>，如互联网应用、金融等领域，这些场景中<strong>需要高效的读写操作和数据访问</strong>。</p>
<p>特点：水平分区的优点是能够将数据分散在多个节点上，减少单节点的压力，提高系统性能和可扩展性。缺点是需要考虑数据一致性的问题，当某个节点发生故障时，需要采取相应的措施保证数据的一致性。</p>
<ol start="2">
<li><strong>垂直分区</strong></li>
</ol>
<p>垂直分区是指将数据按照列进行切分，将不同的列存储在不同的节点上。不同的节点维护不同的数据子集，但是数据之间存在关联关系。垂直分区的目的是将数据分开存储，减少节点之间的冗余数据。</p>
<p>使用场景：垂直分区适用于需要对数据进<strong>行复杂查询和分析</strong>的场景，如数据仓库等。</p>
<p>特点：垂直分区的优点是可以减少冗余数据，提高系统性能和存储效率，同时也能提高数据的安全性。缺点是可能会增加系统的复杂度，同时需要进行多表连接查询，对系统性能有一定影响。</p>
<ol start="3">
<li>列式数据库</li>
</ol>
<p>列式数据库是指将数据按照列进行存储和访问的数据库系统。相比于传统的行式数据库，列式数据库更加适用于大规模数据的分析和查询，能够提供更高的查询效率和存储效率。列式数据库将每列数据存储在一个独立的文件或数据块中，这样可以避免读取不必要的数据，从而提高查询效率。</p>
<p>使用场景：列式数据库适用于大规模数据的分析和查询，如数据仓库、在线分析处理等领域。</p>
<p>特点：列式数据库的优点是<strong>查询效率高，存储效率高，能够快速响应复杂查询请求。缺点是更新效率相对较低，不适用于需要频繁进行更新操作的场景</strong>。</p>
<ol start="4">
<li>行式数据库</li>
</ol>
<p>行式数据库是指将数据按照行进行存储和访问的数据库系统。行式数据库将同一行的数据存储在一起，这样能够提高数据的插入和更新效率。相比于列式数据库，行式数据库更适用于需要频繁进行更新操作的场景。</p>
<p>使用场景：行式数据库适用于需要频繁进行更新操作的场景，如在线交易系统、客户关系管理等领域。</p>
<p>特点：行式数据库的优点是<strong>支持高并发的写入操作，适用于需要频繁进行更新操作的场景。缺点是查询效率相对较低，尤其是对于大规模数据的查询</strong>，查询效率明显低于列式数据库。</p>
<h3 id="3-1-1-水平分区算法">3.1.1 水平分区算法</h3>
<p>水平分区算法是指将数据按照某个属性值进行分区的一种算法。以下是几种常见的水平分区算法：</p>
<ol>
<li>范围分区</li>
</ol>
<p>范围分区是将数据按照某个属性值的范围进行分区的算法。例如，对于一个学生表，可以将学生按照年龄范围进行分区，比如0-10岁、11-20岁、21-30岁等等。</p>
<ol start="2">
<li>哈希分区</li>
</ol>
<p>哈希分区是将数据按照某个属性值的哈希值进行分区的算法。例如，对于一个学生表，可以将学生按照学生编号进行哈希分区，将相同哈希值的学生存储在同一个分区中。</p>
<ol start="3">
<li>轮询分区</li>
</ol>
<p>轮询分区是将数据按照一定的轮询方式进行分区的算法。例如，对于一个负载均衡系统，可以将请求按照轮询的方式分配给不同的服务器处理，以达到负载均衡的效果。</p>
<p>以上算法只是水平分区的几种常见方法，实际应用中还可以根据具体的需求和数据特点进行适当的调整和优化。</p>
<p><strong>一致性哈希：</strong></p>
<p><strong>一致性哈希</strong>（Consistent Hashing）是一种分布式哈希算法，它可以将数据和节点映射到同一个哈希环上，从而方便进行数据的分布式存储和访问。一致性哈希算法的核心思想是通过哈希函数将数据和节点映射到同一个环上，然后根据数据的哈希值在环上查找节点，从而实现分布式存储和访问。</p>
<p>一致性哈希算法的优点是可以有效地解决节点的动态增加和删除问题。当新的节点加入系统时，只需要将它的哈希值插入到哈希环上，然后将相邻的数据重新映射到新节点上即可。当节点离开系统时，只需要将它的哈希值从哈希环上移除，然后将相邻的数据重新映射到其他节点上即可。</p>
<p>另外，一致性哈希算法也可以有效地解决数据倾斜问题。由于哈希函数的随机性，一些节点可能会负责更多的数据，从而导致负载不均衡的问题。为了解决这个问题，一致性哈希算法引入了虚拟节点的概念，将每个物理节点映射到多个虚拟节点上，从而平衡节点的负载。</p>
<p>总之，一致性哈希算法是一种简单有效的分布式哈希算法，可以在分布式系统中实现数据的高效分布式存储和访问。</p>
<h3 id="3-1-2-分区的挑战">3.1.2 分区的挑战</h3>
<p>查询困难和事务</p>
<h2 id="3-2-复制">3.2 复制</h2>
<p>在分布式系统中，复制（Replication）是一种常见的技术，它将数据和计算资源复制到多个节点上。复制的好处包括：</p>
<ol>
<li>高可用性：如果一个节点失效，复制的数据和计算资源可以在其他节点上继续运行，保证系统的可用性。</li>
<li>改善性能：通过将数据和计算资源复制到多个节点上，可以减少网络延迟和瓶颈，提高系统的响应速度和吞吐量。</li>
<li>容错性：复制可以提高系统的容错性，即使某个节点发生故障，也可以在其他节点上继续运行，从而保障数据的完整性和可用性。</li>
<li>提高可扩展性：复制可以提高系统的可扩展性，因为复制的数据和计算资源可以在不同的节点上进行并行处理，从而提高系统的处理能力。</li>
</ol>
<p>需要注意的是，复制也会带来一些负面影响，例如增加系统的复杂度和维护成本，以及可能导致数据一致性的问题。因此，在使用复制技术时，需要仔细考虑各种因素，并根据具体情况进行权衡。</p>
<h3 id="3-2-1-单主复制">3.2.1 单主复制</h3>
<p>单主复制是指在分布式系统中，只有一个节点拥有写入权限，其他节点只能进行读取操作，并且该节点负责将写入的数据复制到其他节点上。单主复制的好处包括：</p>
<ol>
<li>简单易用：单主复制相对于其他复制方案来说比较简单，易于实现和维护。</li>
<li>数据一致性：由于只有一个节点拥有写入权限，所以数据的一致性相对较容易维护，可以避免多个节点同时对同一数据进行写入操作导致的数据不一致问题。</li>
<li>安全性：单主复制可以避免多个节点同时写入数据可能导致的数据冲突问题，从而保证数据的安全性。</li>
</ol>
<p>需要注意的是，单主复制也有一些缺点，例如：</p>
<ol>
<li>单点故障：由于只有一个节点拥有写入权限，如果该节点发生故障，整个系统将不可用。</li>
<li>性能瓶颈：由于所有的写入操作都要经过单个节点，可能会成为性能瓶颈，限制了系统的扩展性和吞吐量。</li>
<li>可用性问题：如果节点之间的网络连接出现问题，可能会导致数据无法及时复制到其他节点，从而影响系统的可用性。</li>
</ol>
<p>因此，在使用单主复制技术时，需要仔细考虑各种因素，并根据具体情况进行权衡。</p>
<p>在单主复制中，可以进一步分为以下两种类型：</p>
<ol>
<li>主从复制（Master-Slave Replication）：在主从复制中，只有一个节点（主节点）拥有写入权限，其他节点（从节点）只能进行读取操作，并且主节点负责将写入的数据复制到从节点上。主节点的写入操作会被异步地复制到从节点上，从节点的数据与主节点可能<strong>存在一定的延迟</strong>，但从节点的数据最终会与主节点保持一致。主从复制可以提供高可用性和数据一致性，并且相对简单易用。</li>
<li>主备复制（Master-Standby Replication）：在主备复制中，也只有一个节点（主节点）拥有写入权限，其他节点（备节点）只能进行读取操作，并且备节点与主节点之间的数据同步是<strong>实时的</strong>。当主节点发生故障时，备节点会接管主节点的功能，成为新的主节点，从而保证系统的高可用性。主备复制相对于主从复制来说，可用性更高，但是实现和维护的复杂度更高。</li>
</ol>
<p><strong>脑裂：</strong></p>
<p>脑裂（Split-Brain）是指在分布式系统中，由于网络分区或者其他原因，导致系统中的节点失去联系，无法进行通信，进而导致系统出现数据不一致或者操作冲突的问题。</p>
<p>当出现网络分区时，系统中的节点可能会被分为两个或者多个独立的部分，每个部分都认为自己是整个系统的唯一部分，而且可能会独立地进行写入操作，导致数据不一致的问题。这种情况被称为脑裂。</p>
<p>脑裂可能会导致系统数据的不一致性，从而影响系统的正确性和可用性。为了避免脑裂的发生，可以采取以下措施：</p>
<ol>
<li>使用复制技术：通过将数据和计算资源复制到多个节点上，可以提高系统的可用性和容错性，减少脑裂的可能性。</li>
<li>使用投票机制：在系统中使用投票机制，可以避免脑裂的发生。例如，在主从复制中，主节点可以将写入操作同步到多个从节点上，然后通过投票机制来确定哪个从节点应该成为新的主节点，从而避免脑裂的发生。</li>
<li>限制节点的数量：在分布式系统中，可以限制节点的数量，从而减少系统的复杂度和容错难度，降低脑裂的风险。</li>
<li>监控系统状态：对系统状态进行监控，及时发现和解决潜在的问题，可以有效地避免脑裂的发生。</li>
</ol>
<p>需要注意的是，虽然可以通过上述措施来减少脑裂的风险，但是完全避免脑裂是非常困难的，因此需要在设计和实现分布式系统时充分考虑脑裂的风险，并制定相应的应对策略。</p>
<h3 id="3-2-2-多主复制">3.2.2 多主复制</h3>
<p>在分布式系统中，多主复制（Multi-Master Replication）是指多个节点拥有写入权限，并且可以同时进行写入操作的一种复制方式。每个节点都可以独立地进行写入操作，写入的数据会被异步地复制到其他节点上，从而实现数据的复制和同步。</p>
<p>多主复制相对于单主复制来说，具有以下几个优点：</p>
<ol>
<li><strong>高并发性</strong>：多主复制允许多个节点同时进行写入操作，可以提高系统的并发性和吞吐量，从而满足高并发场景下的需求。</li>
<li><strong>高可用性</strong>：多主复制允许多个节点同时拥有写入权限，当某个节点出现故障时，其他节点可以继续进行写入操作，从而保证系统的高可用性和容错性。</li>
<li><strong>灵活性</strong>：多主复制可以根据实际需求进行灵活配置，可以在多个节点之间平衡负载，提高系统的稳定性和可靠性。</li>
</ol>
<p>但是，多主复制也存在一些挑战和限制：</p>
<ol>
<li>冲突问题：当多个节点同时进行写入操作时，可能会发生数据冲突的问题，需要采取相应的冲突解决策略来避免数据不一致的问题。</li>
<li>一致性问题：多主复制需要保证节点之间数据的一致性，需要使用相应的协调机制来保证数据的正确性和一致性。</li>
<li>实现和维护的复杂度：多主复制的实现和维护相对复杂，需要考虑节点之间的同步和冲突解决等问题，增加了系统的复杂度和维护难度。</li>
</ol>
<p>需要注意的是，在设计和实现多主复制时，需要综合考虑系统的性能、可用性和一致性等方面的需求，以及各种冲突解决和协调机制的复杂度和实现难度，从而选择最合适的复制方式。</p>
<p><strong>解决冲突：</strong></p>
<p>在多主复制中，当多个节点同时对同一个数据进行写入操作时，可能会发生冲突，从而导致数据的不一致性。为了避免冲突问题，可以采用以下几种解决办法：</p>
<ol>
<li>
<p>乐观锁机制：每个节点在进行写入操作前，先获取当前数据的版本号，并在写入时附带版本号信息。当其他节点进行写入时，会发现版本号不一致，从而引发冲突。此时，节点可以根据具体的策略进行相应的处理，例如选择最新的版本进行更新，或者放弃当前的写入操作等。</p>
</li>
<li>
<p>悲观锁机制：每个节点在进行写入操作时，先尝试获取对应的锁，如果获取不到，则说明有其他节点正在进行写入操作，此时可以等待一段时间后再次尝试获取锁，或者放弃当前的写入操作。</p>
</li>
<li>
<p>时序复制机制：在多主复制中，通过使用全局唯一的时间戳或序列号来协调多个节点之间的写入操作，从而避免冲突。每个节点在进行写入操作时，需要带上对应的时间戳或序列号，当其他节点接收到写入请求时，会根据时间戳或序列号来确定写入的先后顺序，从而保证数据的一致性。</p>
</li>
<li>
<p>基于版本向量的机制：每个节点在进行写入操作时，不仅记录当前数据的版本号，还记录其他节点最近的版本号信息。当其他节点进行写入时，会将自己的版本号信息传递给其他节点，从而形成一个版本向量，用于判断不同节点之间的数据冲突和一致性。</p>
</li>
<li>
<p>由客户端解决冲突</p>
</li>
<li>
<p>“最后写入胜利”（Last Writer Wins，LWW）是一种常见的多主复制冲突解决策略。该策略的基本思想是，当多个节点对同一个数据进行写入时，以最后写入的节点为准，即后来的写入操作会覆盖之前的写入操作。</p>
<p>具体实现时，每个节点在进行写入操作时，都会记录对应的时间戳或版本号，当其他节点收到写入请求时，会比较当前节点的时间戳或版本号和自身记录的时间戳或版本号，以此来判断哪个写入操作更晚，从而决定是否接受该写入请求。当发生冲突时，以最后写入的节点为准，更新数据。</p>
<p>需要注意的是，LWW策略虽然简单易实现，但也存在一些潜在的问题，例如可能导致数据的丢失、数据的不一致性等。因此，在选择冲突解决策略时，需要根据具体的应用场景和需求进行综合考虑，权衡不同策略的优缺点。</p>
</li>
<li>
<p>因果关系跟踪</p>
<p>因果关系跟踪（Causal tracing）是一种在分布式系统中用于跟踪不同节点之间交互的技术。在分布式系统中，不同节点之间的交互往往是异步的，并且可能经过多个中间节点，因此需要一种机制来跟踪交互的因果关系，以便分析和调试系统的行为。</p>
<p>因果关系跟踪通常基于事件模型，即将系统的行为抽象为一系列事件，并记录事件之间的因果关系。具体来说，当一个节点发送请求给另一个节点时，需要将请求的相关信息（例如请求ID、时间戳等）附加到请求中，并在接收到响应时将响应的相关信息（例如响应ID、时间戳等）附加到响应中。这样，每个事件就可以通过相关的信息与之前和之后的事件建立因果关系。</p>
<p>通过因果关系跟踪，可以实现分布式系统中的故障定位、性能调优、容错处理等功能。例如，在进行故障定位时，可以根据事件之间的因果关系，追溯出故障的来源；在进行性能调优时，可以通过分析事件之间的时间关系，找出系统中的瓶颈和优化空间；在进行容错处理时，可以根据因果关系判断不同节点之间的依赖关系，从而决定如何进行容错处理。</p>
<p>目前，因果关系跟踪已经成为分布式系统中的一个重要组成部分，并且在开源工具和云服务平台中得到了广泛应用，例如OpenTelemetry、Zipkin、Jaeger等。</p>
</li>
</ol>
<p>需要注意的是，不同的解决办法适用于不同的场景和需求，选择合适的冲突解决策略需要综合考虑多方面的因素，包括系统的性能、可靠性、一致性和复杂度等。</p>
<h3 id="3-2-3-无主复制">3.2.3 无主复制</h3>
<p>无主复制（Masterless replication）是一种分布式系统中常见的数据复制策略，与单主复制和多主复制不同，无主复制不需要指定特定的节点作为主节点，而是让<strong>所有节点都能够读取和写入数据</strong>。具体来说，无主复制通常采用以下两种方式实现：</p>
<ol>
<li>基于<strong>副本集</strong>：无主复制可以基于副本集实现，即将数据复制到多个节点上，并保证每个节点上的数据副本是一致的。当进行写入操作时，所有节点都可以接受写入请求，并将<strong>写入操作广播</strong>给其他节点进行更新。当进行读取操作时，每个节点都可以从自己本地的数据副本中读取数据。</li>
<li>基于<strong>分片</strong>：无主复制也可以基于分片实现，即将数据划分为多个分片，并将每个分片复制到多个节点上。当进行写入操作时，只需要将<strong>写入操作发送给对应的分片所在的节点</strong>，并更新该节点上的数据副本。当进行读取操作时，只需要根据读取请求所涉及的分片，从对应的节点中读取数据。</li>
</ol>
<p>无主复制相比于单主复制和多主复制，具有<strong>更好的可伸缩性和容错性</strong>，因为每个节点都可以独立地接受读写请求，并且可以通过增加节点数目来提高系统的容错能力和吞吐量。但同时，无主复制也需要考虑数据一致性和冲突解决等问题，例如如何解决并发写入操作导致的冲突，如何保证数据的一致性等。</p>
<p>Dynamo架构中的两种数据修复方法：</p>
<ol>
<li>
<p>读修复（Read repair）：读修复是一种在读取数据时自动修复损坏或不一致数据的技术。在分布式系统中，由于数据副本之间可能存在网络分区或写冲突等问题，导致某些节点上的数据副本可能已经过期或损坏。当客户端<strong>从一个节点读取数据时，如果发现该节点上的数据副本已经过期或与其他节点上的副本不一致，该节点会尝试从其他节点中读取最新的数据，并将其与自己的数据副本进行比较和合并，从而实现数据的修复。</strong></p>
</li>
<li>
<p>反熵过程（Anti-entropy）：反熵过程是一种<strong>定期检查</strong>和修复数据不一致问题的技术。在分布式系统中，由于网络故障或其他原因，不同节点上的数据副本可能会出现不一致的情况，为了解决这个问题，系统可以定期启动反熵过程来检查和修复数据不一致。具体来说，反熵过程会<strong>周期性地比较不同节点之间的数据副本，将不同的数据副本进行合并，从而实现数据的一致性。</strong></p>
<p><strong>反熵过程通常会使用Merkle树来检测和修复数据不一致问题。</strong></p>
<p>Merkle树是一种树形结构，它可以用来验证分布式系统中的数据一致性。在Merkle树中，每个叶子节点都是数据块的哈希值，每个非叶子节点都是其子节点哈希值的哈希值。通过比较不同节点之间的Merkle树，可以快速检测数据不一致的位置，并将不同的数据块进行合并。</p>
<p>在反熵过程中，系统会对不同节点之间的Merkle树进行比较，检测不一致的位置，并将不同的数据块进行合并。具体来说，反熵过程会周期性地对所有节点的Merkle树进行比较，如果发现两个节点的Merkle树有不一致的位置，系统会将不同的数据块进行合并，并更新相应的节点。</p>
<p>使用Merkle树来进行反熵过程有以下优点：</p>
<ol>
<li>高效性：Merkle树具有高效的验证和合并性能，可以快速检测和修复数据不一致问题。</li>
<li>安全性：Merkle树可以有效地保护数据的安全性，因为如果任何一个节点的数据发生了改变，其对应的哈希值也会发生改变，从而导致整个Merkle树的哈希值发生改变。</li>
</ol>
<p>因此，Merkle树是反熵过程中常用的技术之一，可以有效地检测和修复分布式系统中的数据不一致问题。</p>
</li>
</ol>
<p><strong>Quorum的数据冗余机制：</strong></p>
<p>Quorum是一种基于Raft协议的分布式一致性算法，它允许在一个集群中同时运行多个副本来提高系统的可靠性和容错性。在Quorum中，数据冗余机制通常通过副本集群来实现。</p>
<p>具体来说，Quorum通过将数据复制到多个节点来实现数据冗余。在一个Quorum集群中，通常会有多个节点运行相同的应用程序，每个节点上都有一个或多个副本存储相同的数据。这些副本可以保证在节点故障或网络故障时，数据仍然可用。</p>
<p>Quorum的数据冗余机制具有以下特点：</p>
<ol>
<li>多副本：每个节点上通常会运行多个副本，确保数据的可靠性和容错性。</li>
<li>复制同步：Quorum使用Raft协议来保证多个副本之间的数据同步，确保每个副本都存储相同的数据。</li>
<li>副本数量：Quorum要求在集群中<strong>至少有一半以上的节点存储相同的数据</strong>，这样可以确保在一定程度上抵御节点故障和网络故障。</li>
<li>容错性：Quorum可以在节点故障或网络故障的情况下继续工作，确保数据的可用性。</li>
</ol>
<p>除了数据冗余机制，Quorum还支持其他一些功能，如数据复制和数据恢复。数据复制是指在集群中将数据从一个节点复制到另一个节点，以确保数据的可靠性和容错性。数据恢复是指在节点故障或网络故障的情况下，将数据从备份节点恢复到故障节点，以确保数据的可用性。这些功能都可以提高Quorum集群的可靠性和容错性。</p>
<p>W&gt;N/2</p>
<p>W和R通常比N小（因为为了降低延迟）</p>
<h2 id="3-3-CAP定理">3.3 CAP定理</h2>
<p>CAP定理是指在一个分布式系统中，一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）这三个特性无法同时满足，只能满足其中的两个。</p>
<p>具体来说：</p>
<ul>
<li>一致性：所有节点在同一时刻看到的数据是相同的。</li>
<li>可用性：客户端能够获得系统的响应，即使某些节点出现故障。</li>
<li>分区容错性：即使网络中断或节点故障，系统仍能继续运行。</li>
</ul>
<p>CAP定理的核心观点是，在分布式系统中，当网络分区发生时，系统必须要做出选择：是保证一致性还是可用性。由于分布式系统不可避免地会发生网络分区，因此系统必须要容忍分区，否则会导致系统的不可用性。因此，CAP定理的实质是，在网络分区发生时，系统必须要在一致性和可用性之间做出取舍。</p>
<p>需要注意的是，CAP定理中提到的一致性和可用性是指强一致性和高可用性，而不是最终一致性和可接受的可用性。最终一致性是指在一定时间内，系统最终会达到一致的状态；而可接受的可用性是指系统可以在一定时间内保证响应客户端的请求，但可能不是实时的。</p>
<p>CAP定理是分布式系统设计和实现的基础原则之一，它提醒我们在设计分布式系统时要充分考虑系统的一致性、可用性和分区容错性之间的关系，并根据具体需求进行取舍。</p>
<p>在网络分区发生时，分布式系统可能无法同时满足高可用性和强一致性，但是可以通过实现最终一致性来保证系统的可用性，并在一定时间内达到一致的状态。同时，如果系统对一致性要求不是非常高，也可以采用可接受的可用性来满足系统的需求。</p>
<p>需要注意的是，最终一致性并不是一个具体的算法或协议，而是一种设计思想或范式。不同的分布式系统可以采用不同的最终一致性策略，例如基于版本的控制、基于时间戳的控制、基于向量时钟的控制等，来保证数据在不同节点之间的最终一致性。</p>
<p><strong>意义：</strong></p>
<ul>
<li>系统开发需要取舍！不存在完美的系统！</li>
<li>CP</li>
<li>AP</li>
</ul>
<h3 id="3-3-1-PACELC定理">3.3.1 PACELC定理</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/348923238">分布式理论 PACELC 了解么？ - 知乎 (zhihu.com)</a></p>
<p>PACELC定理是指，在分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）三者不可同时兼备，只能选择其中的两项。</p>
<p>PACELC定理是基于CAP定理发展而来的。CAP定理指出，在一个分布式系统中，Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性）这三个因素不可同时保证。在分布式系统出现网络分区时，必须选择放弃一致性还是可用性中的一项，以保证系统的可靠性。</p>
<p>PACELC定理是对CAP定理的进一步扩展和细化，将一致性进一步划分为了强一致性（Strong Consistency）和弱一致性（Weak Consistency），并在此基础上提出了三种情况：当出现网络分区时，系统只能保证两项中的其中之一，而具体保证哪两项则取决于分布式系统的设计和应用场景。</p>
<p>具体来说，PACELC定理认为，在分布式系统中，当发生网络分区时，可以选择以下三种策略：</p>
<ol>
<li>保证分区容错性和强一致性，放弃可用性（PA/EC）：这种情况下，系统会在网络分区发生时，停止接受请求，以保证数据的一致性。</li>
<li>保证分区容错性和可用性，放弃强一致性（PA/EL）：这种情况下，系统会允许不同节点的数据出现短时间的不一致，以保证系统的可用性。</li>
<li>保证可用性和强一致性，放弃分区容错性（CA/EL）：这种情况下，系统会在网络分区发生时，仍然继续接受请求，但可能会导致节点之间的数据不一致，以保证系统的可用性和数据的一致性。</li>
</ol>
<p>在实际应用中，选择哪种策略取决于具体的应用场景和需求，需要根据系统的性能要求、可用性要求、数据一致性要求以及成本等因素进行权衡和选择。</p>
<h3 id="3-3-2-BASE">3.3.2 BASE</h3>
<p>在分布式系统的上下文中，BASE 是 “Basically Available, Soft state, Eventually consistent” 的缩写。这是一组原则，可用于设计和实现分布式系统，优先考虑可用性和分区容忍性，而不是强一致性。</p>
<p>Basically Available 指的是分布式系统应始终能够响应客户端请求，即使系统遇到故障或网络分区。Soft state 指的是系统状态随时间变化的想法，只要变化不是关键的，系统最终能够收敛到一致的状态，就是可接受的。Eventually consistent 指的是在足够的时间和适当的同步下，系统最终会在所有节点上变得一致。</p>
<p>与优先考虑强一致性的 ACID（原子性，一致性，隔离性，持久性）原则不同，BASE 是一种更为松散的方法，可以在分布式系统中实现更高的可用性和可伸缩性，但代价是一些一致性上的权衡。</p>
<h2 id="3-4-一致性模型">3.4 一致性模型</h2>
<p>一致性模型是指在分布式计算中，确保多个节点之间数据的一致性和可靠性的模型。在分布式系统中，节点可能会同时读取和写入共享数据，因此必须确保在所有节点上数据的状态是一致的。</p>
<p>常见的一致性模型包括：</p>
<ol>
<li>强一致性模型（线性一致性）：在任何时候，所有节点都能够读取到相同的数据。强一致性模型可以保证数据的完全一致性，但可能会影响系统的性能。</li>
<li>弱一致性模型：在任何时候，不同节点读取到的数据可能会不一样。弱一致性模型通常可以提高系统的性能，但需要更复杂的算法来确保数据的一致性。</li>
<li>最终一致性模型：在一定时间内，所有节点最终都能够读取到相同的数据。最终一致性模型通常是弱一致性模型和强一致性模型之间的一种妥协方案。</li>
</ol>
<p>一致性模型的选择取决于系统的需求和设计目标，需要综合考虑系统的性能、可靠性、一致性和可扩展性等方面。</p>
<h3 id="3-4-1-线性一致性模型">3.4.1 线性一致性模型</h3>
<p>线性一致性模型是一种强一致性模型，它保证在分布式系统中所有节点读取到的数据是一致的，即如果一个节点在时间轴上比另一个节点先写入数据，则先写入的数据一定先于后写入的数据被读取到。线性一致性模型是对强一致性模型的一种加强形式，它要求所有节点读取到的数据的顺序与它们写入的顺序一致，即数据的全局顺序与它们的时间戳有关。</p>
<p>线性一致性模型的实现通常需要使用一些特殊的算法和技术，例如基于向量时钟（vector clock）的数据版本控制机制、分布式锁机制等。这些技术可以确保所有节点读取到的数据的顺序是一致的，同时还可以保证系统的性能和可扩展性。</p>
<p>线性一致性模型通常用于需要强一致性保证的分布式应用，例如金融交易系统、在线游戏等。</p>
<p><strong>向量时钟：</strong></p>
<p>向量时钟是一种用于分布式系统中维护事件顺序的数据结构。它可以帮助分布式系统中的不同节点确定事件的先后顺序，并保证在不同节点中的时间戳的一致性。</p>
<p>向量时钟的基本思想是：每个节点都维护一个向量，向量的长度等于节点的数量，每个节点的向量元素表示该节点上的事件数目。当节点上发生一个事件时，它会将该节点的向量元素加1，并将整个向量发送给其它节点。接收到向量后，节点会将它的本地向量与接收到的向量进行合并，并更新本地向量的元素值，以反映出其它节点上发生的事件情况。这样，每个节点都可以通过比较向量来判断事件的先后顺序。</p>
<p>具体来说，如果向量V和W都是节点数为N的向量时钟，则V &lt;= W的含义是V中的每个元素都小于等于W中对应元素。如果V &lt;= W并且W &lt;= V，则V和W是相等的。当向量V和W不相等时，就可以根据它们的比较结果来判断事件的先后顺序。</p>
<p>向量时钟通常用于实现一些需要维护事件顺序的分布式应用，例如分布式数据库系统、分布式文件系统、分布式共识算法等。</p>
<p><strong>分布式锁：</strong></p>
<p>分布式锁是一种在分布式系统中实现互斥访问的机制，它可以帮助不同节点之间协调并发操作，避免出现冲突和竞争条件。</p>
<p>在分布式系统中，多个节点可能同时访问共享资源，例如数据库、文件系统等。为了避免多个节点同时修改同一份数据，需要使用分布式锁来保证资源的互斥访问。当一个节点想要访问共享资源时，它需要先获取一个分布式锁，确保其他节点不能同时访问该资源。当节点完成操作后，需要释放锁，以允许其他节点继续访问资源。</p>
<p>实现分布式锁的方法有很多种，其中比较常见的包括：</p>
<ol>
<li>基于数据库实现的分布式锁：将锁状态保存在数据库中，节点需要先获取数据库的一个排他锁，才能对锁进行操作。</li>
<li>基于ZooKeeper实现的分布式锁：利用ZooKeeper提供的原子操作和临时节点机制，实现分布式锁。</li>
<li>基于Redis实现的分布式锁：利用Redis提供的SETNX命令和expire命令，实现分布式锁。</li>
</ol>
<p>需要注意的是，在使用分布式锁时，需要考虑锁的粒度和性能等问题。如果锁的粒度过大，可能会导致锁竞争和性能瓶颈；如果锁的粒度过小，可能会导致锁冲突和死锁等问题。因此，在实际应用中，需要根据具体情况选择合适的锁粒度，并进行性能测试和优化。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_67645544/article/details/124768505?ops_request_misc=%7B%22request%5Fid%22%3A%22168594407216800192234961%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168594407216800192234961&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124768505-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&amp;spm=1018.2226.3001.4187">(459条消息) 什么是分布式锁？几种分布式锁分别是怎么实现的？_Java后端架构猛猛的博客-CSDN博客</a></p>
<h3 id="3-4-2-线性一致性的代价">3.4.2 线性一致性的代价</h3>
<p>线性一致性通常需要付出较高的代价，因为要保证数据的全局顺序一致性，需要牺牲一定的可用性和延迟。</p>
<p>在实现线性一致性时，需要考虑以下几个方面的代价：</p>
<ol>
<li>通信代价：为了保证数据的一致性，需要不断进行节点间的通信和同步操作，这会增加网络带宽的使用和延迟。</li>
<li>吞吐量代价：由于要对所有的操作进行全局排序，需要在整个系统范围内协调所有节点的操作，这会对系统的吞吐量产生影响。</li>
<li>可用性代价：在实现线性一致性时，如果某个节点发生故障，会影响整个系统的可用性。因此，在实现线性一致性时，需要采取一些机制来保证故障时的容错和恢复能力。</li>
<li>性能代价：由于要保证全局顺序一致性，系统可能需要进行多轮操作和协调，这会增加系统的延迟和响应时间。</li>
</ol>
<p>因此，在实际应用中，需要根据具体需求和场景，综合考虑各种代价，选择合适的一致性模型和实现方式，以达到最优的性能和可用性。</p>
<h3 id="3-4-3-顺序一致性">3.4.3 顺序一致性</h3>
<p>顺序一致性是一种弱一致性模型，它要求系统的操作按照提交的顺序执行，但不要求所有节点都看到相同的执行顺序。</p>
<p>具体来说，对于任意两个操作，如果它们在一个节点上执行并且提交的顺序是相同的，则在所有节点上的执行顺序必须保持一致。但是，如果两个操作在不同节点上执行，则可能存在不同的执行顺序，即存在并发执行的可能性。因此，顺序一致性保证了操作的有序性，但是不保证全局的一致性。</p>
<p>在实现顺序一致性时，系统可以采用一些机制来保证操作的有序性，例如对操作进行时间戳或序列号标记，或者采用基于向量时钟的算法来实现。</p>
<p>相对于线性一致性来说，顺序一致性的代价较低，因为它不需要保证所有节点都看到相同的执行顺序。因此，顺序一致性通常用于一些对一致性要求不是特别高的场景，例如社交网络应用、在线游戏等。</p>
<h3 id="3-4-4-因果一致性（微信朋友圈）">3.4.4 因果一致性（微信朋友圈）</h3>
<p>因果一致性是一种弱一致性模型，它要求系统的操作按照因果关系执行，即如果一个操作A在另一个操作B之前发生，那么操作B在所有节点上的执行必须在操作A之后。这意味着，因果一致性可以保证操作的有序性和因果关系，但不要求所有节点都看到相同的执行顺序。</p>
<p>具体来说，因果一致性要求系统中的所有节点都按照相同的因果顺序执行操作。在实现因果一致性时，通常采用向量时钟或其他类似的机制来维护操作的因果关系。</p>
<p>因果一致性相对于线性一致性和顺序一致性来说，代价更低，因为它不需要对所有操作进行全局排序，只需要保证操作的因果关系即可。因此，因果一致性通常用于一些对一致性要求不是特别高的场景，例如分布式日志系统、分布式数据库等。</p>
<p>值得注意的是，因果一致性仅仅保证了操作的因果关系和有序性，而不保证操作的结果和值。因此，在使用因果一致性时，需要考虑数据一致性和可用性等方面的问题。</p>
<h3 id="3-4-5-最终一致性（搜索引擎、社交网络）">3.4.5 最终一致性（搜索引擎、社交网络）</h3>
<p>最终一致性是一种弱一致性模型，它允许系统中的不同节点在一段时间内保持数据的不一致性，但最终会达到一致的状态。这意味着，当系统中存在多个副本时，这些副本在某个时间点上的状态可能不同，但经过一段时间的同步和协调后，最终会达到一致的状态。</p>
<p>在实现最终一致性时，通常采用异步复制或延迟复制的方式，即不要求所有节点在短时间内达到一致的状态，而是允许节点在本地更新数据，并在后续的时间点上将更新的数据同步到其他节点。这样做可以提高系统的可用性和性能，并减少系统之间的通信负担。</p>
<p>最终一致性适用于一些对数据一致性要求不是特别高的场景，例如<strong>搜索引擎、社交网络</strong>等。但是，最终一致性也存在一些问题，例如数据冲突和合并、数据同步的延迟等，需要在实际应用中进行适当的处理和解决。</p>
<h3 id="3-4-6-以客户端为中心的一致性模型">3.4.6 以客户端为中心的一致性模型</h3>
<p>以客户端为中心的一致性模型是一种应用程序在客户端上维护数据一致性的模型。在这个模型中，客户端负责维护数据的一致性，而不是依赖于分布式系统来维护数据的一致性。</p>
<p>具体来说，以客户端为中心的一致性模型通常采用乐观并发控制的策略。在这个策略中，客户端通过在本地缓存中保存数据副本来维护数据的一致性，并在修改数据时对缓存中的数据进行验证。如果数据未被其他客户端修改，则客户端可以直接提交修改。否则，客户端需要处理数据冲突，并根据一些策略来解决冲突。</p>
<p>以客户端为中心的一致性模型适用于一些对一致性要求不是特别高的场景，例如移动应用、离线应用等。这种模型具有良好的可用性和性能，因为客户端可以通过本地缓存快速读写数据，而不必依赖于分布式系统进行通信。但是，它也存在一些问题，例如数据冲突和合并、数据同步的延迟等，需要在实际应用中进行适当的处理和解决。</p>
<p>单调读（Monotonic Reads）和单调写（Monotonic Writes）是指一个线程对于一个特定变量的读操作或写操作，必须按照执行顺序，按照先后顺序看到最近的操作结果。</p>
<p>例如，如果线程A先写入变量x，然后线程B读取变量x，那么线程B必须看到线程A的写入结果，而不是之前的旧值。</p>
<p>读你所写（Read Your Writes，RYW）是指一个线程对于一个特定变量的读操作，必须在它自己的最近的写操作之后进行。这个特性在分布式系统中非常重要，因为它可以保证一个线程在写入某个变量之后，能够看到它自己的写入结果，而不是其他线程的旧值。</p>
<p>PRAM（Parallel Random Access Machine）是一种并行计算模型，它描述了一种在共享内存并行计算机上进行并行计算的方式。PRAM模型中，所有处理器共享一个全局内存，并且可以在O(1)时间内进行读写操作。</p>
<p>在PRAM模型中，单调读、单调写和读你所写是非常重要的一些性质，因为它们可以保证在并行计算中不会发生数据冲突和数据不一致的问题，从而保证并行计算的正确性和性能。</p>
<h2 id="3-5-隔离级别">3.5 隔离级别</h2>
<p>隔离级别是指在数据库事务中不同事务之间对数据的读写所采用的不同的隔离策略。常见的隔离级别有四种：读未提交、读已提交、可重复读和串行化。</p>
<ol>
<li>读未提交（Read Uncommitted）：最低的隔离级别，允许一个事务读取另一个事务未提交的数据，可能导致脏读、不可重复读、幻读等问题。</li>
<li>读已提交（Read Committed）：在一个事务中，读取数据时只能读取已经提交的数据，可以避免脏读问题，但是可能会出现不可重复读和幻读问题。</li>
<li>可重复读（Repeatable Read）：保证一个事务在多次读取同一数据时，能够看到同样的数据，即同一事务内多次查询结果集相同。但是，其他事务可以向该数据表中插入新的数据，导致幻读问题。</li>
<li>串行化（Serializable）：最高的隔离级别，完全隔离每个事务，事务只能一个接一个地执行，避免了所有并发问题，但是效率较低。</li>
</ol>
<p>不同的隔离级别在事务处理中的性能和正确性上有不同的影响，需要根据具体的业务需求进行选择。一般来说，读已提交和可重复读是应用比较广泛的隔离级别。</p>
<h2 id="3-6-一致性和隔离级别的对比">3.6 一致性和隔离级别的对比</h2>
<p>线性一致性和串行化都是数据库中保证事务正确性的机制，但是它们有不同的实现方式和应用场景。</p>
<p>线性一致性（Linearizability）是指，在分布式系统中，每个操作都有一个全局的先后顺序，该顺序满足原子性、顺序性、一致性和实时性的要求。也就是说，线性一致性保证了分布式系统中的操作顺序与单个系统中的操作顺序相同，而且保证了操作的原子性、一致性和实时性。线性一致性保证了分布式系统中的操作表现出和单个系统一样的行为，对于应用程序来说，感知不到分布式环境的存在。</p>
<p>串行化（Serialization）是指，在多个事务并发访问同一份数据时，数据库系统会把这些事务串行执行，以保证数据的正确性。串行化可以消除脏读、不可重复读和幻读等问题，但是会降低并发性能。</p>
<p>虽然线性一致性和串行化都能保证数据的正确性，但是它们的应用场景不同。线性一致性更适用于分布式环境下的系统，例如分布式缓存、分布式队列等。而串行化更适用于事务并发访问同一份数据时，需要严格控制并发执行顺序的场景，例如银行转账、订单处理等。</p>
<p>需要注意的是，线性一致性和串行化都会影响数据库的并发性能，因此需要根据具体的业务需求和系统架构来选择适合的一致性控制机制，以保证系统的正确性和并发性能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Roger-Lv</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/">http://example.com/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Roger-Lv's space</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a><a class="post-meta__tags" href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">深入理解分布式系统</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B0%81%E9%9D%A2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="深入理解分布式系统（五）分布式事务"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">深入理解分布式系统（五）分布式事务</div></div><div class="info-2"><div class="info-item-1">分布式事务 5.1 什么是分布式事务 ACID:  原子性（Atomicity）：一个事务被视为一个不可分割的最小工作单位，事务中的所有操作要么全部完成，要么全部撤销回滚，不允许出现部分完成的情况。 一致性（Consistency）：事务开始前和结束后，数据库必须处于一致的状态，即事务执行后所得的结果必须符合预期的规定的结构和约束条件。 隔离性（Isolation）：多个事务相互隔离不受干扰，每个事务只能“看到”其所执行的数据和其他事务已提交的数据，而看不到其他事务未提交的数据。 持久性（Durability）：一个事务提交后，它对数据库的改变必须被永久保存到数据库中，即使出现断电等故障，其对数据库的改变也不能丢失。  分布式事务两种变体：  同一份数据需要在多个副本上更新，一个分布式事务需要更新所有的副本，如果有的节点提交了事务，有的节点回滚了事务，那么这样的结果对于用户来说是无法接受的。（可利用单主复制解决） 数据进行了分区，事务跨越多个节点，还要同时保证整体数据一致和事务的ACID属性。（常见且重点）  分布式事务通常不讨论ACID中的一致性。 想要实现持久性，只需在向客户...</div></div></div></a><a class="pagination-related" href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/" title="深入理解分布式系统（七）案例研究"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">深入理解分布式系统（七）案例研究</div></div><div class="info-2"><div class="info-item-1">案例研究 7.1 分布式文件系统 GFS (459条消息) 什么是簇：什么是卷_tianwailaibin的博客-CSDN博客 【MIT 6.824】学习笔记 3: GFS - 知乎 (zhihu.com)  7.2 分布式协调服务 Zookeeper 什么是ZooKeeper？ - 知乎 (zhihu.com) zookeeper原理详解 - 知乎 (zhihu.com) [Zookeeper纸上谈兵——Zookeeper与CAP原则-CSDN博客](https://blog.csdn.net/qq_38194699/article/details/109016025?ops_request_misc={&quot;request_id&quot;%3A&quot;171939403416800178545807&quot;%2C&quot;scm&quot;%3A&quot;20140713.130102334.pc_all.&quot;}&amp;request_id=171939403416800178545807&amp;biz_id=0&amp;utm_medium=...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/06/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" title="深入理解分布式系统（一）认识分布式系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B0%81%E9%9D%A2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-24</div><div class="info-item-2">深入理解分布式系统（一）认识分布式系统</div></div><div class="info-2"><div class="info-item-1">认识分布式系统 1.1 什么是分布式系统 定义： 分布式系统指的是由多台计算机组成的系统，这些计算机通过网络连接起来，协同工作以实现共同的目标。在分布式系统中，各个计算机之间相互独立，同时也需要协同工作来处理大量的数据和任务。分布式系统可以包括不同类型的计算机，包括服务器、台式机、移动设备等等。 分布式系统的一个主要特点是其高度的可扩展性，可以随着需求增长而增加计算机的数量。分布式系统还具有高可靠性，因为即使其中一个计算机发生故障，系统也可以继续运行，不会因为单一点的故障而完全崩溃。分布式系统还可以提供更好的性能和更快的响应时间，因为可以将任务分配给多个计算机并行处理，而不是依靠单个计算机来处理所有任务。 分布式系统的应用非常广泛，包括云计算、大数据处理、分布式数据库、分布式存储系统、分布式搜索引擎等等。 1.2 为什么需要分布式系统 分布式系统是由多个独立计算机组成的网络，这些计算机通过网络互相通信和协调，共同完成某些任务或提供某些服务。分布式系统之所以重要，是因为它可以带来以下几个好处：  可靠性：分布式系统可以提高系统的可靠性，因为它可以在某个节点或多个节点发生故障的情况下...</div></div></div></a><a class="pagination-related" href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/" title="深入理解分布式系统（七）案例研究"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B0%81%E9%9D%A2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-26</div><div class="info-item-2">深入理解分布式系统（七）案例研究</div></div><div class="info-2"><div class="info-item-1">案例研究 7.1 分布式文件系统 GFS (459条消息) 什么是簇：什么是卷_tianwailaibin的博客-CSDN博客 【MIT 6.824】学习笔记 3: GFS - 知乎 (zhihu.com)  7.2 分布式协调服务 Zookeeper 什么是ZooKeeper？ - 知乎 (zhihu.com) zookeeper原理详解 - 知乎 (zhihu.com) [Zookeeper纸上谈兵——Zookeeper与CAP原则-CSDN博客](https://blog.csdn.net/qq_38194699/article/details/109016025?ops_request_misc={&quot;request_id&quot;%3A&quot;171939403416800178545807&quot;%2C&quot;scm&quot;%3A&quot;20140713.130102334.pc_all.&quot;}&amp;request_id=171939403416800178545807&amp;biz_id=0&amp;utm_medium=...</div></div></div></a><a class="pagination-related" href="/2024/06/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B/" title="深入理解分布式系统（二）分布式系统模型"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B0%81%E9%9D%A2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-24</div><div class="info-item-2">深入理解分布式系统（二）分布式系统模型</div></div><div class="info-2"><div class="info-item-1">分布式系统模型 2.1 两将军问题 “两将军问题”是一个经典的分布式系统问题，旨在研究在存在故障节点的情况下如何协调两个进程之间的通信。 问题场景是两个将军分别率领一支军队进攻敌方城市。两个将军之间必须达成一致，以确定进攻时间和策略。但是，将军们分别位于两个不同的营地，只能通过信使进行通信。此外，有可能存在恶劣的天气或其它因素干扰通信，或者其中一个将军的信使被敌人抓住并修改了消息。 该问题的关键是如何确保将军之间的通信可靠，并避免消息的丢失和篡改。经典的解决方案是使用拜占庭将军问题中的拜占庭容错算法，该算法可以容忍部分节点的故障和恶意攻击。 具体实现上，将军们需要达成共识，以决定进攻时间和策略。首先，每个将军向所有其他将军发送一个决策信息，并等待回复。如果将军收到的回复都是一致的，他就可以确定其他将军的决策，并做出相应的行动。如果将军收到的回复不一致，他会将这些信息再次发送给所有其他将军，直到收到一致的回复。 在该问题中，每个将军需要知道有多少其他将军参与协调，并且需要容忍其他将军的可能失败和恶意行为。这需要设计合适的算法和协议来保证将军之间的协作和共识。 总之，“两将军问题”是...</div></div></div></a><a class="pagination-related" href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="深入理解分布式系统（五）分布式事务"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B0%81%E9%9D%A2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-26</div><div class="info-item-2">深入理解分布式系统（五）分布式事务</div></div><div class="info-2"><div class="info-item-1">分布式事务 5.1 什么是分布式事务 ACID:  原子性（Atomicity）：一个事务被视为一个不可分割的最小工作单位，事务中的所有操作要么全部完成，要么全部撤销回滚，不允许出现部分完成的情况。 一致性（Consistency）：事务开始前和结束后，数据库必须处于一致的状态，即事务执行后所得的结果必须符合预期的规定的结构和约束条件。 隔离性（Isolation）：多个事务相互隔离不受干扰，每个事务只能“看到”其所执行的数据和其他事务已提交的数据，而看不到其他事务未提交的数据。 持久性（Durability）：一个事务提交后，它对数据库的改变必须被永久保存到数据库中，即使出现断电等故障，其对数据库的改变也不能丢失。  分布式事务两种变体：  同一份数据需要在多个副本上更新，一个分布式事务需要更新所有的副本，如果有的节点提交了事务，有的节点回滚了事务，那么这样的结果对于用户来说是无法接受的。（可利用单主复制解决） 数据进行了分区，事务跨越多个节点，还要同时保证整体数据一致和事务的ACID属性。（常见且重点）  分布式事务通常不讨论ACID中的一致性。 想要实现持久性，只需在向客户...</div></div></div></a><a class="pagination-related" href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89%E6%97%B6%E9%97%B4%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A1%BA%E5%BA%8F/" title="深入理解分布式系统（六）时间和事件顺序"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B0%81%E9%9D%A2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-26</div><div class="info-item-2">深入理解分布式系统（六）时间和事件顺序</div></div><div class="info-2"><div class="info-item-1">时间和事件顺序 6.1 物理时钟  机械时钟 石英时钟 原子钟：原子共振频率标准来计算 GPS  6.2 时钟同步 NTP:(430条消息) NTP详解(网络时间协议)_127.127.1.0 ntp含义_思福迪小白的博客-CSDN博客 针对NTP同步导致时间回退甚至是负数的情况–单调时钟，保证返回的时间严格单调增长 Cloudflare没用单调时钟，而是在发现时间差为负数或者0时变为一个默认值（golang没暴露单调时钟） 单调时钟的局限性：以自身所在的计算机的某个时间为起点，也就是说，来自同一个节点的单调时钟才有意义。 如何发明分布式系统中的单调时钟？ 6.3 逻辑时钟 Lamport Clock Happens-Before: ​	if a-&gt;b  if a and b are in the same process, and a is before b, then a-&gt;b if a is the event that sends a message , b is the event that receives the message, then a-&gt;...</div></div></div></a><a class="pagination-related" href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86/" title="深入理解分布式系统（四）分布式共识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B0%81%E9%9D%A2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-26</div><div class="info-item-2">深入理解分布式系统（四）分布式共识</div></div><div class="info-2"><div class="info-item-1">分布式共识 4.1 分布式共识简介 分布式共识（Distributed Consensus）是指在分布式系统中，多个节点（或进程）协同完成某个任务或达成某个决策的过程。在这个过程中，每个节点需要就该任务或决策达成一致，并且能够互相通信、协调、协作。 分布式共识的一个重要应用是在区块链技术中，用于解决双花问题（Double-spending problem）和确定哪些交易会被写入区块链。比特币等加密货币就是通过共识算法来实现去中心化的交易记录。 常见的分布式共识算法包括拜占庭将军问题（Byzantine fault tolerance, BFT）、Raft、Paxos、Proof of Work（PoW）、Proof of Stake（PoS）等。这些算法都有各自的优缺点，适用于不同的场景。例如，PoW 算法被应用在比特币等加密货币中，而 PoS 算法则被用在以太坊等区块链平台中。 4.1.1 什么是分布式共识 分布式共识是指在一个分布式系统中，多个节点之间需要就某些决策达成一致意见的过程。在这个过程中，各个节点通过相互通信和协作来达成共识，以保证系统能够正常运作并避免出现错误或冲...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Roger-Lv</div><div class="author-info-description">Send a flare and light the way.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">147</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">126</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Roger-Lv"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Roger-Lv" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1150568956@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/zhongrenjie-lv-5588a928a/" target="_blank" title="LinkedIn"><i class="iconfont icon-linkedin-fill"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">分布式系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%88%86%E5%8C%BA"><span class="toc-number">1.1.</span> <span class="toc-text">3.1 分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E6%B0%B4%E5%B9%B3%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">3.1.1 水平分区算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E5%88%86%E5%8C%BA%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">3.1.2 分区的挑战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%A4%8D%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">3.2 复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%8D%95%E4%B8%BB%E5%A4%8D%E5%88%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">3.2.1 单主复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">3.2.2 多主复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E6%97%A0%E4%B8%BB%E5%A4%8D%E5%88%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.2.3 无主复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-CAP%E5%AE%9A%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">3.3 CAP定理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-PACELC%E5%AE%9A%E7%90%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.3.1 PACELC定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-BASE"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.3.2 BASE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">3.4 一致性模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.4.1 线性一致性模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.4.2 线性一致性的代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.4.3 顺序一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E5%9B%A0%E6%9E%9C%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">3.4.4 因果一致性（微信朋友圈）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E3%80%81%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%EF%BC%89"><span class="toc-number">1.4.5.</span> <span class="toc-text">3.4.5 最终一致性（搜索引擎、社交网络）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-6-%E4%BB%A5%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.6.</span> <span class="toc-text">3.4.6 以客户端为中心的一致性模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">3.5 隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.</span> <span class="toc-text">3.6 一致性和隔离级别的对比</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/24/2025-09-24-Intern-%E5%BF%AB%E9%80%9F-Landing+%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="Intern 快速 Landing+环境搭建"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/tencent.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Intern 快速 Landing+环境搭建"/></a><div class="content"><a class="title" href="/2025/09/24/2025-09-24-Intern-%E5%BF%AB%E9%80%9F-Landing+%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="Intern 快速 Landing+环境搭建">Intern 快速 Landing+环境搭建</a><time datetime="2025-09-23T16:00:00.000Z" title="发表于 2025-09-24 00:00:00">2025-09-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/20/2025-09-14-Autogen%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E4%BA%A4%E6%8E%A5/" title="Autogen多智能体交接"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/agent.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Autogen多智能体交接"/></a><div class="content"><a class="title" href="/2025/09/20/2025-09-14-Autogen%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E4%BA%A4%E6%8E%A5/" title="Autogen多智能体交接">Autogen多智能体交接</a><time datetime="2025-09-19T16:00:00.000Z" title="发表于 2025-09-20 00:00:00">2025-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/18/2025-09-17-GPU%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%8A%A2%E5%8D%A0/" title="GPU资源共享/抢占"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GPU资源共享/抢占"/></a><div class="content"><a class="title" href="/2025/09/18/2025-09-17-GPU%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%8A%A2%E5%8D%A0/" title="GPU资源共享/抢占">GPU资源共享/抢占</a><time datetime="2025-09-17T16:00:00.000Z" title="发表于 2025-09-18 00:00:00">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/18/2025-09-18-MTU%E6%8E%A2%E6%B5%8B/" title="MTU探测"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/mtu.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MTU探测"/></a><div class="content"><a class="title" href="/2025/09/18/2025-09-18-MTU%E6%8E%A2%E6%B5%8B/" title="MTU探测">MTU探测</a><time datetime="2025-09-17T16:00:00.000Z" title="发表于 2025-09-18 00:00:00">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/18/2025-09-18-Agent-%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7+eval/" title="Agent 可观测性+eval"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/agent.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Agent 可观测性+eval"/></a><div class="content"><a class="title" href="/2025/09/18/2025-09-18-Agent-%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7+eval/" title="Agent 可观测性+eval">Agent 可观测性+eval</a><time datetime="2025-09-17T16:00:00.000Z" title="发表于 2025-09-18 00:00:00">2025-09-18</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2024 - 2025 By Roger-Lv</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.2"></script><script src="/js/main.js?v=5.4.2"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.8.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'smA3tZdRGodG2VgnMubBQjLm-gzGzoHsz',
      appKey: 'biCDxj0lSBtZTMie2kNIKErd',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.3/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><div class="aplayer no-destroy" data-id="8674547170" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.4.2"></script></div></div></body></html>