<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>容器运行时扩展方案技术解析 | Roger-Lv's space</title><meta name="author" content="Roger-Lv"><meta name="copyright" content="Roger-Lv"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="容器运行时扩展方案技术解析 基于对某容器运行时扩展项目的代码分析，现从架构层面提炼其核心技术实现，聚焦三大核心能力：运行时接入机制、容器根文件系统云端持久化、Docker-in-Docker 安全实现方案。  1. 如何接入 Containerd 运行时生态 项目通过 Containerd Proxy Plugin 机制 实现与容器运行时的无缝集成，架构清晰、扩展性强。 ▶ 配置层接入  在 co">
<meta property="og:type" content="article">
<meta property="og:title" content="容器运行时扩展方案技术解析">
<meta property="og:url" content="http://example.com/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Roger-Lv&#39;s space">
<meta property="og:description" content="容器运行时扩展方案技术解析 基于对某容器运行时扩展项目的代码分析，现从架构层面提炼其核心技术实现，聚焦三大核心能力：运行时接入机制、容器根文件系统云端持久化、Docker-in-Docker 安全实现方案。  1. 如何接入 Containerd 运行时生态 项目通过 Containerd Proxy Plugin 机制 实现与容器运行时的无缝集成，架构清晰、扩展性强。 ▶ 配置层接入  在 co">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/k8s.png">
<meta property="article:published_time" content="2025-09-15T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-19T02:11:22.026Z">
<meta property="article:author" content="Roger-Lv">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="K8S">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/k8s.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "容器运行时扩展方案技术解析",
  "url": "http://example.com/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/",
  "image": "http://example.com/img/cover/k8s.png",
  "datePublished": "2025-09-15T16:00:00.000Z",
  "dateModified": "2025-09-19T02:11:22.026Z",
  "author": [
    {
      "@type": "Person",
      "name": "Roger-Lv",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://example.com/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.4.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '容器运行时扩展方案技术解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">147</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">126</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Roger-Lv's space</span></a><a class="nav-page-title" href="/"><span class="site-name">容器运行时扩展方案技术解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div><!-- 添加搜索按钮 ↓--><span class="search-button"><i class="fas fa-search" aria-hidden="true"></i></span></div></nav><div id="post-info"><h1 class="post-title">容器运行时扩展方案技术解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-15T16:00:00.000Z" title="发表于 2025-09-16 00:00:00">2025-09-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-19T02:11:22.026Z" title="更新于 2025-09-19 10:11:22">2025-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/" data-flag-title="容器运行时扩展方案技术解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>容器运行时扩展方案技术解析</h1>
<p>基于对某容器运行时扩展项目的代码分析，现从架构层面提炼其核心技术实现，聚焦三大核心能力：<strong>运行时接入机制、容器根文件系统云端持久化、Docker-in-Docker 安全实现方案</strong>。</p>
<hr>
<h2 id="1-如何接入-Containerd-运行时生态">1. 如何接入 Containerd 运行时生态</h2>
<p>项目通过 <strong>Containerd Proxy Plugin 机制</strong> 实现与容器运行时的无缝集成，架构清晰、扩展性强。</p>
<h3 id="▶-配置层接入">▶ 配置层接入</h3>
<ul>
<li>在 <code>containerd</code> 配置中注册名为 <code>custom-snapshotter</code> 的代理插件，通过 Unix Domain Socket 与本地 Agent 通信；</li>
<li>同时注册自定义 Runtime，指向特定二进制执行程序，实现容器生命周期的定制化控制。</li>
</ul>
<h3 id="▶-运行时层实现">▶ 运行时层实现</h3>
<ul>
<li><strong>Agent 侧</strong>：实现标准 gRPC 服务，响应来自 Containerd 的 Snapshotter 接口调用（如 Prepare、Mount、Remove）；</li>
<li><strong>存储层封装</strong>：采用 Wrapper 模式封装原生 OverlayFS Snapshotter，在不破坏原有逻辑的前提下注入自定义行为（如镜像预处理、元数据记录等）；</li>
<li><strong>通信机制</strong>：通过本地 Unix Socket 实现低延迟、高安全性的进程间通信。</li>
</ul>
<blockquote>
<p>✅ 价值：无需修改 Containerd 核心代码，即可实现运行时行为扩展，符合云原生插件化设计哲学。</p>
</blockquote>
<hr>
<h2 id="2-容器-RootFS-云端持久化方案">2. 容器 RootFS 云端持久化方案</h2>
<p>项目支持在容器终止时，自动将根文件系统打包并上传至云端存储，实现状态持久化与跨节点恢复。</p>
<h3 id="▶-触发机制">▶ 触发机制</h3>
<ul>
<li>通过 Kubernetes Pod 标签（如 <code>backup.container.io/enabled=true</code>）声明式触发备份行为；</li>
<li>由控制器监听 Pod 生命周期事件，在容器终止前自动发起备份流程。</li>
</ul>
<h3 id="▶-存储架构">▶ 存储架构</h3>
<ul>
<li>支持<strong>本地暂存 + 云端迁移</strong>双阶段模式，适配不同存储后端（如 POSIX 兼容文件系统、分布式存储等）；</li>
<li>使用标准 <code>tar</code> 格式归档容器根目录，兼容性强，支持多版本格式演进；</li>
<li>通过自定义 CRD（Custom Resource Definition）统一管理备份任务状态、元数据及生命周期。</li>
</ul>
<h3 id="▶-上传流程">▶ 上传流程</h3>
<ol>
<li>控制器捕获容器终止事件，匹配备份策略；</li>
<li>调用 Backup Manager 执行本地打包；</li>
<li>将归档文件异步上传至云端存储系统；</li>
<li>更新 CRD 状态，记录存储路径、校验和、时间戳等关键元数据。</li>
</ol>
<blockquote>
<p>✅ 价值：实现“有状态容器”的云原生存储迁移，为故障恢复、环境复现、审计追溯提供基础能力。</p>
</blockquote>
<hr>
<h2 id="3-Docker-in-Docker（DinD）安全实现方案">3. Docker-in-Docker（DinD）安全实现方案</h2>
<p>项目通过轻量化、命名空间隔离的 DinD 架构，为容器内提供完整且安全的 Docker 服务，避免传统 DinD 的权限与资源冲突问题。</p>
<h3 id="▶-架构设计">▶ 架构设计</h3>
<ul>
<li>为每个需 Docker 能力的业务容器，动态创建专属的 DinD容器；</li>
<li>DinD 容器与主容器共享 cgroup 与网络命名空间，确保资源隔离的同时保持网络互通。</li>
</ul>
<h3 id="▶-核心实现">▶ 核心实现</h3>
<ul>
<li><strong>容器创建</strong>：使用轻量级容器工具（如 <code>nerdctl</code>）启动 DinD 容器，挂载主容器 rootfs 至指定路径，实现上下文共享；</li>
<li><strong>网络配置</strong>：通过初始化脚本配置共享网络栈，确保 DinD 内部构建的容器可被主容器访问；</li>
<li><strong>服务暴露</strong>：通过 gRPC 接口封装 Docker API，主容器可通过客户端工具调用构建、运行、镜像管理等操作；</li>
<li><strong>命令行工具</strong>：提供 CLI 工具，支持与 DinD 服务交互，简化调试与集成。</li>
</ul>
<h3 id="▶-关键特性">▶ 关键特性</h3>
<ul>
<li>支持 GPU 设备透传与资源配额管理；</li>
<li>完整兼容 Docker API，业务无感知迁移；</li>
<li>基于 Kubernetes ServiceAccount Token 实现调用鉴权；</li>
<li>内置健康检查与配置热更新机制，保障服务稳定性。</li>
</ul>
<blockquote>
<p>✅ 价值：在安全隔离的前提下，赋予容器内构建与运行 Docker 的能力，适用于 CI/CD、开发环境、模型训练等场景。</p>
</blockquote>
<hr>
<h2 id="总结">总结</h2>
<p>本方案通过深度集成 Containerd 与 Kubernetes，实现了三大核心能力：</p>
<ol>
<li><strong>标准化运行时扩展</strong> —— 基于 Proxy Plugin 机制，非侵入式增强容器行为；</li>
<li><strong>云原生存储迁移</strong> —— 声明式触发 + CRD 管理，实现容器状态持久化；</li>
<li><strong>安全 DinD 架构</strong> ——  命名空间共享，兼顾功能完整与资源隔离。</li>
</ol>
<p>该架构具备良好的可移植性与扩展性，可作为企业级容器平台增强运行时能力的参考实现。</p>
<h1>基于 Containerd Snapshotter 接口的容器镜像操作增强机制</h1>
<p>在容器运行时扩展场景中，通过 <strong>Wrapper 模式封装原生 Snapshotter</strong>，可实现对容器镜像生命周期操作的透明拦截与增强处理。以下从架构设计、操作流程、关键实现与集成方式四个维度，详细解析该技术方案。</p>
<hr>
<h2 id="一、Wrapper-模式架构：非侵入式扩展">一、Wrapper 模式架构：非侵入式扩展</h2>
<p>项目采用标准的 <strong>Wrapper 设计模式</strong>，对 Containerd 原生的 OverlayFS Snapshotter 进行封装，通过 <code>pre</code> / <code>post</code> 钩子函数实现操作拦截，无需修改底层实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：封装 Prepare 接口，支持自定义重写逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *WrappedSnapshotter)</span></span> Prepare(ctx context.Context, req *api.PrepareSnapshotRequest) (*api.PrepareSnapshotResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> s.prepareRewriteFn != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.prepareRewriteFn(ctx, s.parent, req)  <span class="comment">// 自定义预处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.parent.Prepare(ctx, req)  <span class="comment">// 默认调用原生逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ <strong>优势</strong>：</p>
<ul>
<li>保持与原生 Snapshotter 的完全兼容；</li>
<li>支持灵活注入自定义行为（如日志、缓存、备份、恢复等）；</li>
<li>易于维护与升级，不绑定特定底层实现。</li>
</ul>
<hr>
<h2 id="二、标准化操作拦截流程">二、标准化操作拦截流程</h2>
<p>所有 Snapshotter 操作均遵循统一的 <strong>三阶段处理流程</strong>：<strong>Pre → Execute → Post</strong>，确保扩展逻辑可预测、可插拔。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *OperationRewriter)</span></span> do(ctx context.Context, s api.SnapshotsServer, req Request) (Response, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := r.pre(ctx, req); err != <span class="literal">nil</span> &#123;      <span class="comment">// 预处理（如权限校验、日志记录）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    resp, execErr := s.Execute(ctx, req)         <span class="comment">// 执行原生操作</span></span><br><span class="line">    <span class="keyword">if</span> execErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resp, execErr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := r.post(ctx, req, resp, execErr); err != <span class="literal">nil</span> &#123;  <span class="comment">// 后处理（如状态更新、触发备份）</span></span><br><span class="line">        <span class="keyword">return</span> resp, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ <strong>价值</strong>：</p>
<ul>
<li>实现操作前后状态感知；</li>
<li>支持异步、非阻塞扩展逻辑；</li>
<li>便于统一错误处理与审计追踪。</li>
</ul>
<hr>
<h2 id="三、关键操作的具体增强实现">三、关键操作的具体增强实现</h2>
<h3 id="1-Prepare（容器准备阶段）">1. Prepare（容器准备阶段）</h3>
<ul>
<li><strong>PrePrepare</strong>：初始化上下文、记录操作日志；</li>
<li><strong>PostPrepare</strong>：
<ul>
<li>解析挂载参数中的 <code>upperdir</code> 路径，定位容器可写层；</li>
<li>创建容器元数据缓存，记录容器 ID 与存储路径映射；</li>
<li>若检测到需恢复状态（如从云端拉取），触发异步恢复流程。</li>
</ul>
</li>
</ul>
<h3 id="2-Mounts（挂载访问阶段）">2. Mounts（挂载访问阶段）</h3>
<ul>
<li><strong>PostMounts</strong>：
<ul>
<li>初始化容器运行时上下文；</li>
<li>根据策略判断是否需从远程存储恢复 RootFS（如冷启动场景）；</li>
<li>挂载完成后更新容器状态为“已就绪”。</li>
</ul>
</li>
</ul>
<h3 id="3-Remove（快照删除阶段）">3. Remove（快照删除阶段）</h3>
<ul>
<li><strong>PreRemove</strong>：
<ul>
<li>触发容器状态持久化：调用 Backup Manager 将 RootFS 打包上传至云端存储；</li>
<li>支持失败重试与状态标记（如“备份中”、“备份失败”）；</li>
</ul>
</li>
<li><strong>PostRemove</strong>：
<ul>
<li>清理本地缓存元数据；</li>
<li>释放关联资源（如网络、设备句柄等）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌 示例：在 Remove 前自动触发备份</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *SnapshotHandler)</span></span> OnRemove(ctx context.Context, key <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> shouldBackup(key) &#123;</span><br><span class="line">        <span class="keyword">if</span> err := backupManager.TriggerBackup(ctx, containerID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.WithError(err).Error(<span class="string">&quot;Backup failed before snapshot removal&quot;</span>)</span><br><span class="line">            <span class="comment">// 可选：阻塞删除 or 标记状态供后续补偿</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四、容器生命周期元数据管理">四、容器生命周期元数据管理</h2>
<p>通过轻量级缓存层管理容器运行时状态，关键函数包括：</p>
<h3 id="▶-InitSnapshotMounts">▶ InitSnapshotMounts</h3>
<ul>
<li>从 <code>mount.Options</code> 中提取 <code>upperdir</code> 路径；</li>
<li>建立容器 ID → 存储路径 → 状态 的映射关系；</li>
<li>支持多容器并发初始化，线程安全。</li>
</ul>
<h3 id="▶-OnMounts">▶ OnMounts</h3>
<ul>
<li>检查容器是否需从云端恢复 RootFS；</li>
<li>如需恢复，异步拉取并解压至指定路径；</li>
<li>更新容器状态为“恢复完成”，允许后续启动。</li>
</ul>
<h3 id="▶-OnRemove-Clear">▶ OnRemove + Clear</h3>
<ul>
<li>删除前触发备份（可配置策略）；</li>
<li>删除后清理缓存，避免内存泄漏；</li>
<li>支持事件通知（如 Prometheus 指标更新、审计日志）。</li>
</ul>
<hr>
<h2 id="五、与-Containerd-的集成方式">五、与 Containerd 的集成方式</h2>
<ol>
<li>
<p><strong>Proxy Plugin 机制</strong><br>
通过 Unix Domain Socket 暴露 Snapshotter gRPC 服务，Containerd 通过插件配置动态加载。</p>
</li>
<li>
<p><strong>完整接口实现</strong><br>
实现 <code>api.SnapshotsServer</code> 所有方法，确保协议兼容性。</p>
</li>
<li>
<p><strong>操作透传 + 增强</strong><br>
默认调用原生 OverlayFS Snapshotter，仅在特定 Hook 注入自定义逻辑。</p>
</li>
<li>
<p><strong>异步非阻塞设计</strong><br>
耗时操作（如备份、恢复）通过 Goroutine 异步执行，避免阻塞容器启动流程。</p>
</li>
</ol>
<hr>
<h2 id="✅-方案价值总结">✅ 方案价值总结</h2>
<table>
<thead>
<tr>
<th>能力维度</th>
<th>实现效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无缝集成</strong></td>
<td>无需修改 Containerd 核心，通过标准插件机制接入</td>
</tr>
<tr>
<td><strong>透明增强</strong></td>
<td>对上层（如 Kubernetes、CRI）完全透明，无感知使用增强功能</td>
</tr>
<tr>
<td><strong>状态持久化</strong></td>
<td>容器删除前自动备份 RootFS 至云端，支持跨节点恢复</td>
</tr>
<tr>
<td><strong>生命周期感知</strong></td>
<td>通过 Hook 机制精确捕获 Prepare/Mount/Remove 事件，实现精细化控制</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td>所有操作支持插件化 Hook，便于后续扩展审计、加密、压缩、策略路由等功能</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="🧩-适用场景">🧩 适用场景</h2>
<ul>
<li>有状态容器的云原生存储迁移；</li>
<li>容器环境快速复现与调试（如 CI/CD、训练任务）；</li>
<li>安全合规场景下的操作审计与数据留存；</li>
<li>边缘计算中容器状态的云端同步与恢复。</li>
</ul>
<h1>dind这部分</h1>
<p>dind容器中有docker守护进程</p>
<p>构建基础Dind镜像时，下载特定版本的Docker二进制文件</p>
<p>dind容器的网络命名空间是跟main容器一样的</p>
<p>dind容器中执行docker命令的技术原理和逻辑链路：</p>
<h2 id="核心技术">核心技术</h2>
<ol>
<li><strong>Docker-in-Docker (DinD) 技术</strong>: 使用特权容器运行Docker守护进程</li>
<li><strong>Containerd管理</strong>: 通过containerd API创建和管理容器</li>
<li><strong>网络共享</strong>: 使用<code>container:&lt;main_container_id&gt;</code>网络模式共享网络命名空间</li>
<li><strong>文件系统映射</strong>: 通过bind mount将主容器的rootfs映射到dind容器中</li>
<li><strong>请求劫持(Hijack)</strong>: 拦截和修改Docker API请求</li>
</ol>
<h2 id="逻辑链路">逻辑链路</h2>
<h3 id="1-dind容器创建流程">1. dind容器创建流程</h3>
<ul>
<li><strong>权限验证</strong>: 检查Pod注解 <a target="_blank" rel="noopener" href="http://k8s.io/dind=%22enabled%22">k8s.io/dind=“enabled”</a></li>
<li><strong>容器创建</strong>: 使用nerdctl创建特权dind容器</li>
<li><strong>网络配置</strong>: 使用<code>container:&lt;main_id&gt;</code>共享网络命名空间</li>
<li><strong>文件系统映射</strong>: 将主容器rootfs挂载到dind容器的<code>/mainroot</code>目录</li>
<li><strong>安全配置</strong>: 设置seccomp=unconfined, apparmor=unconfined等安全选项</li>
</ul>
<h3 id="2-Docker命令执行流程">2. Docker命令执行流程</h3>
<ul>
<li><strong>API代理</strong>: Gin框架接收Docker API请求</li>
<li><strong>请求劫持</strong>: 拦截create/update/exec请求并修改配置</li>
<li><strong>路径重写</strong>: 将主机路径重写为容器内路径 (如 <code>/host/path</code> → <code>/mainroot/host/path</code>)</li>
<li><strong>反向代理</strong>: 将修改后的请求转发到真正的Docker守护进程socket</li>
</ul>
<h3 id="3-关键技术点">3. 关键技术点</h3>
<p><strong>网络隔离突破</strong>:</p>
<ul>
<li>dind容器使用<code>--network=container:&lt;main_id&gt;</code>启动，共享主容器的网络命名空间</li>
<li>这使得dind容器中的Docker守护进程能够访问主容器的网络环境</li>
</ul>
<p><strong>文件系统访问</strong>:</p>
<ul>
<li>主容器的rootfs通过bind mount挂载到dind容器的<code>/mainroot</code>目录</li>
<li>Docker volume和bind mount的源路径会被重写为容器内路径</li>
</ul>
<p><strong>安全限制</strong>:</p>
<ul>
<li>禁止privileged模式、capabilities修改等危险操作</li>
<li>验证挂载目标路径的合法性，防止路径遍历攻击</li>
</ul>
<p><strong>容器生命周期管理</strong>:</p>
<ul>
<li>通过containerd事件监听自动管理dind容器的创建和清理</li>
<li>主容器删除时自动清理对应的dind容器</li>
</ul>
<h2 id="执行流程示例">执行流程示例</h2>
<ol>
<li>用户在Pod中执行<code>docker run</code>命令</li>
<li>Docker client连接到<code>/mainroot/run/docker.sock</code> (被dind server劫持)</li>
<li>dind server修改请求配置（路径重写、安全验证）</li>
<li>请求被转发到真正的Docker守护进程(/run/docker.sock)</li>
<li>Docker守护进程在dind容器中创建目标容器</li>
<li>dind容器与主容器共享网络命名空间</li>
</ol>
<p>这种设计使得在Kubernetes Pod中安全地运行Docker命令成为可能，同时保持了良好的隔离性和安全性。</p>
<h2 id="dind容器网络配置的具体实现">dind容器网络配置的具体实现</h2>
<p>在 <a href="pkg/dind/controller/create_helpers.go:198-203"><code>pkg/dind/controller/create_helpers.go</code></a> 中，网络配置的具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DindContainerNetworkOptions</span><span class="params">(mainID apis.ContainerID, hostname <span class="type">string</span>)</span></span> types.NetworkOptions &#123;</span><br><span class="line">    <span class="keyword">return</span> types.NetworkOptions&#123;</span><br><span class="line">        NetworkSlice: []<span class="type">string</span>&#123;<span class="string">&quot;container:&quot;</span> + mainID.String()&#125;,</span><br><span class="line">        Hostname:     hostname,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="网络配置流程">网络配置流程</h3>
<ol>
<li>
<p><strong>网络选项创建</strong> (<a href="pkg/dind/controller/dind_manager.go:186"><code>pkg/dind/controller/dind_manager.go</code></a>)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networkOptions := DindContainerNetworkOptions(apis.ContainerID(mainContainer.ID()), mainSpec.Hostname)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>网络管理器创建</strong> (<a href="pkg/dind/controller/dind_manager.go:187"><code>pkg/dind/controller/dind_manager.go</code></a>)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netManager, err := containerutil.NewNetworkingOptionsManager(createOptions.GOptions, networkOptions, client)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>容器创建</strong> (<a href="pkg/dind/controller/dind_manager.go:197"><code>pkg/dind/controller/dind_manager.go</code></a>)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c, gc, err := container.Create(ctx, client, args, netManager, createOptions)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="技术细节">技术细节</h3>
<p><strong><code>container:&lt;main_id&gt;</code> 网络模式</strong>:</p>
<ul>
<li>这是Docker的容器网络模式，允许一个容器共享另一个容器的网络命名空间</li>
<li>在nerdctl/containerd中，这通过设置 <code>NetworkSlice: []string&#123;&quot;container:&quot; + mainID.String()&#125;</code> 实现</li>
</ul>
<p><strong>网络命名空间共享</strong>:</p>
<ul>
<li>dind容器启动时会使用主容器的网络命名空间</li>
<li>这使得dind容器中的Docker守护进程能够看到和访问主容器的网络环境</li>
<li>所有网络接口、路由、iptables规则等都会被共享</li>
</ul>
<p><strong>实际执行效果</strong>:<br>
相当于执行了类似这样的docker命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --network=container:&lt;main_container_id&gt; --name dind-&lt;main_id_prefix&gt; ...</span><br></pre></td></tr></table></figure>
<h3 id="验证逻辑">验证逻辑</h3>
<p>还有网络模式的验证逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> config.HostConfig.NetworkMode.IsBridge() &#123;</span><br><span class="line">    <span class="keyword">return</span> ErrBridgeNetworkNotSupported</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这确保了在dind环境中只能使用容器网络模式，不能使用bridge等其他网络模式。</p>
<p>这种网络配置使得dind容器能够完全共享主容器的网络环境，为在容器内运行Docker命令提供了必要的网络隔离突破。</p>
<h2 id="Docker命令劫持的逻辑">Docker命令劫持的逻辑</h2>
<p>Docker命令能够被劫持的核心逻辑在于<strong>socket重定向和API请求拦截</strong>，具体实现如下：</p>
<h3 id="1-Socket重定向机制">1. Socket重定向机制</h3>
<p>在dind容器中，Docker守护进程监听的是真正的 <code>/run/docker.sock</code>，但是：</p>
<p><strong>客户端连接路径</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address := <span class="string">&quot;/mainroot/run/docker.sock&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>服务端代理路径</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockerSocket := <span class="string">&quot;/run/docker.sock&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-反向代理劫持：">2. 反向代理劫持：</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">r.Any(<span class="string">&quot;*path&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 找到真正的docker socket</span></span><br><span class="line">    _ = s.findDockerSocket()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 请求劫持 - 关键步骤！</span></span><br><span class="line">    <span class="keyword">if</span> err := HijackRequest(c.Request); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.String(http.StatusBadRequest, <span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 创建反向代理到真正的docker守护进程</span></span><br><span class="line">    proxy := &amp;httputil.ReverseProxy&#123;</span><br><span class="line">        Transport: &amp;http.Transport&#123;</span><br><span class="line">            DialContext: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> net.Dial(<span class="string">&quot;unix&quot;</span>, s.dockerSocket) <span class="comment">// 连接到真正的docker socket</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        Director: <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request)</span></span> &#123;</span><br><span class="line">            req.URL = u <span class="comment">// 保持原始URL路径</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    proxy.ServeHTTP(c.Writer, c.Request)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="3-请求劫持逻辑">3. 请求劫持逻辑</h3>
<p><strong>劫持类型识别</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetHijackType</span><span class="params">(method <span class="type">string</span>, path <span class="type">string</span>)</span></span> HijackType &#123;</span><br><span class="line">    <span class="keyword">if</span> method == http.MethodPost &#123;</span><br><span class="line">        path = filepath.Clean(path)</span><br><span class="line">        path = strings.TrimPrefix(path, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">        fields := strings.Split(path, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(fields) &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> HijackNone</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> fields[<span class="number">1</span>] == <span class="string">&quot;containers&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> fields[<span class="number">2</span>] == <span class="string">&quot;create&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> HijackCreate</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(fields) == <span class="number">4</span> &amp;&amp; fields[<span class="number">3</span>] == <span class="string">&quot;update&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> HijackUpdate</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(fields) == <span class="number">4</span> &amp;&amp; fields[<span class="number">3</span>] == <span class="string">&quot;exec&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> HijackExec</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HijackNone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-具体劫持操作">4. 具体劫持操作</h3>
<p><strong>创建请求劫持</strong></p>
<ul>
<li>路径重写：将主机路径重写为容器内路径 (<code>/host/path</code> → <code>/mainroot/host/path</code>)</li>
<li>安全验证：禁止privileged模式、capabilities修改等危险操作</li>
<li>挂载点验证：确保挂载目标路径的合法性</li>
</ul>
<p><strong>执行请求劫持</strong> :</p>
<ul>
<li>验证执行权限和安全设置</li>
</ul>
<h3 id="5-完整的劫持流程">5. 完整的劫持流程</h3>
<ol>
<li><strong>客户端连接</strong>: Docker client连接到 <code>/mainroot/run/docker.sock</code></li>
<li><strong>请求拦截</strong>: dind server (Gin框架) 接收所有API请求</li>
<li><strong>请求分析</strong>: 识别需要劫持的请求类型 (create/update/exec)</li>
<li><strong>配置修改</strong>: 重写路径、验证安全设置、修改容器配置</li>
<li><strong>代理转发</strong>: 将修改后的请求转发到真正的Docker守护进程</li>
<li><strong>响应返回</strong>: 将Docker守护进程的响应返回给客户端</li>
</ol>
<h3 id="技术优势">技术优势</h3>
<p>这种设计实现了：</p>
<ul>
<li><strong>透明劫持</strong>: 客户端无感知，仍然使用标准Docker API</li>
<li><strong>安全控制</strong>: 在转发前进行安全验证和配置修改</li>
<li><strong>灵活性</strong>: 可以根据需要劫持特定的API端点</li>
<li><strong>性能</strong>: 反向代理模式开销极小</li>
</ul>
<p>这就是为什么Docker命令能够被劫持的核心逻辑 - 通过socket重定向和HTTP API拦截来实现透明的请求修改和转发。</p>
<h2 id="问题1-真正的dockerd-socket位置">问题1: 真正的dockerd socket位置</h2>
<p><strong>真正的Docker守护进程socket在dind容器中的 <code>/run/docker.sock</code>。</strong></p>
<p>真正的docker socket路径：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockerSocket := <span class="string">&quot;/run/docker.sock&quot;</span></span><br></pre></td></tr></table></figure>
<p>反向代理直接连接到这个socket：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> net.Dial(<span class="string">&quot;unix&quot;</span>, s.dockerSocket) <span class="comment">// 连接到真正的docker socket</span></span><br></pre></td></tr></table></figure>
<h2 id="问题2-为什么能访问-“-mainroot-run-docker-sock”">问题2: 为什么能访问 “/mainroot/run/docker.sock”</h2>
<p>这是因为<strong>文件系统映射和socket代理机制</strong>：</p>
<h3 id="1-文件系统映射">1. 文件系统映射</h3>
<p>在dind容器创建时</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createOptions.Volume = <span class="built_in">append</span>(createOptions.Volume,</span><br><span class="line">    fmt.Sprintf(<span class="string">&quot;%v:%v&quot;</span>, rootfsMount.Mountpoint, MAINROOT),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里 <code>MAINROOT = &quot;/mainroot&quot;</code>，所以主容器的rootfs被挂载到dind容器的 <code>/mainroot</code> 目录。</p>
<h3 id="2-Socket创建机制">2. Socket创建机制</h3>
<p>dind server会在 <code>/mainroot/run/docker.sock</code> 创建一个代理socket：</p>
<p>在 <a href="pkg/dind/server/server.go:94-101"><code>pkg/dind/server/server.go</code></a>)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_ = os.RemoveAll(s.serveSocket)  <span class="comment">// 清理旧的socket</span></span><br><span class="line"></span><br><span class="line">l, err := net.Listen(<span class="string">&quot;unix&quot;</span>, s.serveSocket)  <span class="comment">// 创建新的socket监听</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> os.Remove(s.serveSocket)</span><br><span class="line">_ = os.Chmod(s.serveSocket, <span class="number">0777</span>)  <span class="comment">// 设置权限</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>s.serveSocket</code> 就是 <code>/mainroot/run/docker.sock</code></p>
<h3 id="3-完整的访问路径">3. 完整的访问路径</h3>
<ol>
<li><strong>主容器中</strong>: 用户执行 <code>docker -H unix:///run/docker.sock ...</code></li>
<li><strong>路径映射</strong>: <code>/run/docker.sock</code> (主容器) → <code>/mainroot/run/docker.sock</code> (dind容器)</li>
<li><strong>socket代理</strong>: dind server监听在 <code>/mainroot/run/docker.sock</code></li>
<li><strong>请求转发</strong>: dind server将请求转发到真正的 <code>/run/docker.sock</code> (dind容器内的真实docker socket)</li>
</ol>
<h3 id="技术实现">技术实现</h3>
<p>这实际上是一个 <strong>Unix socket代理</strong>：</p>
<ul>
<li>在 <code>/mainroot/run/docker.sock</code> 创建一个代理socket</li>
<li>所有连接到这个socket的请求都被dind server处理</li>
<li>dind server进行安全验证和请求修改后，转发到真正的docker socket</li>
<li>响应再通过代理socket返回给客户端</li>
</ul>
<p>这样设计的好处是：</p>
<ul>
<li><strong>对客户端透明</strong>: 用户仍然使用标准Docker命令行</li>
<li><strong>安全控制</strong>: 可以在转发前进行安全验证</li>
<li><strong>灵活性</strong>: 可以劫持和修改特定的API请求</li>
</ul>
<p>所以本质上，<code>/mainroot/run/docker.sock</code> 是一个代理socket，而 <code>/run/docker.sock</code> 是真正的Docker守护进程socket。</p>
<p>dockerctl命令能够被dind manager识别是通过以下机制实现的：</p>
<h2 id="1-gRPC通信机制">1. gRPC通信机制</h2>
<p>dockerctl命令通过gRPC与dind manager进行通信：</p>
<ul>
<li><strong>客户端连接</strong>: dockerctl通过 <a href="cmd/dind/dockerctl/commands/root.go:22"><code>getClient()</code></a> 连接到Unix socket <code>/run/aeon/container/container-service.sock</code></li>
<li><strong>认证机制</strong>: 使用Pod的service account token进行认证 <a href="cmd/dind/dockerctl/commands/root.go:31"><code>getTokenContent()</code></a></li>
</ul>
<h2 id="2-ServiceCall处理流程">2. ServiceCall处理流程</h2>
<h3 id="2-1-命令执行流程">2.1 命令执行流程</h3>
<ol>
<li><strong>用户执行命令</strong>: 如 <code>dockerctl start</code></li>
<li><strong>gRPC调用</strong>: 调用 <a href="cmd/dind/dockerctl/commands/actions.go:22"><code>ServiceCall</code></a> 方法</li>
<li><strong>服务识别</strong>: 指定 <code>Service: &quot;docker&quot;</code> 和相应的 <code>Action</code> (start/stop/restart/status/show-config)</li>
</ol>
<h3 id="2-2-服务端处理">2.2 服务端处理</h3>
<p>在agent的runtime service中，<a href="pkg/agent/service_runtime.go:109"><code>ServiceCall</code></a> 方法处理请求：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;docker&quot;</span>:</span><br><span class="line">    message, err := s.dc.DindCall(ctx, token, req.Action, req.Args)</span><br></pre></td></tr></table></figure>
<h3 id="2-3-dind-manager识别">2.3 dind manager识别</h3>
<p>dind controller的 <a href="pkg/dind/controller/controller.go:114"><code>DindCall</code></a> 方法根据action参数进行识别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> action &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;start&quot;</span>:</span><br><span class="line">    _, err := dc.dcm.CreateDindContainer(ctx, mainID)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;stop&quot;</span>:</span><br><span class="line">    err := dc.dcm.ClearDindContainer(ctx, mainID)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;restart&quot;</span>:</span><br><span class="line">    <span class="comment">// 先stop再start</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;status&quot;</span>:</span><br><span class="line">    tasks, mem, cpu, err := dc.dcm.GetDindStatus(ctx, mainID)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;show-config&quot;</span>:</span><br><span class="line">    config, err := dc.dcm.GetDindConfig(ctx, mainID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-权限验证机制">3. 权限验证机制</h2>
<p>dind manager通过以下方式验证权限：</p>
<ol>
<li><strong>Token验证</strong>: 使用Kubernetes TokenReview API验证token有效性 <a href="pkg/dind/controller/controller.go:215"><code>getPodByToken()</code></a></li>
<li><strong>Pod注解检查</strong>: 检查Pod是否有 <code>mizar.k8s.io/dind: &quot;enabled&quot;</code> 注解 <a href="pkg/dind/controller/utils.go:16"><code>judgeDindEnabled()</code></a></li>
<li><strong>容器ID提取</strong>: 从Pod状态中提取主容器的container ID <a href="pkg/dind/controller/utils.go:23"><code>getMainIDFromPod()</code></a></li>
</ol>
<h2 id="4-命令与action映射">4. 命令与action映射</h2>
<p>dockerctl命令与dind manager action的映射关系：</p>
<table>
<thead>
<tr>
<th>dockerctl命令</th>
<th>dind manager action</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dockerctl start</code></td>
<td><code>&quot;start&quot;</code></td>
<td>创建dind容器</td>
</tr>
<tr>
<td><code>dockerctl stop</code></td>
<td><code>&quot;stop&quot;</code></td>
<td>停止并清理dind容器</td>
</tr>
<tr>
<td><code>dockerctl restart</code></td>
<td><code>&quot;restart&quot;</code></td>
<td>重启dind容器</td>
</tr>
<tr>
<td><code>dockerctl status</code></td>
<td><code>&quot;status&quot;</code></td>
<td>获取dind容器状态</td>
</tr>
<tr>
<td><code>dockerctl show-config</code></td>
<td><code>&quot;show-config&quot;</code></td>
<td>显示dind配置</td>
</tr>
</tbody>
</table>
<h2 id="5-完整的识别流程">5. 完整的识别流程</h2>
<ol>
<li><strong>客户端发起请求</strong>: dockerctl通过gRPC发送ServiceRequest</li>
<li><strong>服务端接收</strong>: runtime service的ServiceCall方法接收请求</li>
<li><strong>服务类型判断</strong>: 检查 <code>req.Service == &quot;docker&quot;</code></li>
<li><strong>权限验证</strong>: 验证token和Pod注解</li>
<li><strong>action分发</strong>: 根据action参数调用相应的dind manager方法</li>
<li><strong>结果返回</strong>: 将执行结果封装成anypb.Any返回给客户端</li>
</ol>
<p>这种设计使得dockerctl命令能够被dind manager准确识别和处理，同时保证了安全性和权限控制。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Roger-Lv</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/">http://example.com/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Roger-Lv's space</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/K8S/">K8S</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/k8s.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/17/2025-09-17-Volcano%E8%B0%83%E5%BA%A6%E5%99%A8/" title="Volcano调度器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Volcano调度器</div></div><div class="info-2"><div class="info-item-1">参考：https://zhuanlan.zhihu.com/p/700565336 在 Volcano 系统中，“Job” 和 “Task” 这两个词在 调度器（Scheduler）内部 和 用户/控制器（Controller）层面 代表的是完全不同的东西。 https://volcano.sh/zh/docs/ 丰富的调度策略  Gang Scheduling：确保作业的所有任务同时启动，适用于分布式训练、大数据等场景 Binpack Scheduling：通过任务紧凑分配优化资源利用率 Heterogeneous device scheduling：高效共享GPU异构资源，支持CUDA和MIG两种模式的GPU调度，支持NPU调度 Proportion/Capacity Scheduling：基于队列配额进行资源的共享/抢占/回收 NodeGroup Scheduling：支持节点分组亲和性调度，实现队列与节点组的绑定关系 DRF Scheduling：支持多维度资源的公平调度 SLA Scheduling：基于服务质量的调度保障 Task-topology Schedulin...</div></div></div></a><a class="pagination-related" href="/2025/09/16/2025-09-16-sandbox%E5%92%8Ccontainer%E5%AF%B9%E6%AF%94/" title="sandbox和container对比"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">sandbox和container对比</div></div><div class="info-2"><div class="info-item-1">sandbox和container对比 Sandbox 和 Container 的区别 基本概念 Sandbox（沙箱）  定义：一种隔离环境，用于安全地运行程序，限制其对系统资源的访问 目的：提供安全隔离，防止恶意代码影响主机系统 范围：通常针对单个应用程序或进程  Container（容器）  定义：一种轻量级虚拟化技术，将应用程序及其依赖打包在一起 目的：提供一致的运行环境，确保应用在不同环境中行为一致 范围：包含完整的应用程序运行时环境  主要区别对比    特性 Sandbox Container     主要目标 安全隔离 环境一致性   隔离级别 高（安全优先） 中等（资源隔离）   资源开销 极低 低到中等   启动速度 极快 快   包含内容 单个应用/进程 完整运行时环境    技术实现差异 Sandbox 实现方式 1234567// 浏览器沙箱示例（概念性）// 运行在受限环境中const sandboxedCode = `  // 无法访问DOM、网络、文件系统  // 只能执行安全的JavaScript代码  return 42;`; 典型技术：  浏...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/15/2025-09-15-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87Pod%E8%BF%9B%E5%85%A5%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA%EF%BC%9F/" title="如何通过Pod进入到宿主机?"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-15</div><div class="info-item-2">如何通过Pod进入到宿主机?</div></div><div class="info-2"><div class="info-item-1">如何通过Pod进入到宿主机? nsenter -a -t 1 bash 命令的作用是让你在一个新的 shell 会话中，进入 PID 为 1 的进程所在的全部命名空间（Namespace）。 通过这种方式，可以从pod中进入到宿主机（全部的namespace都跟宿主机一样） breakdown 如下：  nsenter: 这是一个 Linux 命令行工具，用于将当前进程“进入”到指定进程的一个或多个命名空间中。 -t 1: 这个选项指定了目标进程的 PID (Process ID)。在这里，1 是 Linux 系统中第一个启动的进程（通常是 init 或 systemd）的 PID。所有其他进程都是由它或它的子进程派生出来的。 -a: 这个选项是 “all namespaces” 的缩写。它告诉 nsenter 将当前进程加入到目标进程（PID 1）所属于的所有类型的命名空间中，包括但不限于：  Mount (mnt) UTS (主机名和域名) IPC (进程间通信) Network PID (进程 ID) User ID Cgroup   bash: 这是要在新加入的命名空间环...</div></div></div></a><a class="pagination-related" href="/2025/09/15/2025-09-15-k8s-informer%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AF%A6%E8%A7%A3/" title="k8s informer通俗易懂详解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-15</div><div class="info-item-2">k8s informer通俗易懂详解</div></div><div class="info-2"><div class="info-item-1">Kubernetes Informer 机制详解 核心概念 Informer 是 Kubernetes 中用于监听和缓存资源对象的核心机制，它通过 ListAndWatch 机制实现高效的资源监控。 核心组件及作用 1. Reflector（反射器）  作用：负责从 Kubernetes API Server 获取资源对象 功能：  List：获取资源的全量数据 Watch：监听资源的增量变化 将数据放入 Delta FIFO 队列    2. Delta FIFO Queue（增量队列）  作用：存储资源对象的变化（增删改） 特点：  保持操作顺序 存储对象的增量变化（Delta） 线程安全    3. Informer（通知器）  作用：从 Delta FIFO 队列中取出对象并处理 功能：  调用 Indexer 更新本地缓存 触发注册的事件处理器    4. Indexer（索引器）  作用：本地缓存，提供快速查询 功能：  存储资源对象的本地副本 提供基于索引的快速查找 线程安全的读写操作    5. Resource Event Handlers（资源事件处理器）  ...</div></div></div></a><a class="pagination-related" href="/2025/09/16/2025-09-16-sandbox%E5%92%8Ccontainer%E5%AF%B9%E6%AF%94/" title="sandbox和container对比"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-16</div><div class="info-item-2">sandbox和container对比</div></div><div class="info-2"><div class="info-item-1">sandbox和container对比 Sandbox 和 Container 的区别 基本概念 Sandbox（沙箱）  定义：一种隔离环境，用于安全地运行程序，限制其对系统资源的访问 目的：提供安全隔离，防止恶意代码影响主机系统 范围：通常针对单个应用程序或进程  Container（容器）  定义：一种轻量级虚拟化技术，将应用程序及其依赖打包在一起 目的：提供一致的运行环境，确保应用在不同环境中行为一致 范围：包含完整的应用程序运行时环境  主要区别对比    特性 Sandbox Container     主要目标 安全隔离 环境一致性   隔离级别 高（安全优先） 中等（资源隔离）   资源开销 极低 低到中等   启动速度 极快 快   包含内容 单个应用/进程 完整运行时环境    技术实现差异 Sandbox 实现方式 1234567// 浏览器沙箱示例（概念性）// 运行在受限环境中const sandboxedCode = `  // 无法访问DOM、网络、文件系统  // 只能执行安全的JavaScript代码  return 42;`; 典型技术：  浏...</div></div></div></a><a class="pagination-related" href="/2025/09/17/2025-09-17-k8s-%E6%8E%A2%E9%92%88/" title="k8s 探针"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-17</div><div class="info-item-2">k8s 探针</div></div><div class="info-2"><div class="info-item-1">k8s 探针 三类探针的作用域 1. 存活探针（Liveness Probe）  作用：判断Pod是否存活 影响：失败时重启Pod 范围：仅影响Pod生命周期  2. 就绪探针（Readiness Probe）  作用：判断Pod是否准备好接收流量 影响：控制Pod是否加入Service的Endpoint 范围：影响Service流量分发  3. 启动探针（Startup Probe）  作用：判断应用是否启动完成 影响：在启动期间禁用其他探针 范围：仅影响Pod启动过程  与Service的关系详解 就绪探针与Service的关联 12345678910apiVersion: v1kind: Servicemetadata:  name: my-servicespec:  selector:    app: my-app  # 选择标签匹配的Pod  ports:  - port: 80    targetPort: 8080 123456789101112131415apiVersion: v1kind: Podmetadata:  labels:    app: my-ap...</div></div></div></a><a class="pagination-related" href="/2024/07/19/2024-07-19-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8D%B8%E8%BD%BDanaconda/" title="Linux系统中卸载anaconda"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/Linux.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-19</div><div class="info-item-2">Linux系统中卸载anaconda</div></div><div class="info-2"><div class="info-item-1">Linux系统中卸载anaconda 要在Linux系统中卸载Anaconda，你需要执行一系列的命令。这里是一个通用的步骤指南：   找到Anaconda安装脚本： 在安装Anaconda时，它会在你的主目录中创建一个名为anaconda3的文件夹（默认情况下，如果你在安装时选择了不同的名称或位置，请确保使用正确的路径）。   运行Anaconda卸载程序： Anaconda提供了一个卸载程序anaconda-clean，可以帮助你删除Anaconda的配置文件。在终端中运行以下命令： 12conda install anaconda-cleananaconda-clean --yes 这个命令将删除Anaconda的配置文件，并且可以选择创建一个备份。使用–yes选项可以避免在删除每个项目时都要求确认。   删除Anaconda安装目录： 接下来，你需要手动删除Anaconda的安装目录。如果你的安装目录是默认的~/anaconda3，你可以使用以下命令： 1rm -rf ~/anaconda3 如果你的安装目录不是默认的，请确保使用正确的路径。   编辑.bashrc或其他...</div></div></div></a><a class="pagination-related" href="/2025/09/01/2025-09-01-Linux-%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A0%B9%E5%88%86%E5%8C%BA%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B(ext4-%E7%A4%BA%E4%BE%8B)/" title="Linux 云服务器根分区扩容流程(ext4 示例)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/df.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-01</div><div class="info-item-2">Linux 云服务器根分区扩容流程(ext4 示例)</div></div><div class="info-2"><div class="info-item-1">Linux 云服务器根分区扩容流程（ext4 示例） 1. 云厂商控制台扩容磁盘  登录云服务商（AWS、阿里云、腾讯云等） 找到对应实例的 系统盘 / 数据盘 修改磁盘大小，例如从 40G → 80G 这一步完成后，虚拟磁盘 /dev/vda 就会变大，但分区和文件系统不会自动变大   2. 确认磁盘和分区情况 12lsblkdf -h  lsblk 会显示磁盘和分区大小 df -h 会显示文件系统挂载的空间大小  例子： 12vda    80G└─vda1 40G   / 👉 说明磁盘是 80G，但分区还只有 40G  3. 安装扩容工具 （Ubuntu/Debian） 12sudo apt updatesudo apt install -y cloud-guest-utils （CentOS/RHEL） 1sudo yum install -y cloud-utils-growpart  4. 扩展分区 1sudo growpart /dev/vda 1  /dev/vda → 磁盘名 1 → 分区号（即 /dev/vda1）  执行后再看： 1lsblk 应该变成： ...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Roger-Lv</div><div class="author-info-description">Send a flare and light the way.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">147</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">126</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Roger-Lv"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Roger-Lv" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1150568956@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/zhongrenjie-lv-5588a928a/" target="_blank" title="LinkedIn"><i class="iconfont icon-linkedin-fill"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">容器运行时扩展方案技术解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E6%8E%A5%E5%85%A5-Containerd-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%94%9F%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">1. 如何接入 Containerd 运行时生态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E9%85%8D%E7%BD%AE%E5%B1%82%E6%8E%A5%E5%85%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">▶ 配置层接入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">▶ 运行时层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%B9%E5%99%A8-RootFS-%E4%BA%91%E7%AB%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.</span> <span class="toc-text">2. 容器 RootFS 云端持久化方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">▶ 触发机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">▶ 存储架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E4%B8%8A%E4%BC%A0%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">▶ 上传流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Docker-in-Docker%EF%BC%88DinD%EF%BC%89%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.</span> <span class="toc-text">3. Docker-in-Docker（DinD）安全实现方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">▶ 架构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">▶ 核心实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.3.</span> <span class="toc-text">▶ 关键特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">基于 Containerd Snapshotter 接口的容器镜像操作增强机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Wrapper-%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%EF%BC%9A%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-number">2.1.</span> <span class="toc-text">一、Wrapper 模式架构：非侵入式扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%87%E5%87%86%E5%8C%96%E6%93%8D%E4%BD%9C%E6%8B%A6%E6%88%AA%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">二、标准化操作拦截流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B3%E9%94%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B7%E4%BD%93%E5%A2%9E%E5%BC%BA%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">三、关键操作的具体增强实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Prepare%EF%BC%88%E5%AE%B9%E5%99%A8%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">1. Prepare（容器准备阶段）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Mounts%EF%BC%88%E6%8C%82%E8%BD%BD%E8%AE%BF%E9%97%AE%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">2. Mounts（挂载访问阶段）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Remove%EF%BC%88%E5%BF%AB%E7%85%A7%E5%88%A0%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">2.3.3.</span> <span class="toc-text">3. Remove（快照删除阶段）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">四、容器生命周期元数据管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-InitSnapshotMounts"><span class="toc-number">2.4.1.</span> <span class="toc-text">▶ InitSnapshotMounts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-OnMounts"><span class="toc-number">2.4.2.</span> <span class="toc-text">▶ OnMounts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-OnRemove-Clear"><span class="toc-number">2.4.3.</span> <span class="toc-text">▶ OnRemove + Clear</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%B8%8E-Containerd-%E7%9A%84%E9%9B%86%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">五、与 Containerd 的集成方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E4%BB%B7%E5%80%BC%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">✅ 方案价值总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.7.</span> <span class="toc-text">🧩 适用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">dind这部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF"><span class="toc-number">3.1.</span> <span class="toc-text">核心技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF"><span class="toc-number">3.2.</span> <span class="toc-text">逻辑链路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-dind%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">1. dind容器创建流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Docker%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. Docker命令执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%82%B9"><span class="toc-number">3.2.3.</span> <span class="toc-text">3. 关键技术点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">执行流程示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dind%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.</span> <span class="toc-text">dind容器网络配置的具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">网络配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82"><span class="toc-number">3.4.2.</span> <span class="toc-text">技术细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E9%80%BB%E8%BE%91"><span class="toc-number">3.4.3.</span> <span class="toc-text">验证逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%91%BD%E4%BB%A4%E5%8A%AB%E6%8C%81%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-number">3.5.</span> <span class="toc-text">Docker命令劫持的逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Socket%E9%87%8D%E5%AE%9A%E5%90%91%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.1.</span> <span class="toc-text">1. Socket重定向机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%8A%AB%E6%8C%81%EF%BC%9A"><span class="toc-number">3.5.2.</span> <span class="toc-text">2. 反向代理劫持：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%B7%E6%B1%82%E5%8A%AB%E6%8C%81%E9%80%BB%E8%BE%91"><span class="toc-number">3.5.3.</span> <span class="toc-text">3. 请求劫持逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B7%E4%BD%93%E5%8A%AB%E6%8C%81%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.4.</span> <span class="toc-text">4. 具体劫持操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AE%8C%E6%95%B4%E7%9A%84%E5%8A%AB%E6%8C%81%E6%B5%81%E7%A8%8B"><span class="toc-number">3.5.5.</span> <span class="toc-text">5. 完整的劫持流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8A%BF"><span class="toc-number">3.5.6.</span> <span class="toc-text">技术优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%981-%E7%9C%9F%E6%AD%A3%E7%9A%84dockerd-socket%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.6.</span> <span class="toc-text">问题1: 真正的dockerd socket位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%982-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%AE%BF%E9%97%AE-%E2%80%9C-mainroot-run-docker-sock%E2%80%9D"><span class="toc-number">3.7.</span> <span class="toc-text">问题2: 为什么能访问 “&#x2F;mainroot&#x2F;run&#x2F;docker.sock”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%98%A0%E5%B0%84"><span class="toc-number">3.7.1.</span> <span class="toc-text">1. 文件系统映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Socket%E5%88%9B%E5%BB%BA%E6%9C%BA%E5%88%B6"><span class="toc-number">3.7.2.</span> <span class="toc-text">2. Socket创建机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">3.7.3.</span> <span class="toc-text">3. 完整的访问路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.7.4.</span> <span class="toc-text">技术实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-gRPC%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">3.8.</span> <span class="toc-text">1. gRPC通信机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ServiceCall%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">3.9.</span> <span class="toc-text">2. ServiceCall处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.9.1.</span> <span class="toc-text">2.1 命令执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86"><span class="toc-number">3.9.2.</span> <span class="toc-text">2.2 服务端处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-dind-manager%E8%AF%86%E5%88%AB"><span class="toc-number">3.9.3.</span> <span class="toc-text">2.3 dind manager识别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6"><span class="toc-number">3.10.</span> <span class="toc-text">3. 权限验证机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%91%BD%E4%BB%A4%E4%B8%8Eaction%E6%98%A0%E5%B0%84"><span class="toc-number">3.11.</span> <span class="toc-text">4. 命令与action映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AF%86%E5%88%AB%E6%B5%81%E7%A8%8B"><span class="toc-number">3.12.</span> <span class="toc-text">5. 完整的识别流程</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/24/2025-09-24-Intern-%E5%BF%AB%E9%80%9F-Landing+%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="Intern 快速 Landing+环境搭建"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/tencent.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Intern 快速 Landing+环境搭建"/></a><div class="content"><a class="title" href="/2025/09/24/2025-09-24-Intern-%E5%BF%AB%E9%80%9F-Landing+%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="Intern 快速 Landing+环境搭建">Intern 快速 Landing+环境搭建</a><time datetime="2025-09-23T16:00:00.000Z" title="发表于 2025-09-24 00:00:00">2025-09-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/20/2025-09-14-Autogen%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E4%BA%A4%E6%8E%A5/" title="Autogen多智能体交接"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/agent.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Autogen多智能体交接"/></a><div class="content"><a class="title" href="/2025/09/20/2025-09-14-Autogen%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E4%BA%A4%E6%8E%A5/" title="Autogen多智能体交接">Autogen多智能体交接</a><time datetime="2025-09-19T16:00:00.000Z" title="发表于 2025-09-20 00:00:00">2025-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/18/2025-09-17-GPU%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%8A%A2%E5%8D%A0/" title="GPU资源共享/抢占"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GPU资源共享/抢占"/></a><div class="content"><a class="title" href="/2025/09/18/2025-09-17-GPU%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%8A%A2%E5%8D%A0/" title="GPU资源共享/抢占">GPU资源共享/抢占</a><time datetime="2025-09-17T16:00:00.000Z" title="发表于 2025-09-18 00:00:00">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/18/2025-09-18-MTU%E6%8E%A2%E6%B5%8B/" title="MTU探测"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/mtu.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MTU探测"/></a><div class="content"><a class="title" href="/2025/09/18/2025-09-18-MTU%E6%8E%A2%E6%B5%8B/" title="MTU探测">MTU探测</a><time datetime="2025-09-17T16:00:00.000Z" title="发表于 2025-09-18 00:00:00">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/18/2025-09-18-Agent-%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7+eval/" title="Agent 可观测性+eval"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/agent.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Agent 可观测性+eval"/></a><div class="content"><a class="title" href="/2025/09/18/2025-09-18-Agent-%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7+eval/" title="Agent 可观测性+eval">Agent 可观测性+eval</a><time datetime="2025-09-17T16:00:00.000Z" title="发表于 2025-09-18 00:00:00">2025-09-18</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2024 - 2025 By Roger-Lv</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.2"></script><script src="/js/main.js?v=5.4.2"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.8.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'smA3tZdRGodG2VgnMubBQjLm-gzGzoHsz',
      appKey: 'biCDxj0lSBtZTMie2kNIKErd',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.3/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><div class="aplayer no-destroy" data-id="8674547170" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.4.2"></script></div></div></body></html>