<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>容器运行时扩展方案技术解析 | Roger-Lv's space</title><meta name="author" content="Roger-Lv"><meta name="copyright" content="Roger-Lv"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="容器运行时扩展方案技术解析 基于对某容器运行时扩展项目的代码分析，现从架构层面提炼其核心技术实现，聚焦三大核心能力：运行时接入机制、容器根文件系统云端持久化、Docker-in-Docker 安全实现方案。  1. 如何接入 Containerd 运行时生态 项目通过 Containerd Proxy Plugin 机制 实现与容器运行时的无缝集成，架构清晰、扩展性强。 ▶ 配置层接入  在 co">
<meta property="og:type" content="article">
<meta property="og:title" content="容器运行时扩展方案技术解析">
<meta property="og:url" content="http://example.com/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Roger-Lv&#39;s space">
<meta property="og:description" content="容器运行时扩展方案技术解析 基于对某容器运行时扩展项目的代码分析，现从架构层面提炼其核心技术实现，聚焦三大核心能力：运行时接入机制、容器根文件系统云端持久化、Docker-in-Docker 安全实现方案。  1. 如何接入 Containerd 运行时生态 项目通过 Containerd Proxy Plugin 机制 实现与容器运行时的无缝集成，架构清晰、扩展性强。 ▶ 配置层接入  在 co">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/k8s.png">
<meta property="article:published_time" content="2025-09-15T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-16T10:50:38.909Z">
<meta property="article:author" content="Roger-Lv">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="K8S">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/k8s.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "容器运行时扩展方案技术解析",
  "url": "http://example.com/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/",
  "image": "http://example.com/img/cover/k8s.png",
  "datePublished": "2025-09-15T16:00:00.000Z",
  "dateModified": "2025-09-16T10:50:38.909Z",
  "author": [
    {
      "@type": "Person",
      "name": "Roger-Lv",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://example.com/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.4.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '容器运行时扩展方案技术解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">138</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">124</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">38</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Roger-Lv's space</span></a><a class="nav-page-title" href="/"><span class="site-name">容器运行时扩展方案技术解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div><!-- 添加搜索按钮 ↓--><span class="search-button"><i class="fas fa-search" aria-hidden="true"></i></span></div></nav><div id="post-info"><h1 class="post-title">容器运行时扩展方案技术解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-15T16:00:00.000Z" title="发表于 2025-09-16 00:00:00">2025-09-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-16T10:50:38.909Z" title="更新于 2025-09-16 18:50:38">2025-09-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/" data-flag-title="容器运行时扩展方案技术解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>容器运行时扩展方案技术解析</h1>
<p>基于对某容器运行时扩展项目的代码分析，现从架构层面提炼其核心技术实现，聚焦三大核心能力：<strong>运行时接入机制、容器根文件系统云端持久化、Docker-in-Docker 安全实现方案</strong>。</p>
<hr>
<h2 id="1-如何接入-Containerd-运行时生态">1. 如何接入 Containerd 运行时生态</h2>
<p>项目通过 <strong>Containerd Proxy Plugin 机制</strong> 实现与容器运行时的无缝集成，架构清晰、扩展性强。</p>
<h3 id="▶-配置层接入">▶ 配置层接入</h3>
<ul>
<li>在 <code>containerd</code> 配置中注册名为 <code>custom-snapshotter</code> 的代理插件，通过 Unix Domain Socket 与本地 Agent 通信；</li>
<li>同时注册自定义 Runtime，指向特定二进制执行程序，实现容器生命周期的定制化控制。</li>
</ul>
<h3 id="▶-运行时层实现">▶ 运行时层实现</h3>
<ul>
<li><strong>Agent 侧</strong>：实现标准 gRPC 服务，响应来自 Containerd 的 Snapshotter 接口调用（如 Prepare、Mount、Remove）；</li>
<li><strong>存储层封装</strong>：采用 Wrapper 模式封装原生 OverlayFS Snapshotter，在不破坏原有逻辑的前提下注入自定义行为（如镜像预处理、元数据记录等）；</li>
<li><strong>通信机制</strong>：通过本地 Unix Socket 实现低延迟、高安全性的进程间通信。</li>
</ul>
<blockquote>
<p>✅ 价值：无需修改 Containerd 核心代码，即可实现运行时行为扩展，符合云原生插件化设计哲学。</p>
</blockquote>
<hr>
<h2 id="2-容器-RootFS-云端持久化方案">2. 容器 RootFS 云端持久化方案</h2>
<p>项目支持在容器终止时，自动将根文件系统打包并上传至云端存储，实现状态持久化与跨节点恢复。</p>
<h3 id="▶-触发机制">▶ 触发机制</h3>
<ul>
<li>通过 Kubernetes Pod 标签（如 <code>backup.container.io/enabled=true</code>）声明式触发备份行为；</li>
<li>由控制器监听 Pod 生命周期事件，在容器终止前自动发起备份流程。</li>
</ul>
<h3 id="▶-存储架构">▶ 存储架构</h3>
<ul>
<li>支持<strong>本地暂存 + 云端迁移</strong>双阶段模式，适配不同存储后端（如 POSIX 兼容文件系统、分布式存储等）；</li>
<li>使用标准 <code>tar</code> 格式归档容器根目录，兼容性强，支持多版本格式演进；</li>
<li>通过自定义 CRD（Custom Resource Definition）统一管理备份任务状态、元数据及生命周期。</li>
</ul>
<h3 id="▶-上传流程">▶ 上传流程</h3>
<ol>
<li>控制器捕获容器终止事件，匹配备份策略；</li>
<li>调用 Backup Manager 执行本地打包；</li>
<li>将归档文件异步上传至云端存储系统；</li>
<li>更新 CRD 状态，记录存储路径、校验和、时间戳等关键元数据。</li>
</ol>
<blockquote>
<p>✅ 价值：实现“有状态容器”的云原生存储迁移，为故障恢复、环境复现、审计追溯提供基础能力。</p>
</blockquote>
<hr>
<h2 id="3-Docker-in-Docker（DinD）安全实现方案">3. Docker-in-Docker（DinD）安全实现方案</h2>
<p>项目通过轻量化、命名空间隔离的 DinD 架构，为容器内提供完整且安全的 Docker 服务，避免传统 DinD 的权限与资源冲突问题。</p>
<h3 id="▶-架构设计">▶ 架构设计</h3>
<ul>
<li>为每个需 Docker 能力的业务容器，动态创建专属的 DinD容器；</li>
<li>DinD 容器与主容器共享 cgroup 与网络命名空间，确保资源隔离的同时保持网络互通。</li>
</ul>
<h3 id="▶-核心实现">▶ 核心实现</h3>
<ul>
<li><strong>容器创建</strong>：使用轻量级容器工具（如 <code>nerdctl</code>）启动 DinD 容器，挂载主容器 rootfs 至指定路径，实现上下文共享；</li>
<li><strong>网络配置</strong>：通过初始化脚本配置共享网络栈，确保 DinD 内部构建的容器可被主容器访问；</li>
<li><strong>服务暴露</strong>：通过 gRPC 接口封装 Docker API，主容器可通过客户端工具调用构建、运行、镜像管理等操作；</li>
<li><strong>命令行工具</strong>：提供 CLI 工具，支持与 DinD 服务交互，简化调试与集成。</li>
</ul>
<h3 id="▶-关键特性">▶ 关键特性</h3>
<ul>
<li>支持 GPU 设备透传与资源配额管理；</li>
<li>完整兼容 Docker API，业务无感知迁移；</li>
<li>基于 Kubernetes ServiceAccount Token 实现调用鉴权；</li>
<li>内置健康检查与配置热更新机制，保障服务稳定性。</li>
</ul>
<blockquote>
<p>✅ 价值：在安全隔离的前提下，赋予容器内构建与运行 Docker 的能力，适用于 CI/CD、开发环境、模型训练等场景。</p>
</blockquote>
<hr>
<h2 id="总结">总结</h2>
<p>本方案通过深度集成 Containerd 与 Kubernetes，实现了三大核心能力：</p>
<ol>
<li><strong>标准化运行时扩展</strong> —— 基于 Proxy Plugin 机制，非侵入式增强容器行为；</li>
<li><strong>云原生存储迁移</strong> —— 声明式触发 + CRD 管理，实现容器状态持久化；</li>
<li><strong>安全 DinD 架构</strong> ——  命名空间共享，兼顾功能完整与资源隔离。</li>
</ol>
<p>该架构具备良好的可移植性与扩展性，可作为企业级容器平台增强运行时能力的参考实现。</p>
<h1>基于 Containerd Snapshotter 接口的容器镜像操作增强机制</h1>
<p>在容器运行时扩展场景中，通过 <strong>Wrapper 模式封装原生 Snapshotter</strong>，可实现对容器镜像生命周期操作的透明拦截与增强处理。以下从架构设计、操作流程、关键实现与集成方式四个维度，详细解析该技术方案。</p>
<hr>
<h2 id="一、Wrapper-模式架构：非侵入式扩展">一、Wrapper 模式架构：非侵入式扩展</h2>
<p>项目采用标准的 <strong>Wrapper 设计模式</strong>，对 Containerd 原生的 OverlayFS Snapshotter 进行封装，通过 <code>pre</code> / <code>post</code> 钩子函数实现操作拦截，无需修改底层实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：封装 Prepare 接口，支持自定义重写逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *WrappedSnapshotter)</span></span> Prepare(ctx context.Context, req *api.PrepareSnapshotRequest) (*api.PrepareSnapshotResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> s.prepareRewriteFn != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.prepareRewriteFn(ctx, s.parent, req)  <span class="comment">// 自定义预处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.parent.Prepare(ctx, req)  <span class="comment">// 默认调用原生逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ <strong>优势</strong>：</p>
<ul>
<li>保持与原生 Snapshotter 的完全兼容；</li>
<li>支持灵活注入自定义行为（如日志、缓存、备份、恢复等）；</li>
<li>易于维护与升级，不绑定特定底层实现。</li>
</ul>
<hr>
<h2 id="二、标准化操作拦截流程">二、标准化操作拦截流程</h2>
<p>所有 Snapshotter 操作均遵循统一的 <strong>三阶段处理流程</strong>：<strong>Pre → Execute → Post</strong>，确保扩展逻辑可预测、可插拔。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *OperationRewriter)</span></span> do(ctx context.Context, s api.SnapshotsServer, req Request) (Response, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := r.pre(ctx, req); err != <span class="literal">nil</span> &#123;      <span class="comment">// 预处理（如权限校验、日志记录）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    resp, execErr := s.Execute(ctx, req)         <span class="comment">// 执行原生操作</span></span><br><span class="line">    <span class="keyword">if</span> execErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resp, execErr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := r.post(ctx, req, resp, execErr); err != <span class="literal">nil</span> &#123;  <span class="comment">// 后处理（如状态更新、触发备份）</span></span><br><span class="line">        <span class="keyword">return</span> resp, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ <strong>价值</strong>：</p>
<ul>
<li>实现操作前后状态感知；</li>
<li>支持异步、非阻塞扩展逻辑；</li>
<li>便于统一错误处理与审计追踪。</li>
</ul>
<hr>
<h2 id="三、关键操作的具体增强实现">三、关键操作的具体增强实现</h2>
<h3 id="1-Prepare（容器准备阶段）">1. Prepare（容器准备阶段）</h3>
<ul>
<li><strong>PrePrepare</strong>：初始化上下文、记录操作日志；</li>
<li><strong>PostPrepare</strong>：
<ul>
<li>解析挂载参数中的 <code>upperdir</code> 路径，定位容器可写层；</li>
<li>创建容器元数据缓存，记录容器 ID 与存储路径映射；</li>
<li>若检测到需恢复状态（如从云端拉取），触发异步恢复流程。</li>
</ul>
</li>
</ul>
<h3 id="2-Mounts（挂载访问阶段）">2. Mounts（挂载访问阶段）</h3>
<ul>
<li><strong>PostMounts</strong>：
<ul>
<li>初始化容器运行时上下文；</li>
<li>根据策略判断是否需从远程存储恢复 RootFS（如冷启动场景）；</li>
<li>挂载完成后更新容器状态为“已就绪”。</li>
</ul>
</li>
</ul>
<h3 id="3-Remove（快照删除阶段）">3. Remove（快照删除阶段）</h3>
<ul>
<li><strong>PreRemove</strong>：
<ul>
<li>触发容器状态持久化：调用 Backup Manager 将 RootFS 打包上传至云端存储；</li>
<li>支持失败重试与状态标记（如“备份中”、“备份失败”）；</li>
</ul>
</li>
<li><strong>PostRemove</strong>：
<ul>
<li>清理本地缓存元数据；</li>
<li>释放关联资源（如网络、设备句柄等）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌 示例：在 Remove 前自动触发备份</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *SnapshotHandler)</span></span> OnRemove(ctx context.Context, key <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> shouldBackup(key) &#123;</span><br><span class="line">        <span class="keyword">if</span> err := backupManager.TriggerBackup(ctx, containerID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.WithError(err).Error(<span class="string">&quot;Backup failed before snapshot removal&quot;</span>)</span><br><span class="line">            <span class="comment">// 可选：阻塞删除 or 标记状态供后续补偿</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四、容器生命周期元数据管理">四、容器生命周期元数据管理</h2>
<p>通过轻量级缓存层管理容器运行时状态，关键函数包括：</p>
<h3 id="▶-InitSnapshotMounts">▶ InitSnapshotMounts</h3>
<ul>
<li>从 <code>mount.Options</code> 中提取 <code>upperdir</code> 路径；</li>
<li>建立容器 ID → 存储路径 → 状态 的映射关系；</li>
<li>支持多容器并发初始化，线程安全。</li>
</ul>
<h3 id="▶-OnMounts">▶ OnMounts</h3>
<ul>
<li>检查容器是否需从云端恢复 RootFS；</li>
<li>如需恢复，异步拉取并解压至指定路径；</li>
<li>更新容器状态为“恢复完成”，允许后续启动。</li>
</ul>
<h3 id="▶-OnRemove-Clear">▶ OnRemove + Clear</h3>
<ul>
<li>删除前触发备份（可配置策略）；</li>
<li>删除后清理缓存，避免内存泄漏；</li>
<li>支持事件通知（如 Prometheus 指标更新、审计日志）。</li>
</ul>
<hr>
<h2 id="五、与-Containerd-的集成方式">五、与 Containerd 的集成方式</h2>
<ol>
<li>
<p><strong>Proxy Plugin 机制</strong><br>
通过 Unix Domain Socket 暴露 Snapshotter gRPC 服务，Containerd 通过插件配置动态加载。</p>
</li>
<li>
<p><strong>完整接口实现</strong><br>
实现 <code>api.SnapshotsServer</code> 所有方法，确保协议兼容性。</p>
</li>
<li>
<p><strong>操作透传 + 增强</strong><br>
默认调用原生 OverlayFS Snapshotter，仅在特定 Hook 注入自定义逻辑。</p>
</li>
<li>
<p><strong>异步非阻塞设计</strong><br>
耗时操作（如备份、恢复）通过 Goroutine 异步执行，避免阻塞容器启动流程。</p>
</li>
</ol>
<hr>
<h2 id="✅-方案价值总结">✅ 方案价值总结</h2>
<table>
<thead>
<tr>
<th>能力维度</th>
<th>实现效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无缝集成</strong></td>
<td>无需修改 Containerd 核心，通过标准插件机制接入</td>
</tr>
<tr>
<td><strong>透明增强</strong></td>
<td>对上层（如 Kubernetes、CRI）完全透明，无感知使用增强功能</td>
</tr>
<tr>
<td><strong>状态持久化</strong></td>
<td>容器删除前自动备份 RootFS 至云端，支持跨节点恢复</td>
</tr>
<tr>
<td><strong>生命周期感知</strong></td>
<td>通过 Hook 机制精确捕获 Prepare/Mount/Remove 事件，实现精细化控制</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td>所有操作支持插件化 Hook，便于后续扩展审计、加密、压缩、策略路由等功能</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="🧩-适用场景">🧩 适用场景</h2>
<ul>
<li>有状态容器的云原生存储迁移；</li>
<li>容器环境快速复现与调试（如 CI/CD、训练任务）；</li>
<li>安全合规场景下的操作审计与数据留存；</li>
<li>边缘计算中容器状态的云端同步与恢复。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Roger-Lv</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/">http://example.com/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Roger-Lv's space</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/K8S/">K8S</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/k8s.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/17/2025-09-17-Volcano%E8%B0%83%E5%BA%A6%E5%99%A8/" title="Volcano调度器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Volcano调度器</div></div><div class="info-2"><div class="info-item-1">参考：https://zhuanlan.zhihu.com/p/700565336 在 Volcano 系统中，“Job” 和 “Task” 这两个词在 调度器（Scheduler）内部 和 用户/控制器（Controller）层面 代表的是完全不同的东西。 https://volcano.sh/zh/docs/ 丰富的调度策略  Gang Scheduling：确保作业的所有任务同时启动，适用于分布式训练、大数据等场景 Binpack Scheduling：通过任务紧凑分配优化资源利用率 Heterogeneous device scheduling：高效共享GPU异构资源，支持CUDA和MIG两种模式的GPU调度，支持NPU调度 Proportion/Capacity Scheduling：基于队列配额进行资源的共享/抢占/回收 NodeGroup Scheduling：支持节点分组亲和性调度，实现队列与节点组的绑定关系 DRF Scheduling：支持多维度资源的公平调度 SLA Scheduling：基于服务质量的调度保障 Task-topology Schedulin...</div></div></div></a><a class="pagination-related" href="/2025/09/16/2025-09-16-sandbox%E5%92%8Ccontainer%E5%AF%B9%E6%AF%94/" title="sandbox和container对比"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">sandbox和container对比</div></div><div class="info-2"><div class="info-item-1">sandbox和container对比 Sandbox 和 Container 的区别 基本概念 Sandbox（沙箱）  定义：一种隔离环境，用于安全地运行程序，限制其对系统资源的访问 目的：提供安全隔离，防止恶意代码影响主机系统 范围：通常针对单个应用程序或进程  Container（容器）  定义：一种轻量级虚拟化技术，将应用程序及其依赖打包在一起 目的：提供一致的运行环境，确保应用在不同环境中行为一致 范围：包含完整的应用程序运行时环境  主要区别对比    特性 Sandbox Container     主要目标 安全隔离 环境一致性   隔离级别 高（安全优先） 中等（资源隔离）   资源开销 极低 低到中等   启动速度 极快 快   包含内容 单个应用/进程 完整运行时环境    技术实现差异 Sandbox 实现方式 1234567// 浏览器沙箱示例（概念性）// 运行在受限环境中const sandboxedCode = `  // 无法访问DOM、网络、文件系统  // 只能执行安全的JavaScript代码  return 42;`; 典型技术：  浏...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/15/2025-09-15-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87Pod%E8%BF%9B%E5%85%A5%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA%EF%BC%9F/" title="如何通过Pod进入到宿主机?"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-15</div><div class="info-item-2">如何通过Pod进入到宿主机?</div></div><div class="info-2"><div class="info-item-1">如何通过Pod进入到宿主机? nsenter -a -t 1 bash 命令的作用是让你在一个新的 shell 会话中，进入 PID 为 1 的进程所在的全部命名空间（Namespace）。 通过这种方式，可以从pod中进入到宿主机（全部的namespace都跟宿主机一样） breakdown 如下：  nsenter: 这是一个 Linux 命令行工具，用于将当前进程“进入”到指定进程的一个或多个命名空间中。 -t 1: 这个选项指定了目标进程的 PID (Process ID)。在这里，1 是 Linux 系统中第一个启动的进程（通常是 init 或 systemd）的 PID。所有其他进程都是由它或它的子进程派生出来的。 -a: 这个选项是 “all namespaces” 的缩写。它告诉 nsenter 将当前进程加入到目标进程（PID 1）所属于的所有类型的命名空间中，包括但不限于：  Mount (mnt) UTS (主机名和域名) IPC (进程间通信) Network PID (进程 ID) User ID Cgroup   bash: 这是要在新加入的命名空间环...</div></div></div></a><a class="pagination-related" href="/2025/09/15/2025-09-15-k8s-informer%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AF%A6%E8%A7%A3/" title="k8s informer通俗易懂详解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-15</div><div class="info-item-2">k8s informer通俗易懂详解</div></div><div class="info-2"><div class="info-item-1">Kubernetes Informer 机制详解 核心概念 Informer 是 Kubernetes 中用于监听和缓存资源对象的核心机制，它通过 ListAndWatch 机制实现高效的资源监控。 核心组件及作用 1. Reflector（反射器）  作用：负责从 Kubernetes API Server 获取资源对象 功能：  List：获取资源的全量数据 Watch：监听资源的增量变化 将数据放入 Delta FIFO 队列    2. Delta FIFO Queue（增量队列）  作用：存储资源对象的变化（增删改） 特点：  保持操作顺序 存储对象的增量变化（Delta） 线程安全    3. Informer（通知器）  作用：从 Delta FIFO 队列中取出对象并处理 功能：  调用 Indexer 更新本地缓存 触发注册的事件处理器    4. Indexer（索引器）  作用：本地缓存，提供快速查询 功能：  存储资源对象的本地副本 提供基于索引的快速查找 线程安全的读写操作    5. Resource Event Handlers（资源事件处理器）  ...</div></div></div></a><a class="pagination-related" href="/2025/09/16/2025-09-16-sandbox%E5%92%8Ccontainer%E5%AF%B9%E6%AF%94/" title="sandbox和container对比"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-16</div><div class="info-item-2">sandbox和container对比</div></div><div class="info-2"><div class="info-item-1">sandbox和container对比 Sandbox 和 Container 的区别 基本概念 Sandbox（沙箱）  定义：一种隔离环境，用于安全地运行程序，限制其对系统资源的访问 目的：提供安全隔离，防止恶意代码影响主机系统 范围：通常针对单个应用程序或进程  Container（容器）  定义：一种轻量级虚拟化技术，将应用程序及其依赖打包在一起 目的：提供一致的运行环境，确保应用在不同环境中行为一致 范围：包含完整的应用程序运行时环境  主要区别对比    特性 Sandbox Container     主要目标 安全隔离 环境一致性   隔离级别 高（安全优先） 中等（资源隔离）   资源开销 极低 低到中等   启动速度 极快 快   包含内容 单个应用/进程 完整运行时环境    技术实现差异 Sandbox 实现方式 1234567// 浏览器沙箱示例（概念性）// 运行在受限环境中const sandboxedCode = `  // 无法访问DOM、网络、文件系统  // 只能执行安全的JavaScript代码  return 42;`; 典型技术：  浏...</div></div></div></a><a class="pagination-related" href="/2024/07/19/2024-07-19-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8D%B8%E8%BD%BDanaconda/" title="Linux系统中卸载anaconda"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/Linux.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-19</div><div class="info-item-2">Linux系统中卸载anaconda</div></div><div class="info-2"><div class="info-item-1">Linux系统中卸载anaconda 要在Linux系统中卸载Anaconda，你需要执行一系列的命令。这里是一个通用的步骤指南：   找到Anaconda安装脚本： 在安装Anaconda时，它会在你的主目录中创建一个名为anaconda3的文件夹（默认情况下，如果你在安装时选择了不同的名称或位置，请确保使用正确的路径）。   运行Anaconda卸载程序： Anaconda提供了一个卸载程序anaconda-clean，可以帮助你删除Anaconda的配置文件。在终端中运行以下命令： 12conda install anaconda-cleananaconda-clean --yes 这个命令将删除Anaconda的配置文件，并且可以选择创建一个备份。使用–yes选项可以避免在删除每个项目时都要求确认。   删除Anaconda安装目录： 接下来，你需要手动删除Anaconda的安装目录。如果你的安装目录是默认的~/anaconda3，你可以使用以下命令： 1rm -rf ~/anaconda3 如果你的安装目录不是默认的，请确保使用正确的路径。   编辑.bashrc或其他...</div></div></div></a><a class="pagination-related" href="/2025/09/01/2025-09-01-Linux-%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A0%B9%E5%88%86%E5%8C%BA%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B(ext4-%E7%A4%BA%E4%BE%8B)/" title="Linux 云服务器根分区扩容流程(ext4 示例)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/df.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-01</div><div class="info-item-2">Linux 云服务器根分区扩容流程(ext4 示例)</div></div><div class="info-2"><div class="info-item-1">Linux 云服务器根分区扩容流程（ext4 示例） 1. 云厂商控制台扩容磁盘  登录云服务商（AWS、阿里云、腾讯云等） 找到对应实例的 系统盘 / 数据盘 修改磁盘大小，例如从 40G → 80G 这一步完成后，虚拟磁盘 /dev/vda 就会变大，但分区和文件系统不会自动变大   2. 确认磁盘和分区情况 12lsblkdf -h  lsblk 会显示磁盘和分区大小 df -h 会显示文件系统挂载的空间大小  例子： 12vda    80G└─vda1 40G   / 👉 说明磁盘是 80G，但分区还只有 40G  3. 安装扩容工具 （Ubuntu/Debian） 12sudo apt updatesudo apt install -y cloud-guest-utils （CentOS/RHEL） 1sudo yum install -y cloud-utils-growpart  4. 扩展分区 1sudo growpart /dev/vda 1  /dev/vda → 磁盘名 1 → 分区号（即 /dev/vda1）  执行后再看： 1lsblk 应该变成： ...</div></div></div></a><a class="pagination-related" href="/2025/09/17/2025-09-17-NUMA-Aware-Scheduling%E4%BB%8B%E7%BB%8D/" title="NUMA-Aware Scheduling介绍"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-17</div><div class="info-item-2">NUMA-Aware Scheduling介绍</div></div><div class="info-2"><div class="info-item-1">NUMA-Aware Scheduling https://zhuanlan.zhihu.com/p/713060080 一、 什么是 NUMA？ NUMA (Non-Uniform Memory Access，非统一内存访问) 是现代多处理器服务器（尤其是AI服务器）的标准架构。  核心思想：将CPU和内存划分为多个“节点”（Node）。每个节点内的CPU访问本节点的内存速度极快（本地内存访问），而访问其他节点的内存则速度较慢（远程内存访问），存在显著的延迟和带宽差异。 类比：想象一个办公室有多个小组，每个小组有自己的文件柜（本地内存）。找自己组的文件柜拿资料很快，但去别的组借资料就要走过去，花时间。  在一台配备8块GPU和2个CPU插槽的AI服务器上，通常会形成2个或4个NUMA节点。GPU通常通过PCIe总线直连到某个特定的CPU（NUMA节点）上。  二、 为什么需要 NUMA-Aware Scheduling？ 在传统的、非NUMA感知的调度下，操作系统或调度器（如K8s原生调度器）可能会做出灾难性的决策：  场景：一个需要大量内存的大模型推理Pod被调度到NUMA ...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Roger-Lv</div><div class="author-info-description">Send a flare and light the way.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">138</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">124</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">38</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Roger-Lv"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Roger-Lv" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1150568956@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/zhongrenjie-lv-5588a928a/" target="_blank" title="LinkedIn"><i class="iconfont icon-linkedin-fill"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">容器运行时扩展方案技术解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E6%8E%A5%E5%85%A5-Containerd-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%94%9F%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">1. 如何接入 Containerd 运行时生态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E9%85%8D%E7%BD%AE%E5%B1%82%E6%8E%A5%E5%85%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">▶ 配置层接入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">▶ 运行时层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%B9%E5%99%A8-RootFS-%E4%BA%91%E7%AB%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.</span> <span class="toc-text">2. 容器 RootFS 云端持久化方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">▶ 触发机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">▶ 存储架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E4%B8%8A%E4%BC%A0%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">▶ 上传流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Docker-in-Docker%EF%BC%88DinD%EF%BC%89%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.</span> <span class="toc-text">3. Docker-in-Docker（DinD）安全实现方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">▶ 架构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">▶ 核心实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.3.</span> <span class="toc-text">▶ 关键特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">基于 Containerd Snapshotter 接口的容器镜像操作增强机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Wrapper-%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%EF%BC%9A%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-number">2.1.</span> <span class="toc-text">一、Wrapper 模式架构：非侵入式扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%87%E5%87%86%E5%8C%96%E6%93%8D%E4%BD%9C%E6%8B%A6%E6%88%AA%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">二、标准化操作拦截流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B3%E9%94%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B7%E4%BD%93%E5%A2%9E%E5%BC%BA%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">三、关键操作的具体增强实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Prepare%EF%BC%88%E5%AE%B9%E5%99%A8%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">1. Prepare（容器准备阶段）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Mounts%EF%BC%88%E6%8C%82%E8%BD%BD%E8%AE%BF%E9%97%AE%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">2. Mounts（挂载访问阶段）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Remove%EF%BC%88%E5%BF%AB%E7%85%A7%E5%88%A0%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">2.3.3.</span> <span class="toc-text">3. Remove（快照删除阶段）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">四、容器生命周期元数据管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-InitSnapshotMounts"><span class="toc-number">2.4.1.</span> <span class="toc-text">▶ InitSnapshotMounts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-OnMounts"><span class="toc-number">2.4.2.</span> <span class="toc-text">▶ OnMounts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6-OnRemove-Clear"><span class="toc-number">2.4.3.</span> <span class="toc-text">▶ OnRemove + Clear</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%B8%8E-Containerd-%E7%9A%84%E9%9B%86%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">五、与 Containerd 的集成方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E4%BB%B7%E5%80%BC%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">✅ 方案价值总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.7.</span> <span class="toc-text">🧩 适用场景</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/17/2025-09-17-Volcano%E8%B0%83%E5%BA%A6%E5%99%A8/" title="Volcano调度器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Volcano调度器"/></a><div class="content"><a class="title" href="/2025/09/17/2025-09-17-Volcano%E8%B0%83%E5%BA%A6%E5%99%A8/" title="Volcano调度器">Volcano调度器</a><time datetime="2025-09-16T16:00:00.000Z" title="发表于 2025-09-17 00:00:00">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/17/2025-09-17-NUMA-Aware-Scheduling%E4%BB%8B%E7%BB%8D/" title="NUMA-Aware Scheduling介绍"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NUMA-Aware Scheduling介绍"/></a><div class="content"><a class="title" href="/2025/09/17/2025-09-17-NUMA-Aware-Scheduling%E4%BB%8B%E7%BB%8D/" title="NUMA-Aware Scheduling介绍">NUMA-Aware Scheduling介绍</a><time datetime="2025-09-16T16:00:00.000Z" title="发表于 2025-09-17 00:00:00">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/17/2025-09-17-io-uring%E5%AD%A6%E4%B9%A0/" title="io uring学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/iouring.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="io uring学习"/></a><div class="content"><a class="title" href="/2025/09/17/2025-09-17-io-uring%E5%AD%A6%E4%B9%A0/" title="io uring学习">io uring学习</a><time datetime="2025-09-16T16:00:00.000Z" title="发表于 2025-09-17 00:00:00">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/16/2025-09-16-sandbox%E5%92%8Ccontainer%E5%AF%B9%E6%AF%94/" title="sandbox和container对比"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="sandbox和container对比"/></a><div class="content"><a class="title" href="/2025/09/16/2025-09-16-sandbox%E5%92%8Ccontainer%E5%AF%B9%E6%AF%94/" title="sandbox和container对比">sandbox和container对比</a><time datetime="2025-09-15T16:00:00.000Z" title="发表于 2025-09-16 00:00:00">2025-09-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/" title="容器运行时扩展方案技术解析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="容器运行时扩展方案技术解析"/></a><div class="content"><a class="title" href="/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/" title="容器运行时扩展方案技术解析">容器运行时扩展方案技术解析</a><time datetime="2025-09-15T16:00:00.000Z" title="发表于 2025-09-16 00:00:00">2025-09-16</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2024 - 2025 By Roger-Lv</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.2"></script><script src="/js/main.js?v=5.4.2"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.8.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'smA3tZdRGodG2VgnMubBQjLm-gzGzoHsz',
      appKey: 'biCDxj0lSBtZTMie2kNIKErd',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.3/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><div class="aplayer no-destroy" data-id="8674547170" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.4.2"></script></div></div></body></html>