<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>io uring学习 | Roger-Lv's space</title><meta name="author" content="Roger-Lv"><meta name="copyright" content="Roger-Lv"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="看这个就行 https:&#x2F;&#x2F;arthurchiao.art&#x2F;blog&#x2F;intro-to-io-uring-zh&#x2F; 阻塞式I&#x2F;O与非阻塞式I&#x2F;O 1. 阻塞式 I&#x2F;O 的问题 在最原始的模型中，应用程序调用 read() 或 write() 时，如果数据没有准备好（例如，网络包未到达，或磁盘数据未从硬盘读入内存），进程就会被挂起（阻塞），直到操作完成。这在高并发场景下是灾难性的，因为一个线程只能处理">
<meta property="og:type" content="article">
<meta property="og:title" content="io uring学习">
<meta property="og:url" content="http://example.com/2025/09/17/2025-09-17-io-uring%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Roger-Lv&#39;s space">
<meta property="og:description" content="看这个就行 https:&#x2F;&#x2F;arthurchiao.art&#x2F;blog&#x2F;intro-to-io-uring-zh&#x2F; 阻塞式I&#x2F;O与非阻塞式I&#x2F;O 1. 阻塞式 I&#x2F;O 的问题 在最原始的模型中，应用程序调用 read() 或 write() 时，如果数据没有准备好（例如，网络包未到达，或磁盘数据未从硬盘读入内存），进程就会被挂起（阻塞），直到操作完成。这在高并发场景下是灾难性的，因为一个线程只能处理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/iouring.png">
<meta property="article:published_time" content="2025-09-16T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-17T07:59:14.514Z">
<meta property="article:author" content="Roger-Lv">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/iouring.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "io uring学习",
  "url": "http://example.com/2025/09/17/2025-09-17-io-uring%E5%AD%A6%E4%B9%A0/",
  "image": "http://example.com/img/cover/iouring.png",
  "datePublished": "2025-09-16T16:00:00.000Z",
  "dateModified": "2025-09-17T07:59:14.514Z",
  "author": [
    {
      "@type": "Person",
      "name": "Roger-Lv",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://example.com/2025/09/17/2025-09-17-io-uring%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.4.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'io uring学习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">161</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">143</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Roger-Lv's space</span></a><a class="nav-page-title" href="/"><span class="site-name">io uring学习</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div><!-- 添加搜索按钮 ↓--><span class="search-button"><i class="fas fa-search" aria-hidden="true"></i></span></div></nav><div id="post-info"><h1 class="post-title">io uring学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-16T16:00:00.000Z" title="发表于 2025-09-17 00:00:00">2025-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-17T07:59:14.514Z" title="更新于 2025-09-17 15:59:14">2025-09-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2025/09/17/2025-09-17-io-uring%E5%AD%A6%E4%B9%A0/" data-flag-title="io uring学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>看这个就行</p>
<p><a target="_blank" rel="noopener" href="https://arthurchiao.art/blog/intro-to-io-uring-zh/">https://arthurchiao.art/blog/intro-to-io-uring-zh/</a></p>
<h2 id="阻塞式I-O与非阻塞式I-O">阻塞式I/O与非阻塞式I/O</h2>
<h3 id="1-阻塞式-I-O-的问题">1. 阻塞式 I/O 的问题</h3>
<p>在最原始的模型中，应用程序调用 <code>read()</code> 或 <code>write()</code> 时，如果数据没有准备好（例如，网络包未到达，或磁盘数据未从硬盘读入内存），进程就会被挂起（阻塞），直到操作完成。这在高并发场景下是灾难性的，因为一个线程只能处理一个请求。</p>
<h3 id="2-非阻塞-I-O-I-O-多路复用-select-poll-epoll-的“伪异步”">2. 非阻塞 I/O + I/O 多路复用 (<code>select</code>/<code>poll</code>/<code>epoll</code>) 的“伪异步”</h3>
<p>为了解决阻塞问题，引入了非阻塞 I/O 和 I/O 多路复用机制。</p>
<ul>
<li><strong>工作方式</strong>：应用程序将文件描述符（fd）设置为非阻塞模式，然后使用 <code>epoll</code> 等系统调用来“监听”一组 fd。当 <code>epoll_wait()</code> 返回时，它会告诉你哪些 fd 已经“就绪”（ready），即可以进行无阻塞的读写操作。</li>
<li><strong>优点</strong>：一个线程可以同时管理成千上万个网络连接，极大地提升了并发能力。这也是 Node.js、Nginx、Redis 等高性能服务的基石。</li>
</ul>
<h3 id="3-致命缺点：仅限于“就绪通知”，且不支持-Storage-I-O">3. 致命缺点：仅限于“就绪通知”，且不支持 Storage I/O</h3>
<p>这正是您指出的核心问题：</p>
<ul>
<li><strong>“就绪通知”而非“完成通知”</strong>：<code>epoll</code> 告诉你一个 socket “可读”，只是意味着内核的接收缓冲区里有数据了。当你去调用 <code>read()</code> 时，这个 <code>read()</code> 系统调用本身<strong>仍然需要从用户态陷入内核态</strong>，并且对于磁盘文件，它<strong>仍然可能因为要等待磁盘 I/O 而阻塞</strong>。</li>
<li><strong>不支持 Storage Files</strong>：这是最关键的一点。<code>epoll</code> 的设计初衷是为网络和管道服务的。你<strong>无法</strong>用 <code>epoll</code> 来监听一个普通磁盘文件的读写是否“就绪”。对于磁盘 I/O，即使你设置了 <code>O_NONBLOCK</code> 标志，很多文件系统也会直接忽略它，<code>read()</code> 调用依然会阻塞直到数据从磁盘读取完毕。</li>
</ul>
<p>这就导致了一个非常割裂的局面：</p>
<ul>
<li>对于网络编程，我们有 <code>epoll</code> 这样的高性能工具。</li>
<li>对于磁盘 I/O，我们只能依赖阻塞调用，或者使用功能残缺、性能不佳的 POSIX AIO (<code>libaio</code>)，而后者通常又要求 <code>O_DIRECT</code>（绕过系统缓存），这在很多场景下是不切实际的。</li>
</ul>
<h3 id="4-io-uring-的革命性突破">4. <code>io_uring</code> 的革命性突破</h3>
<p><code>io_uring</code> 彻底解决了上述所有问题：</p>
<ul>
<li><strong>真正的异步</strong>：它提供的是“<strong>完成通知</strong>”，而不是“就绪通知”。你提交一个 <code>read</code> 请求后，可以去做其他事。当数据真正从磁盘读取完毕并拷贝到你的缓冲区后，内核会主动通知你。</li>
<li><strong>统一接口</strong>：<code>io_uring</code> <strong>同时支持 Network I/O 和 Storage I/O</strong>。你可以用同一套 API 来处理 TCP 连接和读写磁盘文件，极大地简化了编程模型。</li>
<li><strong>零拷贝与零系统调用 (可选)</strong>：通过共享内存环形队列，<code>io_uring</code> 将提交请求和获取结果的开销降到了最低。在某些模式下（如 <code>SQPOLL</code>），甚至可以完全避免应用层的系统调用。</li>
</ul>
<h3 id="总结">总结</h3>
<p><code>io_uring</code> 的出现，不是对 <code>epoll</code> 的简单优化，而是对整个 Linux I/O 模型的一次范式转移。它填补了 <code>epoll</code> 无法处理 Storage I/O 的巨大空白，为构建真正统一、高效的异步系统铺平了道路。</p>
<h2 id="0-DIRECT">0_DIRECT</h2>
<p><code>O_DIRECT</code> 是 Linux 系统中一个用于<strong>文件 I/O 操作</strong>的<strong>文件打开标志（flag）</strong>。当你在调用 <code>open()</code> 系统调用打开一个文件时，可以传入这个标志，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;myfile.dat&quot;</span>, O_RDONLY | O_DIRECT);</span><br></pre></td></tr></table></figure>
<p>它的核心作用是：<strong>绕过操作系统的页缓存（Page Cache），让应用程序的数据直接在用户空间缓冲区和存储设备（如磁盘）之间传输。</strong></p>
<hr>
<h3 id="一、-为什么要用-O-DIRECT？——-解决“双重缓存”问题"><strong>一、 为什么要用 O_DIRECT？—— 解决“双重缓存”问题</strong></h3>
<p>在传统的文件 I/O 中，数据流是这样的：</p>
<ol>
<li><strong>应用程序</strong> 调用 <code>read()</code>。</li>
<li>数据从 <strong>磁盘</strong> 读取到 <strong>内核的页缓存（Page Cache）</strong>。</li>
<li>数据从 <strong>页缓存</strong> 拷贝到 <strong>应用程序的用户空间缓冲区</strong>。</li>
</ol>
<p>对于像数据库（MySQL, PostgreSQL）、高性能键值存储（RocksDB）这类应用，它们自己实现了非常精密的缓存和预读策略。如果再让操作系统做一层缓存，就形成了“<strong>双重缓存</strong>”，这会带来两个严重问题：</p>
<ul>
<li><strong>内存浪费</strong>：同一份数据在应用层和内核层各存一份，浪费宝贵的内存资源。</li>
<li><strong>性能不可控</strong>：应用无法精确控制数据何时写入磁盘，因为数据可能先停留在页缓存中。这对于需要严格保证数据一致性和持久性的数据库来说是灾难性的。</li>
</ul>
<p><code>O_DIRECT</code> 就是为了解决这个问题而生的。它让数据流变成：</p>
<ol>
<li><strong>应用程序</strong> 调用 <code>read()</code> (with <code>O_DIRECT</code>)。</li>
<li><strong>数据直接从磁盘读取到用户空间缓冲区</strong> (或反之)。</li>
</ol>
<p>这样，应用程序就拥有了对 I/O 的完全控制权。</p>
<hr>
<h3 id="二、-使用-O-DIRECT-的严苛要求"><strong>二、 使用 O_DIRECT 的严苛要求</strong></h3>
<p><code>O_DIRECT</code> 虽然强大，但使用起来有非常严格的限制，这也是它“臭名昭著”的原因：</p>
<ol>
<li><strong>内存对齐</strong>：用户空间的缓冲区地址必须是<strong>块设备逻辑块大小</strong>（通常是 512 字节或 4KB）的整数倍。通常需要使用 <code>posix_memalign()</code> 来分配内存。</li>
<li><strong>长度对齐</strong>：<code>read()</code>/<code>write()</code> 的数据长度也必须是块大小的整数倍。</li>
<li><strong>偏移量对齐</strong>：文件读写的偏移量也必须是块大小的整数倍。</li>
</ol>
<p>如果违反了以上任何一条，系统调用可能会失败（返回 <code>EINVAL</code> 错误），或者在某些内核版本和文件系统上，内核会“悄悄地”回退到使用页缓存的模式，这就完全违背了使用 <code>O_DIRECT</code> 的初衷。</p>
<hr>
<h3 id="三、-与你经历的关联：为什么-POSIX-AIO-是残缺的？"><strong>三、 与你经历的关联：为什么 POSIX AIO 是残缺的？</strong></h3>
<p>在我们之前的讨论中提到，传统的 <code>epoll</code> 无法处理磁盘 I/O，而 POSIX AIO (<code>libaio</code>) 是 Linux 上另一个异步 I/O 方案。但它有一个致命缺陷：</p>
<blockquote>
<p><strong>POSIX AIO 仅对使用了 <code>O_DIRECT</code> 标志的文件描述符有效。</strong></p>
</blockquote>
<p>这意味着：</p>
<ul>
<li>如果你想用 POSIX AIO 来异步读写一个普通文件（没有 <code>O_DIRECT</code>），它内部会退化成同步调用，性能毫无提升。</li>
<li>你被迫使用 <code>O_DIRECT</code>，从而必须面对它那严苛的内存、长度、偏移量对齐要求，大大增加了编程的复杂度和出错概率。</li>
</ul>
<p>这正是 <code>io_uring</code> 的革命性所在——它<strong>不需要 <code>O_DIRECT</code></strong> 就能提供真正的、高效的异步文件 I/O，彻底解放了开发者。</p>
<hr>
<h3 id="四、-总结"><strong>四、 总结</strong></h3>
<p><code>O_DIRECT</code> 是一个强大的工具，它赋予了高性能应用（如数据库）对 I/O 的终极控制权，避免了“双重缓存”的开销。然而，它像一把锋利的双刃剑，使用不当会伤及自身（程序崩溃或性能下降）。</p>
<h1><code>io_uring</code></h1>
<p>io_uring 来自资深内核开发者 Jens Axboe 的想法，他在 Linux I/O stack 领域颇有研究。 从最早的 patch <a target="_blank" rel="noopener" href="https://lwn.net/ml/linux-fsdevel/20181221192236.12866-9-axboe@kernel.dk">aio: support for IO polling</a> 可以看出，这项工作始于一个很简单的观察：随着设备越来越快， <strong>中断驱动（interrupt-driven）模式效率已经低于轮询模式</strong> （polling for completions） —— 这也是高性能领域最常见的主题之一。</p>
<ul>
<li><code>io_uring</code> 的<strong>基本逻辑与 linux-aio 是类似的</strong>：提供两个接口，一个将 I/O 请求提交到内核，一个从内核接收完成事件。</li>
<li>但随着开发深入，它逐渐变成了一个完全不同的接口：设计者开始从源头思考 <strong>如何支持完全异步的操作</strong>。</li>
</ul>
<h2 id="1-与-Linux-AIO-的不同">1 与 Linux AIO 的不同</h2>
<p><code>io_uring</code> 与 <code>linux-aio</code> 有着本质的不同：</p>
<ol>
<li>
<p><strong>在设计上是真正异步的</strong>（truly asynchronous）。只要 设置了合适的 flag，它在<strong>系统调用上下文中就只是将请求放入队列</strong>， 不会做其他任何额外的事情，<strong>保证了应用永远不会阻塞</strong>。</p>
</li>
<li>
<p><strong>支持任何类型的 I/O</strong>：cached files、direct-access files 甚至 blocking sockets。</p>
<p>由于设计上就是异步的（async-by-design nature），因此<strong>无需 poll+read/write 来处理 sockets</strong>。 只需提交一个阻塞式读（blocking read），请求完成之后，就会出现在 completion ring。</p>
</li>
<li>
<p><strong>灵活、可扩展</strong>：基于 <code>io_uring</code> 甚至能重写（re-implement）Linux 的每个系统调用。</p>
</li>
</ol>
<h2 id="2-原理及核心数据结构：SQ-CQ-SQE-CQE">2 原理及核心数据结构：SQ/CQ/SQE/CQE</h2>
<p>每个 io_uring 实例都有<strong>两个环形队列</strong>（ring），在内核和应用程序之间共享：</p>
<ul>
<li><strong>提交队列</strong>：submission queue (SQ)</li>
<li><strong>完成队列</strong>：completion queue (CQ)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://arthurchiao.art/assets/img/intro-to-io-uring/io_uring.png" alt="img"></p>
<p>这两个队列：</p>
<ul>
<li>都是<strong>单生产者、单消费者</strong>，size 是 2 的幂次；</li>
<li>提供<strong>无锁接口</strong>（lock-less access interface），内部使用 <strong>内存屏障</strong>做同步（coordinated with memory barriers）。</li>
</ul>
<p><strong>使用方式</strong>：</p>
<ul>
<li>请求
<ul>
<li>应用创建 SQ entries (SQE)，更新 SQ tail；</li>
<li>内核消费 SQE，更新 SQ head。</li>
</ul>
</li>
<li>完成
<ul>
<li>内核为完成的一个或多个请求创建 CQ entries (CQE)，更新 CQ tail；</li>
<li>应用消费 CQE，更新 CQ head。</li>
<li>完成事件（completion events）可能以任意顺序到达，到总是与特定的 SQE 相关联的。</li>
<li>消费 CQE 过程无需切换到内核态。</li>
</ul>
</li>
</ul>
<h2 id="3-带来的好处">3 带来的好处</h2>
<p><code>io_uring</code> 这种请求方式还有一个好处是：原来需要多次系统调用（读或写），现在变成批处理一次提交。</p>
<p>还记得 Meltdown 漏洞吗？当时我还写了<a target="_blank" rel="noopener" href="https://www.scylladb.com/2018/01/07/cost-of-avoiding-a-meltdown/">一篇文章</a> 解释为什么我们的 Scylla NoSQL 数据库受影响很小：<code>aio</code> 已经将我们的 I/O 系统调用批处理化了。</p>
<p><code>io_uring</code> <strong>将这种批处理能力带给了</strong> storage I/O 系统调用之外的 <strong>其他一些系统调用</strong>，包括：</p>
<ul>
<li><code>read</code></li>
<li><code>write</code></li>
<li><code>send</code></li>
<li><code>recv</code></li>
<li><code>accept</code></li>
<li><code>openat</code></li>
<li><code>stat</code></li>
<li>专用的一些系统调用，例如 <code>fallocate</code></li>
</ul>
<p>此外，<code>io_uring</code> 使异步 I/O 的使用场景也不再仅限于数据库应用，<strong>普通的 非数据库应用也能用</strong>。这一点值得重复一遍：</p>
<blockquote>
<p>虽然 <code>io_uring</code> 与 <code>aio</code> 有一些相似之处，但它的<strong>扩展性和架构是革命性的</strong>： 它<strong>将异步操作的强大能力带给了所有应用</strong>（及其开发者），而 <strong>不再仅限于是数据库应用这一细分领域</strong>。</p>
</blockquote>
<p>我们的 CTO Avi Kivity 在 the Core C++ 2019 event 上 <a target="_blank" rel="noopener" href="https://www.scylladb.com/2020/03/26/avi-kivity-at-core-c-2019">有一次关于 async 的分享</a>。 核心点包括：<strong>从延迟上来说</strong>，</p>
<ol>
<li>现代多核、多 CPU 设备，其内部本身就是一个基础网络；</li>
<li><strong>CPU 之间</strong>是另一个网络；</li>
<li><strong>CPU 和磁盘 I/O 之间</strong>又是一个网络。</li>
</ol>
<p>因此网络编程采用异步是明智的，而现在开发自己的应用也应该考虑异步。 这<strong>从根本上改变了 Linux 应用的设计方式</strong>：</p>
<ul>
<li>之前都是一段顺序代码流，需要系统调用时才执行系统调用，</li>
<li>现在需要思考一个文件是否 ready，因而自然地引入 event-loop，不断通过共享 buffer 提交请求和接收结果。</li>
</ul>
<h2 id="4-三种工作模式">4 三种工作模式</h2>
<p>io_uring 实例可工作在三种模式：</p>
<ol>
<li>
<p><strong>中断驱动模式</strong>（interrupt driven）</p>
<p><strong>默认模式</strong>。可通过 io_uring_enter() 提交 I/O 请求，然后直接检查 CQ 状态判断是否完成。</p>
</li>
<li>
<p><strong>轮询模式</strong>（polled）</p>
<p>Busy-waiting for an I/O completion，而不是通过异步 IRQ（Interrupt Request）接收通知。</p>
<p>这种模式需要文件系统（如果有）和块设备（block device）支持轮询功能。 相比中断驱动方式，这种方式延迟更低（<a target="_blank" rel="noopener" href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Linux-io_uring-Fast-Efficient">连系统调用都省了</a>）， 但可能会消耗更多 CPU 资源。</p>
<p>目前，只有指定了 O_DIRECT flag 打开的文件描述符，才能使用这种模式。当一个读 或写请求提交给轮询上下文（polled context）之后，应用（application）必须调用 <code>io_uring_enter()</code> 来轮询 CQ 队列，判断请求是否已经完成。</p>
<p>对一个 io_uring 实例来说，<strong>不支持混合使用轮询和非轮询模式</strong>。</p>
</li>
<li>
<p><strong>内核轮询模式</strong>（kernel polled）</p>
<p>这种模式中，会 <strong>创建一个内核线程</strong>（kernel thread）来执行 SQ 的轮询工作。</p>
<p>使用这种模式的 io_uring 实例， <strong>应用无需切到到内核态</strong> 就能触发（issue）I/O 操作。 通过 SQ 来提交 SQE，以及监控 CQ 的完成状态，应用无需任何系统调用，就能提交和收割 I/O（submit and reap I/Os）。</p>
<p>如果内核线程的空闲时间超过了用户的配置值，它会通知应用，然后进入 idle 状态。 这种情况下，应用必须调用 <code>io_uring_enter()</code> 来唤醒内核线程。如果 I/O 一直很繁忙，内核线性是不会 sleep 的。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Roger-Lv</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/17/2025-09-17-io-uring%E5%AD%A6%E4%B9%A0/">http://example.com/2025/09/17/2025-09-17-io-uring%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Roger-Lv's space</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/iouring.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/17/2025-09-17-K8s-drain%E5%92%8Ccordon%E7%9A%84%E5%8C%BA%E5%88%AB/" title="K8s drain和cordon的区别"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">K8s drain和cordon的区别</div></div><div class="info-2"><div class="info-item-1">K8s drain和cordon的区别 Kubernetes中Drain和Cordon的区别 Cordon（封锁节点） 作用  标记节点为不可调度 新的Pod不会被调度到该节点 现有Pod不受影响，继续正常运行  使用场景 12345# 封锁节点kubectl cordon node-name# 解除封锁kubectl uncordon node-name 实际效果 1234节点状态变化：- 调度状态：可调度 → 不可调度- 现有Pod：继续运行- 新Pod：不会调度到此节点 Drain（排空节点） 作用  首先执行Cordon操作（封锁节点） 优雅地驱逐节点上的所有Pod 等待Pod在其他节点上重新启动 节点变为空节点  使用场景 1234567891011# 排空节点（默认行为）kubectl drain node-name# 排空节点并忽略DaemonSetkubectl drain node-name --ignore-daemonsets# 强制删除（不等待优雅终止）kubectl drain node-name --force# 设置优雅终止时间kubectl dri...</div></div></div></a><a class="pagination-related" href="/2025/09/17/2025-09-17-NUMA-Aware-Scheduling%E4%BB%8B%E7%BB%8D/" title="NUMA-Aware Scheduling介绍"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">NUMA-Aware Scheduling介绍</div></div><div class="info-2"><div class="info-item-1">NUMA-Aware Scheduling https://zhuanlan.zhihu.com/p/713060080 一、 什么是 NUMA？ NUMA (Non-Uniform Memory Access，非统一内存访问) 是现代多处理器服务器（尤其是AI服务器）的标准架构。  核心思想：将CPU和内存划分为多个“节点”（Node）。每个节点内的CPU访问本节点的内存速度极快（本地内存访问），而访问其他节点的内存则速度较慢（远程内存访问），存在显著的延迟和带宽差异。 类比：想象一个办公室有多个小组，每个小组有自己的文件柜（本地内存）。找自己组的文件柜拿资料很快，但去别的组借资料就要走过去，花时间。  在一台配备8块GPU和2个CPU插槽的AI服务器上，通常会形成2个或4个NUMA节点。GPU通常通过PCIe总线直连到某个特定的CPU（NUMA节点）上。  二、 为什么需要 NUMA-Aware Scheduling？ 在传统的、非NUMA感知的调度下，操作系统或调度器（如K8s原生调度器）可能会做出灾难性的决策：  场景：一个需要大量内存的大模型推理Pod被调度到NUMA ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/07/19/2024-07-19-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8D%B8%E8%BD%BDanaconda/" title="Linux系统中卸载anaconda"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/Linux.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-19</div><div class="info-item-2">Linux系统中卸载anaconda</div></div><div class="info-2"><div class="info-item-1">Linux系统中卸载anaconda 要在Linux系统中卸载Anaconda，你需要执行一系列的命令。这里是一个通用的步骤指南：   找到Anaconda安装脚本： 在安装Anaconda时，它会在你的主目录中创建一个名为anaconda3的文件夹（默认情况下，如果你在安装时选择了不同的名称或位置，请确保使用正确的路径）。   运行Anaconda卸载程序： Anaconda提供了一个卸载程序anaconda-clean，可以帮助你删除Anaconda的配置文件。在终端中运行以下命令： 12conda install anaconda-cleananaconda-clean --yes 这个命令将删除Anaconda的配置文件，并且可以选择创建一个备份。使用–yes选项可以避免在删除每个项目时都要求确认。   删除Anaconda安装目录： 接下来，你需要手动删除Anaconda的安装目录。如果你的安装目录是默认的~/anaconda3，你可以使用以下命令： 1rm -rf ~/anaconda3 如果你的安装目录不是默认的，请确保使用正确的路径。   编辑.bashrc或其他...</div></div></div></a><a class="pagination-related" href="/2025/09/01/2025-09-01-Linux-%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A0%B9%E5%88%86%E5%8C%BA%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B(ext4-%E7%A4%BA%E4%BE%8B)/" title="Linux 云服务器根分区扩容流程(ext4 示例)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/df.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-01</div><div class="info-item-2">Linux 云服务器根分区扩容流程(ext4 示例)</div></div><div class="info-2"><div class="info-item-1">Linux 云服务器根分区扩容流程（ext4 示例） 1. 云厂商控制台扩容磁盘  登录云服务商（AWS、阿里云、腾讯云等） 找到对应实例的 系统盘 / 数据盘 修改磁盘大小，例如从 40G → 80G 这一步完成后，虚拟磁盘 /dev/vda 就会变大，但分区和文件系统不会自动变大   2. 确认磁盘和分区情况 12lsblkdf -h  lsblk 会显示磁盘和分区大小 df -h 会显示文件系统挂载的空间大小  例子： 12vda    80G└─vda1 40G   / 👉 说明磁盘是 80G，但分区还只有 40G  3. 安装扩容工具 （Ubuntu/Debian） 12sudo apt updatesudo apt install -y cloud-guest-utils （CentOS/RHEL） 1sudo yum install -y cloud-utils-growpart  4. 扩展分区 1sudo growpart /dev/vda 1  /dev/vda → 磁盘名 1 → 分区号（即 /dev/vda1）  执行后再看： 1lsblk 应该变成： ...</div></div></div></a><a class="pagination-related" href="/2025/09/15/2025-09-15-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87Pod%E8%BF%9B%E5%85%A5%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA%EF%BC%9F/" title="如何通过Pod进入到宿主机?"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-15</div><div class="info-item-2">如何通过Pod进入到宿主机?</div></div><div class="info-2"><div class="info-item-1">如何通过Pod进入到宿主机? nsenter -a -t 1 bash 命令的作用是让你在一个新的 shell 会话中，进入 PID 为 1 的进程所在的全部命名空间（Namespace）。 通过这种方式，可以从pod中进入到宿主机（全部的namespace都跟宿主机一样） breakdown 如下：  nsenter: 这是一个 Linux 命令行工具，用于将当前进程“进入”到指定进程的一个或多个命名空间中。 -t 1: 这个选项指定了目标进程的 PID (Process ID)。在这里，1 是 Linux 系统中第一个启动的进程（通常是 init 或 systemd）的 PID。所有其他进程都是由它或它的子进程派生出来的。 -a: 这个选项是 “all namespaces” 的缩写。它告诉 nsenter 将当前进程加入到目标进程（PID 1）所属于的所有类型的命名空间中，包括但不限于：  Mount (mnt) UTS (主机名和域名) IPC (进程间通信) Network PID (进程 ID) User ID Cgroup   bash: 这是要在新加入的命名空间环...</div></div></div></a><a class="pagination-related" href="/2025/09/15/2025-09-15-k8s-informer%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AF%A6%E8%A7%A3/" title="k8s informer通俗易懂详解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-15</div><div class="info-item-2">k8s informer通俗易懂详解</div></div><div class="info-2"><div class="info-item-1">Kubernetes Informer 机制详解 核心概念 Informer 是 Kubernetes 中用于监听和缓存资源对象的核心机制，它通过 ListAndWatch 机制实现高效的资源监控。 核心组件及作用 1. Reflector（反射器）  作用：负责从 Kubernetes API Server 获取资源对象 功能：  List：获取资源的全量数据 Watch：监听资源的增量变化 将数据放入 Delta FIFO 队列    2. Delta FIFO Queue（增量队列）  作用：存储资源对象的变化（增删改） 特点：  保持操作顺序 存储对象的增量变化（Delta） 线程安全    3. Informer（通知器）  作用：从 Delta FIFO 队列中取出对象并处理 功能：  调用 Indexer 更新本地缓存 触发注册的事件处理器    4. Indexer（索引器）  作用：本地缓存，提供快速查询 功能：  存储资源对象的本地副本 提供基于索引的快速查找 线程安全的读写操作    5. Resource Event Handlers（资源事件处理器）  ...</div></div></div></a><a class="pagination-related" href="/2025/09/16/2025-09-16-sandbox%E5%92%8Ccontainer%E5%AF%B9%E6%AF%94/" title="sandbox和container对比"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-16</div><div class="info-item-2">sandbox和container对比</div></div><div class="info-2"><div class="info-item-1">sandbox和container对比 Sandbox 和 Container 的区别 基本概念 Sandbox（沙箱）  定义：一种隔离环境，用于安全地运行程序，限制其对系统资源的访问 目的：提供安全隔离，防止恶意代码影响主机系统 范围：通常针对单个应用程序或进程  Container（容器）  定义：一种轻量级虚拟化技术，将应用程序及其依赖打包在一起 目的：提供一致的运行环境，确保应用在不同环境中行为一致 范围：包含完整的应用程序运行时环境  主要区别对比    特性 Sandbox Container     主要目标 安全隔离 环境一致性   隔离级别 高（安全优先） 中等（资源隔离）   资源开销 极低 低到中等   启动速度 极快 快   包含内容 单个应用/进程 完整运行时环境    技术实现差异 Sandbox 实现方式 1234567// 浏览器沙箱示例（概念性）// 运行在受限环境中const sandboxedCode = `  // 无法访问DOM、网络、文件系统  // 只能执行安全的JavaScript代码  return 42;`; 典型技术：  浏...</div></div></div></a><a class="pagination-related" href="/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/" title="容器运行时扩展方案技术解析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-16</div><div class="info-item-2">容器运行时扩展方案技术解析</div></div><div class="info-2"><div class="info-item-1">容器运行时扩展方案技术解析 基于对某容器运行时扩展项目的代码分析，现从架构层面提炼其核心技术实现，聚焦三大核心能力：运行时接入机制、容器根文件系统云端持久化、Docker-in-Docker 安全实现方案。  1. 如何接入 Containerd 运行时生态 项目通过 Containerd Proxy Plugin 机制 实现与容器运行时的无缝集成，架构清晰、扩展性强。 ▶ 配置层接入  在 containerd 配置中注册名为 custom-snapshotter 的代理插件，通过 Unix Domain Socket 与本地 Agent 通信； 同时注册自定义 Runtime，指向特定二进制执行程序，实现容器生命周期的定制化控制。  ▶ 运行时层实现  Agent 侧：实现标准 gRPC 服务，响应来自 Containerd 的 Snapshotter 接口调用（如 Prepare、Mount、Remove）； 存储层封装：采用 Wrapper 模式封装原生 OverlayFS Snapshotter，在不破坏原有逻辑的前提下注入自定义行为（如镜像预处理、元数据记录等）； 通...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Roger-Lv</div><div class="author-info-description">Send a flare and light the way.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">161</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">143</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Roger-Lv"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Roger-Lv" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1150568956@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/zhongrenjie-lv-5588a928a/" target="_blank" title="LinkedIn"><i class="iconfont icon-linkedin-fill"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%BC%8FI-O%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FI-O"><span class="toc-number">1.</span> <span class="toc-text">阻塞式I&#x2F;O与非阻塞式I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%98%BB%E5%A1%9E%E5%BC%8F-I-O-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">1. 阻塞式 I&#x2F;O 的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%9E%E9%98%BB%E5%A1%9E-I-O-I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select-poll-epoll-%E7%9A%84%E2%80%9C%E4%BC%AA%E5%BC%82%E6%AD%A5%E2%80%9D"><span class="toc-number">1.2.</span> <span class="toc-text">2. 非阻塞 I&#x2F;O + I&#x2F;O 多路复用 (select&#x2F;poll&#x2F;epoll) 的“伪异步”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%87%B4%E5%91%BD%E7%BC%BA%E7%82%B9%EF%BC%9A%E4%BB%85%E9%99%90%E4%BA%8E%E2%80%9C%E5%B0%B1%E7%BB%AA%E9%80%9A%E7%9F%A5%E2%80%9D%EF%BC%8C%E4%B8%94%E4%B8%8D%E6%94%AF%E6%8C%81-Storage-I-O"><span class="toc-number">1.3.</span> <span class="toc-text">3. 致命缺点：仅限于“就绪通知”，且不支持 Storage I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-io-uring-%E7%9A%84%E9%9D%A9%E5%91%BD%E6%80%A7%E7%AA%81%E7%A0%B4"><span class="toc-number">1.4.</span> <span class="toc-text">4. io_uring 的革命性突破</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-DIRECT"><span class="toc-number">2.</span> <span class="toc-text">0_DIRECT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-O-DIRECT%EF%BC%9F%E2%80%94%E2%80%94-%E8%A7%A3%E5%86%B3%E2%80%9C%E5%8F%8C%E9%87%8D%E7%BC%93%E5%AD%98%E2%80%9D%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">一、 为什么要用 O_DIRECT？—— 解决“双重缓存”问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E4%BD%BF%E7%94%A8-O-DIRECT-%E7%9A%84%E4%B8%A5%E8%8B%9B%E8%A6%81%E6%B1%82"><span class="toc-number">2.2.</span> <span class="toc-text">二、 使用 O_DIRECT 的严苛要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E4%B8%8E%E4%BD%A0%E7%BB%8F%E5%8E%86%E7%9A%84%E5%85%B3%E8%81%94%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-POSIX-AIO-%E6%98%AF%E6%AE%8B%E7%BC%BA%E7%9A%84%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">三、 与你经历的关联：为什么 POSIX AIO 是残缺的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.</span> <span class="toc-text">四、 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">io_uring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%8E-Linux-AIO-%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">1.</span> <span class="toc-text">1 与 Linux AIO 的不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9ASQ-CQ-SQE-CQE"><span class="toc-number">2.</span> <span class="toc-text">2 原理及核心数据结构：SQ&#x2F;CQ&#x2F;SQE&#x2F;CQE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">3.</span> <span class="toc-text">3 带来的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">4 三种工作模式</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/04/2025-12-04-LangGraph-%E4%B8%AD-checkpoint_id-%E7%9A%84%E6%9B%B4%E6%96%B0%E6%97%B6%E6%9C%BA%EF%BC%9A%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%AF%9D%E8%BD%AE%E6%AC%A1%E8%BF%98%E6%98%AF%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E6%B5%81%E8%BD%AC%EF%BC%9F/" title="LangGraph 中 checkpoint_id 的更新时机：每个对话轮次还是每个节点流转？"><div style="background: /img/cover/langgraph.jepg"></div></a><div class="content"><a class="title" href="/2025/12/04/2025-12-04-LangGraph-%E4%B8%AD-checkpoint_id-%E7%9A%84%E6%9B%B4%E6%96%B0%E6%97%B6%E6%9C%BA%EF%BC%9A%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%AF%9D%E8%BD%AE%E6%AC%A1%E8%BF%98%E6%98%AF%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E6%B5%81%E8%BD%AC%EF%BC%9F/" title="LangGraph 中 checkpoint_id 的更新时机：每个对话轮次还是每个节点流转？">LangGraph 中 checkpoint_id 的更新时机：每个对话轮次还是每个节点流转？</a><time datetime="2025-12-03T16:00:00.000Z" title="发表于 2025-12-04 00:00:00">2025-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/04/2025-12-04-%E4%BB%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%88%B0-GraphRAG%EF%BC%9A%E6%8E%A2%E7%B4%A2%E5%B1%9E%E6%80%A7%E5%9B%BE%E7%9A%84%E6%9E%84%E5%BB%BA%E5%92%8C%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2%E5%AE%9E%E8%B7%B5/" title="从知识图谱到 GraphRAG：探索属性图的构建和复杂的数据检索实践"><div style="background: /img/cover/memgraph.jepg"></div></a><div class="content"><a class="title" href="/2025/12/04/2025-12-04-%E4%BB%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%88%B0-GraphRAG%EF%BC%9A%E6%8E%A2%E7%B4%A2%E5%B1%9E%E6%80%A7%E5%9B%BE%E7%9A%84%E6%9E%84%E5%BB%BA%E5%92%8C%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2%E5%AE%9E%E8%B7%B5/" title="从知识图谱到 GraphRAG：探索属性图的构建和复杂的数据检索实践">从知识图谱到 GraphRAG：探索属性图的构建和复杂的数据检索实践</a><time datetime="2025-12-03T16:00:00.000Z" title="发表于 2025-12-04 00:00:00">2025-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/04/2025-12-04-%E6%B7%B1%E5%85%A5-KV-Cache-%E7%9A%84%E8%BF%90%E4%BD%9C%E8%BF%87%E7%A8%8B/" title="深入 KV Cache 的运作过程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/kvcache.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入 KV Cache 的运作过程"/></a><div class="content"><a class="title" href="/2025/12/04/2025-12-04-%E6%B7%B1%E5%85%A5-KV-Cache-%E7%9A%84%E8%BF%90%E4%BD%9C%E8%BF%87%E7%A8%8B/" title="深入 KV Cache 的运作过程">深入 KV Cache 的运作过程</a><time datetime="2025-12-03T16:00:00.000Z" title="发表于 2025-12-04 00:00:00">2025-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/04/2025-12-04-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9CInfiniBand-&amp;-ROCE%E5%AD%A6%E4%B9%A0/" title="高性能网络InfiniBand &amp; ROCE学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/ROCE.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高性能网络InfiniBand &amp; ROCE学习"/></a><div class="content"><a class="title" href="/2025/12/04/2025-12-04-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9CInfiniBand-&amp;-ROCE%E5%AD%A6%E4%B9%A0/" title="高性能网络InfiniBand &amp; ROCE学习">高性能网络InfiniBand &amp; ROCE学习</a><time datetime="2025-12-03T16:00:00.000Z" title="发表于 2025-12-04 00:00:00">2025-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/02/2025-12-02-%E6%96%87%E6%A1%A3-memgraph%E6%8F%90%E5%8F%96/" title="非结构化文档-&gt;memgraph提取(GraphDocument)"><div style="background: /img/cover/memgraph.jepg"></div></a><div class="content"><a class="title" href="/2025/12/02/2025-12-02-%E6%96%87%E6%A1%A3-memgraph%E6%8F%90%E5%8F%96/" title="非结构化文档-&gt;memgraph提取(GraphDocument)">非结构化文档-&gt;memgraph提取(GraphDocument)</a><time datetime="2025-12-01T16:00:00.000Z" title="发表于 2025-12-02 00:00:00">2025-12-02</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2024 - 2025 By Roger-Lv</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.2"></script><script src="/js/main.js?v=5.4.2"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.8.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'smA3tZdRGodG2VgnMubBQjLm-gzGzoHsz',
      appKey: 'biCDxj0lSBtZTMie2kNIKErd',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.3/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><div class="aplayer no-destroy" data-id="8674547170" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.4.2"></script></div></div></body></html>