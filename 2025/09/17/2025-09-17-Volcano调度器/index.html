<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Volcano调度器 | Roger-Lv's space</title><meta name="author" content="Roger-Lv"><meta name="copyright" content="Roger-Lv"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="参考：https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;700565336 在 Volcano 系统中，“Job” 和 “Task” 这两个词在 调度器（Scheduler）内部 和 用户&#x2F;控制器（Controller）层面 代表的是完全不同的东西。 https:&#x2F;&#x2F;volcano.sh&#x2F;zh&#x2F;docs&#x2F; 丰富的调度策略  Gang Scheduling：确保作业的所有任务同时启动，适用于">
<meta property="og:type" content="article">
<meta property="og:title" content="Volcano调度器">
<meta property="og:url" content="http://example.com/2025/09/17/2025-09-17-Volcano%E8%B0%83%E5%BA%A6%E5%99%A8/index.html">
<meta property="og:site_name" content="Roger-Lv&#39;s space">
<meta property="og:description" content="参考：https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;700565336 在 Volcano 系统中，“Job” 和 “Task” 这两个词在 调度器（Scheduler）内部 和 用户&#x2F;控制器（Controller）层面 代表的是完全不同的东西。 https:&#x2F;&#x2F;volcano.sh&#x2F;zh&#x2F;docs&#x2F; 丰富的调度策略  Gang Scheduling：确保作业的所有任务同时启动，适用于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/k8s.png">
<meta property="article:published_time" content="2025-09-16T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-17T07:39:00.810Z">
<meta property="article:author" content="Roger-Lv">
<meta property="article:tag" content="K8S">
<meta property="article:tag" content="Volcano">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/k8s.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Volcano调度器",
  "url": "http://example.com/2025/09/17/2025-09-17-Volcano%E8%B0%83%E5%BA%A6%E5%99%A8/",
  "image": "http://example.com/img/cover/k8s.png",
  "datePublished": "2025-09-16T16:00:00.000Z",
  "dateModified": "2025-09-17T07:39:00.810Z",
  "author": [
    {
      "@type": "Person",
      "name": "Roger-Lv",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://example.com/2025/09/17/2025-09-17-Volcano%E8%B0%83%E5%BA%A6%E5%99%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.4.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Volcano调度器',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">177</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">150</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">49</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Roger-Lv's space</span></a><a class="nav-page-title" href="/"><span class="site-name">Volcano调度器</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div><!-- 添加搜索按钮 ↓--><span class="search-button"><i class="fas fa-search" aria-hidden="true"></i></span></div></nav><div id="post-info"><h1 class="post-title">Volcano调度器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-16T16:00:00.000Z" title="发表于 2025-09-17 00:00:00">2025-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-17T07:39:00.810Z" title="更新于 2025-09-17 15:39:00">2025-09-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%B0%83%E5%BA%A6%E5%99%A8/">调度器</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2025/09/17/2025-09-17-Volcano%E8%B0%83%E5%BA%A6%E5%99%A8/" data-flag-title="Volcano调度器"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/700565336">https://zhuanlan.zhihu.com/p/700565336</a></p>
<p>在 Volcano 系统中，“Job” 和 “Task” 这两个词在 <strong>调度器（Scheduler）内部</strong> 和 <strong>用户/控制器（Controller）层面</strong> 代表的是完全不同的东西。</p>
<p><a target="_blank" rel="noopener" href="https://volcano.sh/zh/docs/">https://volcano.sh/zh/docs/</a></p>
<h3 id="丰富的调度策略">丰富的调度策略</h3>
<ul>
<li><strong>Gang Scheduling</strong>：确保作业的所有任务同时启动，适用于分布式训练、大数据等场景</li>
<li><strong>Binpack Scheduling</strong>：通过任务紧凑分配优化资源利用率</li>
<li><strong>Heterogeneous device scheduling</strong>：高效共享GPU异构资源，支持CUDA和MIG两种模式的GPU调度，支持NPU调度</li>
<li><strong>Proportion/Capacity Scheduling</strong>：基于队列配额进行资源的共享/抢占/回收</li>
<li><strong>NodeGroup Scheduling</strong>：支持节点分组亲和性调度，实现队列与节点组的绑定关系</li>
<li><strong>DRF Scheduling</strong>：支持多维度资源的公平调度</li>
<li><strong>SLA Scheduling</strong>：基于服务质量的调度保障</li>
<li><strong>Task-topology Scheduling</strong>：支持任务拓扑感知调度，优化通信密集型应用性能</li>
<li><strong>NUMA Aware Scheduling</strong>：支持NUMA架构的调度，优化任务在多核处理器上的资源分配，提升内存访问效率和计算性能</li>
</ul>
<h3 id="Volcano-调度器核心概念映射图"><strong>Volcano 调度器核心概念映射图</strong></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">|                                                                                                 |</span><br><span class="line"></span><br><span class="line">|   [ 用户/控制器 (Controller) 视角 ]                                                             |</span><br><span class="line"></span><br><span class="line">|   +---------------------+                                                                       |</span><br><span class="line"></span><br><span class="line">|   |   VolcanoJob (CR)   |  &lt;--- 用户创建的自定义资源 (Custom Resource)                          |</span><br><span class="line"></span><br><span class="line">|   +----------+----------+                                                                       |</span><br><span class="line"></span><br><span class="line">|              |                                                                                  |</span><br><span class="line"></span><br><span class="line">|              |  .spec.tasks: []TaskSpec  (定义Pod模板和副本数，类似ReplicaSet)                    |</span><br><span class="line"></span><br><span class="line">|              |                                                                                  |</span><br><span class="line"></span><br><span class="line">|              v                                                                                  |</span><br><span class="line"></span><br><span class="line">|   +---------------------+                                                                       |</span><br><span class="line"></span><br><span class="line">|   |    PodGroup (CR)    |  &lt;--- VolcanoJob Controller 创建的资源，代表一组强关联的Pod           |</span><br><span class="line"></span><br><span class="line">|   +----------+----------+                                                                       |</span><br><span class="line"></span><br><span class="line">|              |                                                                                  |</span><br><span class="line"></span><br><span class="line">|              |  (通过标签/注解关联)                                                               |</span><br><span class="line"></span><br><span class="line">|              v                                                                                  |</span><br><span class="line"></span><br><span class="line">|   +---------------------+    +---------------------+    +---------------------+                 |</span><br><span class="line"></span><br><span class="line">|   |      Pod (CR)       |    |      Pod (CR)       |    |      Pod (CR)       |  ...            |</span><br><span class="line"></span><br><span class="line">|   +---------------------+    +---------------------+    +---------------------+                 |</span><br><span class="line"></span><br><span class="line">|                                                                                                 |</span><br><span class="line"></span><br><span class="line">+-------------------------------------------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">​                                      ^                          ^                          ^</span><br><span class="line"></span><br><span class="line">​                                      |                          |                          |</span><br><span class="line"></span><br><span class="line">​                                      | (调度器内部映射)          |                          |</span><br><span class="line"></span><br><span class="line">​                                      |                          |                          |</span><br><span class="line"></span><br><span class="line">+-------------------------------------------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">|                                                                                                 |</span><br><span class="line"></span><br><span class="line">|   [ 调度器 (Scheduler) 内部视角 ]                                                               |</span><br><span class="line"></span><br><span class="line">|                                                                                                 |</span><br><span class="line"></span><br><span class="line">|   +---------------------+                                                                       |</span><br><span class="line"></span><br><span class="line">|   |   JobInfo (Struct)  |  &lt;--- 调度器内部数据结构，本质是 `PodGroup` 的包装器 (Wrapper)        |</span><br><span class="line"></span><br><span class="line">|   |  - 包含 PodGroup    |                                                                       |</span><br><span class="line"></span><br><span class="line">|   +----------+----------+                                                                       |</span><br><span class="line"></span><br><span class="line">|              |                                                                                  |</span><br><span class="line"></span><br><span class="line">|              |  .Tasks: map[TaskInfo]  (Key是Pod UID, Value是该Pod的调度信息)                   |</span><br><span class="line"></span><br><span class="line">|              |                                                                                  |</span><br><span class="line"></span><br><span class="line">|              v                                                                                  |</span><br><span class="line"></span><br><span class="line">|   +---------------------+    +---------------------+    +---------------------+                 |</span><br><span class="line"></span><br><span class="line">|   |   TaskInfo (Struct) |    |   TaskInfo (Struct) |    |   TaskInfo (Struct) |  ...            |</span><br><span class="line"></span><br><span class="line">|   +---------------------+    +---------------------+    +---------------------+                 |</span><br><span class="line"></span><br><span class="line">|          ^                          ^                          ^                               |</span><br><span class="line"></span><br><span class="line">|          |                          |                          |                               |</span><br><span class="line"></span><br><span class="line">|          +--------------------------+--------------------------+                               |</span><br><span class="line"></span><br><span class="line">|                                     |                                                          |</span><br><span class="line"></span><br><span class="line">|                                     | (一一对应)                                                 |</span><br><span class="line"></span><br><span class="line">|                                     v                                                          |</span><br><span class="line"></span><br><span class="line">|                             [ Kubernetes Pod 对象 ]                                            |</span><br><span class="line"></span><br><span class="line">|                                                                                                 |</span><br><span class="line"></span><br><span class="line">+-------------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<h3 id="关键结论-图例说明"><strong>关键结论 (图例说明)</strong></h3>
<ol>
<li><strong>调度器不直接看 <code>VolcanoJob</code></strong>：当你在调度器源码里看到 <code>Job</code>，它指的是 <code>JobInfo</code>，而不是用户创建的 <code>VolcanoJob</code> CR。</li>
<li><strong><code>JobInfo</code> = <code>PodGroup</code> Wrapper</strong>：调度器内部的 <code>Job</code> (<code>JobInfo</code>) 是对 <code>PodGroup</code> 这个概念的封装。调度器真正调度的单位是 <code>PodGroup</code>。</li>
<li><strong><code>TaskInfo</code> = <code>Pod</code> Wrapper</strong>：调度器内部的 <code>Task</code> (<code>TaskInfo</code>) 是对单个 <code>Pod</code> 的封装。一个 <code>JobInfo</code> 包含多个 <code>TaskInfo</code>，对应 <code>PodGroup</code> 包含多个 <code>Pod</code>。</li>
<li><strong><code>VolcanoJob</code> 是更高层的抽象</strong>：用户创建的 <code>VolcanoJob</code> 是一个更高级的、面向应用的CR，它定义了任务模板。它的控制器会负责创建底层的 <code>PodGroup</code> 和 <code>Pod</code>。</li>
<li><strong>为什么用 Job/Task？</strong> 这是调度器内部为了方便管理和实现（如gang调度）而设计的数据结构和术语，它们是对底层K8s原生对象（PodGroup, Pod）的抽象和包装，与用户定义的 <code>VolcanoJob</code> 中的 <code>TaskSpec</code> 完全不是一回事。</li>
</ol>
<h2 id="0-总结前置"><strong>0. 总结前置</strong></h2>
<p>这段总结在文末还有，不过我还是决定在开头放一份，方便第二次翻阅的读者快速找到结论。你可以选择跳到1. 概述开始顺序阅读本文。</p>
<blockquote>
<p>看到这里，我开始疑惑为什么调度里关注的是 Job，Task 这些，不应该是关注 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=637939845&amp;content_type=Answer&amp;match_order=1&amp;q=PodGroup&amp;zhida_source=entity">PodGroup</a> 吗？然后我找 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=637939845&amp;content_type=Answer&amp;match_order=1&amp;q=Volcano&amp;zhida_source=entity">Volcano</a> 社区的几个朋友聊了下，回过头来再理代码，发现 Scheduler 里的 Job、Task 和 Controller 里的 Job、Task 并不是一回事。<br>
对于熟悉 K8s 源码的读者而言，很容易带着 Job 就是 CR 的 Job 这种先入为主的观点开始看代码，并且觉得 Task 就是 CR Job 内的 Task。看到最后才反应过来，其实上面调度器里多次出现的 jobs 里放的那个 job 是 JobInfo 类型，JobInfo 类型对象里面的 Tasks 本质是 TaskInfo 类型对象的 map，而这个 TaskInfo 类型的 Task 和 Pod 是一一对应的，也就是 Pod 的一层 wrapper。<br>
回过来看 Volcano 引入的 CR 中的 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=637939845&amp;content_type=Answer&amp;match_order=1&amp;q=VolcanoJob&amp;zhida_source=entity">VolcanoJob</a> 也不是 Scheduler 里出现的这个 Job。VolcanoJob 里也有一个 Tasks 属性，对应的类型是 TaskSpec 类型，这个 TaskSpec 类似于 K8s 的 RS 级别资源，里面包含 Pod 模板和副本数等。<br>
因此调度器里的 Task 其实对应 Pod，当做 Pod wrapper 理解；而 Task 的集合也就是 Pod 的集合，名字叫做 job，但是对应 PodGroup；而控制器里的 Job，也就是 VolcanoJob，它的属性里并没有 PodGroup；相反调度器那个 JobInfo 类型的 job 其实属性里包含了一个 PodGroup，其实也可以认为是一个 PodGroup 的 wrapper。<br>
所以看代码的过程中会一直觉得 Scheduler 在面向 Job 和 Task 调度，和 PodGroup 没有太大关系。其实这里的 Job 就是 PodGroup wrapper，Task 就是 Pod wrapper。</p>
</blockquote>
<h2 id="1-概述"><strong>1. 概述</strong></h2>
<p>Volcano 是一个开源的 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=637939845&amp;content_type=Answer&amp;match_order=1&amp;q=Kubernetes&amp;zhida_source=entity">Kubernetes</a> <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=637939845&amp;content_type=Answer&amp;match_order=1&amp;q=%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F&amp;zhida_source=entity">批处理系统</a>，专为高性能计算任务设计。它提供了一种高效的方式来管理和调度资源密集型作业，比如大数据处理和机器学习任务。</p>
<p>在批处理领域，任务通常需要大量计算资源，但这些资源在 Kubernetes 集群中可能是有限的或者分布不均。Volcano 尝试通过一些高级调度功能来解决这些问题，尽可能确保资源被高效利用，同时最小化作业的等待时间。这对于需要快速处理大量数据的场景尤其重要，如科学研究、金融建模或任何需要并行处理大量任务的应用。</p>
<p>Volcano 的关键特性之一是它的 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=637939845&amp;content_type=Answer&amp;match_order=1&amp;q=gang+%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6&amp;zhida_source=entity">gang 调度机制</a>。这个机制允许同时调度一组相关任务，确保它们要么全部启动，要么都不启动。这种方法对于那些需要多个任务协同工作的复杂作业来说至关重要，因为它避免了部分任务因资源不足而无法执行的情况。</p>
<p>举个例子：Kubernetes 原生的调度器只能实现一个 Pod 一个 Pod 顺序调度，对于小规模在线服务而言，也基本够用。不过当一个服务需要大量 Pod 一起启动才能正常运行时（比如一次模型训练任务需要用到100个 pods 时，如何保证这100个 pods 要么都成功调度，要么都不被调度呢？这时候就需要 Volcano 提供的 gang 调度能力了。</p>
<p>今天咱就来具体分析下 Volcano 的工作原理。</p>
<h2 id="2-Volcano-核心概念"><strong>2. Volcano 核心概念</strong></h2>
<p>先认识下 Volcano 的几个核心概念。</p>
<h3 id="2-1-认识-Queue、PodGroup-和-VolcanoJob"><strong>2.1 认识 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=637939845&amp;content_type=Answer&amp;match_order=1&amp;q=Queue&amp;zhida_source=entity">Queue</a>、PodGroup 和 VolcanoJob</strong></h3>
<p>Volcano 引入了几个新概念：</p>
<ol>
<li><code>Queue</code></li>
<li><code>PodGroup</code></li>
<li><code>VolcanoJob</code></li>
</ol>
<p>这些都是 K8s 里的自定义资源，也就是我们能够通过 kubectl 命令查到相应的资源对象，好比 Deployment、Service、Pod 这些。</p>
<p>在 Volcano 中，<code>Queue</code> 用于管理和优先级排序任务。它允许用户根据业务需求或优先级，将作业分组到不同的队列中。这有助于更好地控制资源分配和调度优先级，确保高优先级的任务可以优先获取资源。</p>
<p><code>PodGroup</code> 一组相关的 Pod 集合。这主要解决了 Kubernetes 原生调度器中单个 Pod 调度的限制。通过将相关的 Pod 组织成 PodGroup，Volcano 能够更有效地处理那些需要多个 Pod 协同工作的复杂任务。</p>
<p><code>VolcanoJob</code> 是 Volcano 中的一个核心概念，它扩展了 Kubernetes 的 Job 资源。VolcanoJob 不仅包括了 Kubernetes Job 的所有特性，还加入了对批处理作业的额外支持，使得 Volcano 能够更好地适应高性能和大规模计算任务的需求。</p>
<h3 id="2-2-Queue、PodGroup-和-VolcanoJob-的关系"><strong>2.2. Queue、PodGroup 和 VolcanoJob 的关系</strong></h3>
<p>大致知道了 Volcano 中有 Queue、PodGroup 和 VolcanoJob 三种自定义资源后，我们接着具体看下这三种资源的作用、关系等。</p>
<p>首先，<code>Queue</code> 是一个 <code>PodGroup</code> 队列，<code>PodGroup</code> 是一组强关联的 <code>Pod</code> 集合。而 <code>VolcanoJob</code> 则是一个 K8s Job 升级版，对应的下一级资源是 <code>PodGroup</code>。换言之，就好比 ReplicaSet 的下一级资源是 Pod 一样。</p>
<p>所以 VolcanoJob 背后对应一个 K8s 里的自定义控制器（Operator 模式），这个控制器会根据 VolcanoJob 的具体配置去创建相应的 PodGroup 出来。而 PodGroup 最终会被当做一个整体被 Volcano Scheduler 调度。在调度的过程中，Volcano 还用到了 Queue 来实现 PodGroup 的排队、优先级控制等逻辑。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/80/v2-d626727a81c49514e425ad3aeebe8ae4_1440w.webp?source=2c26e567" alt="img"></p>
<h2 id="3-Volcano-调度框架概览"><strong>3. Volcano 调度框架概览</strong></h2>
<p>继续看 Volcano 调度逻辑的实现框架。</p>
<p>官方文档里有一张图，长这样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pica.zhimg.com/80/v2-06e2d49e168aea5153138ee8213b0d4f_1440w.webp?source=2c26e567" alt="img"></p>
<p>第一眼看这张图会有点蒙，主要是如何理解 <code>Action</code> 和 <code>Plugin</code> 两个概念，以及具体的 actions 和 plugins 作用是啥。</p>
<p>简单来说，Volcano 调度过程中会执行一系列的动作，这些动作也就是 Action，主要是 <strong>enqueue、allocate、backfill</strong> 这些。具体有哪些 actions，默认执行哪些 actions，后面我们到源码里去寻找。然后每个具体的 Action 中执行什么算法逻辑，就取决于注册进去的 plugins。换言之，actions 是基本固定的，合计6个（刚翻源码看到的，文档落后了），可选执行其中某几个；而 plugins 就有点多了（十几个），具体哪些 plugins 在哪个 Action 中被调用呢？咱接下来翻源码扒一扒。</p>
<h2 id="4-源码分析"><strong>4. 源码分析</strong></h2>
<p>接下来开始带着问题读源码。</p>
<h3 id="4-1-Action-实现在哪里？"><strong>4.1 Action 实现在哪里？</strong></h3>
<p>Action 相关源码入口还是很好找，Volcano 在 <code>pkg/scheduler</code> 中放了调度器相关的代码，里面有一个 actions 目录。在 actions 目录里的 <code>factory.go</code> 源文件中包含了一个 init 函数：</p>
<ul>
<li><code>pkg/scheduler/actions/factory.go:29</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	framework.RegisterAction(reclaim.New())</span><br><span class="line">	framework.RegisterAction(allocate.New())</span><br><span class="line">	framework.RegisterAction(backfill.New())</span><br><span class="line">	framework.RegisterAction(preempt.New())</span><br><span class="line">	framework.RegisterAction(enqueue.New())</span><br><span class="line">	framework.RegisterAction(shuffle.New())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里注册了6个 actions。<code>RegisterAction</code> 方法的实现也很简单：</p>
<ul>
<li><code>pkg/scheduler/framework/plugins.go:102</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> var actionMap = map[string]Action&#123;&#125;</span><br><span class="line"></span><br><span class="line">// RegisterAction register action</span><br><span class="line">func RegisterAction(act Action) &#123;</span><br><span class="line">	pluginMutex.Lock()</span><br><span class="line">	defer pluginMutex.Unlock()</span><br><span class="line"></span><br><span class="line">	actionMap[act.Name()] = act</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个 <code>actionMap</code> 来保存所有的 actions。这里的 Action 是一个 interface，定义如下：</p>
<ul>
<li><code>pkg/scheduler/framework/interface.go:20</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> // Action is the interface of scheduler action.</span><br><span class="line">type Action interface &#123;</span><br><span class="line">	// The unique name of Action.</span><br><span class="line">	Name() string</span><br><span class="line"></span><br><span class="line">	// Initialize initializes the allocator plugins.</span><br><span class="line">	Initialize()</span><br><span class="line"></span><br><span class="line">	// Execute allocates the cluster&#x27;s resources into each queue.</span><br><span class="line">	Execute(ssn *Session)</span><br><span class="line"></span><br><span class="line">	// UnIntialize un-initializes the allocator plugins.</span><br><span class="line">	UnInitialize()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-从-main-函数入手看调度器启动过程"><strong>4.2 从 main 函数入手看调度器启动过程</strong></h3>
<p>接着我们从 main 函数入手看调度器启动过程，看能不能找到 Action 是从哪里被调用的，actions 的调用顺序等相关逻辑，进而后面我们可以按照 actions 执行顺序来逐个分析具体的 Action 行为。</p>
<h3 id="4-2-1-入口逻辑"><strong>4.2.1 入口逻辑</strong></h3>
<p>调度器源码入口很直观：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.zhimg.com/80/v2-1bc809e026269ee974a3a754669d0aa3_1440w.webp?source=2c26e567" alt="img"></p>
<p>main 函数中主要逻辑是调用这个 <code>Run()</code> 方法：</p>
<ul>
<li><code>cmd/scheduler/main.go:71</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	if err := app.Run(s); err != nil &#123;</span><br><span class="line">	fmt.Fprintf(os.Stderr, &quot;%v\n&quot;, err)</span><br><span class="line">	os.Exit(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Run()</code> 方法负责启动一个 Volcano 调度器，里面核心代码只有下列2行，先构造 <code>Scheduler</code> 对象，然后调用其 <code>Run()</code> 方法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> sched, err := scheduler.NewScheduler(config, opt)</span><br><span class="line">// ……</span><br><span class="line">sched.Run(ctx.Done())</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-NewScheduler-方法"><strong>4.2.2 NewScheduler() 方法</strong></h3>
<p>接着看 <code>NewScheduler</code> 和 <code>Run()</code> 两个方法：</p>
<ul>
<li><code>pkg/scheduler/scheduler.go:59</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> // NewScheduler returns a scheduler</span><br><span class="line">func NewScheduler(config *rest.Config, opt *options.ServerOption) (*Scheduler, error) &#123;</span><br><span class="line">	// ……</span><br><span class="line"></span><br><span class="line">	cache := schedcache.New(config, opt.SchedulerNames, opt.DefaultQueue, opt.NodeSelector, opt.NodeWorkerThreads)</span><br><span class="line">	scheduler := &amp;Scheduler&#123;</span><br><span class="line">		schedulerConf:  opt.SchedulerConf,</span><br><span class="line">		fileWatcher:    watcher,</span><br><span class="line">		cache:          cache,</span><br><span class="line">		schedulePeriod: opt.SchedulePeriod,</span><br><span class="line">		dumper:         schedcache.Dumper&#123;Cache: cache&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return scheduler, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要涉及到一个 <code>Scheduler</code> 对象，看起来是调度过程的核心实现对象：</p>
<ul>
<li><code>pkg/scheduler/scheduler.go:44</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> // Scheduler watches for new unscheduled pods for volcano. It attempts to find</span><br><span class="line">// nodes that they fit on and writes bindings back to the api server.</span><br><span class="line">type Scheduler struct &#123;</span><br><span class="line">	cache          schedcache.Cache</span><br><span class="line">	schedulerConf  string</span><br><span class="line">	fileWatcher    filewatcher.FileWatcher</span><br><span class="line">	schedulePeriod time.Duration</span><br><span class="line">	once           sync.Once</span><br><span class="line"></span><br><span class="line">	mutex          sync.Mutex</span><br><span class="line">	actions        []framework.Action</span><br><span class="line">	plugins        []conf.Tier</span><br><span class="line">	configurations []conf.Configuration</span><br><span class="line">	metricsConf    map[string]string</span><br><span class="line">	dumper         schedcache.Dumper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-3-Run-方法"><strong>4.2.3 Run() 方法</strong></h3>
<p>暂时不忙细看每个属性，继续来看 Run 方法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> // Run runs the Scheduler</span><br><span class="line">func (pc *Scheduler) Run(stopCh &lt;-chan struct&#123;&#125;) &#123;</span><br><span class="line">	pc.loadSchedulerConf()</span><br><span class="line">	go pc.watchSchedulerConf(stopCh)</span><br><span class="line">	// Start cache for policy.</span><br><span class="line">	pc.cache.SetMetricsConf(pc.metricsConf)</span><br><span class="line">	pc.cache.Run(stopCh)</span><br><span class="line">	pc.cache.WaitForCacheSync(stopCh)</span><br><span class="line">	klog.V(2).Infof(&quot;scheduler completes Initialization and start to run&quot;)</span><br><span class="line">	go wait.Until(pc.runOnce, pc.schedulePeriod, stopCh)</span><br><span class="line">	if options.ServerOpts.EnableCacheDumper &#123;</span><br><span class="line">		pc.dumper.ListenForSignal(stopCh)</span><br><span class="line">	&#125;</span><br><span class="line">	go runSchedulerSocket()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是 Scheduler 的启动逻辑了，我们先来看这里被周期性调用的 <code>runOnce</code> 方法，这个方法每隔1秒被执行一次：</p>
<ul>
<li><code>pkg/scheduler/scheduler.go:99</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> func (pc *Scheduler) runOnce() &#123;</span><br><span class="line">	// ……</span><br><span class="line"></span><br><span class="line">	actions := pc.actions</span><br><span class="line">	plugins := pc.plugins</span><br><span class="line">	configurations := pc.configurations</span><br><span class="line">	pc.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">	//Load configmap to check which action is enabled.</span><br><span class="line">	conf.EnabledActionMap = make(map[string]bool)</span><br><span class="line">	for _, action := range actions &#123;</span><br><span class="line">		conf.EnabledActionMap[action.Name()] = true</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ssn := framework.OpenSession(pc.cache, plugins, configurations)</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		framework.CloseSession(ssn)</span><br><span class="line">		metrics.UpdateE2eDuration(metrics.Duration(scheduleStartTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	for _, action := range actions &#123;</span><br><span class="line">		actionStartTime := time.Now()</span><br><span class="line">		action.Execute(ssn)</span><br><span class="line">		metrics.UpdateActionDuration(action.Name(), metrics.Duration(actionStartTime))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在 <code>runOnce</code> 中的2个关键步骤：</p>
<ol>
<li><code>ssn := framework.OpenSession(pc.cache, plugins, configurations)</code></li>
<li>遍历 actions，调用 <code>action.Execute(ssn)</code></li>
</ol>
<p>这里的 actions 集合是什么呢？OpenSession 拿到的 plugins 又是啥呢？</p>
<p>进一步跟代码可以找到如下默认配置：</p>
<ul>
<li><code>pkg/scheduler/util.go:31</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> var defaultSchedulerConf = `</span><br><span class="line">actions: &quot;enqueue, allocate, backfill&quot;</span><br><span class="line">tiers:</span><br><span class="line">- plugins:</span><br><span class="line">  - name: priority</span><br><span class="line">  - name: gang</span><br><span class="line">  - name: conformance</span><br><span class="line">- plugins:</span><br><span class="line">  - name: overcommit</span><br><span class="line">  - name: drf</span><br><span class="line">  - name: predicates</span><br><span class="line">  - name: proportion</span><br><span class="line">  - name: nodeorder</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>所以默认配置下，执行的 actions 是 <strong>enqueue, allocate, backfill</strong> 三个。再看默认方式部署后容器内的配置文件：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> # cat /volcano.scheduler/volcano-scheduler.conf</span><br><span class="line">actions: &quot;enqueue, allocate, backfill&quot;</span><br><span class="line">tiers:</span><br><span class="line">- plugins:</span><br><span class="line">  - name: priority</span><br><span class="line">  - name: gang</span><br><span class="line">    enablePreemptable: false</span><br><span class="line">  - name: conformance</span><br><span class="line">- plugins:</span><br><span class="line">  - name: overcommit</span><br><span class="line">  - name: drf</span><br><span class="line">    enablePreemptable: false</span><br><span class="line">  - name: predicates</span><br><span class="line">  - name: proportion</span><br><span class="line">  - name: nodeorder</span><br><span class="line">  - name: binpack</span><br></pre></td></tr></table></figure>
<p>plugins 稍有不同，一个是 <code>glang</code> 和 <code>drf</code> 多了 <code>enablePreemptable</code>，一个是多了 <code>binpack</code>。接下来我们先看 actions 和 plugins 的调用逻辑，再看具体的 actions 和 plugins 分别是什么含义。</p>
<h3 id="4-3-寻找-actions-和-plugins-的调用逻辑"><strong>4.3 寻找 actions 和 plugins 的调用逻辑</strong></h3>
<p>前面我们看到 <code>runOnce()</code> 方法里的2个关键步骤：</p>
<ol>
<li><code>ssn := framework.OpenSession(pc.cache, plugins, configurations)</code></li>
<li>遍历 actions，调用 <code>action.Execute(ssn)</code></li>
</ol>
<p>接下来咱顺着这两步来寻找 actions 和 plugins 的调用逻辑。</p>
<h3 id="4-3-1-理解-Session-以及-plugins-被调用的本质"><strong>4.3.1 理解 Session 以及 plugins 被调用的本质</strong></h3>
<p><code>framework.OpenSession()</code> 函数打开了一个 Session。不过什么是 Session 呢？来具体看下 <code>OpenSession()</code> 函数的实现：</p>
<ul>
<li><code>pkg/scheduler/framework/framework.go:30</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> func OpenSession(cache cache.Cache, tiers []conf.Tier, configurations []conf.Configuration) *Session &#123;</span><br><span class="line">	ssn := openSession(cache)</span><br><span class="line">	ssn.Tiers = tiers</span><br><span class="line">	ssn.Configurations = configurations</span><br><span class="line">	ssn.NodeMap = GenerateNodeMapAndSlice(ssn.Nodes)</span><br><span class="line">	ssn.PodLister = NewPodLister(ssn)</span><br><span class="line"></span><br><span class="line">	for _, tier := range tiers &#123;</span><br><span class="line">		for _, plugin := range tier.Plugins &#123;</span><br><span class="line">			if pb, found := GetPluginBuilder(plugin.Name); !found &#123;</span><br><span class="line">				klog.Errorf(&quot;Failed to get plugin %s.&quot;, plugin.Name)</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				plugin := pb(plugin.Arguments)</span><br><span class="line">				ssn.plugins[plugin.Name()] = plugin</span><br><span class="line">				onSessionOpenStart := time.Now()</span><br><span class="line">				plugin.OnSessionOpen(ssn)</span><br><span class="line">				metrics.UpdatePluginDuration(plugin.Name(), metrics.OnSessionOpen, metrics.Duration(onSessionOpenStart))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ssn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 Session 对象属性很多，不过还是值得浏览一遍，大概心里有个印象，知道哪些功能被封装进去了：</p>
<ul>
<li><code>pkg/scheduler/framework/session.go:45</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> type Session struct &#123;</span><br><span class="line">	UID types.UID</span><br><span class="line"></span><br><span class="line">	kubeClient      kubernetes.Interface</span><br><span class="line">	recorder        record.EventRecorder</span><br><span class="line">	cache           cache.Cache</span><br><span class="line">	restConfig      *rest.Config</span><br><span class="line">	informerFactory informers.SharedInformerFactory</span><br><span class="line"></span><br><span class="line">	TotalResource *api.Resource</span><br><span class="line">	// podGroupStatus cache podgroup status during schedule</span><br><span class="line">	// This should not be mutated after initiated</span><br><span class="line">	podGroupStatus map[api.JobID]scheduling.PodGroupStatus</span><br><span class="line"></span><br><span class="line">	Jobs           map[api.JobID]*api.JobInfo</span><br><span class="line">	Nodes          map[string]*api.NodeInfo</span><br><span class="line">	CSINodesStatus map[string]*api.CSINodeStatusInfo</span><br><span class="line">	RevocableNodes map[string]*api.NodeInfo</span><br><span class="line">	Queues         map[api.QueueID]*api.QueueInfo</span><br><span class="line">	NamespaceInfo  map[api.NamespaceName]*api.NamespaceInfo</span><br><span class="line"></span><br><span class="line">	// NodeMap is like Nodes except that it uses k8s NodeInfo api and should only</span><br><span class="line">	// be used in k8s compatable api scenarios such as in predicates and nodeorder plugins.</span><br><span class="line">	NodeMap   map[string]*k8sframework.NodeInfo</span><br><span class="line">	PodLister *PodLister</span><br><span class="line"></span><br><span class="line">	Tiers          []conf.Tier</span><br><span class="line">	Configurations []conf.Configuration</span><br><span class="line">	NodeList       []*api.NodeInfo</span><br><span class="line"></span><br><span class="line">	plugins           map[string]Plugin</span><br><span class="line">	eventHandlers     []*EventHandler</span><br><span class="line">	jobOrderFns       map[string]api.CompareFn</span><br><span class="line">	queueOrderFns     map[string]api.CompareFn</span><br><span class="line">	taskOrderFns      map[string]api.CompareFn</span><br><span class="line">	clusterOrderFns   map[string]api.CompareFn</span><br><span class="line">	predicateFns      map[string]api.PredicateFn</span><br><span class="line">	prePredicateFns   map[string]api.PrePredicateFn</span><br><span class="line">	bestNodeFns       map[string]api.BestNodeFn</span><br><span class="line">	nodeOrderFns      map[string]api.NodeOrderFn</span><br><span class="line">	batchNodeOrderFns map[string]api.BatchNodeOrderFn</span><br><span class="line">	nodeMapFns        map[string]api.NodeMapFn</span><br><span class="line">	nodeReduceFns     map[string]api.NodeReduceFn</span><br><span class="line">	preemptableFns    map[string]api.EvictableFn</span><br><span class="line">	reclaimableFns    map[string]api.EvictableFn</span><br><span class="line">	overusedFns       map[string]api.ValidateFn</span><br><span class="line">	allocatableFns    map[string]api.AllocatableFn</span><br><span class="line">	jobReadyFns       map[string]api.ValidateFn</span><br><span class="line">	jobPipelinedFns   map[string]api.VoteFn</span><br><span class="line">	jobValidFns       map[string]api.ValidateExFn</span><br><span class="line">	jobEnqueueableFns map[string]api.VoteFn</span><br><span class="line">	jobEnqueuedFns    map[string]api.JobEnqueuedFn</span><br><span class="line">	targetJobFns      map[string]api.TargetJobFn</span><br><span class="line">	reservedNodesFns  map[string]api.ReservedNodesFn</span><br><span class="line">	victimTasksFns    map[string][]api.VictimTasksFn</span><br><span class="line">	jobStarvingFns    map[string]api.ValidateFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>OpenSession()</code> 函数中，plugins 被遍历，然后依次调用 <code>plugin.OnSessionOpen(ssn)</code> 方法。这个 <code>OnSessionOpen(ssn)</code> 方法的调用并不会执行具体的动作，只是注册了一堆的方法到 Session 里，比如上面这个 Session 对象的 preemptableFns 属性就会在 <code>gangPlugin</code> 的 <code>OnSessionOpen()</code> 方法被调用时初始化，执行一行类似 <code>ssn.preemptableFns[gp.Name()] = preemptableFn</code> 的逻辑。所以一堆的 plugins 的调用逻辑就是将算法注册到 Session 里。</p>
<p>接着看一眼 Plugin 对象的定义，其实很简洁：</p>
<ul>
<li><code>pkg/scheduler/framework/interface.go:35</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> type Plugin interface &#123;</span><br><span class="line">	Name() string</span><br><span class="line"></span><br><span class="line">	OnSessionOpen(ssn *Session)</span><br><span class="line">	OnSessionClose(ssn *Session)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-2-理解-actions-的执行逻辑"><strong>4.3.2 理解 actions 的执行逻辑</strong></h3>
<p>我们已经看到了 plugins 最终就是被绑到 Session 上的一堆算法，那么这些算法是怎样被调用的呢？在 <code>runOnce()</code> 方法中的第二个主要逻辑是：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	for _, action := range actions &#123;</span><br><span class="line">	actionStartTime := time.Now()</span><br><span class="line">	action.Execute(ssn)</span><br><span class="line">	metrics.UpdateActionDuration(action.Name(), metrics.Duration(actionStartTime))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是 actions 被遍历，然后依次执行 Execute() 方法，这里传递了一个 ssn（*Session 类型）对象进去。所以下一步的重点就是看 <code>Execute()</code> 方法的执行逻辑。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/80/v2-4f45b90cacbe26ed4a927ff145af34c8_1440w.webp?source=2c26e567" alt="img"></p>
<p>前面提到默认被执行的 actions 只有三个：enqueue, allocate 和 backfill。到这里可以看到接着的逻辑就是逐个调用这些 actions 的 Execute() 方法，那么 Execute() 里放的应该就是 Action 的具体逻辑了。</p>
<p>到这里在回过头来看官网的图，主流程就很好理解了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/80/v2-06e2d49e168aea5153138ee8213b0d4f_1440w.webp?source=2c26e567" alt="img"></p>
<p>一个个 plugins 注册具体的算法函数到 Session 里，然后 actions 顺序执行的过程中，到 Session 里去取相应的算法函数来执行。</p>
<h3 id="4-4-Action-分析：enqueue"><strong>4.4 Action 分析：enqueue</strong></h3>
<p><code>enqueue</code> Action 的 <code>Execute()</code> 方法骨架如下：</p>
<ul>
<li><code>pkg/scheduler/actions/enqueue/enqueue.go:44</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> func (enqueue *Action) Execute(ssn *framework.Session) &#123;</span><br><span class="line">	// ......</span><br><span class="line">	queues := util.NewPriorityQueue(ssn.QueueOrderFn)</span><br><span class="line">	queueSet := sets.NewString()</span><br><span class="line">	jobsMap := map[api.QueueID]*util.PriorityQueue&#123;&#125;</span><br><span class="line"></span><br><span class="line">	for _, job := range ssn.Jobs &#123;</span><br><span class="line">		// ......</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.V(3).Infof(&quot;Try to enqueue PodGroup to %d Queues&quot;, len(jobsMap))</span><br><span class="line"></span><br><span class="line">	for &#123;</span><br><span class="line">		// ......</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开头引入了3个局部变量 queues、queueSet 和 jobsMap，接着执行了2个 for 循环，接着我们逐个来分析。</p>
<h3 id="4-4-1-queues、queueSet-和-jobsMap"><strong>4.4.1 queues、queueSet 和 jobsMap</strong></h3>
<p><strong>1. queues</strong></p>
<p>这里的 queues 是一个 Priority Queue，定义如下：</p>
<ul>
<li><code>pkg/scheduler/util/priority_queue.go:26</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> type PriorityQueue struct &#123;</span><br><span class="line">	queue priorityQueue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type priorityQueue struct &#123;</span><br><span class="line">	items  []interface&#123;&#125;</span><br><span class="line">	lessFn api.LessFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个队列的实现用了 heap 包，实现了一个“最大堆”，也就是每次 Pop() 会拿到一个优先级最高的 item。另外需要注意的是这里的 queues 用了复数形式，其实是因为下文这个队列的用法中，item 是一个队列，也就是当前队列中存放的还是队列。后面我们具体来看。</p>
<p><strong>2. queueSet</strong></p>
<p>这个没啥好说的，一个 name set。</p>
<p><strong>3. jobsMap</strong></p>
<p>这是一个从 QueueID 到 PriorityQueue 的 map</p>
<h3 id="4-4-2-for-循环遍历-jobs"><strong>4.4.2 for 循环遍历 jobs</strong></h3>
<p>这一段 for 循环的代码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> // 这个 Job 是 Volcano 自定义资源 Job，不是 K8s 里的 Job；这里开始遍历所有 jobs</span><br><span class="line">for _, job := range ssn.Jobs &#123;</span><br><span class="line">	if job.ScheduleStartTimestamp.IsZero() &#123;</span><br><span class="line">		ssn.Jobs[job.UID].ScheduleStartTimestamp = metav1.Time&#123;</span><br><span class="line">			Time: time.Now(),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 如果 job 中定义的 Queue 在 Session 中存在，那就执行</span><br><span class="line">	// queueSet.Insert(string(queue.UID)) 和</span><br><span class="line">	// queues.Push(queue)；注意这里 Push 进去的是 queue</span><br><span class="line">	if queue, found := ssn.Queues[job.Queue]; !found &#123;</span><br><span class="line">		klog.Errorf(&quot;Failed to find Queue &lt;%s&gt; for Job &lt;%s/%s&gt;&quot;,</span><br><span class="line">			job.Queue, job.Namespace, job.Name)</span><br><span class="line">		continue</span><br><span class="line">	&#125; else if !queueSet.Has(string(queue.UID)) &#123;</span><br><span class="line">		klog.V(5).Infof(&quot;Added Queue &lt;%s&gt; for Job &lt;%s/%s&gt;&quot;,</span><br><span class="line">			queue.Name, job.Namespace, job.Name)</span><br><span class="line"></span><br><span class="line">		// 这里构建了一个 queue UID 的 set 和一个 queue 队列（优先级队列，heap 实现）</span><br><span class="line">		queueSet.Insert(string(queue.UID))</span><br><span class="line">		queues.Push(queue)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if job.IsPending() &#123;</span><br><span class="line">		// 如果 job 指定的 queue 还没存到 jobsMap 里，则创建一个对应的 PriorityQueue</span><br><span class="line">		if _, found := jobsMap[job.Queue]; !found &#123;</span><br><span class="line">			jobsMap[job.Queue] = util.NewPriorityQueue(ssn.JobOrderFn)</span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(5).Infof(&quot;Added Job &lt;%s/%s&gt; into Queue &lt;%s&gt;&quot;, job.Namespace, job.Name, job.Queue)</span><br><span class="line">		// 将 job 加到指定 queue 中</span><br><span class="line">		jobsMap[job.Queue].Push(job)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 for 循环主要做2件事情，一个是遍历 jobs 的过程中判断用到了哪些 Queue（K8s 自定义资源对象），将这些 Queue 保存到 queueSet 和 queues 中；另外一个就是将处于 Pending 状态的 jobs 加入到 jobsMap 中。这里涉及到自定义资源 Queue 和局部变量 queue、queues 这些，看起来有点绕。</p>
<h3 id="4-4-3-无限循环-for"><strong>4.4.3 无限循环 for</strong></h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> for &#123;</span><br><span class="line">	// 没有队列，退出循环</span><br><span class="line">	if queues.Empty() &#123;</span><br><span class="line">		break</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 从优先级队列 queues 中 Pop 一个高优的队列出来</span><br><span class="line">	queue := queues.Pop().(*api.QueueInfo)</span><br><span class="line"></span><br><span class="line">	// 如果这个高优队列在 jobsMap 里没有保存相应的 jobs，也就是为空，那就继续下一轮循环</span><br><span class="line">	jobs, found := jobsMap[queue.UID]</span><br><span class="line">	if !found || jobs.Empty() &#123;</span><br><span class="line">		continue</span><br><span class="line">	&#125;</span><br><span class="line">	// jobs 也是一个优先级队列，Pop 一个高优 job 出来</span><br><span class="line">	job := jobs.Pop().(*api.JobInfo)</span><br><span class="line"></span><br><span class="line">	if job.PodGroup.Spec.MinResources == nil || ssn.JobEnqueueable(job) &#123;</span><br><span class="line">		ssn.JobEnqueued(job)</span><br><span class="line">		// Phase 更新为 &quot;Inqueue&quot;</span><br><span class="line">		job.PodGroup.Status.Phase = scheduling.PodGroupInqueue</span><br><span class="line">		// 将当前 job 加入到 ssn.Jobs map</span><br><span class="line">		ssn.Jobs[job.UID] = job</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 将前面 Pop 出来的 queue 加回到 queues 中，直到 queue 中没有 job，这样逐步 queues 为空空，上面的 Empty() 方法就会返回 true，然后循环退出。</span><br><span class="line">	queues.Push(queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个循环的逻辑是消化队列里的 jobs。首先将全局队列按照优先级 Pop 一个高优队列出来，然后根据这个队列的 UID 找到本地 jobsMap 里对应的 jobs 队列，这又是一个优先级队列。最后从这个优先级队列中 Pop 一个高优 Job 出来，将其状态设置成 Inqueue。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pica.zhimg.com/80/v2-0512adc1d46b2a3f2cfe215b5e400b4d_1440w.webp?source=2c26e567" alt="img"></p>
<p><strong>总的来说，enqueue 过程就是按照队列的优先级顺序，将队列中的 jobs 再按照优先级依次标记为 “Inqueue” 状态（job.PodGroup.Status.Phase = “Inqueue”）。</strong></p>
<h3 id="4-5-Action-分析：allocate"><strong>4.5 Action 分析：allocate</strong></h3>
<p>接着来看 allocate 过程。</p>
<h3 id="4-5-1-allocate-Execute-整体逻辑"><strong>4.5.1 allocate.Execute() 整体逻辑</strong></h3>
<p><code>allocate.Execute()</code> 方法的实现如下：</p>
<ul>
<li><code>pkg/scheduler/actions/allocate/allocate.go:44</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func (alloc *Action) Execute(ssn *framework.Session) &#123;</span><br><span class="line">klog.V(5).Infof(&quot;Enter Allocate ...&quot;)</span><br><span class="line">defer klog.V(5).Infof(&quot;Leaving Allocate ...&quot;)</span><br><span class="line"></span><br><span class="line">// the allocation for pod may have many stages</span><br><span class="line">// 1. pick a queue named Q (using ssn.QueueOrderFn)</span><br><span class="line">// 2. pick a job named J from Q (using ssn.JobOrderFn)</span><br><span class="line">// 3. pick a task T from J (using ssn.TaskOrderFn)</span><br><span class="line">// 4. use predicateFn to filter out node that T can not be allocated on.</span><br><span class="line">// 5. use ssn.NodeOrderFn to judge the best node and assign it to T</span><br><span class="line"></span><br><span class="line">// queues sort queues by QueueOrderFn.</span><br><span class="line">queues := util.NewPriorityQueue(ssn.QueueOrderFn)</span><br><span class="line">// jobsMap is used to find job with the highest priority in given queue.</span><br><span class="line">jobsMap := map[api.QueueID]*util.PriorityQueue&#123;&#125;</span><br><span class="line"></span><br><span class="line">for _, job := range ssn.Jobs &#123;</span><br><span class="line">	// ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.V(3).Infof(&quot;Try to allocate resource to %d Queues&quot;, len(jobsMap))</span><br><span class="line"></span><br><span class="line">pendingTasks := map[api.JobID]*util.PriorityQueue&#123;&#125;</span><br><span class="line"></span><br><span class="line">allNodes := ssn.NodeList</span><br><span class="line">predicateFn := func(task *api.TaskInfo, node *api.NodeInfo) ([]*api.Status, error)&#123;</span><br><span class="line">	// ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">	// ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我把三个相对独立的逻辑模块替换成了省略号，剩下的内容就不到十行了，相对好理解很多。我们先看这不到十行的方法主体，再看省略的三部分逻辑。</p>
<p>首先这里还是引入了一个优先级队列 queues 和一个从 queue id 到一个优先级队列的 map jobsMap。</p>
<ul>
<li><strong>queues</strong>：一个元素为优先级队列的优先级队列，也就是一个保存 queue 的“最大堆”，从而方便获取一个优先级最高的 queue；</li>
<li><strong>jobsMap</strong>：一个 map，key 是 queue 的 id，value 是一个优先级队列，也就是一个特定的 queue，queue 中存着 jobs；通过这个 map 可以方便获取指定 queue 中的一个优先 job；</li>
</ul>
<h3 id="4-5-2-第一个-for-循环的逻辑"><strong>4.5.2 第一个 for 循环的逻辑</strong></h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> for _, job := range ssn.Jobs &#123;</span><br><span class="line">	// ......</span><br><span class="line">	jobsMap[job.Queue].Push(job)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 for 看着长，不过除了一些健壮性逻辑之外，核心逻辑只有这样一行，也就是遍历 jobs，将其按照 queue 不同存到 jobsMap 中。</p>
<h3 id="4-5-3-预选函数-predicateFn"><strong>4.5.3 预选函数 predicateFn</strong></h3>
<p>接着来看预选函数 predicateFn 的实现逻辑。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> predicateFn := func(task *api.TaskInfo, node *api.NodeInfo) ([]*api.Status, error) &#123;</span><br><span class="line">	// Check for Resource Predicate</span><br><span class="line">	if ok, resources := task.InitResreq.LessEqualWithResourcesName(node.FutureIdle(), api.Zero); !ok &#123;</span><br><span class="line">		return nil, api.NewFitError(task, node, api.WrapInsufficientResourceReason(resources))</span><br><span class="line">	&#125;</span><br><span class="line">	var statusSets util.StatusSets</span><br><span class="line">	statusSets, err := ssn.PredicateFn(task, node)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, api.NewFitError(task, node, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if statusSets.ContainsUnschedulable() || statusSets.ContainsUnschedulableAndUnresolvable() ||</span><br><span class="line">		statusSets.ContainsErrorSkipOrWait() &#123;</span><br><span class="line">		return nil, api.NewFitError(task, node, statusSets.Message())</span><br><span class="line">	&#125;</span><br><span class="line">	return nil, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑是接收一个 task 和 node 作为参数，然后判断这个 node 上能否跑起来这个 task。返回值 Status 类型是一个结构体，定义如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> type Status struct &#123;</span><br><span class="line">	Code   int</span><br><span class="line">	Reason string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Code 的可选值有5个：<code>Success</code>、<code>Error</code>、<code>Unschedulable</code>、<code>UnschedulableAndUnresolvable</code>、<code>Wait</code> 和 <code>Skip</code>。这里主要需要理解三个状态：</p>
<ol>
<li>Success：可调度</li>
<li>Unschedulable：不可调度，但是驱逐后可能可调度</li>
<li>UnschedulableAndUnresolvable：不可调度且驱逐也不可调度</li>
</ol>
<p>接着我们去看这个 predicateFn 是如何被调用的。</p>
<h3 id="4-5-4-第二个-for-循环的逻辑"><strong>4.5.4 第二个 for 循环的逻辑</strong></h3>
<p>这个 for 循环行数超过 160，真是，，，不优雅。</p>
<ul>
<li><code>pkg/scheduler/actions/allocate/allocate.go:120</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"> for &#123;</span><br><span class="line">	if queues.Empty() &#123;</span><br><span class="line">		break</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Pop 一个最高优的 queue 出来</span><br><span class="line">	queue := queues.Pop().(*api.QueueInfo)</span><br><span class="line">	// ......</span><br><span class="line">	// jobs 也就是这个高优 queue 中的所有 jobs</span><br><span class="line">	jobs, found := jobsMap[queue.UID]</span><br><span class="line">	if !found || jobs.Empty() &#123;</span><br><span class="line">		klog.V(4).Infof(&quot;Can not find jobs for queue %s.&quot;, queue.Name)</span><br><span class="line">		continue</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// job 就是 jobs 这个优先级队列中的最高优条目</span><br><span class="line">	job := jobs.Pop().(*api.JobInfo)</span><br><span class="line">	if _, found = pendingTasks[job.UID]; !found &#123;</span><br><span class="line">		// tasks 也是一个优先级队列，里面保存一个 job 下的所有 tasks</span><br><span class="line">		tasks := util.NewPriorityQueue(ssn.TaskOrderFn)</span><br><span class="line">		for _, task := range job.TaskStatusIndex[api.Pending] &#123;</span><br><span class="line">			// Skip BestEffort task in &#x27;allocate&#x27; action.</span><br><span class="line">			if task.Resreq.IsEmpty() &#123;</span><br><span class="line">				klog.V(4).Infof(&quot;Task &lt;%v/%v&gt; is BestEffort task, skip it.&quot;,</span><br><span class="line">					task.Namespace, task.Name)</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">			// 将 task Push 到 tasks 队列中</span><br><span class="line">			tasks.Push(task)</span><br><span class="line">		&#125;</span><br><span class="line">		// 这个 map 的 key 是 job 的 id，value 是 tasks 队列</span><br><span class="line">		pendingTasks[job.UID] = tasks</span><br><span class="line">	&#125;</span><br><span class="line">	tasks := pendingTasks[job.UID]</span><br><span class="line"></span><br><span class="line">	// Added Queue back until no job in Namespace.</span><br><span class="line">	queues.Push(queue)</span><br><span class="line"></span><br><span class="line">	if tasks.Empty() &#123;</span><br><span class="line">		continue</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.V(3).Infof(&quot;Try to allocate resource to %d tasks of Job &lt;%v/%v&gt;&quot;,</span><br><span class="line">		tasks.Len(), job.Namespace, job.Name)</span><br><span class="line"></span><br><span class="line">	stmt := framework.NewStatement(ssn)</span><br><span class="line">	ph := util.NewPredicateHelper()</span><br><span class="line">	// tasks 不为空时，开一个循环来消化这些 tasks；这里的 tasks 属于同一个 job</span><br><span class="line">	for !tasks.Empty()&#123;</span><br><span class="line">		// ......</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if ssn.JobReady(job) &#123;</span><br><span class="line">		stmt.Commit()</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if !ssn.JobPipelined(job) &#123;</span><br><span class="line">			stmt.Discard()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续来看内部循环，也就是 tasks 不 Empty 的时候相应的处理逻辑：</p>
<ul>
<li><code>pkg/scheduler/actions/allocate/allocate.go:169</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"> for !tasks.Empty() &#123;</span><br><span class="line">	// 取出最高优的 task</span><br><span class="line">	task := tasks.Pop().(*api.TaskInfo)</span><br><span class="line"></span><br><span class="line">	// ......</span><br><span class="line"></span><br><span class="line">	// 跑一次预选算法，具体算法内容后面再分析</span><br><span class="line">	if err := ssn.PrePredicateFn(task); err != nil &#123;</span><br><span class="line">		klog.V(3).Infof(&quot;PrePredicate for task %s/%s failed for: %v&quot;, task.Namespace, task.Name, err)</span><br><span class="line">		fitErrors := api.NewFitErrors()</span><br><span class="line">		for _, ni := range allNodes &#123;</span><br><span class="line">			fitErrors.SetNodeError(ni.Name, err)</span><br><span class="line">		&#125;</span><br><span class="line">		job.NodesFitErrors[task.UID] = fitErrors</span><br><span class="line">		break</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 拿到预选通过的节点列表</span><br><span class="line">	predicateNodes, fitErrors := ph.PredicateNodes(task, allNodes, predicateFn, true)</span><br><span class="line">	if len(predicateNodes) == 0 &#123;</span><br><span class="line">		job.NodesFitErrors[task.UID] = fitErrors</span><br><span class="line">		break</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 候选节点列表，注意这里是二维切片，后面会依次直接保存 idleCandidateNodes 和 futureIdleCandidateNodes 两个切片本身进去</span><br><span class="line">	var candidateNodes [][]*api.NodeInfo</span><br><span class="line">	// 空闲候选节点列表</span><br><span class="line">	var idleCandidateNodes []*api.NodeInfo</span><br><span class="line">	// 未来空闲候选节点列表（预期即将有资源会被释放出来的节点）</span><br><span class="line">	var futureIdleCandidateNodes []*api.NodeInfo</span><br><span class="line">	for _, n := range predicateNodes &#123;</span><br><span class="line">		if task.InitResreq.LessEqual(n.Idle, api.Zero) &#123;</span><br><span class="line">			idleCandidateNodes = append(idleCandidateNodes, n)</span><br><span class="line">		&#125; else if task.InitResreq.LessEqual(n.FutureIdle(), api.Zero) &#123;</span><br><span class="line">			futureIdleCandidateNodes = append(futureIdleCandidateNodes, n)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			klog.V(5).Infof(&quot;Predicate filtered node %v, idle: %v and future idle: %v do not meet the requirements of task: %v&quot;,</span><br><span class="line">				n.Name, n.Idle, n.FutureIdle(), task.Name)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 填充候选节点列表</span><br><span class="line">	candidateNodes = append(candidateNodes, idleCandidateNodes)</span><br><span class="line">	candidateNodes = append(candidateNodes, futureIdleCandidateNodes)</span><br><span class="line"></span><br><span class="line">	// 准备寻找最优节点</span><br><span class="line">	var bestNode *api.NodeInfo</span><br><span class="line">	// for 循环变量里用的是 nodes，也就是先拿到 idleCandidateNodes，再拿 futureIdleCandidateNodes</span><br><span class="line">	for index, nodes := range candidateNodes &#123;</span><br><span class="line">		// ......</span><br><span class="line">		switch &#123;</span><br><span class="line">		case len(nodes) == 0:</span><br><span class="line">			klog.V(5).Infof(&quot;Task: %v, no matching node is found in the candidateNodes（index: %d） list.&quot;, task.Name, index)</span><br><span class="line">		case len(nodes) == 1: // If only one node after predicate, just use it.</span><br><span class="line">			bestNode = nodes[0]</span><br><span class="line">		case len(nodes) &gt; 1: // If more than one node after predicate, using &quot;the best&quot; one</span><br><span class="line">			// 优选算法来打分</span><br><span class="line">			nodeScores := util.PrioritizeNodes(task, nodes, ssn.BatchNodeOrderFn, ssn.NodeOrderMapFn, ssn.NodeOrderReduceFn)</span><br><span class="line"></span><br><span class="line">			bestNode = ssn.BestNodeFn(task, nodeScores)</span><br><span class="line">			if bestNode == nil &#123;</span><br><span class="line">				bestNode = util.SelectBestNode(nodeScores)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 如果在 idleCandidateNodes 中找到合适的节点，那就不看 futureIdleCandidateNodes 了</span><br><span class="line">		if bestNode != nil &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 将前面找到的最佳节点相应资源分配给当前 task</span><br><span class="line">	if task.InitResreq.LessEqual(bestNode.Idle, api.Zero) &#123;</span><br><span class="line">		// ......</span><br><span class="line">		if err := stmt.Allocate(task, bestNode); err != nil &#123;</span><br><span class="line">			// ......</span><br><span class="line">		&#125; </span><br><span class="line">		// ......</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// 将 node 上预期要释放的资源分配给当前 task</span><br><span class="line">		if task.InitResreq.LessEqual(bestNode.FutureIdle(), api.Zero) &#123;</span><br><span class="line">			// ......</span><br><span class="line">			if err := stmt.Pipeline(task, bestNode.Name); err != nil &#123;</span><br><span class="line">				klog.Errorf(&quot;Failed to pipeline Task %v on %v in Session %v for %v.&quot;,</span><br><span class="line">					task.UID, bestNode.Name, ssn.UID, err)</span><br><span class="line">			&#125;</span><br><span class="line">			// ......</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if ssn.JobReady(job) &amp;&amp; !tasks.Empty() &#123;</span><br><span class="line">		jobs.Push(job)</span><br><span class="line">		break</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 for 循环的逻辑主要是按照优先级依次给 tasks 寻找最合适的 node，找到后“预占”资源，于是按顺序逐步给所有的 tasks 都找到了最佳节点。</p>
<p>到这里我们没有具体去深究最后 pods 是如何被绑定到节点上的，也没有去看 Pipeline、Summit 这些逻辑；先放放，往后看完最后一个 Action backfill 之后，对整体框架熟悉了，再进一步分析细节。</p>
<h3 id="4-6-Action-分析：backfill"><strong>4.6 Action 分析：backfill</strong></h3>
<p>backfill 的逻辑是遍历待调度 jobs（Inqueue 状态），然后将没有没有指明资源申请大小的 task 调度掉。不过这里没有处理一个 job 中部分 task 指明了资源大小，部分没有指定的场景。总之看起来不是核心逻辑，考虑到本文篇幅已经过长，这块暂时不赘述。</p>
<h2 id="5-总结"><strong>5. 总结</strong></h2>
<p>看到这里，我开始疑惑为什么调度里关注的是 Job，Task 这些，不应该是关注 PodGroup 吗？然后我找 Volcano 社区的几个朋友聊了下，回过头来再理代码，发现 Scheduler 里的 Job、Task 和 Controller 里的 Job、Task 并不是一回事。</p>
<p>对于熟悉 K8s 源码的读者而言，很容易带着 Job 就是 CR 的 Job 这种先入为主的观点开始看代码，并且觉得 Task 就是 CR Job 内的 Task。看到最后才反应过来，其实上面调度器里多次出现的 jobs 里放的那个 job 是 JobInfo 类型，JobInfo 类型对象里面的 Tasks 本质是 TaskInfo 类型对象的 map，而这个 TaskInfo 类型的 Task 和 Pod 是一一对应的，也就是 Pod 的一层 wrapper。</p>
<p>回过来看 Volcano 引入的 CR 中的 VolcanoJob 也不是 Scheduler 里出现的这个 Job。VolcanoJob 里也有一个 Tasks 属性，对应的类型是 TaskSpec 类型，这个 TaskSpec 类似于 K8s 的 RS 级别资源，里面包含 Pod 模板和副本数等。</p>
<p>因此调度器里的 Task 其实对应 Pod，当做 Pod wrapper 理解；而 Task 的集合也就是 Pod 的集合，名字叫做 job，但是对应 PodGroup；而控制器里的 Job，也就是 VolcanoJob，它的属性里并没有 PodGroup；相反调度器那个 JobInfo 类型的 job 其实属性里包含了一个 PodGroup，其实也可以认为是一个 PodGroup 的 wrapper。</p>
<p>所以看代码的过程中会一直觉得 Scheduler 在面向 Job 和 Task 调度，和 PodGroup 没有太大关系。其实这里的 Job 就是 PodGroup wrapper，Task 就是 Pod wrapper。</p>
<h2 id="6-结尾"><strong>6. 结尾</strong></h2>
<p>在大致知道 Scheduler 的工作过程后，还有很多的细节等着我们进一步分析。比如：</p>
<ol>
<li>从 PodGroup 的创建入手，Scheduler 如何接手 PodGroup 完成调度过程的呢？（这条路一定走得通，不然其他框架，比如 Kubeflow 等就无法和 Volcano 整合了。）</li>
<li>PodGroup 里不包含 pods 信息，那 Scheduler 如何找到对应的 Pod 完成节点绑定呢？（粗看应该是通过 Pod 的 annotation 来过滤特定 PodGroup 名下的 pods，然后完成的调度。</li>
<li>Job（vcjob）和 PodGroup 控制器的主要工作逻辑是什么？</li>
<li>……</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Roger-Lv</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/17/2025-09-17-Volcano%E8%B0%83%E5%BA%A6%E5%99%A8/">http://example.com/2025/09/17/2025-09-17-Volcano%E8%B0%83%E5%BA%A6%E5%99%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Roger-Lv's space</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/K8S/">K8S</a><a class="post-meta__tags" href="/tags/Volcano/">Volcano</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/k8s.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/17/2025-09-17-NUMA-Aware-Scheduling%E4%BB%8B%E7%BB%8D/" title="NUMA-Aware Scheduling介绍"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">NUMA-Aware Scheduling介绍</div></div><div class="info-2"><div class="info-item-1">NUMA-Aware Scheduling https://zhuanlan.zhihu.com/p/713060080 一、 什么是 NUMA？ NUMA (Non-Uniform Memory Access，非统一内存访问) 是现代多处理器服务器（尤其是AI服务器）的标准架构。  核心思想：将CPU和内存划分为多个“节点”（Node）。每个节点内的CPU访问本节点的内存速度极快（本地内存访问），而访问其他节点的内存则速度较慢（远程内存访问），存在显著的延迟和带宽差异。 类比：想象一个办公室有多个小组，每个小组有自己的文件柜（本地内存）。找自己组的文件柜拿资料很快，但去别的组借资料就要走过去，花时间。  在一台配备8块GPU和2个CPU插槽的AI服务器上，通常会形成2个或4个NUMA节点。GPU通常通过PCIe总线直连到某个特定的CPU（NUMA节点）上。  二、 为什么需要 NUMA-Aware Scheduling？ 在传统的、非NUMA感知的调度下，操作系统或调度器（如K8s原生调度器）可能会做出灾难性的决策：  场景：一个需要大量内存的大模型推理Pod被调度到NUMA ...</div></div></div></a><a class="pagination-related" href="/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/" title="容器运行时扩展方案技术解析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">容器运行时扩展方案技术解析</div></div><div class="info-2"><div class="info-item-1">容器运行时扩展方案技术解析 基于对某容器运行时扩展项目的代码分析，现从架构层面提炼其核心技术实现，聚焦三大核心能力：运行时接入机制、容器根文件系统云端持久化、Docker-in-Docker 安全实现方案。  1. 如何接入 Containerd 运行时生态 项目通过 Containerd Proxy Plugin 机制 实现与容器运行时的无缝集成，架构清晰、扩展性强。 ▶ 配置层接入  在 containerd 配置中注册名为 custom-snapshotter 的代理插件，通过 Unix Domain Socket 与本地 Agent 通信； 同时注册自定义 Runtime，指向特定二进制执行程序，实现容器生命周期的定制化控制。  ▶ 运行时层实现  Agent 侧：实现标准 gRPC 服务，响应来自 Containerd 的 Snapshotter 接口调用（如 Prepare、Mount、Remove）； 存储层封装：采用 Wrapper 模式封装原生 OverlayFS Snapshotter，在不破坏原有逻辑的前提下注入自定义行为（如镜像预处理、元数据记录等）； 通...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/28/2024-09-28-NVIDIA-device-plugin-for-Kubernetes%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" title="NVIDIA device plugin for Kubernetes原理分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/CUDA.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-28</div><div class="info-item-2">NVIDIA device plugin for Kubernetes原理分析</div></div><div class="info-2"><div class="info-item-1">NVIDIA device plugin for Kubernetes原理分析 什么是 Device Plugin K8s 原生并没有支持第三方设备厂商的物理设备资源，因此 Device Plugins 给第三方设备厂商提供了相关接口，可以让他们的物理设备资源以 Extended Resources 提供给底层的容器。 当 device plugin 功能启动后，可以令 kubelet 开放 Register 的 gRPC 服务，device plugin 就可以通过这个服务向 kubelet 进行注册，注册成功后 device plugin 就进入了 Serving 模式，提供前面提到的 gRPC 接口调用服务，kubelet 也就可以通过调用 Listandwatch、Allocate 等方法对设备进行操作，可以用下图来描述单一节点上这一过程：  下面以 NVIDIA k8s-device-plugin 为例简单讲讲这一过程。 注册服务 先看 gRPC 注册部分，下面的函数用于启动一个 gRPC 服务器并在 kubelet 中注册 1234567891011121314151...</div></div></div></a><a class="pagination-related" href="/2025/09/14/2025-09-14-k8s%E6%8E%A7%E5%88%B6%E9%9D%A2%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/" title="k8s控制面相关学习&amp;controller&#x2F;informer生成"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-14</div><div class="info-item-2">k8s控制面相关学习&amp;controller&#x2F;informer生成</div></div><div class="info-2"><div class="info-item-1">k8s控制面相关学习&amp;controller/informer生成 informer informer:https://zhuanlan.zhihu.com/p/391465614  https://www.zhihu.com/question/463207052/answer/2377261278 (注意Informer最后也有个controller，跟这个不一样) 对于Informer而言  大步骤1: Reflector 将资源对象的事件添加进 Delta FIFO queue 中  这里先提前介绍一下 Delta FIFO queue。 所谓 Delta 就是变化的意思，什么的变化呢？就是资源对象的变化。 即 资源对象的变化都会被添加到 Delta FIFO queue 中！这样是不是就很好理解了。  大步骤2: Informer 将 Delta FIFO queue 中的对象数据 添加到本地 cache 中。  补充一下这个本地 cache 缓存的就是监听资源对象的最新版。就是缓存的当前集群里面的资源信息。  大步骤3: 使用 workqueue 处理业务逻辑。 ...</div></div></div></a><a class="pagination-related" href="/2025/09/15/2025-09-15-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87Pod%E8%BF%9B%E5%85%A5%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA%EF%BC%9F/" title="如何通过Pod进入到宿主机?"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-15</div><div class="info-item-2">如何通过Pod进入到宿主机?</div></div><div class="info-2"><div class="info-item-1">如何通过Pod进入到宿主机? nsenter -a -t 1 bash 命令的作用是让你在一个新的 shell 会话中，进入 PID 为 1 的进程所在的全部命名空间（Namespace）。 通过这种方式，可以从pod中进入到宿主机（全部的namespace都跟宿主机一样） breakdown 如下：  nsenter: 这是一个 Linux 命令行工具，用于将当前进程“进入”到指定进程的一个或多个命名空间中。 -t 1: 这个选项指定了目标进程的 PID (Process ID)。在这里，1 是 Linux 系统中第一个启动的进程（通常是 init 或 systemd）的 PID。所有其他进程都是由它或它的子进程派生出来的。 -a: 这个选项是 “all namespaces” 的缩写。它告诉 nsenter 将当前进程加入到目标进程（PID 1）所属于的所有类型的命名空间中，包括但不限于：  Mount (mnt) UTS (主机名和域名) IPC (进程间通信) Network PID (进程 ID) User ID Cgroup   bash: 这是要在新加入的命名空间环...</div></div></div></a><a class="pagination-related" href="/2025/09/15/2025-09-15-k8s-informer%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E8%AF%A6%E8%A7%A3/" title="k8s informer通俗易懂详解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-15</div><div class="info-item-2">k8s informer通俗易懂详解</div></div><div class="info-2"><div class="info-item-1">Kubernetes Informer 机制详解 核心概念 Informer 是 Kubernetes 中用于监听和缓存资源对象的核心机制，它通过 ListAndWatch 机制实现高效的资源监控。 核心组件及作用 1. Reflector（反射器）  作用：负责从 Kubernetes API Server 获取资源对象 功能：  List：获取资源的全量数据 Watch：监听资源的增量变化 将数据放入 Delta FIFO 队列    2. Delta FIFO Queue（增量队列）  作用：存储资源对象的变化（增删改） 特点：  保持操作顺序 存储对象的增量变化（Delta） 线程安全    3. Informer（通知器）  作用：从 Delta FIFO 队列中取出对象并处理 功能：  调用 Indexer 更新本地缓存 触发注册的事件处理器    4. Indexer（索引器）  作用：本地缓存，提供快速查询 功能：  存储资源对象的本地副本 提供基于索引的快速查找 线程安全的读写操作    5. Resource Event Handlers（资源事件处理器）  ...</div></div></div></a><a class="pagination-related" href="/2025/09/16/2025-09-16-sandbox%E5%92%8Ccontainer%E5%AF%B9%E6%AF%94/" title="sandbox和container对比"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-16</div><div class="info-item-2">sandbox和container对比</div></div><div class="info-2"><div class="info-item-1">sandbox和container对比 Sandbox 和 Container 的区别 基本概念 Sandbox（沙箱）  定义：一种隔离环境，用于安全地运行程序，限制其对系统资源的访问 目的：提供安全隔离，防止恶意代码影响主机系统 范围：通常针对单个应用程序或进程  Container（容器）  定义：一种轻量级虚拟化技术，将应用程序及其依赖打包在一起 目的：提供一致的运行环境，确保应用在不同环境中行为一致 范围：包含完整的应用程序运行时环境  主要区别对比    特性 Sandbox Container     主要目标 安全隔离 环境一致性   隔离级别 高（安全优先） 中等（资源隔离）   资源开销 极低 低到中等   启动速度 极快 快   包含内容 单个应用/进程 完整运行时环境    技术实现差异 Sandbox 实现方式 1234567// 浏览器沙箱示例（概念性）// 运行在受限环境中const sandboxedCode = `  // 无法访问DOM、网络、文件系统  // 只能执行安全的JavaScript代码  return 42;`; 典型技术：  浏...</div></div></div></a><a class="pagination-related" href="/2025/09/16/2025-09-16-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/" title="容器运行时扩展方案技术解析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/k8s.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-16</div><div class="info-item-2">容器运行时扩展方案技术解析</div></div><div class="info-2"><div class="info-item-1">容器运行时扩展方案技术解析 基于对某容器运行时扩展项目的代码分析，现从架构层面提炼其核心技术实现，聚焦三大核心能力：运行时接入机制、容器根文件系统云端持久化、Docker-in-Docker 安全实现方案。  1. 如何接入 Containerd 运行时生态 项目通过 Containerd Proxy Plugin 机制 实现与容器运行时的无缝集成，架构清晰、扩展性强。 ▶ 配置层接入  在 containerd 配置中注册名为 custom-snapshotter 的代理插件，通过 Unix Domain Socket 与本地 Agent 通信； 同时注册自定义 Runtime，指向特定二进制执行程序，实现容器生命周期的定制化控制。  ▶ 运行时层实现  Agent 侧：实现标准 gRPC 服务，响应来自 Containerd 的 Snapshotter 接口调用（如 Prepare、Mount、Remove）； 存储层封装：采用 Wrapper 模式封装原生 OverlayFS Snapshotter，在不破坏原有逻辑的前提下注入自定义行为（如镜像预处理、元数据记录等）； 通...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Roger-Lv</div><div class="author-info-description">Send a flare and light the way.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">177</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">150</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">49</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Roger-Lv"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Roger-Lv" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1150568956@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/zhongrenjie-lv-5588a928a/" target="_blank" title="LinkedIn"><i class="iconfont icon-linkedin-fill"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B0%E5%AF%8C%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">1.</span> <span class="toc-text">丰富的调度策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volcano-%E8%B0%83%E5%BA%A6%E5%99%A8%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E6%98%A0%E5%B0%84%E5%9B%BE"><span class="toc-number">2.</span> <span class="toc-text">Volcano 调度器核心概念映射图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%93%E8%AE%BA-%E5%9B%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">3.</span> <span class="toc-text">关键结论 (图例说明)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E6%80%BB%E7%BB%93%E5%89%8D%E7%BD%AE"><span class="toc-number"></span> <span class="toc-text">0. 总结前置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number"></span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Volcano-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number"></span> <span class="toc-text">2. Volcano 核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%AE%A4%E8%AF%86-Queue%E3%80%81PodGroup-%E5%92%8C-VolcanoJob"><span class="toc-number">1.</span> <span class="toc-text">2.1 认识 Queue、PodGroup 和 VolcanoJob</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Queue%E3%80%81PodGroup-%E5%92%8C-VolcanoJob-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.</span> <span class="toc-text">2.2. Queue、PodGroup 和 VolcanoJob 的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Volcano-%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88"><span class="toc-number"></span> <span class="toc-text">3. Volcano 调度框架概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number"></span> <span class="toc-text">4. 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Action-%E5%AE%9E%E7%8E%B0%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">4.1 Action 实现在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%BB%8E-main-%E5%87%BD%E6%95%B0%E5%85%A5%E6%89%8B%E7%9C%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">4.2 从 main 函数入手看调度器启动过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E5%85%A5%E5%8F%A3%E9%80%BB%E8%BE%91"><span class="toc-number">3.</span> <span class="toc-text">4.2.1 入口逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-NewScheduler-%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">4.2.2 NewScheduler() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-Run-%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">4.2.3 Run() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AF%BB%E6%89%BE-actions-%E5%92%8C-plugins-%E7%9A%84%E8%B0%83%E7%94%A8%E9%80%BB%E8%BE%91"><span class="toc-number">6.</span> <span class="toc-text">4.3 寻找 actions 和 plugins 的调用逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E7%90%86%E8%A7%A3-Session-%E4%BB%A5%E5%8F%8A-plugins-%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">7.</span> <span class="toc-text">4.3.1 理解 Session 以及 plugins 被调用的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E7%90%86%E8%A7%A3-actions-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="toc-number">8.</span> <span class="toc-text">4.3.2 理解 actions 的执行逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Action-%E5%88%86%E6%9E%90%EF%BC%9Aenqueue"><span class="toc-number">9.</span> <span class="toc-text">4.4 Action 分析：enqueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-queues%E3%80%81queueSet-%E5%92%8C-jobsMap"><span class="toc-number">10.</span> <span class="toc-text">4.4.1 queues、queueSet 和 jobsMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-for-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86-jobs"><span class="toc-number">11.</span> <span class="toc-text">4.4.2 for 循环遍历 jobs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF-for"><span class="toc-number">12.</span> <span class="toc-text">4.4.3 无限循环 for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Action-%E5%88%86%E6%9E%90%EF%BC%9Aallocate"><span class="toc-number">13.</span> <span class="toc-text">4.5 Action 分析：allocate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-allocate-Execute-%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91"><span class="toc-number">14.</span> <span class="toc-text">4.5.1 allocate.Execute() 整体逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E7%AC%AC%E4%B8%80%E4%B8%AA-for-%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-number">15.</span> <span class="toc-text">4.5.2 第一个 for 循环的逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-%E9%A2%84%E9%80%89%E5%87%BD%E6%95%B0-predicateFn"><span class="toc-number">16.</span> <span class="toc-text">4.5.3 预选函数 predicateFn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-4-%E7%AC%AC%E4%BA%8C%E4%B8%AA-for-%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-number">17.</span> <span class="toc-text">4.5.4 第二个 for 循环的逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-Action-%E5%88%86%E6%9E%90%EF%BC%9Abackfill"><span class="toc-number">18.</span> <span class="toc-text">4.6 Action 分析：backfill</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">5. 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%BB%93%E5%B0%BE"><span class="toc-number"></span> <span class="toc-text">6. 结尾</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/24/2025-12-24-Function-Call-%E7%9A%84%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D%E8%A6%81%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E6%98%AF%E6%9C%80%E9%9A%BE%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%9F/" title="Function Call 的多轮对话要怎么处理？为什么它是最难的部分？"><div style="background: /img/cover/langgraph.jepg"></div></a><div class="content"><a class="title" href="/2025/12/24/2025-12-24-Function-Call-%E7%9A%84%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D%E8%A6%81%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E6%98%AF%E6%9C%80%E9%9A%BE%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%9F/" title="Function Call 的多轮对话要怎么处理？为什么它是最难的部分？">Function Call 的多轮对话要怎么处理？为什么它是最难的部分？</a><time datetime="2025-12-23T16:00:00.000Z" title="发表于 2025-12-24 00:00:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/24/2025-12-24-RL-for-LLM-%E9%AB%98%E8%B4%A8%E9%87%8F%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/" title="RL for LLM 高质量文章汇总"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/RL.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RL for LLM 高质量文章汇总"/></a><div class="content"><a class="title" href="/2025/12/24/2025-12-24-RL-for-LLM-%E9%AB%98%E8%B4%A8%E9%87%8F%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/" title="RL for LLM 高质量文章汇总">RL for LLM 高质量文章汇总</a><time datetime="2025-12-23T16:00:00.000Z" title="发表于 2025-12-24 00:00:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/23/2025-12-23-Anthropic-skils%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%AE%9E%E8%B7%B5/" title="Anthropic skils解读与实践"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/SKILL.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Anthropic skils解读与实践"/></a><div class="content"><a class="title" href="/2025/12/23/2025-12-23-Anthropic-skils%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%AE%9E%E8%B7%B5/" title="Anthropic skils解读与实践">Anthropic skils解读与实践</a><time datetime="2025-12-22T16:00:00.000Z" title="发表于 2025-12-23 00:00:00">2025-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/2025-12-22-LLM%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF%EF%BC%9AMC-TD-Q-Learning-DQN-PG-AC-TRPO-PPO-DPO-GRPO/" title="LLM强化学习算法演进之路：MC-&gt;TD-&gt;Q-Learning-&gt;DQN-&gt;PG-&gt;AC-&gt;TRPO-&gt;PPO-&gt;DPO-&gt;GRPO"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/pytorch.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LLM强化学习算法演进之路：MC-&gt;TD-&gt;Q-Learning-&gt;DQN-&gt;PG-&gt;AC-&gt;TRPO-&gt;PPO-&gt;DPO-&gt;GRPO"/></a><div class="content"><a class="title" href="/2025/12/22/2025-12-22-LLM%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF%EF%BC%9AMC-TD-Q-Learning-DQN-PG-AC-TRPO-PPO-DPO-GRPO/" title="LLM强化学习算法演进之路：MC-&gt;TD-&gt;Q-Learning-&gt;DQN-&gt;PG-&gt;AC-&gt;TRPO-&gt;PPO-&gt;DPO-&gt;GRPO">LLM强化学习算法演进之路：MC-&gt;TD-&gt;Q-Learning-&gt;DQN-&gt;PG-&gt;AC-&gt;TRPO-&gt;PPO-&gt;DPO-&gt;GRPO</a><time datetime="2025-12-21T16:00:00.000Z" title="发表于 2025-12-22 00:00:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/19/2025-12-19-pytorch%E5%AD%A6%E4%B9%A0/" title="pytorch学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/pytorch.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pytorch学习"/></a><div class="content"><a class="title" href="/2025/12/19/2025-12-19-pytorch%E5%AD%A6%E4%B9%A0/" title="pytorch学习">pytorch学习</a><time datetime="2025-12-18T16:00:00.000Z" title="发表于 2025-12-19 00:00:00">2025-12-19</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2024 - 2025 By Roger-Lv</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.2"></script><script src="/js/main.js?v=5.4.2"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.8.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'smA3tZdRGodG2VgnMubBQjLm-gzGzoHsz',
      appKey: 'biCDxj0lSBtZTMie2kNIKErd',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.3/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><div class="aplayer no-destroy" data-id="8674547170" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.4.2"></script></div></div></body></html>