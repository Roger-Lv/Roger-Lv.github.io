<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Agent八股 | Roger-Lv's space</title><meta name="author" content="Roger-Lv"><meta name="copyright" content="Roger-Lv"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Agent八股 模板1 八股：Encoder与decoder的中Attention区别？ 答案：https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;26252050300 https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;588325646&#x2F;answer&#x2F;1981416261771604279 八股：Attention如何计算？为什么除以根号下Dk？mask attention是">
<meta property="og:type" content="article">
<meta property="og:title" content="Agent八股">
<meta property="og:url" content="http://example.com/2025/12/17/2025-12-17-Agent%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="Roger-Lv&#39;s space">
<meta property="og:description" content="Agent八股 模板1 八股：Encoder与decoder的中Attention区别？ 答案：https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;26252050300 https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;588325646&#x2F;answer&#x2F;1981416261771604279 八股：Attention如何计算？为什么除以根号下Dk？mask attention是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2025-12-16T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-23T09:19:40.682Z">
<meta property="article:author" content="Roger-Lv">
<meta property="article:tag" content="agent">
<meta property="article:tag" content="多模态">
<meta property="article:tag" content="llm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Agent八股",
  "url": "http://example.com/2025/12/17/2025-12-17-Agent%E5%85%AB%E8%82%A1/",
  "image": "http://example.com/img/avatar.jpg",
  "datePublished": "2025-12-16T16:00:00.000Z",
  "dateModified": "2025-12-23T09:19:40.682Z",
  "author": [
    {
      "@type": "Person",
      "name": "Roger-Lv",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://example.com/2025/12/17/2025-12-17-Agent%E5%85%AB%E8%82%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.4.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Agent八股',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">177</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">150</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">49</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Roger-Lv's space</span></a><a class="nav-page-title" href="/"><span class="site-name">Agent八股</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div><!-- 添加搜索按钮 ↓--><span class="search-button"><i class="fas fa-search" aria-hidden="true"></i></span></div></nav><div id="post-info"><h1 class="post-title">Agent八股</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-16T16:00:00.000Z" title="发表于 2025-12-17 00:00:00">2025-12-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-23T09:19:40.682Z" title="更新于 2025-12-23 17:19:40">2025-12-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/agent/">agent</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2025/12/17/2025-12-17-Agent%E5%85%AB%E8%82%A1/" data-flag-title="Agent八股"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>Agent八股</h1>
<h2 id="模板1">模板1</h2>
<h3 id="八股：Encoder与decoder的中Attention区别？">八股：Encoder与decoder的中Attention区别？</h3>
<p>答案：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26252050300">https://zhuanlan.zhihu.com/p/26252050300</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/588325646/answer/1981416261771604279">https://www.zhihu.com/question/588325646/answer/1981416261771604279</a></p>
<h3 id="八股：Attention如何计算？为什么除以根号下Dk？mask-attention是如何实现的？">八股：Attention如何计算？为什么除以根号下Dk？mask attention是如何实现的？</h3>
<p>你的问题涉及 <strong>Transformer 模型中 Attention 机制</strong>的三个关键点：</p>
<ol>
<li><strong>Attention 的计算方式</strong></li>
<li><strong>为什么除以 (\sqrt{d_k})</strong></li>
<li><strong>Masked Attention 的实现方式</strong></li>
</ol>
<p>下面逐一解释：</p>
<hr>
<ol>
<li>Attention 如何计算？（以 Scaled Dot-Product Attention 为例）</li>
</ol>
<p>标准的 <strong>Scaled Dot-Product Attention</strong> 公式如下：</p>
\[
\text{Attention}(Q, K, V) = \text{softmax}\left( \frac{QK^T}{\sqrt{d_k}} \right) V
\]

<p>其中：</p>
<ul>
<li>
\(Q \in \mathbb{R}^{n \times d_k}\)

<p>：查询（Query）矩阵</p>
</li>
<li>
\(K \in \mathbb{R}^{m \times d_k}\)

<p>：键（Key）矩阵</p>
</li>
<li>
\(V \in \mathbb{R}^{m \times d_v}\)

<p>：值（Value）矩阵</p>
</li>
<li>
\(d_k\)

<p>：Key 的维度（也等于 Query 的维度）</p>
</li>
</ul>
<p>计算步骤：</p>
<ol>
<li>计算点积 (<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">QK^T
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0858em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p>
)，得到一个 (<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span></p>
) 的相似度矩阵。</li>
<li>除以\(\sqrt{d_k}\)

（缩放，见下文解释）。</li>
<li>对每一行进行 softmax，得到注意力权重。</li>
<li>用权重对 (V) 加权求和，得到输出。</li>
</ol>
<hr>
<ol start="2">
<li>为什么除以 (\sqrt{d_k})？</li>
</ol>
<p>这是为了 <strong>缓解点积过大导致 softmax 梯度消失的问题</strong>。</p>
<ul>
<li>假设 (q) 和 (k) 的每个元素是均值为 0、方差为 1 的独立随机变量。</li>
<li>那么点积\(q \cdot k = \sum_{i=1}^{d_k} q_i k_i\)

的期望为 0，**方差为 **\(d_k\)

。</li>
<li>当 (d_k) 较大时（如 64、512），点积的值会很大，使得 softmax 的输入进入其极值区域（趋于 0 或 1）。</li>
<li>这会导致梯度非常小（softmax 饱和），训练困难。</li>
</ul>
<p><strong>解决方法</strong>：将点积结果除以</p>
\(\sqrt{d_k}\)

<p>，使得其方差回到 1，从而保持 softmax 的输入在合理范围内，梯度更稳定。</p>
<blockquote>
<p>这就是 “Scaled” 的由来：<strong>Scaled Dot-Product Attention</strong>。</p>
</blockquote>
<hr>
<ol start="3">
<li>Masked Attention 是如何实现的？</li>
</ol>
<p><strong>Masked Attention</strong> 主要用于 <strong>自回归模型</strong>（如 GPT、Decoder-only Transformer），防止当前位置“看到”未来信息。</p>
<p>实现方式：</p>
<p>在 softmax 之前，将未来位置的 attention score 设为 <strong>负无穷（(-\infty)）</strong>，这样 softmax 后对应的权重为 0。</p>
<p>具体步骤：</p>
<ol>
<li>
<p>计算</p>
\(QK^T / \sqrt{d_k}\)

<p>，得到 attention scores 矩阵 (A)。</p>
</li>
<li>
<p>构造一个 <strong>上三角 mask</strong>（未来位置为 True），例如对长度为 4 的序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mask = [[0, 1, 1, 1],</span><br><span class="line">        [0, 0, 1, 1],</span><br><span class="line">        [0, 0, 0, 1],</span><br><span class="line">        [0, 0, 0, 0]]</span><br></pre></td></tr></table></figure>
<p>实际代码中常用 <strong>布尔 mask</strong> 或 <strong>加性 mask</strong>。</p>
</li>
<li>
<p>将 mask 位置的 score 替换为一个极大负数（如 <code>-1e9</code>）：</p>
\[
A_{\text{masked}} = A + \text{mask} \times (-\infty)
\]

</li>
<li>
<p>再对</p>
\(A_{\text{masked}}\)

<p>做 softmax。</p>
</li>
</ol>
<p>代码示例（PyTorch）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attn_scores = torch.matmul(Q, K.transpose(-<span class="number">2</span>, -<span class="number">1</span>)) / math.sqrt(d_k)</span><br><span class="line">mask = torch.triu(torch.ones(seq_len, seq_len), diagonal=<span class="number">1</span>).<span class="built_in">bool</span>()  <span class="comment"># 上三角为True</span></span><br><span class="line">attn_scores = attn_scores.masked_fill(mask, <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>))</span><br><span class="line">attn_weights = torch.softmax(attn_scores, dim=-<span class="number">1</span>)</span><br><span class="line">output = torch.matmul(attn_weights, V)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 Encoder 中通常 <strong>不加 mask</strong>（因为可以看整个输入）；<br>
在 Decoder 的 self-attention 中 <strong>必须加 mask</strong>（防止信息泄露）。</p>
</blockquote>
<hr>
<p>总结</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody>
<tr>
<td>Attention 计算</td>
<td>(\text{softmax}(QK^T / \sqrt{d_k}) V)</td>
</tr>
<tr>
<td>除以 (\sqrt{d_k}) 原因</td>
<td>控制点积方差，防止 softmax 梯度消失</td>
</tr>
<tr>
<td>Masked Attention</td>
<td>用 mask 将未来位置 score 设为 (-\infty)，再 softmax</td>
</tr>
</tbody>
</table>
<p>如果你对 Multi-Head Attention、Cross-Attention 或具体代码实现感兴趣，也可以继续问！</p>
<h3 id="八股：除了MHA还知道哪些-GQA-MQA-MLA-讲原理">八股：除了MHA还知道哪些(GQA MQA MLA)讲原理</h3>
<p>除了经典的 <strong>MHA（Multi-Head Attention）</strong>，近年来为了在<strong>推理效率、显存占用和模型性能</strong>之间取得更好平衡，研究者提出了多种改进型注意力机制，主要包括：</p>
<ul>
<li><strong>MQA（Multi-Query Attention）</strong></li>
<li><strong>GQA（Grouped-Query Attention）</strong></li>
<li><strong>MLA（Multi-Layer Attention / Memory-efficient Latent Attention）</strong></li>
</ul>
<p>下面分别讲解它们的核心原理和区别：</p>
<hr>
<ol>
<li>MHA（Multi-Head Attention）——基准</li>
</ol>
<ul>
<li><strong>原理</strong>：将 Query、Key、Value 分别用 (h) 个不同的线性投影头（heads）映射。</li>
<li>每个头独立计算注意力，最后拼接或加权融合。</li>
<li><strong>特点</strong>：
<ul>
<li>(h) 个 Q、K、V（例如 32 头 → 32 个 K/V）</li>
<li>表达能力强，但 KV Cache 显存开销大（每个 token 存 (h) 份 K 和 V）</li>
</ul>
</li>
</ul>
<hr>
<ol start="2">
<li>MQA（Multi-Query Attention）——极致压缩 KV</li>
</ol>
<ul>
<li><strong>原理</strong>：<strong>所有 attention head 共享同一组 Key 和 Value</strong>，但每个 head 有自己的 Query。
<ul>
<li>即：(h) 个 Q，但只有 <strong>1 个 K 和 1 个 V</strong></li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li><strong>KV Cache 大幅减少</strong>（从 (h) 份 → 1 份）</li>
<li>推理速度更快，显存占用更低</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>模型表达能力下降，可能导致生成质量略降（尤其在小模型上）</li>
</ul>
</li>
<li><strong>应用场景</strong>：推理效率优先的场景（如早期的 <strong>StarCoder</strong> 使用了 MQA）</li>
</ul>
<hr>
<ol start="3">
<li>GQA（Grouped-Query Attention）——MHA 与 MQA 的折中</li>
</ol>
<ul>
<li><strong>原理</strong>：将 (h) 个 Query heads <strong>分组</strong>（比如 8 组），<strong>每组共享一个 K/V head</strong>。
<ul>
<li>例如：32 个 Q heads → 分成 8 组 → 每组 4 个 Q 共享 1 个 K/V → 总共 8 个 K/V</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li>相比 MHA：<strong>显著减少 KV Cache</strong>（从 32 份 → 8 份）</li>
<li>相比 MQA：<strong>保留更多表达能力</strong>，性能损失更小</li>
</ul>
</li>
<li><strong>实际应用</strong>：
<ul>
<li><strong>Llama-2 / Llama-3</strong> 的 70B 模型使用了 GQA（32 Q heads, 8 KV heads）</li>
<li>被证明可以在几乎不损失效果的前提下提升推理吞吐</li>
</ul>
</li>
</ul>
<blockquote>
<p>GQA 被认为是 <strong>MHA 和 MQA 之间的最佳平衡点</strong> 。</p>
</blockquote>
<hr>
<ol start="4">
<li>MLA（Multi-Layer Attention / Memory-efficient Latent Attention）</li>
</ol>
<blockquote>
<p>⚠️ 注意：MLA 有两种不同含义，此处指 <strong>Gemini 系列模型中提出的高效注意力机制</strong>（不是“多层注意力”字面意思）。</p>
</blockquote>
<ul>
<li><strong>原理</strong>（以 Google Gemini 的 MLA 为例）：
<ul>
<li>不直接缓存原始 K/V，而是将 K/V <strong>压缩到一个低维共享的“潜在记忆”（latent memory）</strong> 中。</li>
<li>推理时通过这个共享 latent 来重建近似的 K/V。</li>
<li>本质是一种 <strong>KV 压缩+共享</strong> 技术。</li>
</ul>
</li>
<li><strong>优点</strong>：
<ul>
<li><strong>KV Cache 体积极小</strong>（比 GQA 还小）</li>
<li>更适合长上下文、高并发推理</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>实现复杂，需额外训练或微调</li>
<li>可能引入重建误差</li>
</ul>
</li>
<li><strong>应用</strong>：Google <strong>Gemini 1.5 / 2.0</strong> 使用了 MLA 来支持百万 token 上下文 。</li>
</ul>
<hr>
<p>对比总结表</p>
<table>
<thead>
<tr>
<th>机制</th>
<th>Q heads</th>
<th>K/V heads</th>
<th>KV Cache 量</th>
<th>表达能力</th>
<th>典型应用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>MHA</strong></td>
<td>(h)</td>
<td>(h)</td>
<td>高（(h) 份）</td>
<td>最强</td>
<td>Transformer 原始设计</td>
</tr>
<tr>
<td><strong>MQA</strong></td>
<td>(h)</td>
<td>1</td>
<td>极低（1 份）</td>
<td>较弱</td>
<td>StarCoder</td>
</tr>
<tr>
<td><strong>GQA</strong></td>
<td>(h)</td>
<td>(g)（(1 &lt; g &lt; h)）</td>
<td>中（(g) 份）</td>
<td>接近 MHA</td>
<td>Llama-2/3 70B</td>
</tr>
<tr>
<td><strong>MLA</strong></td>
<td>(h)</td>
<td>隐式共享（latent）</td>
<td>极低</td>
<td>依赖压缩质量</td>
<td>Gemini 1.5/2.0</td>
</tr>
</tbody>
</table>
<hr>
<p>为什么这些改进重要？</p>
<ul>
<li>在 <strong>大模型推理</strong> 中，<strong>KV Cache 占用显存最多</strong>（尤其长文本）。</li>
<li>MHA 的 KV Cache 与 <strong>head 数 × token 数 × dim</strong> 成正比，成为瓶颈。</li>
<li>MQA/GQA/MLA 通过 <strong>减少或压缩 K/V 的存储</strong>，<strong>提升吞吐、降低延迟、支持更长上下文</strong>，同时尽量保持模型能力 。</li>
</ul>
<hr>
<p>如需进一步了解某一种机制的数学公式或代码实现，也可以告诉我！</p>
<h3 id="八股：为什么要用位置编码？为什么要用sin-cos？">八股：为什么要用位置编码？为什么要用sin_cos？</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/454482273">https://zhuanlan.zhihu.com/p/454482273</a></p>
<p>之所以要sin cos交替，想要位置向量也可以表示相对位置，想象一个旋转的角度，△t，就也可以进行线性变化（矩阵乘）</p>
<h3 id="八股：你提到用DeepSpeed做SFT训练，请讲一下DeepSpeed-ZeRO-Stage-1-3的区别，以及什么时候用FSDP会更好？">八股：你提到用DeepSpeed做SFT训练，请讲一下DeepSpeed ZeRO Stage 1-3的区别，以及什么时候用FSDP会更好？</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/694880795">https://zhuanlan.zhihu.com/p/694880795</a></p>
<p>显存占用分析：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/694880795">https://zhuanlan.zhihu.com/p/694880795</a></p>
<p>fp16 fp32</p>
<p>参数/梯度/优化器/激活值对于显存的占用</p>
<p>混合精度训练：权重采用fp16存储，反向传播更新，<strong>优化器会维持fp32模型权重</strong>和fp32优化器参数的副本，因为使用32位更准确</p>
<p>优化器状态：使用adamW优化器，fp32模型权重，fp32的梯度移动平均值和梯度平方移动平均值，fp16的梯度</p>
<p>简单计算，fp16模型需要的显存是其参数量的八倍</p>
<p>1.模型参数：</p>
<p>–fp16存储，2 bytes *7 B =14GB.</p>
<p>2.梯度：</p>
<p>–fp16存储，2 bytes *7 B =14GB.</p>
<p>3.激活值:</p>
<p>–和batch_size和序列长度有关。</p>
<p>4.优化器状态：</p>
<p>– <em>fp32 模型参数: 4 bytes * 7B = 28GB</em></p>
<p><em>–fp32</em> 梯度的移动平均值*(m): 4 bytes * 7B = 28GB*</p>
<p><em>–fp32</em> 梯度平方的移动平均值*(v): 4 bytes * 7B = 28GB*</p>
<p>zero1: 切分优化器状态。</p>
<ol>
<li>优化器状态是主要的内存占用者。zero1的思路是将这些优化器状态分布到多个GPU上</li>
<li>这样增加了GPU通信，但降低了显存占用</li>
<li>减少4倍显存，保持通信量与dp相同</li>
</ol>
<p>zero2: 切分梯度</p>
<ol>
<li>再次将内存需求减少了一半，总体减少了8倍</li>
<li>仍保持与标准dp相同的通信水平</li>
</ol>
<p>zero3:切分模型参数</p>
<ol>
<li>减少显存占用与gpu数量成正比</li>
<li>增加了50%通讯量？</li>
<li>它的“分割”对象并非模型计算图本身，而是<strong>训练状态</strong>（参数、梯度、优化器状态）。它将这些状态切片，均匀地分发到所有 GPU 上。（动态聚合机制）</li>
</ol>
<p>这类特别说一下deepspeed的zero3的切分模型参数后是怎么计算的：</p>
<p>假设我们有 4 个 GPU (GPU 0, 1, 2, 3)，并且需要计算网络中的 <code>Layer L</code>。</p>
<ul>
<li><strong>第 1 步：计算前的分区状态</strong> 在计算开始前，<code>Layer L</code> 的权重参数 <code>W_L</code> 被切分成了 4 片 (<code>P_0</code>, <code>P_1</code>, <code>P_2</code>, <code>P_3</code>)，分别存储在 4 个 GPU 的显存中。此时，没有任何一个 GPU 能独立开始计算。</li>
<li><strong>第 2 步：计算时的动态聚合 (<code>All-Gather</code>)</strong> 当计算流程到达 <code>Layer L</code> 时，ZeRO-3 触发一次 <code>All-Gather</code> 通信操作。每个 GPU 将自己持有的那一分片参数发送给所有其他 GPU，并同时接收其他所有 GPU 发来的分片。操作完成后：每个 GPU 都在自己的显存里临时拼凑出了一份完全相同的、完整的 <code>Layer L</code> 的参数 <code>W_L</code>。</li>
<li><strong>第 3 步：执行标准的层计算</strong> 现在，每个 GPU 都手握完整的 <code>Layer L</code> 参数，于是它们可以像标准数据并行一样，用<strong>各自的数据分片</strong>和<strong>这份完整的参数</strong>，独立地完成 <code>Layer L</code> 的前向传播计算。</li>
<li><strong>第 4 步：计算后立即释放</strong> 一旦 <code>Layer L</code> 的计算完成，每个 GPU 会<strong>立刻丢弃</strong>刚刚组装起来的完整参数，只保留自己最初负责的那一分片。显存被瞬间释放，为下一层的计算做好了准备。</li>
</ul>
<blockquote>
<p><strong>这里必须强调一个最关键、也最容易被误解的核心要点：ZeRO-3 的 All-Gather 不是一次性聚合整个模型，而是逐层（Layer-by-Layer）进行的。</strong> 它对显存的峰值需求，取决于<strong>模型中最大的那一层的参数大小</strong>，而不是整个模型的总大小。正是这种精细化的、“即用即弃”的逐层管理，才使得 ZeRO-3 能够以数据并行的方式，训练远超单卡显存容量的巨型模型。</p>
</blockquote>
<p>它的“模型分割”实际上是**“训练状态分割”**。它在计算的瞬间，通过通信换取空间，让每个 GPU 能“看到”完整的层参数来执行标准计算。它对模型代码的侵入性很低，但要求单卡至少能容纳下模型最大层带来的瞬时显存开销。</p>
<p>deepspeed没有原生tp，用的还是megatron的。</p>
<p>megatron就是列切，行切</p>
<h3 id="项目：问Agent的工具tool的设计，是否是workflow形式">项目：问Agent的工具tool的设计，是否是workflow形式</h3>
<p>不完全是，一方面有规则，一方面有agentic的成分</p>
<h3 id="项目：了解哪些agent开发框架，例如langchain和LlamaIndex，他们核心应用场景有何不同">项目：了解哪些agent开发框架，例如langchain和LlamaIndex，他们核心应用场景有何不同</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1933162022566106990">https://zhuanlan.zhihu.com/p/1933162022566106990</a></p>
<p>前面就是用来造智能体的框架，提供工具、message、state、graph（1.0）, memory</p>
<p>后者则是增强rag能力的，比如有的库就是导入向量库，有的是能够用来自动构建知识图谱的</p>
<h3 id="项目：问数据的输入输出格式如何保证大模型输出稳定的json做了哪些工作">项目：问数据的输入输出格式如何保证大模型输出稳定的json做了哪些工作</h3>
<h3 id="智力题：有12个外观相同的芯片、其中一个重量不同-不知轻重-，用天平最少称几次能找出这张芯片？">智力题：有12个外观相同的芯片、其中一个重量不同(不知轻重)，用天平最少称几次能找出这张芯片？</h3>
<h3 id="代码题：lc215-数组中的第K个最大元素">代码题：lc215 数组中的第K个最大元素</h3>
<h2 id="模板2">模板2</h2>
<h3 id="1-介绍RAG项目">1. 介绍RAG项目</h3>
<h3 id="2-怎么解决LLM幻觉问题">2.怎么解决LLM幻觉问题</h3>
<p>分阶段来回答：</p>
<p>数据处理阶段：</p>
<ol>
<li><strong>数据质量和多样性</strong>：选择高质量、多样性和平衡的数据集进行训练。这包括从多个来源收集数据，以及确保数据覆盖了各种主题和领域</li>
<li><strong>数据清洗</strong>：在训练模型之前，对数据进行清洗和预处理，以去除错误、偏见和不相关的信息</li>
<li><strong>数据标注</strong>：对数据进行标注，以提供关于信息真实性的额外信息。例如，可以标注数据中的事实是否正确，或者是否包含误导性的信息</li>
</ol>
<p>训练阶段：</p>
<ol>
<li><strong>模型微调</strong>：在特定任务或数据集上进一步训练模型，以改善模型在特定上下文中的表现</li>
<li><strong>模型结构和参数选择</strong>：选择或设计适合任务的模型结构，并调整模型的参数，以优化模型的性能</li>
<li><strong>模型集成</strong>：训练多个模型，并结合它们的输出，以提高输出的真实性</li>
<li><strong>有限状态约束 FST</strong>：使用约束解码，将输入的 FSA x 与一个特殊的 FST T 进行合成，用于编码所有可能的分段决策，并将其投影到输出带中，以获得输出空间的确定性有限状态自动机</li>
</ol>
<p>后处理阶段：</p>
<ol>
<li><strong>后处理和过滤</strong>：在模型生成输出后，使用各种策略来过滤或修改输出，以提高其真实性</li>
<li><strong>模型解释和可视化</strong>：理解模型的决策过程，以帮助识别可能的问题并改进模型</li>
<li><strong>用户反馈</strong>：收集用户对模型输出的反馈，并使用这些反馈来改进模型</li>
<li><strong>Levenshtein 事后对齐算法</strong>：我们使用它将生成的字符串与参考字符串进行对齐，在 LLM 没有精确重新创建输入时，可以消除一些不流畅的文本</li>
<li><strong>Web 检索确认</strong></li>
<li>引入外部知识库</li>
</ol>
<h3 id="3-LLM的参数介绍（temp-topk-top-p等）">3.LLM的参数介绍（temp topk top p等）</h3>
<p>logits/temp，温度越大各个位置的概率就越均衡</p>
<h3 id="4-LLaMA和GLM的区别，模型架构等方面">4.LLaMA和GLM的区别，模型架构等方面</h3>
<p>一篇跟大模型架构对比相关的文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1953492025719644723">https://zhuanlan.zhihu.com/p/1953492025719644723</a></p>
<h4 id="DeepSeek-v3-r1">DeepSeek v3/r1:</h4>
<ol>
<li>
<p>MLA（多头潜在注意力）</p>
<ol>
<li>MHA-&gt;GQA-&gt;MLA</li>
<li>MLA提供了一种不同的内存节省策略，与kv cache配合的比较好</li>
<li>MLA不像GQA那样共享键值头，而是将kv tensor压缩到低维空间，然后将它们存储在kv cache中。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/v2-f2c8830e57e890a3cbe4fa02675752d7_1440w.jpg" alt="img"></li>
<li><strong>MLA 是一个巧妙的技巧，可以减少 KV 缓存内存的使用，同时在建模性能方面甚至略胜于 MHA。</strong></li>
</ol>
</li>
<li>
<p>混合专家moe</p>
<ol>
<li>
<p><strong>用多个专家层替换 Transformer 模块中的每个前馈模块，其中每个专家层本身也是一个前馈模块</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic3.zhimg.com/v2-f80ceb4abce1f582d75caa230851fd48_1440w.jpg" alt="img"></p>
</li>
<li>
<p>关键在于我们不会为每个 token 使用（“激活”）所有专家。相反，路由器只会为每个 token 选择一小部分专家。</p>
</li>
<li>
<p>由于每次只有少数专家处于活跃状态，因此 MoE 模块通常被称为稀疏模块，这与始终使用完整参数集的密集模块形成对比。然而，通过 MoE 获得的大量参数增加了 LLM 的容量，这意味着它可以在训练期间吸收更多知识。然而，稀疏性保持了推理的高效性，因为我们不会同时使用所有参数。</p>
</li>
<li>
<p>例如，DeepSeek-V3 每个 MoE 模块有 256 位专家，总共 6710 亿个参数。然而，在推理过程中，每次只有 9 位专家处于活动状态（1 位共享专家加上 8 位由路由器选择的专家）。这意味着每个推理步骤仅使用 370 亿个参数，而不是全部 6710 亿个参数。</p>
<p><strong>DeepSeek-V3 的 MoE 设计的一个显著特点是使用了一个共享专家</strong>。这是一个始终对每个 token 保持活跃的专家。这个想法并不新鲜，早在DeepSeek 2024 MoE[<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1953492025719644723#ref_3">3]</a>和2022 DeepSpeedMoE[<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1953492025719644723#ref_4">4]</a>论文中就已提出。</p>
</li>
<li>
<p>DeepSpeedMoE 论文首次提出了共享专家的优势，他们发现与没有共享专家相比，共享专家可以提升整体建模性能。这可能是因为多个专家无需学习常见或重复的模式，从而为它们提供了更多学习更专业模式的空间。</p>
</li>
</ol>
</li>
</ol>
<h4 id="Qwen3">Qwen3</h4>
<p>moe</p>
<p>Qwen3 也有两种 MoE 版本：30B-A3B 和 235B-A22B。为什么有些架构（例如 Qwen3）会同时提供常规（密集）和 MoE（稀疏）版本？</p>
<p>正如本文开头所述，MoE 变体有助于降低大型基础模型的推理成本。同时提供密集模型和 MoE 版本，让用户能够根据自己的目标和约束条件灵活地进行推理。</p>
<p><strong>密集模型通常更容易在各种硬件上进行微调、部署和优化。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.zhimg.com/v2-5c137aa067787d1cfc74418cf9cce94c_1440w.jpg" alt="img"></p>
<p>如上图所示，DeepSeek-V3 和 Qwen3 235B-A22B 架构非常相似。值得注意的是，Qwen3 模型不再使用共享专家（早期的 Qwen 模型，例如Qwen2.5-MoE，确实使用了共享专家）。</p>
<p>遗憾的是，Qwen3 团队并未透露放弃共享专家的任何原因。如果非要我猜的话，可能是因为在他们将专家数量从2个（Qwen2.5-MoE中的设置）增加到8个（Qwen3中的设置）时，对于他们那个训练架构的稳定性来说，并没有这个必要。然后，他们通过只使用8个专家而不是8+1个专家，节省了额外的计算和内存开销。（不过，这并不能解释为什么DeepSeek-V3仍然保留了它的共享专家。）</p>
<p>Qwen3的开发者之一Junyang Lin对此做出了如下回应：</p>
<blockquote>
<p>当时，我们并没有发现共享专家有足够显著的改进，我们担心共享专家会导致推理优化问题。说实话，这个问题没有直接的答案。</p>
</blockquote>
<h4 id="Kimi-K2">Kimi K2</h4>
<p>它使用了相对较新的Muon优化器的一个变体来替代 AdamW。据我所知，这是 Muon 首次用于这种规模的生产模型，而非 AdamW（此前，它仅被证明可以扩展到 16B）。这带来了非常漂亮的训练损失曲线，这可能有助于该模型跃居上述基准测试的榜首。</p>
<p>该模型本身有 1 万亿个参数，这确实令人印象深刻。</p>
<p>它也完成了一个循环，因为 Kimi 2 使用了我们在本文开头介绍过的 DeepSeek-V3 架构，只不过他们把它做得更大了，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/v2-2d3ced3d46518ae2033a4410e03c4add_1440w.jpg" alt="img"></p>
<p>384个专家</p>
<h4 id="Grok2-5">Grok2.5</h4>
<p>Grok 2.5 使用少量大型专家（8 个），这反映了一种较旧的趋势。如前所述，较新的设计（例如 DeepSeekMoE 论文中的设计）倾向于使用更多小型专家（Qwen3 中也存在这种情况）。</p>
<p>另一个有趣的选择是使用相当于共享专家的功能。图 32 左侧显示的附加 SwiGLU 模块充当始终在线的共享专家。它与经典的共享专家设计并不完全相同，因为它的中间维度加倍了，但思路是一样的。（我仍然觉得 Qwen3 省略了共享专家这一点很有意思，看看 Qwen4 及后续型号是否会有变化也值得关注。）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/v2-13e18f296bfbbf3165c00ac2f3631a15_1440w.jpg" alt="img"></p>
<h3 id="5-Qwen模型每个版本之间的改进点">5.Qwen模型每个版本之间的改进点</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1902064402053695444">https://zhuanlan.zhihu.com/p/1902064402053695444</a></p>
<p>Qwen 的发展主要体现在以下几点：</p>
<ul>
<li>
<p><strong>模型规模从小到大</strong>：主要体现在：</p>
<ul>
<li>预训练数据集越来越大，从<strong>3万亿</strong>token，逐步发展到2.5版本的 <strong>18万亿</strong>，3.0版本还没公布多少万亿，总之是更多了；</li>
<li>模型参数规模：最早就是主打<strong>7B</strong>，现在就不仅仅是7B了，还包括了 <strong>235B</strong>参数；并在2.5版本开始着手验证scaling law。</li>
<li>对齐阶段SFT的数据量，最早30万条，现在也已经上百万条了。</li>
</ul>
</li>
<li></li>
<li>
<p><strong>不断考虑训练推理效率</strong>：</p>
<ul>
<li>像初代版本还用的是dense FFL，此后就演变成了 <strong>MoE</strong>模型，加快了训练和推理效率；</li>
<li>注意力机制计算也采用了 <strong>GQA</strong>技术，减少计算量；</li>
<li>扩展上下文长度也新增了 <strong>DCA</strong> 和 <strong>Yarn</strong>，总之不是蛮力扩展上下文长度，而是采用了技巧，目的也是为了节省计算资源。</li>
<li>对齐阶段，PPO 也被改成了 <strong>DPO</strong>，同样是省去了复杂的强化模型训练框架。</li>
<li>推理阶段给出了 <strong>AWQ</strong> 量化策略，同样是为了保证效果的同时，兼顾效率。</li>
</ul>
</li>
<li>
<p><strong>向数学、编程发展</strong>：众所周知，数学和编程这两样对于语言模型来说，比较难，是不少公司发力研发的目标。</p>
<ul>
<li>数据组织大幅提高数学、编程的数据占比。</li>
<li>为了控制数学、编程输出结果的稳定性、确定性，在对齐阶段也采用了offline和 online 两种方式。</li>
<li><strong>诟病</strong>：数学和编程能力确实在2.5、3.0版本中有提升，但大量用户反馈，在写报告、回答常识问题、复述一些用户问话、处理简单日常任务能力上，返回幻觉频发，参数量增加了，但效果更差了。这种情况也不是Qwen 一家如此。似乎数学和编程这类问题和日常常识问答存在一些思维方式上的矛盾。</li>
</ul>
</li>
<li>
<p><strong>深度思考</strong>：深度思考现在几乎每家模型都需要接入了，因为这个过程必不可少：</p>
<ul>
<li>深度思考其实是 decoder-only 模型弥补相对于 encoder-decoder 模型不足的一种补充；</li>
<li>深度思考也是解决复杂问题，包括编程、数学、agent 等必不可少的一关；</li>
<li>深度思考是语言表示思维的必经步骤。</li>
</ul>
</li>
</ul>
<h3 id="6-介绍检索做的优化，具体追问子问题分解怎么做，有没有做意图识别">6.介绍检索做的优化，具体追问子问题分解怎么做，有没有做意图识别</h3>
<h3 id="7-RAG怎么评估，指标有哪些">7.RAG怎么评估，指标有哪些</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/717985736">https://zhuanlan.zhihu.com/p/717985736</a></p>
<p>precision@k</p>
<p>recall@k</p>
<p>上面这些就是可以完全计算、量化的，还有一些nlp的指标 BLEU ROUGE等</p>
<p>参考ragas中的一些评估指标</p>
<p>correctness 相关性 helpfulness 等，llm as judge</p>
<h3 id="8-RAG如果有噪声怎么办">8.RAG如果有噪声怎么办</h3>
<p>有办法可以减少，多阶段：</p>
<p><strong>文档预处理降噪</strong></p>
<ul>
<li><strong>格式统一化</strong>：将PDF、Word等多格式文档转换为Markdown格式，便于统一处理</li>
<li><strong>结构化过滤</strong>：删除OCR识别的无效图表描述、无意义数字（如&quot;0/1&quot;转换为文字）</li>
<li><strong>冗余清理</strong>：去除大量空格、分割符等格式噪声（参考2025-09-04知乎文章）</li>
</ul>
<p><strong>2. 检索阶段去噪技术</strong></p>
<ul>
<li><strong>多阶段检索</strong>：先通过向量索引初筛，再用BGE-Reranker等模型重排（参考2025-05-09知乎文章）</li>
<li><strong>段落注入机制</strong>：将检索段落融入推理过程，增强模型辨伪能力（中科院2025-11-08研究）</li>
<li><strong>证据质量验证</strong>：使用EviNote-RAG的SEN（支持性证据笔记）标记不确定信息（2025-09-12联合研究）</li>
</ul>
<p><strong>3. 推理阶段抗噪优化</strong></p>
<ul>
<li><strong>证据质量奖励（EQR）</strong>：通过逻辑蕴含监督确保证据支撑答案（EviNote-RAG核心创新）</li>
<li><strong>自我反思机制</strong>：让模型在生成答案时同步判断证据相关性（2025-11-21网页研究）</li>
<li><strong>噪声训练增强</strong>：在SFT阶段按比例加入随机噪声文档，提升模型抗干扰能力（2025-11-23编程知识研究）</li>
</ul>
<p>openai的一个优化策略：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/704291371">https://zhuanlan.zhihu.com/p/704291371</a></p>
<h3 id="9-怎么构建SFT数据集，数据量多少，微调方式是什么">9.怎么构建SFT数据集，数据量多少，微调方式是什么</h3>
<h3 id="10-SFT数据问题不够多样化怎么办">10.SFT数据问题不够多样化怎么办</h3>
<h3 id="11-介绍一下function-calling和MCP">11.介绍一下function calling和MCP</h3>
<p>一个是模型选择、调用工具的能力</p>
<p>另一个是提供了一个标准化的方式，让模型知道有哪些工具，工具的参数、描述等等</p>
<p>最终实际上还是模型输出一个结构化的调用，然后让真正的后端去执行这个工具</p>
<h3 id="12-代码题：lc215-数组中的第-K-个最大元素">12.代码题：lc215 数组中的第 K 个最大元素</h3>
<h2 id="模板3">模板3</h2>
<h3 id="1-lora-原理，初始化，为什么，对比-sft">1.lora 原理，初始化，为什么，对比 sft</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/716893478">https://zhuanlan.zhihu.com/p/716893478</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/702629428">https://zhuanlan.zhihu.com/p/702629428</a></p>
<h3 id="2-训练网络过程的一些优化">2.训练网络过程的一些优化</h3>
<h3 id="3-batchnorm和layernorm-区别，为什么用，在哪里用">3.batchnorm和layernorm 区别，为什么用，在哪里用</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/656647661">https://zhuanlan.zhihu.com/p/656647661</a></p>
<p>batchnorm就是给一批数据的某一个feature做归一化</p>
<p>layernorm就是给某一个sequence的多个feature做归一化</p>
<p>均值为0，方差为一</p>
<h3 id="4-attention-及其变体原理，cross-attention-的-qkv-来自哪里">4.attention 及其变体原理，cross attention 的 qkv 来自哪里</h3>
<p>Attention 机制及其变体（如 Self-Attention、Cross-Attention）的核心思想是通过“查询”（Query）、“键”（Key）和“值”（Value）三部分计算加权表示。下面分别说明其原理及 Cross-Attention 中 Q、K、V 的来源。</p>
<hr>
<ol>
<li>Attention 的基本原理</li>
</ol>
<p>给定 Query ( Q )、Key ( K )、Value ( V )，Attention 的计算公式为：</p>
\[
\text{Attention}(Q, K, V) = \text{softmax}\left( \frac{QK^\top}{\sqrt{d_k}} \right) V
\]

<p>其中：</p>
<ul>
<li>( d_k ) 是 Key 的维度，用于缩放防止点积过大；</li>
<li>softmax 使注意力权重归一化；</li>
<li>输出是 Value 的加权和，权重由 Query 与 Key 的相似度决定。</li>
</ul>
<hr>
<ol start="2">
<li>Self-Attention（自注意力）</li>
</ol>
<ul>
<li><strong>应用场景</strong>：处理单一序列内部的关系（如 Transformer 编码器或解码器内部）；</li>
<li><strong>Q、K、V 来源</strong>：全部来自<strong>同一个输入序列</strong> ( X )；
<ul>
<li>通常通过三个可学习的线性变换（权重矩阵）得到：\[
Q = X W_Q,\quad K = X W_K,\quad V = X W_V
\]

</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-Cross-Attention（交叉注意力）">3. Cross-Attention（交叉注意力）</h3>
<ul>
<li>
<p><strong>应用场景</strong>：处理<strong>两个不同序列</strong>之间的关系，常见于 Transformer 的解码器中，用于让目标序列关注源序列（如机器翻译中，目标语言关注源语言）。</p>
</li>
<li>
<p><strong>Q、K、V 来源</strong>：</p>
<ul>
<li><strong>Query (Q)</strong>：来自<strong>目标序列</strong>（例如解码器的输入，如已生成的部分目标句子）；</li>
<li><strong>Key (K) 和 Value (V)</strong>：来自<strong>源序列</strong>（例如编码器的输出，如源语言句子的表示）；</li>
<li>数学表达（以 Transformer 解码器为例）：\[
Q = X_{\text{dec}} W_Q,\quad K = X_{\text{enc}} W_K,\quad V = X_{\text{enc}} W_V
\]

其中\( X_{\text{dec}} \)

是解码器侧的表示，\( X_{\text{enc}} \)

是编码器输出。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-为什么这样设计？">4. 为什么这样设计？</h3>
<ul>
<li><strong>Query 表示“我想关注什么”</strong>，所以由当前正在处理的序列（如目标语言）提供；</li>
<li><strong>Key/Value 表示“我可以提供什么信息”</strong>，所以由外部序列（如源语言）提供；</li>
<li>Cross-Attention 使得模型能动态地从源序列中检索与当前目标 token 最相关的信息。</li>
</ul>
<hr>
<p>总结</p>
<table>
<thead>
<tr>
<th>Attention 类型</th>
<th>Query 来源</th>
<th>Key/Value 来源</th>
</tr>
</thead>
<tbody>
<tr>
<td>Self-Attention</td>
<td>同一序列</td>
<td>同一序列</td>
</tr>
<tr>
<td>Cross-Attention</td>
<td>目标序列</td>
<td>源序列</td>
</tr>
</tbody>
</table>
<p>这种机制是 Transformer 能够有效建模跨模态（如文本-图像）或跨语言（如英-中翻译）关系的关键基础。</p>
<h3 id="5-自注意力机制是什么？计算复杂度怎么算？">5.自注意力机制是什么？计算复杂度怎么算？</h3>
<p>自注意力机制（Self-Attention）是 Transformer 模型的核心组件，用于在<strong>单个序列内部</strong>建模元素之间的相互依赖关系。它不依赖于位置或距离，能够直接捕获任意两个位置之间的关联。</p>
<hr>
<p>一、自注意力机制是什么？</p>
<p>给定一个输入序列</p>
\( X = [x_1, x_2, ..., x_n] \in \mathbb{R}^{n \times d} \)

<p>，其中：</p>
<ul>
<li>( n ) 是序列长度（token 数），</li>
<li>( d ) 是每个 token 的特征维度，</li>
</ul>
<p>自注意力通过三个可学习的线性变换生成 Query、Key、Value：</p>
\[
Q = X W_Q,\quad K = X W_K,\quad V = X W_V
\]

<p>其中</p>
\( W_Q, W_K, W_V \in \mathbb{R}^{d \times d_k} \)

<p>（通常 ( d_k = d_v = d ) 或 ( d/ h ) 在多头注意力中）。</p>
<p>然后计算注意力输出：</p>
\[
\text{Self-Attention}(X) = \text{softmax}\left( \frac{Q K^\top}{\sqrt{d_k}} \right) V
\]

<ul>
<li>
\( QK^\top \in \mathbb{R}^{n \times n} \)

<p>表示所有 token 对之间的相似度；</p>
</li>
<li>
<p>softmax 后得到注意力权重矩阵</p>
\( A \in \mathbb{R}^{n \times n} \)

<p>；</p>
</li>
<li>
<p>每个输出 token 是所有输入 token 的加权和（权重由相关性决定）。</p>
</li>
</ul>
<hr>
<p>二、计算复杂度分析</p>
<p>假设：</p>
<ul>
<li>序列长度为 ( n )，</li>
<li>每个 token 的维度为 ( d )（通常 ( d_k = d_v = d )）。</li>
</ul>
<p>各步骤的计算复杂度如下：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>操作</th>
<th>复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>计算 ( Q, K, V )：三个矩阵乘法 ( X W )</td>
<td>( 3 \times (n d \cdot d) = 3 n d^2 )</td>
</tr>
<tr>
<td>2</td>
<td>计算 ( Q K^\top )</td>
<td>( n \cdot d \cdot n = n^2 d )</td>
</tr>
<tr>
<td>3</td>
<td>softmax（元素级操作）</td>
<td>( O(n^2) )（通常忽略，因远小于矩阵乘）</td>
</tr>
<tr>
<td>4</td>
<td>计算 ( A V )（注意力权重 × Value）</td>
<td>( n^2 \cdot d = n^2 d )</td>
</tr>
</tbody>
</table>
<p><strong>总时间复杂度</strong>：</p>
\[
O(n d^2 + n^2 d)
\]

<p>通常在实际模型中（如 BERT、GPT），( d ) 是固定的（例如 768），而 ( n ) 可变。当序列较长时（如 ( n &gt; d )），<strong>主导项是 ( n^2 d )</strong>，即 <strong>自注意力的时间复杂度为 ( O(n^2 d) )</strong>。</p>
<p><strong>空间复杂度</strong>（主要指注意力矩阵 ( A ) 的存储）：</p>
<ul>
<li>需要存储\( QK^\top \)

或 softmax 后的\( A \in \mathbb{R}^{n \times n} \)

，</li>
<li>所以空间复杂度为\( O(n^2) \)

。</li>
</ul>
<hr>
<p>三、实际影响</p>
<ul>
<li>当 ( n = 512 )，<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>=</mo><mn>262</mn><mo separator="true">,</mo><mn>144</mn><mtext> </mtext></mrow><annotation encoding="application/x-tex">n^2 = 262,144 \
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">262</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">144</span><span class="mspace"> </span></span></span></span></span></p>
—— 可接受；</li>
<li>当 ( n = 8192 )，<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>≈</mo><mn>67</mn><mtext> </mtext><mi>m</mi><mi>i</mi><mi>l</mi><mi>l</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex"> n^2 \approx 67 \ million
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">67</span><span class="mspace"> </span><span class="mord mathnormal">mi</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span></span></p>
—— 显存和计算开销剧增；</li>
<li>这也是为什么很多研究致力于 <strong>降低自注意力复杂度</strong>，如：
<ul>
<li>Sparse Attention（稀疏注意力）</li>
<li>Linformer（用低秩近似）</li>
<li>Performer（核函数近似）</li>
<li>FlashAttention（I/O 优化）</li>
</ul>
</li>
</ul>
<hr>
<p>总结</p>
<ul>
<li><strong>自注意力机制</strong>：让序列中每个元素关注所有其他元素，通过 Q、K、V 动态计算相关性；</li>
<li><strong>时间复杂度</strong>：( O(n^2 d) )；</li>
<li><strong>空间复杂度</strong>：( O(n^2) )（主要来自注意力矩阵）；</li>
<li><strong>瓶颈</strong>：长序列处理时的二次复杂度，是当前大模型上下文长度扩展的主要挑战之一。</li>
</ul>
<h3 id="6-KV-Cache的如何加速推理？">6.KV-Cache的如何加速推理？</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/662498827">https://zhuanlan.zhihu.com/p/662498827</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic4.zhimg.com/v2-f8706213a1f04fa1e41533bc0eeef601_1440w.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/v2-81197e811503d1ffa5f864f164127ddb_1440w.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.zhimg.com/v2-cdf2a0f4e164b8b2fdfb4d65fbda8a20_1440w.jpg" alt="img"></p>
<p>在利用kv cache的时候，输入第一个token，变成embedding，然后proj成为q、k、v。假设只有一层transformer，计算完q<em>k^T</em>v之后，通过一个language head映射到词表，选择概率最大的一个token。此时序列变成2个token，继续生成，只需要第二个token-&gt;embedding，然后proj成为q、k、v，再进行注意力计算的时候，kv要和第一个token已经计算好的kv合并，然后再跟q计算attention score（即q<em>k^T</em>v），然后以此类推。<br>
每次最后生成的token是没有对应的qkv的，如果要继续生成的话，要把最后生成的token先proj成为qkv，然后把前面所有的kv与当前的kv合并，最后利用最后生成的token对应的q与合并后的kv计算attention，然后通过language head生成新的token。</p>
<p>KV-Cache（Key-Value Cache）是<strong>在自回归语言模型（如 Transformer 解码器）推理阶段</strong>用于<strong>避免重复计算</strong>、显著<strong>加速生成过程</strong>的关键优化技术。</p>
<hr>
<p>一、为什么需要 KV-Cache？</p>
<p>在自回归生成中（如 GPT 生成文本）：</p>
<ul>
<li>每次生成一个 token，需对<strong>当前所有已生成的 token</strong>（包括新 token）重新计算 Self-Attention；</li>
<li>如果不缓存，第 ( t ) 步就要重新计算前 ( t ) 个 token 的 Q、K、V —— <strong>大量重复计算</strong>。</li>
</ul>
<p><strong>举例</strong>：<br>
生成第 5 个 token 时，模型会重新计算 token 1~5 的 K、V；<br>
生成第 6 个 token 时，又重新计算 token 1~6 的 K、V —— 其中 1~5 完全重复！</p>
<hr>
<p>二、KV-Cache 的核心思想</p>
<blockquote>
<p><strong>只计算新 token 的 K、V，旧 token 的 K、V 缓存起来复用。</strong></p>
</blockquote>
<p>具体做法：</p>
<ul>
<li>在第 ( t ) 步（生成第 ( t ) 个 token）：
<ul>
<li><strong>Query</strong>：仅对当前新输入（通常是第 ( t ) 个 token）计算 ( q_t )；</li>
<li><strong>Key / Value</strong>：
<ul>
<li>新部分：计算当前 token 的 ( k_t, v_t )；</li>
<li>旧部分：从缓存中读取之前所有 token 的 ( {k_1, …, k_{t-1}}, {v_1, …, v_{t-1}} )；</li>
</ul>
</li>
<li>拼接得到完整 ( K_{1:t}, V_{1:t} )，参与注意力计算。</li>
</ul>
</li>
</ul>
<hr>
<p>三、如何加速推理？</p>
<p>✅ 1. <strong>减少计算量</strong></p>
<ul>
<li>原本每步计算 ( t ) 个 token 的 K、V（复杂度 ( O(t d^2) )）；</li>
<li>使用 KV-Cache 后，<strong>每步只计算 1 个 token 的 K、V</strong>（复杂度 ( O(d^2) )）；</li>
<li><strong>总计算量从</strong> ( O(n^2 d^2) ) <strong>降到</strong> ( O(n d^2) )（( n ) 为生成长度）。</li>
</ul>
<p>✅ 2. <strong>减少访存与 FLOPs</strong></p>
<ul>
<li>避免重复读取历史 token 并做矩阵乘；</li>
<li>虽然要维护缓存（增加内存），但<strong>大大降低每步延迟</strong>，尤其在长文本生成时效果显著。</li>
</ul>
<p>✅ 3. <strong>支持批处理（batching）优化</strong></p>
<ul>
<li>多个请求可共享相同长度的 KV-Cache 结构，便于 GPU 并行。</li>
</ul>
<hr>
<p>四、KV-Cache 的存储开销</p>
<ul>
<li>每层 Transformer 都需要缓存 K 和 V；</li>
<li>假设模型有 ( L ) 层，每层注意力头数 ( h )，每个头维度 ( d_h )，序列长度 ( n )；</li>
<li>总缓存大小 ≈\( 2 \times L \times h \times n \times d_h \times \text{bytes per param} \)

；</li>
<li>例如：Llama-7B（( L=32, h=32, d_h=128 )），生成 2048 个 token，约需 <strong>数 GB 显存</strong>。</li>
</ul>
<blockquote>
<p>📌 这也是长上下文推理显存瓶颈的主要来源。</p>
</blockquote>
<hr>
<p>五、注意事项</p>
<ul>
<li><strong>仅用于推理（inference）</strong>，训练时因并行处理整个序列，不需要 KV-Cache；</li>
<li><strong>不适用于所有模型</strong>：仅自回归解码器（如 GPT）使用；Encoder-only（如 BERT）或非自回归模型无需；</li>
<li><strong>需配合 Position Embedding / RoPE</strong>：缓存的 K、V 仍需正确的位置信息。</li>
</ul>
<hr>
<p>总结</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>无 KV-Cache</th>
<th>有 KV-Cache</th>
</tr>
</thead>
<tbody>
<tr>
<td>每步 K/V 计算量</td>
<td>( O(t d^2) )</td>
<td>( O(d^2) )</td>
</tr>
<tr>
<td>总时间复杂度</td>
<td>( O(n^2 d^2) )</td>
<td>( O(n d^2) )</td>
</tr>
<tr>
<td>是否重复计算</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>推理速度</td>
<td>慢（随长度平方增长）</td>
<td>快（线性增长）</td>
</tr>
<tr>
<td>显存开销</td>
<td>低</td>
<td>高（但可接受）</td>
</tr>
</tbody>
</table>
<p>✅ <strong>KV-Cache 用显存换时间，是现代大语言模型高效推理的基石。</strong></p>
<h3 id="7-LoRA的原理是什么？与P-Tuning、Adapter的异同点？LoRA的参数选择对模型性能有何影响？">7.LoRA的原理是什么？与P-Tuning、Adapter的异同点？LoRA的参数选择对模型性能有何影响？</h3>
<p>LoRA（Low-Rank Adaptation）是一种高效的<strong>参数高效微调</strong>（Parameter-Efficient Fine-Tuning, PEFT）方法，其核心思想是<strong>用低秩矩阵近似原始模型权重的更新</strong>，从而在只训练极少参数的情况下实现接近全参数微调的性能。</p>
<p>下面从原理、与其他方法（P-Tuning、Adapter）的异同、以及参数选择对性能的影响三方面详细说明。</p>
<hr>
<p>一、LoRA 原理</p>
<ol>
<li>基本思想</li>
</ol>
<p>在微调大型预训练模型（如 LLM）时，直接更新全部参数成本高、易过拟合。LoRA 假设：<strong>权重更新 (\Delta W) 具有低秩结构</strong>，即：</p>
\[
\Delta W = A B, \quad A \in \mathbb{R}^{d \times r}, \; B \in \mathbb{R}^{r \times k}, \; r \ll \min(d, k)
\]

<p>其中：</p>
<ul>
<li>
\(W_0 \in \mathbb{R}^{d \times k}\)

<p>是预训练权重（冻结不训练）；</p>
</li>
<li>
<p>(A, B) 是可训练的低秩分解矩阵，秩为 (r)；</p>
</li>
<li>
<p>前向传播时实际使用：</p>
\(h = x (W_0 + \Delta W) = x W_0 + x A B\)

</li>
</ul>
<blockquote>
<p>这样，<strong>只训练 (A) 和 (B)</strong>，原始 (W_0) 保持不变。</p>
</blockquote>
<ol start="2">
<li>应用位置</li>
</ol>
<p>LoRA 通常插入在：</p>
<ul>
<li>Transformer 的 <strong>Attention 模块</strong>（如 (W_q, W_k, W_v, W_o)），</li>
<li>有时也用于 <strong>MLP 层</strong>，但实践中主要用在 Attention。</li>
</ul>
<ol start="3">
<li>推理时合并</li>
</ol>
<p>训练完成后，可将</p>
\(\Delta W = AB\)

<p>加到 (W_0) 上，<strong>零开销部署</strong>（与原始模型无区别）。</p>
<hr>
<p>二、与 P-Tuning、Adapter 的异同</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>核心机制</th>
<th>可训练参数位置</th>
<th>是否修改模型结构</th>
<th>推理是否需额外开销</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>LoRA</strong></td>
<td>低秩分解更新权重矩阵</td>
<td>原有线性层旁路（低秩矩阵）</td>
<td>否（可合并）</td>
<td>否（可合并）</td>
<td>通用，尤其 LLM 微调</td>
</tr>
<tr>
<td><strong>Adapter</strong></td>
<td>在 FFN 或 Attention 后插入小型全连接模块（如 bottleneck）</td>
<td>新增子网络（如 down-projection + up-projection）</td>
<td>是（插入模块）</td>
<td>是（需保留 Adapter 层）</td>
<td>多任务、跨任务迁移</td>
</tr>
<tr>
<td><strong>P-Tuning v2</strong></td>
<td>在输入层或每层前添加可学习的<strong>连续 prompt 向量</strong>（软提示）</td>
<td>输入嵌入空间或每层前缀</td>
<td>是（增加 prompt token）</td>
<td>是（需保留 prompt）</td>
<td>少样本、提示学习</td>
</tr>
</tbody>
</table>
<p>关键区别：</p>
<ul>
<li>
<p><strong>LoRA vs Adapter</strong>：</p>
<ul>
<li>Adapter 修改模型结构，增加额外模块，推理时需保留；</li>
<li>LoRA 不改变前向结构，仅修改权重，可合并，<strong>部署更干净</strong>；</li>
<li>LoRA 通常在相同参数量下表现优于 Adapter。</li>
</ul>
</li>
<li>
<p><strong>LoRA vs P-Tuning</strong>：</p>
<ul>
<li>P-Tuning 仅调整<strong>输入表示</strong>（类似“软提示”），不修改模型内部权重；</li>
<li>LoRA 直接调整<strong>模型参数空间</strong>，表达能力更强；</li>
<li>P-Tuning 更适合<strong>任务提示</strong>（如 NLU），LoRA 更适合<strong>指令微调、领域适配</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌 实践中，LoRA 因其<strong>高效果、易部署、灵活性强</strong>，已成为 LLM 微调的事实标准（如 Hugging Face PEFT 库默认支持）。</p>
</blockquote>
<hr>
<p>三、LoRA 参数选择对性能的影响</p>
<p>关键超参数：</p>
<ol>
<li>
<p><strong>秩（rank）(r)</strong>：</p>
<ul>
<li>(r) 越大，表达能力越强，但参数量和过拟合风险增加；</li>
<li>常见值：8、16、32、64；</li>
<li>实验表明：<strong>r=8~32 通常足够</strong>，超过 64 收益递减；</li>
<li>小模型（如 7B）常用 r=8，大模型（70B）可用 r=64。</li>
</ul>
</li>
<li>
<p><strong>应用层位置</strong>：</p>
<ul>
<li>仅在 <strong>Attention 的 (W_q, W_v)</strong> 上加 LoRA，通常就能达到 90%+ 全微调性能；</li>
<li>加在 (W_k, W_o) 或 MLP 上收益有限，甚至有害；</li>
<li><strong>推荐策略</strong>：优先 (q, v)，必要时扩展到 (k, o)。</li>
</ul>
</li>
<li>
<p><strong>缩放因子（alpha）</strong>：</p>
<ul>
<li>LoRA 输出常带缩放：( \frac{\alpha}{r} AB )；</li>
<li>(\alpha) 控制更新幅度，类似学习率；</li>
<li>通常设 (\alpha = 2r)（如 r=8 → α=16），效果较稳定。</li>
</ul>
</li>
<li>
<p><strong>参数量占比</strong>：</p>
<ul>
<li>以 LLaMA-7B 为例：
<ul>
<li>全参数：7B；</li>
<li>LoRA（r=8，仅 q/v）：约 4M 参数（<strong>0.06%</strong>）；</li>
</ul>
</li>
<li>即使如此少的参数，也能在指令微调中接近全微调效果。</li>
</ul>
</li>
</ol>
<blockquote>
<p>⚠️ 注意：<strong>过小的 r（如 r=1~2）会严重限制模型容量</strong>，导致欠拟合；<strong>过大的 r 可能过拟合小数据集</strong>。</p>
</blockquote>
<hr>
<p>总结</p>
<ul>
<li><strong>LoRA 原理</strong>：用低秩矩阵近似权重更新，冻结主干，只训旁路；</li>
<li><strong>vs Adapter / P-Tuning</strong>：
<ul>
<li>LoRA 更高效、可合并、通用性强；</li>
<li>Adapter 需保留结构，P-Tuning 仅改输入；</li>
</ul>
</li>
<li><strong>参数选择</strong>：
<ul>
<li>rank (r) 是关键：8~32 通常最佳；</li>
<li>优先应用于 Attention 的 (W_q, W_v)；</li>
<li>合理设置 (\alpha)（如 (\alpha = 2r)）。</li>
</ul>
</li>
</ul>
<p>✅ LoRA 在<strong>低资源、多任务、快速迭代</strong>场景中极具优势，是当前大模型微调的首选 PEFT 方法。</p>
<h3 id="8-介绍下RLHF的基本流程，与DPO的差异是什么？">8.介绍下RLHF的基本流程，与DPO的差异是什么？</h3>
<p>GRPO PPO DPO: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1910019667268986241">https://zhuanlan.zhihu.com/p/1910019667268986241</a></p>
<p>DPO属于<strong>直接偏好对齐</strong>方法，是在2023年由斯坦福大学研究团队提出的偏好优化算法，主要为了解决<strong>PPO训练难度高导致不容易收敛，资源消耗大</strong>的问题。主要的方法是通过引入人类偏好数据，将在线策略优化，修改为通过二元交叉熵直接拟合人类偏好数据的离线策略。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/v2-d222883db3171863b7790128d4f12233_1440w.jpg" alt="img"></p>
<p>RLHF vs DPO</p>
<p><strong>DPO优点</strong></p>
<ul>
<li><strong>训练流程短</strong>：RLHF的过程，需要提前训练好一个reward model，但DPO由于不需要引入<strong>reward model</strong>，因此也无需这个阶段。DPO根据预先给定的偏好数据直接进行学习，属于<strong>离线策略</strong>，不需要进行在线数据采样。</li>
<li><strong>训练资源要求低</strong>：其中RLHF需要策略模型（<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=258164937&amp;content_type=Article&amp;match_order=1&amp;q=Policy+Model&amp;zhida_source=entity">Policy Model</a>）、参考模型（Reference Model）、奖励模型（<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=258164937&amp;content_type=Article&amp;match_order=1&amp;q=Reward+Model&amp;zhida_source=entity">Reward Model</a>）、价值模型（<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=258164937&amp;content_type=Article&amp;match_order=1&amp;q=Value+Model&amp;zhida_source=entity">Value Model</a>），而DPO仅需要前<strong>两个模型</strong>，并且<strong>参考模型属于可选加载</strong>，可以通过将参考模型的输出结果预先录制好，在训练时就可以不加载。因此对于训练资源显存等要求低。</li>
<li><strong>稳定性高</strong>：DPO属于<strong>有监督学习</strong>（通过概率匹配直接优化策略），摆脱了强化学习由于高方差带来的不稳定（由于奖励稀疏or噪声造成）。DPO可以通过人类偏好数据，用二元交叉熵对策略进行优化，而不需要多次进行在线数据采样进行优化。其中， yw为偏好数据，yl为非偏好数据。</li>
<li><strong>训练难度低</strong>：其中DPO仅需要关注<strong>学习率和偏好权重</strong>β ，而RLHF需要同时关注策略更新幅度、奖励模型置信度等。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/v2-33137b12aebec247601bee7d89183791_1440w.jpg" alt="img"></p>
<p><strong>这个loss是咋来的？</strong></p>
<p><strong>DPO缺点</strong></p>
<ul>
<li><strong>容易过拟合</strong>：DPO由于缺少reward model的泛化，因此容易直接拟合人类偏好数据，造成过拟合。</li>
<li><strong>需求更大标注数据量</strong>：相比PPO等，DPO的效果表现更依赖标注数据量。</li>
<li><strong>多任务适配较难</strong>：由于DPO仅依赖数据，所以如果需要进行多任务的对比，则需要从头标注涉及到多个维度的数据，但是在线策略的方法可以通过单个维度的数据，训练不同的多个reward model，引入多维度的奖励。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>DPO</th>
<th>传统 PPO + RM</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否需要奖励模型</td>
<td>❌ 不需要</td>
<td>✅ 需要</td>
</tr>
<tr>
<td>是否需要强化学习</td>
<td>❌ 不需要</td>
<td>✅ 需要（PPO）</td>
</tr>
<tr>
<td>训练稳定性</td>
<td>高（标准有监督学习）</td>
<td>低（RL 不稳定）</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>低（几十行代码）</td>
<td>高（多模型、值函数、clip 等）</td>
</tr>
<tr>
<td>训练效率</td>
<td>高（可批量训练）</td>
<td>低（需采样、策略梯度）</td>
</tr>
<tr>
<td>性能</td>
<td>通常优于或持平 PPO</td>
<td>基线</td>
</tr>
</tbody>
</table>
<p>**GRPO vs PPO **</p>
<p>为了在PPO和DPO之间取得平衡，deepseek提出了GRPO（<strong>群组相对优化策略</strong>），a在一定程度上能够通过去掉价值模型<strong>Value Model</strong>，缓解PPO对于显存的瓶颈，确保策略更新的稳定性和高效性；同时保留了<strong>Reward Model</strong>，避免了DPO因为直接拟合人类偏好数据，而容易造成的过拟合和效果不佳。</p>
<p>其中GRPO跟PPO的重要区别，主要是去掉了Value Model，同时使用Policy Model的多个output采样的Reward Model输出的多个奖励的平均值作为优势函数。</p>
<p><strong>一、优势函数不同</strong></p>
<p><strong>二、奖励值的归一化方式不同</strong></p>
<p><strong>三、KL散度的作用范围不同</strong></p>
<p>KL散度在<strong>PPO</strong>是放在奖励函数中。在<strong>GRPO</strong>的目标函数直接放在了损失函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.zhimg.com/v2-666f326c43006ac1679437d4542c0840_1440w.jpg" alt="img"></p>
<p>DPO vs RLHF</p>
<ul>
<li>**训练流程：**其中DPO因为不依赖Reward Model，所以只有一个训练流程，而PPO、GRPO等在线策略需要先训练Reward Model，再进行对齐，需要两个阶段。</li>
<li>**显卡资源需求：**对于显卡的需求PPO（加载4个模型）&gt;GRPO（加载3个模型）&gt;DPO（加载1个必选模型+1个可选模型）</li>
<li>**对样本依赖：**其中PPO、GRPO因为通过Reward Model来进行对齐，有一定的泛化作用，因此对样本标注的精度和数据量依赖相对较小；DPO与之相反。</li>
<li>**灵活扩展性：**当涉及到多个业务场景时，其中PPO、GRPO可以通过多个Reward Model来进行灵活的扩展，而不需要从头标注多业务维度的人工偏向数据；DPO则需要重新构建数据，整体的灵活性和可扩展性较差。</li>
</ul>
<h3 id="9-分布式训练中的TP、PP、DP分别是什么？">9.分布式训练中的TP、PP、DP分别是什么？</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1904506837543420662">https://zhuanlan.zhihu.com/p/1904506837543420662</a></p>
<h3 id="10-flash-attention的原理是什么？">10.flash-attention的原理是什么？</h3>
<p>作用：加速注意力计算！！</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/676655352">https://zhuanlan.zhihu.com/p/676655352</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/668888063">https://zhuanlan.zhihu.com/p/668888063</a></p>
<p>看这个简单些：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/714881594">https://zhuanlan.zhihu.com/p/714881594</a></p>
<p>FlashAttention的核心原理是将输入QKV分块，并保证每个块能够在<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=246992481&amp;content_type=Article&amp;match_order=1&amp;q=SRAM&amp;zhida_source=entity">SRAM</a>（一级缓存）上完成注意力操作，并将结果更新回<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=246992481&amp;content_type=Article&amp;match_order=1&amp;q=HBM&amp;zhida_source=entity">HBM</a>，从而降低对高带宽内存（HBM）的读写操作。总之，FlashAttention从GPU的内存读写入手，减少了内存读写量，从而实现了2~4倍的速度提升。</p>
<p>FlashAttention <strong>has slightly higher FLOP count</strong> than naive attention due to recomputation, but reduces data movement dramatically.</p>
<p>FlashAttention 是一种<strong>高效、内存感知的注意力机制实现</strong>，旨在<strong>减少 GPU 显存访问（I/O）开销</strong>，从而<strong>加速注意力计算并降低显存占用</strong>。它不是改变注意力公式，而是通过<strong>算法重排与分块计算</strong>，在不损失精度的前提下显著提升性能。</p>
<p>SRAM&gt;HBM&gt;DRAM的速度</p>
<hr>
<p>一、背景：标准注意力的瓶颈</p>
<p>标准 Self-Attention 计算如下（忽略 softmax 缩放）：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>=</mo><mtext>softmax</mtext><mo stretchy="false">(</mo><mi>Q</mi><msup><mi>K</mi><mi mathvariant="normal">⊤</mi></msup><mo stretchy="false">)</mo><mspace width="1em"/><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow></msup><mspace linebreak="newline"></mspace><mtext>Output</mtext><mo>=</mo><mi>A</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">A = \text{softmax}(Q K^\top) \quad \in \mathbb{R}^{n \times n} \\
\text{Output} = A V
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1491em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">softmax</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8213em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Output</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p>
<p>其中：</p>
<ul>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">Q, K, V \in \mathbb{R}^{n \times d}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8991em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>(n)：序列长度（如 2048）</p>
</li>
<li>
<p>(d)：特征维度（如 128）</p>
</li>
</ul>
<p>问题：</p>
<ol>
<li><strong>中间矩阵 (QK^\top) 和 (A) 需要 (O(n^2)) 显存</strong>；</li>
<li><strong>GPU 高带宽显存</strong>（HBM）；</li>
<li>即使计算快，<strong>I/O 成为瓶颈</strong>（“memory-bound” 而非 “compute-bound”）。</li>
</ol>
<hr>
<p>二、FlashAttention 的核心思想</p>
<blockquote>
<p><strong>不显式构造完整的 (QK^\top) 或 (A) 矩阵，而是通过分块</strong>（tiling）</p>
</blockquote>
<p>具体来说，FlashAttention 利用两个关键技术：</p>
<p>✅ 1. <strong>分块计算</strong>（Tiling / Blocking）</p>
<ul>
<li>将 (Q, K, V) 沿序列维度（(n)）切分为小块（tiles）；</li>
<li>每次只加载一小块到<strong>高速片上 SRAM</strong>（如 GPU 的 shared memory）；</li>
<li>在 SRAM 内完成局部 (q_i k_j^\top)、softmax、与 (v_j) 的乘积累加；</li>
<li>避免将完整的 (n \times n) 矩阵写入/读出 HBM。</li>
</ul>
<p>✅ 2. <strong>在线 Softmax 技巧</strong>（Online Softmax）</p>
<ul>
<li>Softmax 不能直接分块计算（因需全局最大值和归一化）；</li>
<li>FlashAttention 使用<strong>数值稳定的在线归约方法</strong>：
<ul>
<li>
<p>对每个 query 块，维护局部最大值 (m) 和局部和 (l)；（safe-softmax，减去最大值）</p>
</li>
<li>
<p>合并不同 key 块时，动态更新：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>m</mi><mtext>new</mtext></msub><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>m</mi><mtext>old</mtext></msub><mo separator="true">,</mo><msub><mi>m</mi><mtext>curr</mtext></msub><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><msub><mi>l</mi><mtext>new</mtext></msub><mo>=</mo><msub><mi>l</mi><mtext>old</mtext></msub><msup><mi>e</mi><mrow><msub><mi>m</mi><mtext>old</mtext></msub><mo>−</mo><msub><mi>m</mi><mtext>new</mtext></msub></mrow></msup><mo>+</mo><msub><mi>l</mi><mtext>curr</mtext></msub><msup><mi>e</mi><mrow><msub><mi>m</mi><mtext>curr</mtext></msub><mo>−</mo><msub><mi>m</mi><mtext>new</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">m_{\text{new}} = \max(m_{\text{old}}, m_{\text{curr}}) \\
l_{\text{new}} = l_{\text{old}} e^{m_{\text{old}} - m_{\text{new}}} + l_{\text{curr}} e^{m_{\text{curr}} - m_{\text{new}}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">new</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">curr</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">new</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9713em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">new</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9713em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">curr</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">curr</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">new</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>最终结果等价于完整 softmax，但无需存储完整 (A)。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>这样，<strong>中间注意力矩阵 (A) 从未完整存在于 HBM 中</strong>，只在 SRAM 中临时存在并立即用于计算 (AV)。</p>
</blockquote>
<hr>
<p>三、优势</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>标准 Attention</th>
<th>FlashAttention</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>时间复杂度</strong></td>
<td>(O(n^2 d))</td>
<td>(O(n^2 d))（但常数小）</td>
</tr>
<tr>
<td><strong>显存复杂度</strong></td>
<td>(O(n^2 + nd))</td>
<td>(O(nd))（<strong>不存 (A)</strong>）</td>
</tr>
<tr>
<td><strong>HBM 读写次数</strong></td>
<td>高（多次读写 (A)）</td>
<td><strong>极低</strong>（只读 (Q,K,V)，只写 Output）</td>
</tr>
<tr>
<td><strong>实际速度</strong></td>
<td>慢（I/O 瓶颈）</td>
<td><strong>快 2–5 倍</strong>（尤其长序列）</td>
</tr>
<tr>
<td><strong>支持长上下文</strong></td>
<td>受限（显存爆炸）</td>
<td>更高（如 8K、16K、32K）</td>
</tr>
</tbody>
</table>
<hr>
<p>四、FlashAttention-2 的改进（2023）</p>
<p>在 FlashAttention 基础上进一步优化：</p>
<ul>
<li>更优的线程块调度；</li>
<li>减少 shared memory 同步；</li>
<li>更好的并行性；</li>
<li><strong>速度再提升 1.5–2 倍</strong>，接近理论算力上限。</li>
</ul>
<hr>
<p>五、实际应用</p>
<ul>
<li><strong>主流 LLM 框架默认启用</strong>：
<ul>
<li>Hugging Face Transformers（通过 <code>use_flash_attention_2=True</code>）；</li>
<li>vLLM、TensorRT-LLM、Llama.cpp（部分支持）；</li>
<li>PyTorch 2.0+ 内置 <code>torch.nn.functional.scaled_dot_product_attention</code> 自动 fallback 到 FlashAttention（若硬件支持）。</li>
</ul>
</li>
<li><strong>要求</strong>：
<ul>
<li>GPU 架构 ≥ Ampere（如 A100、RTX 3090/4090）；</li>
<li>安装 <code>flash-attn</code> 库（CUDA 扩展）。</li>
</ul>
</li>
</ul>
<hr>
<p>六、注意事项</p>
<ul>
<li><strong>仅加速计算，不改变模型结构或结果</strong>（数值误差在可接受范围）；</li>
<li><strong>对短序列</strong>（如 (n &lt; 512)），收益有限；</li>
<li><strong>不直接降低算法复杂度</strong>（仍是 (O(n^2))），但通过 I/O 优化使长序列可行；</li>
<li><strong>与 KV Cache 兼容</strong>：推理时仍可使用 KV Cache + FlashAttention 加速每步 attention。</li>
</ul>
<hr>
<p>s总结</p>
<blockquote>
<p><strong>FlashAttention 是一种 I/O 感知的注意力实现，通过分块计算 + 在线 softmax，在不改变数学定义的前提下，大幅减少显存访问和占用，从而加速训练与推理，尤其对长上下文场景至关重要。</strong></p>
</blockquote>
<p>它是现代大模型高效训练/推理的<strong>基础设施级优化</strong>，已被广泛集成到主流框架中。</p>
<h2 id="模板4">模板4</h2>
<h3 id="1-训练数据，有没有做数据处理与增强的工作">1.训练数据，有没有做数据处理与增强的工作</h3>
<p>这里的数据会进行扩写</p>
<h3 id="4-在什么机器上训练，时间，数据量大小">4.在什么机器上训练，时间，数据量大小</h3>
<p>跨机器，4卡A100，tp=2，时间很快，几条，ms-swift</p>
<h3 id="5-rag中怎么做的pdf解析，对pdf里面的图片，表格数据怎么处理的，怎么编码的，检索，召回的时候都做了哪些操作，混合检索的时候的权重怎么处理的，有没有消融实现对比">5.rag中怎么做的pdf解析，对pdf里面的图片，表格数据怎么处理的，怎么编码的，检索，召回的时候都做了哪些操作，混合检索的时候的权重怎么处理的，有没有消融实现对比</h3>
<p>最佳实践：<strong>分层解析 + 结构感知</strong></p>
<table>
<thead>
<tr>
<th>内容类型</th>
<th>工具/方法</th>
<th>输出形式</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>文本</strong>（含格式）</td>
<td><code>pymupdf</code>（PyMuPDF）、<code>pdfplumber</code></td>
<td>保留段落、标题层级、字体大小、位置坐标</td>
</tr>
<tr>
<td><strong>表格</strong></td>
<td><code>camelot-py</code>（PDF 线条表）、<code>table-transformer</code>（无框线表）</td>
<td>转为 <strong>Markdown 表格</strong> 或 <strong>结构化 JSON</strong></td>
</tr>
<tr>
<td><strong>图片/图表</strong></td>
<td><code>pymupdf</code> 提取图像 + <strong>OCR/多模态理解</strong></td>
<td>图像文件 + <strong>Caption</strong>（由多模态模型生成）</td>
</tr>
<tr>
<td><strong>公式/LaTeX</strong></td>
<td><code>latex-ocr</code>（Pix2Text）</td>
<td>转为 LaTeX 字符串</td>
</tr>
<tr>
<td><strong>版面分析</strong></td>
<td><code>unstructured</code> + <code>layoutparser</code></td>
<td>返回 <code>ElementType</code>（text/table/figure/title）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>📌 <strong>关键原则</strong>：<strong>不丢弃任何信息，但转化为可检索的文本形式</strong>。</p>
</blockquote>
<p>caption这里要随着原文档也塞入向量数据库，base64编码了，有个映射关系</p>
<p>文档、表格统一转化成markdown格式。经过最开始的几个实验发现转化成markdown格式对于解析表格有作用。</p>
<p>-&gt;tabulate。</p>
<p>分块：langchain.RecursiveCharacterTextSplitter</p>
<p>rrf</p>
<p>消融实验做了部分</p>
<p>还有agentic rag。</p>
<p>混合召回：语义召回（相似度）+ 图召回+ 关键词召回。</p>
<p>涉及到多跳的仅靠一次查询是不行的。</p>
<p>召回：rrf/融合加权，这里rrf+reranker，一个参数</p>
<p>问题是这里rerank每次都要发起多次API推理。</p>
<p>多阶段重排：向量召回+图召回+关键词召回top30，RRF融合top15, reranker重排</p>
<h3 id="7-sft与rag对比">7.sft与rag对比</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1970490096991081408">https://zhuanlan.zhihu.com/p/1970490096991081408</a></p>
<h3 id="9-agent方面有哪些了解">9.agent方面有哪些了解</h3>
<p>框架 langchain langgraph autogen</p>
<p>记忆</p>
<p>上下文压缩</p>
<p>工具</p>
<p>mcp</p>
<h2 id="模板5">模板5</h2>
<h3 id="1-两三句介绍下agent以及当前的挑战">1. 两三句介绍下agent以及当前的挑战</h3>
<p>Agent（智能体）是指能够感知环境、自主规划并执行任务以达成目标的大模型系统，通常具备记忆、工具调用、推理和自我反思等能力。当前主要挑战包括：<strong>可靠性不足</strong>（如幻觉、工具误用）、<strong>复杂任务规划能力有限</strong>、<strong>多步执行中的错误累积</strong>，以及<strong>缺乏统一评估基准和高效训练范式</strong>。</p>
<h3 id="2-transformer架构-有哪些机制">2. transformer架构 有哪些机制</h3>
<p>Transformer 架构是自然语言处理（NLP）中一种革命性的神经网络结构，最早由 Vaswani 等人在 2017 年的论文《Attention is All You Need》中提出。其核心在于完全基于注意力机制，摒弃了传统的循环（RNN）和卷积（CNN）结构。Transformer 的主要机制包括以下几个关键组成部分：</p>
<hr>
<ol>
<li><strong>自注意力机制（Self-Attention / Scaled Dot-Product Attention）</strong></li>
</ol>
<ul>
<li>
<p>允许模型在处理每个词时关注输入序列中的其他所有词。</p>
</li>
<li>
<p>通过计算 Query (Q)、Key (K)、Value (V) 三个向量来实现：</p>
\[
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
\]

</li>
<li>
<p>“Scaled” 是因为点积可能很大，导致 softmax 梯度消失，因此除以 (\sqrt{d_k}) 进行缩放。</p>
</li>
</ul>
<hr>
<ol start="2">
<li><strong>多头注意力（Multi-Head Attention）</strong></li>
</ol>
<ul>
<li>
<p>将自注意力机制并行地应用多次（多个“头”），每个头学习不同的注意力子空间。</p>
</li>
<li>
<p>将多个头的输出拼接后通过一个线性变换得到最终输出：</p>
[
\text{MultiHead}(Q, K, V) = \text{Concat}(\text{head}_1, ..., \text{head}_h)W^O
\]

</li>
<li>
<p>增强模型对不同位置、不同语义关系的建模能力。</p>
</li>
</ul>
<hr>
<ol start="3">
<li><strong>位置编码（Positional Encoding）</strong></li>
</ol>
<ul>
<li>
<p>因为 Transformer 没有像 RNN 那样的顺序处理机制，需显式加入位置信息。</p>
</li>
<li>
<p>通常使用正弦和余弦函数编码位置：</p>
\[
PE_{(pos, 2i)} = \sin\left(\frac{pos}{10000^{2i/d}}\right), \quad
PE_{(pos, 2i+1)} = \cos\left(\frac{pos}{10000^{2i/d}}\right)
\]

</li>
<li>
<p>也可使用可学习的位置嵌入（如 BERT 中）。</p>
</li>
</ul>
<hr>
<ol start="4">
<li><strong>残差连接（Residual Connection）与层归一化（Layer Normalization）</strong></li>
</ol>
<ul>
<li>
<p>每个子层（如多头注意力、前馈网络）后都接残差连接和 LayerNorm：</p>
\[
\text{Output} = \text{LayerNorm}(x + \text{Sublayer}(x))
\]

</li>
<li>
<p>有助于缓解深层网络训练中的梯度消失问题，并稳定训练。</p>
</li>
</ul>
<hr>
<ol start="5">
<li><strong>前馈神经网络（Position-wise Feed-Forward Network）</strong></li>
</ol>
<ul>
<li>
<p>每个位置独立地通过一个两层全连接网络：</p>
\[
\text{FFN}(x) = \max(0, xW_1 + b_1)W_2 + b_2
\]

</li>
<li>
<p>通常包含 ReLU 激活函数，且同一层对所有位置共享参数（但不同层参数不同）。</p>
</li>
</ul>
<hr>
<ol start="6">
<li><strong>编码器-解码器结构（Encoder-Decoder Architecture）</strong></li>
</ol>
<ul>
<li><strong>编码器（Encoder）</strong>：由 N 个相同层堆叠而成，每层包含多头自注意力 + 前馈网络。</li>
<li><strong>解码器（Decoder）</strong>：也由 N 层组成，但每层包含：
<ol>
<li><strong>掩码多头自注意力</strong>（防止看到未来 token）；</li>
<li><strong>编码器-解码器注意力</strong>（Query 来自解码器，Key/Value 来自编码器）；</li>
<li>前馈网络。</li>
</ol>
</li>
<li>解码器通过自回归方式生成输出（一次一个 token）。</li>
</ul>
<hr>
<ol start="7">
<li><strong>掩码机制（Masking）</strong></li>
</ol>
<ul>
<li><strong>Padding Mask</strong>：忽略输入中的填充 token（如 <code>&lt;pad&gt;</code>）。</li>
<li><strong>Look-ahead Mask（因果掩码）</strong>：在解码器中，防止当前位置关注未来位置的 token，保证自回归性质。</li>
</ul>
<hr>
<p>这些机制共同使得 Transformer 能够高效地并行处理长序列、捕捉长距离依赖，并成为现代大模型（如 BERT、GPT、T5、LLaMA 等）的基础架构。</p>
<h3 id="3-解释下交叉注意力机制">3. 解释下交叉注意力机制</h3>
<p>模板3 问题3</p>
<h3 id="4-介绍下ppo-dpo-grpo算法">4. 介绍下ppo dpo grpo算法</h3>
<p>模板3 问题8</p>
<p>这里grpo单独提出来说一下</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>J</mi><mrow><mi>G</mi><mi>R</mi><mi>P</mi><mi>O</mi></mrow></msub><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi mathvariant="double-struck">E</mi><mrow><mi>q</mi><mo>∼</mo><mi>P</mi><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><msub><mi>o</mi><mi>i</mi></msub><msubsup><mo stretchy="false">}</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>G</mi></msubsup><mo>∼</mo><msub><mi>π</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo stretchy="false">(</mo><mi>O</mi><mi mathvariant="normal">∣</mi><mi>q</mi><mo stretchy="false">)</mo></mrow></msub><mrow><mo fence="true">[</mo><mfrac><mn>1</mn><mi>G</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>G</mi></munderover><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><msub><mi>o</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi mathvariant="normal">∣</mi><msub><mi>o</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi></mrow></munderover><mrow><mo fence="true">(</mo><msub><mi>r</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>t</mi></mrow></msub><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><msub><mover accent="true"><mi>A</mi><mo>^</mo></mover><mrow><mi>i</mi><mo separator="true">,</mo><mi>t</mi></mrow></msub><mo>−</mo><mi>β</mi><msub><mi>D</mi><mrow><mi>K</mi><mi>L</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>π</mi><mi>θ</mi></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>π</mi><mrow><mi>r</mi><mi>e</mi><mi>f</mi></mrow></msub><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">J_{GRPO}(\theta) = \mathbb{E}_{q \sim P(Q), \{o_i\}_{i=1}^G \sim \pi_{old}(O|q)} \left[ \frac{1}{G} \sum_{i=1}^G \frac{1}{|o_i|} \sum_{t=1}^{|o_i|} \left( r_{i,t}(\theta) \hat{A}_{i,t} - \beta D_{KL}(\pi_\theta || \pi_{ref}) \right) \right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">GRPO</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="mord"><span class="mord mathbb">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.4618em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="mrel mtight">∼</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">Q</span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mopen mtight">{</span><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight"><span class="mclose mtight">}</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8329em;"><span style="top:-2.1777em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.8448em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3223em;"><span></span></span></span></span></span></span><span class="mrel mtight">∼</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4638em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M403 1759 V84 H666 V0 H319 V1759 v0 v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">G</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.961em;"><span style="top:-1.8829em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2671em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M347 1759 V0 H0 V84 H263 V1759 v0 v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>举例假设：</p>
<ul>
<li>q = “翻译：Hello world”</li>
<li>G = 2 个输出：o₁ = “你好世界”，o₂ = “哈喽世界”</li>
<li>|o₁| = 4，|o₂| = 4（按字计）</li>
<li>β = 0.01</li>
<li>π_ref 是旧策略，例如在“你”字处概率为 0.8，在“哈”字处概率为 0.7</li>
<li>当前策略 π_θ 在“你”字处概率为 0.9，在“哈”字处概率为 0.6</li>
</ul>
<p>在 t=1 时刻（第一个字）：</p>
<ul>
<li>假设 reward model 给出 r₁,₁ = 1.0（“你”好），r₂,₁ = 0.8（“哈”稍差）</li>
<li>优势估计：A₁,₁ = 0.6，A₂,₁ = 0.3 → 平均优势 = 0.45 → 相对优势：Â₁,₁ = 0.15，Â₂,₁ = -0.15</li>
<li>KL 项：D_KL(π_θ || π_ref) 在 t=1 位置约为 0.02（粗略估算）</li>
</ul>
<p>则 t=1 的贡献为：</p>
<ul>
<li>o₁: 1.0 × 0.15 - 0.01 × 0.02 = 0.15 - 0.0002 ≈ 0.1498</li>
<li>o₂: 0.8 × (-0.15) - 0.01 × 0.02 = -0.12 - 0.0002 ≈ -0.1202</li>
</ul>
<p>然后对所有 t 和所有 i 求平均，得到最终目标 J_GRPO(θ)，我们通过梯度上升最大化它。</p>
<h3 id="5-grpo的loss怎么计算的-数据用的什么">5. grpo的loss怎么计算的 数据用的什么</h3>
<p>。。不会</p>
<h3 id="6-deepresearch和强化学习怎么结合应用">6.deepresearch和强化学习怎么结合应用</h3>
<p>webdancer</p>
<p>奖励函数设计：开放域问题reward难以量化，其他的到都好说，套用现成的一个算法就行。</p>
<p>有研究就是用的LLM as reward judge（kimi-research 用o3-mini评估答案正确性）</p>
<h3 id="7-解释下topk-topp的实现原理">7. 解释下topk topp的实现原理</h3>
<p>略</p>
<h3 id="8-为什么现在大模型都是decoder架构">8. 为什么现在大模型都是decoder架构</h3>
<h2 id="模板5-2">模板5</h2>
<h3 id="1-损失函数设计">1. 损失函数设计</h3>
<h3 id="2-LoRA吟唱">2. LoRA吟唱</h3>
<h3 id="3-手撕MHA">3. 手撕MHA</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1909650875439387633">https://zhuanlan.zhihu.com/p/1909650875439387633</a></p>
<p>暂时别管</p>
<h3 id="4-看你除以了根号k-有什么作用">4. 看你除以了根号k 有什么作用</h3>
<h3 id="5-梯度消失和梯度爆炸-如何缓解">5. 梯度消失和梯度爆炸 如何缓解</h3>
<h3 id="6-QKV代表什么-说说理解">6. QKV代表什么 说说理解</h3>
<p>QKV 是 <strong>Query（查询）、Key（键）、Value（值）</strong> 的缩写，是 <strong>注意力机制（Attention Mechanism）</strong> 中的核心组成部分，尤其在 <strong>Transformer 模型</strong> 中被广泛使用。</p>
<p>基本理解</p>
<p>在注意力机制中，Q、K、V 用于计算输入序列中不同位置之间的相关性（即“注意力权重”），从而决定在处理某个位置时，应该“关注”序列中的哪些其他位置。</p>
<ul>
<li><strong>Query (Q)</strong>：代表当前要处理的元素的“查询向量”，用于与其他位置的 Key 进行匹配。</li>
<li><strong>Key (K)</strong>：代表序列中每个位置的“标识”或“索引”，用于与 Query 计算相似度。</li>
<li><strong>Value (V)</strong>：代表序列中每个位置实际携带的“信息内容”，最终加权求和时使用。</li>
</ul>
<p>工作流程（以自注意力为例）</p>
<ol>
<li>
<p>对输入序列中的每个 token，通过不同的线性变换（可学习的权重矩阵）分别得到对应的 Q、K、V 向量。</p>
</li>
<li>
<p>计算 Query 与所有 Key 的点积（通常除以 √d_k 以稳定梯度），得到注意力分数（未归一化的相关性）。</p>
\[
\text{Attention Scores} = \frac{QK^T}{\sqrt{d_k}}
\]

</li>
<li>
<p>对注意力分数应用 Softmax，得到归一化的注意力权重（表示每个位置对当前 token 的重要性）。</p>
</li>
<li>
<p>用这些权重对 Value 向量加权求和，得到最终的输出表示：</p>
\[
\text{Output} = \text{Softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right) V
\]

</li>
</ol>
<p>直观类比</p>
<p>可以类比为 <strong>信息检索系统</strong>：</p>
<ul>
<li>Query 是用户的搜索请求；</li>
<li>Key 是数据库中每条记录的索引或标签；</li>
<li>Value 是数据库中每条记录的实际内容；</li>
<li>系统根据 Query 与 Key 的匹配程度，从 Value 中提取最相关的信息。</li>
</ul>
<p>为什么需要 Q、K、V？</p>
<ul>
<li>如果直接用输入本身计算注意力，表达能力受限；</li>
<li>通过可学习的投影矩阵将输入映射到 Q、K、V 空间，模型能更灵活地学习“在什么情况下关注什么信息”。</li>
</ul>
<p>扩展：多头注意力（Multi-Head Attention）</p>
<p>Transformer 使用多个 QKV 投影头（即多组权重矩阵），并行计算多组注意力，最后拼接结果。这样可以让模型同时关注不同子空间中的信息（例如语法、语义、位置等）。</p>
<hr>
<p>总之，QKV 是注意力机制实现“动态加权信息聚合”的数学工具，是现代大模型（如 BERT、GPT、LLaMA 等）高效建模长距离依赖的关键。</p>
<h3 id="7-如果QK变成同一个矩阵你觉得有什么影响">7. 如果QK变成同一个矩阵你觉得有什么影响</h3>
<p>如果将 <strong>Query（Q）</strong> 和 <strong>Key（K）</strong> 设为<strong>同一个矩阵</strong>（即 ( Q = K )），会对注意力机制产生若干重要影响，既有理论上的含义，也有实际效果上的改变。下面我们从多个角度分析：</p>
<hr>
<ol>
<li><strong>注意力分数变成自相关（Self-Similarity）</strong></li>
</ol>
<p>原始注意力分数为：</p>
\[
A = QK^T
\]

<p>若 ( Q = K )，则变为：</p>
\[
A = QQ^T
\]

<p>这意味着注意力分数变成了 <strong>每个 token 与自身及其他 token 的内积（相似度）</strong>，即衡量 token 表示之间的<strong>自相似性</strong>。</p>
<ul>
<li>优点：计算更简单，参数减少（只需一个投影矩阵而非两个）。</li>
<li>缺点：<strong>Query 和 Key 的角色耦合</strong>，模型无法独立学习“如何查询”和“如何被查询”。</li>
</ul>
<hr>
<ol start="2">
<li><strong>对称性引入</strong></li>
</ol>
<p>由于 ( QQ^T ) 是<strong>对称矩阵</strong>，注意力权重矩阵（Softmax 后）也会近似对称（严格对称性被 Softmax 破坏，但结构上仍有对称倾向）。</p>
<ul>
<li>这意味着：<strong>token i 对 token j 的注意力 ≈ token j 对 token i 的注意力</strong>。</li>
<li>但在很多任务中，注意力应是非对称的。例如：
<ul>
<li>在 “I love cats” 中，“love” 应高度关注主语 “I” 和宾语 “cats”，但 “I” 不一定需要关注 “cats”。</li>
<li>对称注意力会<strong>限制模型表达方向性依赖关系的能力</strong>。</li>
</ul>
</li>
</ul>
<hr>
<ol start="3">
<li><strong>表达能力下降</strong></li>
</ol>
<p>Q 和 K 使用<strong>不同的可学习投影矩阵</strong>（( W_Q \neq W_K )）允许模型：</p>
<ul>
<li>从不同视角编码“查询意图”和“被查特征”；</li>
<li>学习更复杂的交互模式。</li>
</ul>
<p>强制 ( Q = K ) 相当于<strong>约束了模型的表示空间</strong>，可能降低其拟合复杂依赖的能力。</p>
<blockquote>
<p>类比：如果你只能用同一把钥匙既去“寻找锁”（Query）又去“代表自己是一把锁”（Key），灵活性远不如拥有两把可独立设计的钥匙。</p>
</blockquote>
<hr>
<ol start="4">
<li><strong>实际模型中的尝试</strong></li>
</ol>
<p>尽管标准 Transformer 使用独立的 ( W_Q ) 和 ( W_K )，但某些简化模型或特定场景中会共享参数：</p>
<ul>
<li><strong>Linear Transformer / Performer</strong> 等高效注意力变体有时会探索 Q=K 以降低计算；</li>
<li><strong>某些自监督预训练方法</strong>（如 BYOL、SimSiam）在对比学习中使用对称结构，但那是不同范式；</li>
<li><strong>实验表明</strong>：在多数 NLP 任务中，Q=K 会导致性能<strong>轻微到中度下降</strong>，尤其在需要精细依存分析的任务上（如机器翻译、阅读理解）。</li>
</ul>
<hr>
<ol start="5">
<li><strong>特殊情况：可能有益？</strong></li>
</ol>
<p>在某些对称性天然存在的任务中，Q=K 可能不是大问题，甚至有益：</p>
<ul>
<li>图神经网络（节点间关系对称）；</li>
<li>某些无向序列建模（如蛋白质序列的接触预测）；</li>
<li>极端压缩模型时，作为参数削减手段。</li>
</ul>
<hr>
<p>总结</p>
<table>
<thead>
<tr>
<th>方面</th>
<th>影响</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>计算</strong></td>
<td>略微简化，参数减少</td>
</tr>
<tr>
<td><strong>对称性</strong></td>
<td>引入（可能不希望的）对称注意力</td>
</tr>
<tr>
<td><strong>表达能力</strong></td>
<td>下降，难以建模非对称依赖</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>通常略有下降，特定场景可接受</td>
</tr>
</tbody>
</table>
<blockquote>
<p>✅ <strong>标准做法仍推荐使用独立的 Q 和 K 投影</strong>，除非有明确动机（如压缩、对称任务、理论研究）才考虑令 ( Q = K )。</p>
</blockquote>
<p>如果你在设计轻量化模型或探索新架构，可以尝试 Q=K 作为消融实验，但需谨慎评估任务是否容忍对称注意力。</p>
<h3 id="8-除了LoRA还有什么微调的方法">8. 除了LoRA还有什么微调的方法</h3>
<p>P Tuning</p>
<p>peft： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/636326003">https://zhuanlan.zhihu.com/p/636326003</a></p>
<ol>
<li>adapter(另外插入一个模块进去)</li>
<li>prefix tuning（在输入或者隐层添加多个可学习的前缀 tokens）</li>
<li>prompt tuning</li>
<li>lora</li>
</ol>
<p>Prefix Tuning 和 Prompt Tuning 都是面向大语言模型（LLM）的参数高效微调（Parameter-Efficient Fine-Tuning, PEFT）方法，它们通过在输入中添加可学习的“软提示”（soft prompts）来引导模型完成特定任务，而无需更新整个模型的参数。下面分别举例说明：</p>
<hr>
<ol>
<li><strong>Prefix Tuning</strong></li>
</ol>
<p><strong>核心思想</strong>：在输入序列的<strong>前面</strong>（或在每一层 Transformer 的 Key/Value 中）插入一组可学习的连续向量（称为 prefix），这些向量在训练中被优化，而原始模型参数保持冻结。</p>
<p><strong>举例</strong>（文本生成任务）：</p>
<p>假设我们有一个预训练的语言模型（如 GPT-2），想让它完成<strong>翻译任务</strong>（英文 → 法文）。</p>
<ul>
<li>
<p><strong>原始输入</strong>（普通提示）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Translate English to French: Hello →</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Prefix Tuning 的做法</strong>：</p>
<ul>
<li>在输入前面插入一串可学习的 embedding 向量（比如长度为 10 的向量序列）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[P1, P2, ..., P10] + [“Translate”, “English”, “to”, “French”, “:”, “Hello”, “→”]</span><br></pre></td></tr></table></figure>
</li>
<li>这些 <code>[P1...P10]</code> 不是真实词的 embedding，而是随机初始化、通过反向传播优化的<strong>连续向量</strong>。</li>
<li>训练时只更新这些 prefix 向量，语言模型本身冻结。</li>
<li>推理时，同样在输入前加上学习到的 prefix。</li>
</ul>
</li>
</ul>
<p><strong>特点</strong>：prefix 向量可以插入到 Transformer 的每一层（不仅输入层），对模型内部状态进行引导，效果通常优于仅修改输入。</p>
<hr>
<ol start="2">
<li><strong>Prompt Tuning</strong></li>
</ol>
<p><strong>核心思想</strong>：只在<strong>输入层</strong>添加可学习的 soft prompt tokens（也是连续向量），形式上更简单，是 Prefix Tuning 的简化版。</p>
<p><strong>举例</strong>（情感分类任务）：</p>
<ul>
<li>
<p><strong>任务</strong>：判断句子 “I love this movie!” 是正面还是负面情感。</p>
</li>
<li>
<p><strong>传统提示（hard prompt）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sentence: I love this movie! Sentiment:</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Prompt Tuning 的做法</strong>：</p>
<ul>
<li>用可学习的 soft tokens 替代或补充提示词。例如，在输入开头加 20 个可学习的 embedding：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[S1, S2, ..., S20] + [“Sentence”, “:”, “I”, “love”, “this”, “movie”, “!”, “Sentiment”, “:”]</span><br></pre></td></tr></table></figure>
</li>
<li>这些 <code>[S1...S20]</code> 是连续向量，通过训练优化，模型其余部分冻结。</li>
<li>最终让模型输出 “positive” 或 “negative”。</li>
</ul>
</li>
</ul>
<p><strong>特点</strong>：只修改输入 embedding 层，结构简单，参数更少。在大模型（如 T5-XXL）上效果接近全参数微调。</p>
<hr>
<p>简单对比</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>可学习位置</th>
<th>参数量</th>
<th>适用模型规模</th>
<th>复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>Prefix Tuning</td>
<td>所有层的 K/V 或输入前缀</td>
<td>中等</td>
<td>中到大模型</td>
<td>较高</td>
</tr>
<tr>
<td>Prompt Tuning</td>
<td>仅输入 embedding 层</td>
<td>很小</td>
<td><strong>超大模型</strong>（&gt;10B）</td>
<td>很低</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注：当模型足够大时（如 T5-11B），Prompt Tuning 的性能可接近全微调，而 Prefix Tuning 在中小模型上通常更优。</p>
</blockquote>
<hr>
<p>如果你有特定任务场景（如问答、摘要、代码生成等），我可以给出更具体的例子。</p>
<p>全参数微调</p>
<h2 id="模板6">模板6</h2>
<h3 id="你对-SFT（监督微调）中的-scaling-law-有了解吗？在实际训练中，你遇到过哪些比较大的困难？">你对 SFT（监督微调）中的 scaling law 有了解吗？在实际训练中，你遇到过哪些比较大的困难？</h3>
<p>其实主要是造数据。</p>
<p>训练上的困难其实还好，megatron封装好了很多东西，另外尝试跨机器训练但是因为模型本身比较小，也没用太多机器，不会出现超大规模训练的那种比如掉卡、容错、慢节点之类的问题</p>
<p>核心规律：数据、模型与性能的幂律关系</p>
<ol>
<li><strong>数据量与性能的关系</strong>：
<ul>
<li>当模型参数量固定时，模型性能随微调数据量的增加呈现<strong>幂律增长</strong>（即性能提升速度逐渐放缓）。</li>
<li>例如，在翻译任务中，数据量增加10倍可能带来BLEU分数5%的提升，但再增加10倍可能仅提升2%。</li>
<li><strong>关键结论</strong>：数据量并非越多越好，需与模型规模匹配，否则会进入收益递减阶段。</li>
</ul>
</li>
<li><strong>模型参数量与性能的关系</strong>：
<ul>
<li>当微调数据量固定时，模型性能随参数量的增加同样呈现<strong>幂律增长</strong>。</li>
<li>例如，8B模型的性能可能显著优于1B模型，但16B模型的提升幅度会缩小。</li>
<li><strong>关键结论</strong>：更大的模型能更好地利用微调数据，但需平衡计算成本。</li>
</ul>
</li>
<li><strong>联合Scaling（数据与模型同步放大）</strong>：
<ul>
<li>若同时增加模型参数量和微调数据量，性能提升最为显著。</li>
<li>例如，模型参数量增加8倍，数据量需同步增加5倍（比例约为N^0.74/D），才能避免过拟合惩罚。</li>
<li><strong>关键结论</strong>：数据与模型的同步放大是突破性能瓶颈的关键。</li>
</ul>
</li>
</ol>
<h3 id="在模型训练时，如果发现-advantage-或者-loss-突然变成-0，一般可能是什么原因导致的？">在模型训练时，如果发现 advantage 或者 loss 突然变成 0，一般可能是什么原因导致的？</h3>
<p>特殊场景处理</p>
<ul>
<li><strong>GRPO训练初期loss为0</strong>：这是正常现象，因为初始策略与参考策略一致
<ul>
<li>初始策略与参考策略完全一致，导致概率比（ratio）恒为 1，且参与计算Loss的优势函数、<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=264662292&amp;content_type=Article&amp;match_order=1&amp;q=KL%E6%95%A3%E5%BA%A6&amp;zhida_source=entity">KL散度</a>均为0，<strong>因此对于GRPO第一步的Loss一定为0</strong>。</li>
<li>过了第一步后，后续的前几步也可能为0，这个时候主要可能由于数值精度、LearningRate过低导致。</li>
</ul>
</li>
<li><strong>持续为0</strong>：需检查reward模型是否返回常数，或模型是否未正确更新</li>
</ul>
<h3 id="在构建-AI-Agent-时，它的记忆（Memory）机制通常是怎么设计的？">在构建 AI Agent 时，它的记忆（Memory）机制通常是怎么设计的？</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1940091301249909899">https://zhuanlan.zhihu.com/p/1940091301249909899</a></p>
<p>mem0开源版本去做的</p>
<p>提取：</p>
<ol>
<li>
<p>t时刻接收到user+assistant信息，触发提取。信息源有俩：</p>
<ol>
<li>保存在数据库的摘要S</li>
<li>具体每轮的对话内容mt-m,mt-m+1…mt-2。</li>
</ol>
<p>这里的摘要是全局的一个信息，对话的内容覆盖摘要没有的细节。提取环节是异步的，不阻塞主流程。</p>
<p>这里S和若干m构成一个prompt整体P，llm来抽取返回一组记忆Ω(w1,w2,w3…)</p>
</li>
</ol>
<p>更新：</p>
<ol>
<li>提取阶段后，对w2,w2,w3…做评估，保障记忆一致性，避免冗余。然后从向量数据库中提取s个相似度最高的记忆，和事实一起扔给llm，让llm决定操作：
<ol>
<li>add</li>
<li>update</li>
<li>delete</li>
<li>noop(啥都不做)</li>
</ol>
</li>
</ol>
<p>memg: mem0的带图版本</p>
<p>图结构在涉及细微关系语境的场景中更为有益，⽽不是简单的检索。对于多跳问题，Mem0 通过有效地整合多个会话中分散的信息，展现出明显的优势，证实了⾃然语⾔记忆为这些综合性任务提供了⾜够的表现⼒。Mem0g预期的关系优势并没有在这⾥转化为更好的结果，这表明在多步推理场景中导航更复杂的图结构时可能存在潜在的开销或冗余。</p>
<p>在时间推理⽅⾯，Mem0g显著优于其他⽅法，验证了结构化关系图在捕捉时间顺序和事件序列⽅⾯的优越性。明确的关系上下⽂显著增强了Mem0g的时间连贯性，超越了Mem0的密集记忆存储，凸显了在追踪时间敏感信息时精确关系表⽰的重要性。</p>
<p>总体⽽⾔，我们的分析表明 Mem0 和 Mem0g 在各种任务需求中具有互补的优势：基于密集⾃然语⾔的记忆在简单查询中提供了显著的效率，⽽明确的关系建模对于需要细微时间与上下⽂整合的任务变得⾄关重要。这些发现进⼀步强化了在 AI 代理部署中，根据特定推理语境量⾝定制灵活记忆结构的重要性。</p>
<h3 id="当模型出现-bad-case-时，你一般会怎么分析？后续会采取哪些措施来改进？">当模型出现 bad case 时，你一般会怎么分析？后续会采取哪些措施来改进？</h3>
<h3 id="如果需要为特定领域的文本训练一套-Embedding，你会怎么做？">如果需要为特定领域的文本训练一套 Embedding，你会怎么做？</h3>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/663835334/answer/1907642089266708585">https://www.zhihu.com/question/663835334/answer/1907642089266708585</a> 大模型的embedding层和专门的embedding模型</p>
<p>这里是qwen3 embedding模型架构、训练方法、数据策略：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1919807089414505767">https://zhuanlan.zhihu.com/p/1919807089414505767</a></p>
<p>为特定领域训练（或微调）Embedding 模型是提升 RAG 系统性能的“杀手锏”。当通用模型（如 OpenAI 的 <code>text-embedding-3-small</code> 或 BGE 系列）无法准确分辨你行业内的专业术语（如医学、法律、代码）时，定制化就变得至关重要。</p>
<p>以下是实现这一目标的专业路径，通常分为 <strong>“数据准备”</strong>、<strong>“对比学习微调”</strong> 和 <strong>“评估”</strong> 三个阶段：</p>
<hr>
<ol>
<li><strong>核心思路：对比学习 (Contrastive Learning)</strong></li>
</ol>
<p>目前主流的 Embedding 训练都采用对比学习。其核心逻辑是：<strong>拉近相关文本（正样本）的距离，推远无关文本（负样本）的距离。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2025/12/19/16BS2kqXnxNtdOi.png" alt="image.png"></p>
<hr>
<ol start="2">
<li><strong>具体实施步骤</strong></li>
</ol>
<p><strong>第一步：数据准备 (这是最难也最关键的一步)</strong></p>
<p>你需要构建三元组数据：<code>(Query, Positive, Negative)</code>。</p>
<ul>
<li><strong>正样本（Positive）：</strong> 与问题高度相关的文档片段。可以通过业务日志（用户点了哪个搜索结果）获取，或者利用 LLM（如 GPT-4）对文档块生成配套的问题。</li>
<li><strong>负样本（Negative）：</strong> * <strong>简单负样本：</strong> 随机抽取的无关文档。
<ul>
<li><strong>难负样本 (Hard Negatives)：</strong> 语义相似但答案错误的文档（例如：咨询“A产品的售后”，负样本可以是“B产品的售后”）。<strong>难负样本是提升模型区分度的关键。</strong></li>
</ul>
</li>
</ul>
<p><strong>第二步：选择基础模型</strong></p>
<p>不要从零开始（From Scratch），除非你有海量算力和数据。建议选择优秀的开源基座进行微调：</p>
<ul>
<li><strong>中文首选：</strong> <code>BAAI/bge-large-zh-v1.5</code> (目前中文社区公认的最强基座之一)。</li>
<li><strong>多语言/通用：</strong> <code>sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2</code> (轻量、快速)。</li>
</ul>
<p><strong>第三步：使用训练框架</strong></p>
<p>推荐使用 <strong>Sentence-Transformers</strong> 或 <strong>FlagEmbedding</strong> 框架，它们封装了复杂的损失函数。</p>
<p><strong>常用的 Loss Function：</strong></p>
<ul>
<li><strong>MultipleNegativesRankingLoss：</strong> 最常用，只需 <code>(Query, Positive)</code> 对，它会自动将同 Batch 内的其他正样本视为负样本。</li>
<li><strong>CoSENT (Cosine Sentence)：</strong> 在中文任务中表现非常稳定。</li>
</ul>
<hr>
<ol start="3">
<li>一个典型的训练流程 (Python 伪代码)</li>
</ol>
<p>Python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from sentence_transformers import SentenceTransformer, losses, InputExample</span><br><span class="line">from torch.utils.data import DataLoader</span><br><span class="line"></span><br><span class="line"># 1. 加载基座模型</span><br><span class="line">model = SentenceTransformer(&#x27;BAAI/bge-small-zh-v1.5&#x27;)</span><br><span class="line"></span><br><span class="line"># 2. 准备训练数据 (Query, Positive)</span><br><span class="line">train_examples = [</span><br><span class="line">    InputExample(texts=[&#x27;什么是分布式锁？&#x27;, &#x27;分布式锁是控制分布式系统之间同步访问共享资源的一种方式。&#x27;]),</span><br><span class="line">    # ... 更多行业数据</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 3. 定义 DataLoader 和 Loss</span><br><span class="line">train_dataloader = DataLoader(train_examples, shuffle=True, batch_size=16)</span><br><span class="line">train_loss = losses.MultipleNegativesRankingLoss(model)</span><br><span class="line"></span><br><span class="line"># 4. 开始微调</span><br><span class="line">model.fit(train_objectives=[(train_dataloader, train_loss)], epochs=3)</span><br></pre></td></tr></table></figure>
<hr>
<ol start="4">
<li>进阶技巧：无需人工标注的自监督预训练 (TSDAE)</li>
</ol>
<p>如果你完全没有“问题-文档”对，只有一堆行业论文或报告，可以使用 <strong>TSDAE (Transformer-based Denoising Auto-Encoder)</strong>。</p>
<ul>
<li><strong>原理：</strong> 给句子加噪声（删掉一些词），让模型尝试还原。</li>
<li><strong>效果：</strong> 这种方法能让模型迅速“学会”行业术语的语义特征，非常适合领域迁移。</li>
</ul>
<hr>
<ol start="5">
<li>如何评估效果？</li>
</ol>
<p>训练好后，绝对不能只看 Loss，要看业务指标：</p>
<ol>
<li><strong>Recall@K：</strong> 前 K 个检索结果中包含正确答案的比例。</li>
<li><strong>MRR (Mean Reciprocal Rank)：</strong> 正确答案排在第几位，越靠前分数越高。</li>
<li><strong>可视化：</strong> 使用 t-SNE 将向量降维投影，观察同类知识点是否真的聚拢在一起。</li>
</ol>
<hr>
<p><strong>建议：</strong> 在开始训练之前，可以先尝试使用 <strong>BGE 的微调脚本 (FlagEmbedding)</strong>，它支持“自动挖掘难负样本”的功能，这通常能比普通微调再提升 5%-10% 的精度。</p>
<p>你想针对哪个特定行业（如医疗、金融、工业控制）进行训练？我可以根据行业特性帮你细化负样本的筛选策略。</p>
<h3 id="你对大模型分布式训练的底层了解多少？比如数据并行（DP）、张量并行（TP）这些，看过-Megatron-这类框架的源码吗？">你对大模型分布式训练的底层了解多少？比如数据并行（DP）、张量并行（TP）这些，看过 Megatron 这类框架的源码吗？</h3>
<p>基础知识：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650234985">https://zhuanlan.zhihu.com/p/650234985</a></p>
<p>原理介绍：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650383289">https://zhuanlan.zhihu.com/p/650383289</a></p>
<p>megatron中的pipeline并行<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/432969288">https://zhuanlan.zhihu.com/p/432969288</a></p>
<p>代码结构：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650237820">https://zhuanlan.zhihu.com/p/650237820</a></p>
<p>并行设置：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650500590">https://zhuanlan.zhihu.com/p/650500590</a></p>
<p>张量并行：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650237833">https://zhuanlan.zhihu.com/p/650237833</a></p>
<p>流水线刷新机制：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/651341660">https://zhuanlan.zhihu.com/p/651341660</a></p>
<p>1F1B流水线并行负载不均衡：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/693425934">https://zhuanlan.zhihu.com/p/693425934</a></p>
<h3 id="核心代码模式算法题：二维数组中的查找">核心代码模式算法题：二维数组中的查找</h3>
<h2 id="50问">50问</h2>
<h3 id="1-大模型里应用强化学习时，状态，动作空间，动作都是什么">1. 大模型里应用强化学习时，状态，动作空间，动作都是什么</h3>
<p>在大模型（如大型语言模型，LLM）中应用强化学习（Reinforcement Learning, RL）时，通常会将语言生成任务建模为一个序列决策过程。典型的场景包括使用<strong>强化学习从人类反馈中学习（RLHF）</strong>。在这种设置下，强化学习的各个要素可解释如下：</p>
<hr>
<ol>
<li><strong>状态（State）</strong></li>
</ol>
<p>状态表示当前生成过程的上下文信息，通常包括：</p>
<ul>
<li><strong>历史生成的 token 序列</strong>（即已生成的部分输出）；</li>
<li><strong>输入 prompt</strong>（用户的问题、指令等）；</li>
<li><strong>可选的外部信息</strong>（如检索结果、对话历史等）。</li>
</ul>
<blockquote>
<p>在 RL 术语中，状态 ( s_t ) 通常是到时间步 ( t ) 为止的所有输入和已生成 token 的组合，用于决定下一步该生成什么。</p>
</blockquote>
<hr>
<ol start="2">
<li><strong>动作（Action）</strong></li>
</ol>
<p>动作是指模型在当前状态下选择的下一个 token（或 token 的分布）。</p>
<ul>
<li>在离散 token 空间中，动作空间就是**词汇表（vocabulary）**中的所有可能 token；</li>
<li>每次动作 ( a_t ) 就是从词汇表中选择一个 token 添加到输出序列中。</li>
</ul>
<blockquote>
<p>实际实现中，动作往往不是直接采样一个 token，而是从策略（policy）输出的概率分布中采样（如通过 softmax over logits）。</p>
</blockquote>
<hr>
<ol start="3">
<li><strong>动作空间（Action Space）</strong></li>
</ol>
<p>动作空间是所有可能动作的集合，在 LLM 中通常为：</p>
<ul>
<li><strong>离散且巨大的空间</strong>：大小等于词汇表大小（例如 50,000 或 100,000 个 token）；</li>
<li>通常用<strong>softmax over logits</strong>建模策略，即 ( \pi(a_t | s_t) = P(x_t | x_{&lt;t}, \text{prompt}) )。</li>
</ul>
<hr>
<ol start="4">
<li><strong>奖励（Reward）</strong></li>
</ol>
<p>虽然你没问，但这是 RL 的关键部分：</p>
<ul>
<li>奖励通常来自一个<strong>奖励模型（Reward Model）</strong>，该模型在 RLHF 中由人类偏好数据训练得到；</li>
<li>奖励在完整序列生成结束后给出（或使用中间奖励）；</li>
<li>在 PPO 等算法中，奖励用于调整策略，使模型更倾向于生成高奖励的序列。</li>
</ul>
<hr>
<p>示例：RLHF 中的完整流程</p>
<ol>
<li>**初始策略（SFT 模型）**生成多个回答；</li>
<li>人类对回答排序，训练<strong>奖励模型（RM）</strong>；</li>
<li>使用 RM 作为奖励函数，用 <strong>PPO</strong> 等算法微调语言模型；
<ul>
<li>状态：prompt + 已生成的 token；</li>
<li>动作：选择下一个 token；</li>
<li>动作空间：整个词汇表；</li>
<li>奖励：RM 对完整回答的打分。</li>
</ul>
</li>
</ol>
<hr>
<p>小结</p>
<table>
<thead>
<tr>
<th>RL 要素</th>
<th>在大模型中的对应含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>状态（State）</td>
<td>输入 prompt + 已生成的 token 序列</td>
</tr>
<tr>
<td>动作（Action）</td>
<td>选择下一个 token</td>
</tr>
<tr>
<td>动作空间</td>
<td>词汇表中的所有 token（离散、巨大）</td>
</tr>
</tbody>
</table>
<p>这种建模方式使得强化学习能够指导大模型生成更符合人类偏好的高质量文本。</p>
<h3 id="2-RLHF训练时，Reward-Model和LLM是同时训练还是先后训练，instruct-GPT论文里是如何训练RM的">2. <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=266637202&amp;content_type=Article&amp;match_order=1&amp;q=RLHF&amp;zhida_source=entity">RLHF</a>训练时，<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=266637202&amp;content_type=Article&amp;match_order=1&amp;q=Reward+Model&amp;zhida_source=entity">Reward Model</a>和LLM是同时训练还是先后训练，<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=266637202&amp;content_type=Article&amp;match_order=1&amp;q=instruct+GPT&amp;zhida_source=entity">instruct GPT</a>论文里是如何训练RM的</h3>
<p>在 <strong>InstructGPT</strong>（以及其前身 <strong>Learning to Summarize from Human Feedback</strong>）这类基于 <strong>RLHF（Reinforcement Learning from Human Feedback）</strong> 的方法中，<strong>RLHF 和 LLM（大语言模型）并不是同时训练的</strong>，而是采用<strong>分阶段、先后训练</strong>的方式。整个流程通常是 <strong>三阶段流水线（three-stage pipeline）</strong>。</p>
<hr>
<p>InstructGPT 的三阶段训练流程（依据原始论文：<em>Training language models to follow instructions with human feedback</em>, Ouyang et al., 2022）</p>
<p><strong>阶段 1：监督微调（Supervised Fine-Tuning, SFT）</strong></p>
<ul>
<li><strong>目标</strong>：获得一个初步对齐人类意图的模型。</li>
<li><strong>数据</strong>：人工标注的 prompt-response 对（例如，给定指令，专家写出理想回答）。</li>
<li><strong>方法</strong>：在预训练 LLM（如 GPT-3）基础上，用标准的监督学习进行微调。</li>
<li><strong>输出模型</strong>：<strong>SFT model</strong>（记作 (<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>π</mi><mtext>SFT</mtext></msup></mrow><annotation encoding="application/x-tex">\pi^{\text{SFT}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">SFT</span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
)）。</li>
</ul>
<blockquote>
<p>🔹 此阶段不涉及强化学习或奖励模型，纯监督学习。</p>
</blockquote>
<hr>
<p><strong>阶段 2：训练奖励模型（Reward Model, RM）</strong></p>
<ul>
<li><strong>目标</strong>：训练一个能预测人类偏好的标量奖励函数 ( r(x, y) )，其中 ( x ) 是 prompt，( y ) 是模型生成的回答。</li>
<li><strong>数据来源</strong>：
<ul>
<li>使用 <strong>SFT model</strong>（或有时用原始 GPT）对同一个 prompt 生成 <strong>多个（通常 4~9 个）不同回答</strong>；</li>
<li>人类标注员对这些回答进行 <strong>两两比较（pairwise ranking）</strong>，选出更优的一个；</li>
<li>得到大量 <strong>(prompt, chosen, rejected)</strong> 三元组。</li>
</ul>
</li>
<li><strong>训练方法</strong>：
<ul>
<li>奖励模型（通常是一个去掉语言建模头的 SFT 模型变体）为每个回答 ( y ) 输出一个标量分数 ( r(x, y) )；</li>
<li>使用 <strong>Bradley-Terry 模型</strong> 最大化偏好概率：<br>
[<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="script">L</mi><mtext>RM</mtext></msub><mo>=</mo><mo>−</mo><mi>log</mi><mo>⁡</mo><mi>σ</mi><mrow><mo fence="true">(</mo><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>y</mi><mtext>chosen</mtext></msub><mo stretchy="false">)</mo><mo>−</mo><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>y</mi><mtext>rejected</mtext></msub><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{L}_{\text{RM}} = -\log \sigma \left( r(x, y_{\text{chosen}}) - r(x, y_{\text{rejected}}) \right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">RM</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">chosen</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">rejected</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p>
]</li>
<li>即：让“chosen”回答的奖励高于“rejected”回答。</li>
</ul>
</li>
<li><strong>输出</strong>：<strong>奖励模型 RM</strong>。</li>
</ul>
<blockquote>
<p>🔹 注意：RM 是<strong>独立训练的</strong>，不与语言模型联合训练；它只用于下一阶段提供奖励信号。</p>
</blockquote>
<hr>
<p><strong>阶段 3：强化学习微调（RL Fine-Tuning）</strong></p>
<ul>
<li><strong>目标</strong>：用 RM 作为奖励函数，通过 RL（如 PPO）进一步优化语言模型策略。</li>
<li><strong>方法</strong>：
<ul>
<li>以 <strong>SFT model 作为初始策略 ( \pi_{\theta} )</strong>；</li>
<li>对每个 prompt ( x )：
<ul>
<li>从当前策略 (<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>π</mi><mi>θ</mi></msub></mrow><annotation encoding="application/x-tex">\pi_{\theta}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
) 采样一个回答 (<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>∼</mo><msub><mi>π</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y \sim \pi_{\theta}(y|x)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></p>
)；</li>
<li>用 RM 计算奖励 ( r(x, y) )；</li>
<li>使用 <strong>PPO（Proximal Policy Optimization）</strong> 算法更新策略，最大化奖励；</li>
</ul>
</li>
<li>同时加入 <strong>KL 散度正则项</strong>，防止模型偏离 SFT 太远（避免过拟合 RM 或生成无意义高分文本）。</li>
</ul>
</li>
<li><strong>损失函数</strong>（简化）：<br>
[<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi mathvariant="script">L</mi><mtext>RL</mtext></msup><mo>=</mo><mi mathvariant="double-struck">E</mi><mrow><mo fence="true">[</mo><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>−</mo><mi>β</mi><mo>⋅</mo><mtext>KL</mtext><mo stretchy="false">(</mo><msub><mi>π</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo><mo>∥</mo><msup><mi>π</mi><mtext>SFT</mtext></msup><mo stretchy="false">(</mo><mi>y</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{L}^{\text{RL}} = \mathbb{E} \left[ r(x, y) - \beta \cdot \text{KL}(\pi_{\theta}(y|x) \parallel \pi^{\text{SFT}}(y|x)) \right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathcal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">RL</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2413em;vertical-align:-0.35em;"></span><span class="mord mathbb">E</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord text"><span class="mord">KL</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">SFT</span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span></span></span></span></span></p>
]</li>
</ul>
<blockquote>
<p>🔹 此阶段才是真正的“RLHF”：用人类反馈（通过 RM 体现）指导 RL 训练。</p>
</blockquote>
<hr>
<p>回答你的两个问题：</p>
<p>Q1: <strong>RLHF 和 LLM 是同时训练还是先后训练？</strong></p>
<p>✅ <strong>先后训练</strong>。整个流程是<strong>顺序的三阶段</strong>：</p>
<ol>
<li>先微调 LLM → SFT model；</li>
<li>再训练 RM（用 SFT 生成的数据 + 人类偏好）；</li>
<li>最后用 RM 作为奖励，对 LLM 做 RL 微调。</li>
</ol>
<blockquote>
<p>❌ 不是端到端联合训练，也不是同时训练 RM 和策略。</p>
</blockquote>
<hr>
<p>Q2: <strong>InstructGPT 论文中是如何训练 RM 的？</strong></p>
<ul>
<li>使用 <strong>SFT model 生成多个回答</strong>；</li>
<li>人类对回答做 <strong>两两偏好标注</strong>（chosen vs. rejected）；</li>
<li>用这些 <strong>偏好数据</strong> 训练一个 <strong>标量奖励模型</strong>，目标是让 chosen 的奖励 &gt; rejected 的奖励；</li>
<li>损失函数基于 <strong>Bradley-Terry 偏好模型</strong>（即对数 sigmoid 差值）；</li>
<li>RM 架构通常基于 SFT 模型（冻结某些层或共享主干）。</li>
</ul>
<hr>
<p>补充说明</p>
<ul>
<li><strong>RM 不是语言模型</strong>：它不生成文本，只输出一个分数；</li>
<li><strong>RL 阶段仍依赖 SFT 模型</strong>：用于 KL 正则项，保持生成质量；</li>
<li><strong>人类反馈只用于阶段 2</strong>：一旦 RM 训好，RL 阶段就无需人工参与。</li>
</ul>
<hr>
<p>这种分阶段设计使得 RLHF 在工程上可行，同时有效结合了<strong>人类偏好信号</strong>与<strong>大规模语言生成能力</strong>。</p>
<h3 id="3-训练RM时，无论是instruct-GPT还是DPO，-为什么loss里有log和sigmod函数？-直接用reward相减不行吗？">3. 训练RM时，无论是instruct GPT还是<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=266637202&amp;content_type=Article&amp;match_order=1&amp;q=DPO&amp;zhida_source=entity">DPO</a>， 为什么loss里有log和sigmod函数？ 直接用reward相减不行吗？</h3>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/1964058546414003939/answer/1964366564519285912">https://www.zhihu.com/question/1964058546414003939/answer/1964366564519285912</a></p>
<p><strong>训练RM时使用log和sigmoid函数是为了将人类相对偏好转化为可优化的概率目标，直接用reward相减无法有效引导模型学习。</strong></p>
<p>核心原因在于人类偏好数据的特性与优化目标的数学合理性：</p>
<p>一、为什么必须用sigmoid函数？</p>
<ol>
<li>
<p><strong>将分数差映射为概率</strong><br>
人类标注的是相对偏好（A比B好），而非绝对分数。sigmoid函数能将两个回答的分数差 s_chosen - s_rejected 压缩到[0,1]区间，对应&quot;模型预测人类偏好chosen的概率&quot;：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mtext>chosen</mtext><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mtext>chosen</mtext></msub><mo>−</mo><msub><mi>s</mi><mtext>rejected</mtext></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mo stretchy="false">(</mo><msub><mi>s</mi><mtext>chosen</mtext></msub><mo>−</mo><msub><mi>s</mi><mtext>rejected</mtext></msub><mo stretchy="false">)</mo></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">P(\text{chosen}) = \sigma(s_{\text{chosen}} - s_{\text{rejected}}) = \frac{1}{1 + e^{-(s_{\text{chosen}} - s_{\text{rejected}})}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord text"><span class="mord">chosen</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">chosen</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">rejected</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1306em;vertical-align:-0.8092em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.2742em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8358em;"><span style="top:-3.0108em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">chosen</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">rejected</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2901em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8092em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>当 s_chosen &gt; s_rejected 时，概率接近1；反之接近0，完美匹配人类比较的二分类本质。</p>
</li>
<li>
<p><strong>避免绝对分数依赖</strong><br>
人类难以给出一致的绝对评分（如&quot;这个回答值7.5分&quot;），但擅长比较。sigmoid仅关注分数的相对差异，与绝对数值无关（例如 s_chosen=5, s_rejected=3 和 s_chosen=105, s_rejected=103 会得到相同概率）。</p>
</li>
</ol>
<p>二、为什么需要log函数？</p>
<ol>
<li>
<p><strong>最大化正确预测的对数似然</strong><br>
log函数将概率转化为可加性损失，符合最大似然估计（MLE）框架。损失函数定义为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Loss</mtext><mo>=</mo><mo>−</mo><mi>log</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mtext>chosen</mtext></msub><mo>−</mo><msub><mi>s</mi><mtext>rejected</mtext></msub><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{Loss} = -\log\left( \sigma(s_{\text{chosen}} - s_{\text{rejected}}) \right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">Loss</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">chosen</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">rejected</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p>
<p>当模型预测正确时（概率接近1），log值接近0；预测错误时（概率接近0），log值趋向负无穷，损失急剧增大，迫使模型优化参数。</p>
</li>
<li>
<p><strong>梯度稳定且可解释</strong><br>
log-sigmoid组合的梯度具有良好性质：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mtext>Loss</mtext></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>s</mi><mtext>chosen</mtext></msub></mrow></mfrac><mo>=</mo><mo>−</mo><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mtext>chosen</mtext></msub><mo>−</mo><msub><mi>s</mi><mtext>rejected</mtext></msub><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\frac{\partial \text{Loss}}{\partial s_{\text{chosen}}} = - \left(1 - \sigma(s_{\text{chosen}} - s_{\text{rejected}})\right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.2074em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">chosen</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord text"><span class="mord">Loss</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">chosen</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">rejected</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p>
<p>梯度大小与预测错误程度正相关，且始终在[-1,1]区间内，避免梯度爆炸。</p>
</li>
</ol>
<p>三、直接用reward相减的问题</p>
<p>如果采用简单的L1损失 Loss = |(s_chosen - s_rejected) - 1|（假设目标是让差为1），会导致：</p>
<ol>
<li><strong>缺乏概率意义</strong><br>
无法将分数差与人类选择概率关联，模型难以理解优化目标。</li>
<li><strong>梯度不稳定</strong><br>
当分数差远大于1时，梯度会持续推动分数无限增大（如 s_chosen=1000, s_rejected=1），导致模型参数发散。</li>
<li><strong>对异常值敏感</strong><br>
若某样本的标注错误导致 s_chosen &lt; s_rejected，简单相减会产生巨大损失，破坏整体训练稳定性。</li>
</ol>
<p>四、本质：拟合Bradley-Terry模型</p>
<p>整个设计源于<strong>Bradley-Terry模型</strong>，该模型假设两个选项的选择概率仅依赖其质量分数的相对差异： 选择而非 log-sigmoid损失正是该模型的负对数似然，完美契合人类偏好数据的比较特性。</p>
<p><strong>总结</strong>：log和sigmoid函数的组合是将离散的人类偏好转化为连续优化目标的关键桥梁，既保证了概率解释性，又确保了训练稳定性。直接相减的损失函数无法满足这些要求，会导致模型训练失败。</p>
<h3 id="4-RLHF-指openai-instruct-GPT论文中-，训练LLM的损失函数是什么？">4. RLHF(指openai instruct GPT论文中)，训练LLM的损失函数是什么？</h3>
<h3 id="5-了解RLHF-PPO吗，里面需要训练几个模型，加载几个模型">5. 了解RLHF-<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=266637202&amp;content_type=Article&amp;match_order=1&amp;q=PPO&amp;zhida_source=entity">PPO</a>吗，里面需要训练几个模型，加载几个模型</h3>
<p>PPO和PPO2，一个基于kl penalty一个基于clip <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/538486008">https://zhuanlan.zhihu.com/p/538486008</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1921699623363388138">https://zhuanlan.zhihu.com/p/1921699623363388138</a></p>
<p>重要性采样</p>
<p>PPO GRPO 强化学习全流程：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1981324776086721831">https://zhuanlan.zhihu.com/p/1981324776086721831</a></p>
<p>PPO训练中需要训练2个模型，加载4个模型</p>
<p><strong>PPO训练的核心模型构成</strong></p>
<p>在PPO训练框架中，理论上存在4个核心模型：</p>
<ol>
<li><strong>Actor模型</strong>（需训练）
<ul>
<li><strong>角色</strong>：主角模型，即我们最终要优化的大语言模型（LLM）。</li>
<li><strong>任务</strong>：根据用户输入生成回答，通过PPO算法更新参数，使其输出更符合人类偏好。</li>
</ul>
</li>
<li><strong>Reference Model（参考模型）</strong>（冻结参数）
<ul>
<li><strong>角色</strong>：SFT（监督微调）后的原始模型副本。</li>
<li><strong>任务</strong>：作为约束，通过计算KL散度（衡量新策略与原始策略的差异）防止Actor模型过度优化而偏离基础语言能力。</li>
</ul>
</li>
<li><strong>Reward Model（奖励模型）</strong>（冻结参数）
<ul>
<li><strong>角色</strong>：人类偏好的“判卷人”。</li>
<li><strong>任务</strong>：对Actor生成的完整回答打分（如8.0分），将抽象的人类偏好转化为可计算的奖励信号。</li>
</ul>
</li>
<li><strong>Critic Model（价值模型）</strong>（需训练）
<ul>
<li><strong>角色</strong>：状态价值评估器。</li>
<li><strong>任务</strong>：预测每个token生成时的状态价值（即当前token到序列结束的期望回报），用于计算优势函数（Advantage），减少训练方差。</li>
</ul>
</li>
</ol>
<h3 id="6-RLHF-PPO里，reward的设计是什么，GAE是什么">6. RLHF-PPO里，reward的设计是什么，GAE是什么</h3>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/1900547615495545054/answer/1982243985448777023">https://www.zhihu.com/question/1900547615495545054/answer/1982243985448777023</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1885633225205998104">https://zhuanlan.zhihu.com/p/1885633225205998104</a></p>
<p><strong>TD残差（Temporal Difference Error）</strong>：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>δ</mi><mi>t</mi></msub><mo>=</mo><msub><mi>r</mi><mi>t</mi></msub><mo>+</mo><mi>γ</mi><mi>V</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>−</mo><mi>V</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta_t = r_t + \gamma V(s_{t+1}) - V(s_t)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">γV</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p><strong>GAE:</strong></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mtext>Adv</mtext><mi>t</mi></msub><mo>=</mo><msub><mi>δ</mi><mi>t</mi></msub><mo>+</mo><mi>γ</mi><mi>λ</mi><mo>⋅</mo><msub><mtext>Adv</mtext><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Adv}_t = \delta_t + \gamma \lambda \cdot \text{Adv}_{t+1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Adv</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">γλ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9028em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord text"><span class="mord">Adv</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong>回报（Returns）:</strong></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>R</mi><mi>t</mi></msub><mo>=</mo><msub><mtext>Adv</mtext><mi>t</mi></msub><mo>+</mo><mi>V</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R_t = \text{Adv}_t + V(s_t)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Adv</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>回报的理解：“从状态 st执行动作 at获得的总回报”，等于“该动作相比平均表现的优势”加上“该状态本身的平均价值”。</p>
<p>PPO <strong>不直接优化 reward，而是优化 advantage（优势函数）</strong></p>
<p>而 Advt 的计算依赖于 <strong>TD 误差</strong>，TD 误差又依赖于 <strong>reward</strong> 和 <strong>价值函数 V(s)</strong>：</p>
<table>
<thead>
<tr>
<th>误区</th>
<th>正确理解</th>
</tr>
</thead>
<tbody>
<tr>
<td>“reward 是每个词的分数”</td>
<td>通常是<strong>整个回答</strong>的分数，再分配到序列</td>
</tr>
<tr>
<td>“PPO 直接最大化 reward”</td>
<td>实际是最大化 <strong>reward 减去 baseline（即 Advantage）</strong>，以降低方差</td>
</tr>
<tr>
<td>“reward 是固定的”</td>
<td>在 RLHF 中，RM 是固定的；但在环境交互中，reward 是动态的</td>
</tr>
</tbody>
</table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.zhimg.com/v2-82a87f6ea305d3acd1b8fa425549e44e_1440w.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic4.zhimg.com/v2-2992f38defc01646da32c2e8d62f3603_1440w.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.zhimg.com/v2-49b491a129ed4bcefc6c1ebbf09da23e_1440w.jpg" alt="img"></p>
<h3 id="7-RLHF-PPO训练的损失函数公式">7. RLHF-PPO训练的损失函数公式</h3>
<ul>
<li><strong>策略更新</strong>：利用优势函数 <code>A</code> 作为梯度方向指引，结合策略梯度算法（如 PPO 的损失函数优化 <code>Policy Model</code>，让策略更倾向产生高优势的动作。</li>
<li><strong>价值网络更新</strong>：通过最小化 “价值估计 <code>v</code> 与实际累计奖励（含 GAE 修正 ）” 的误差（如 MSE 损失 ），更新 <code>Value Model</code>，提升价值预估精度，为后续优势计算提供可靠基准。</li>
</ul>
<p>RLHF-PPO训练的损失函数由<strong>策略损失(Policy Loss)</strong>、**价值函数损失(Value Loss)<strong>和</strong>熵正则化项(Entropy Regularization)**三部分组成，其核心目标是在最大化奖励的同时保持策略更新的稳定性。</p>
<p>一、核心损失函数公式</p>
<p><strong>总损失函数</strong>：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Total Loss</mtext><mo>=</mo><mtext>Policy Loss</mtext><mo>+</mo><mtext>Value Loss</mtext><mo>−</mo><mi>β</mi><mo>×</mo><mtext>Entropy</mtext></mrow><annotation encoding="application/x-tex">\text{Total Loss} = \text{Policy Loss} + \text{Value Loss} - \beta \times \text{Entropy}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">Total Loss</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Policy Loss</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord">Value Loss</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Entropy</span></span></span></span></span></span></p>
<ol>
<li><strong>策略损失（Policy Loss）</strong></li>
</ol>
<p>策略损失是PPO的核心，用于优化策略模型（Actor）以最大化奖励。它通过<strong>裁剪机制</strong>限制策略更新幅度，防止训练不稳定。</p>
<p><strong>公式</strong>：</p>
<p>(这个公式里面的GAE部分用动态规划的方式去计算)</p>
<p>advantages： 老策略中，response部分每个token对应的优势（这个是固定的，不随actor实时更新而改变）</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Policy Loss</mtext><mo>=</mo><mo>−</mo><mi mathvariant="double-struck">E</mi><mrow><mo fence="true">[</mo><mi>min</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mrow><msub><mi>π</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>π</mi><msub><mi>θ</mi><mtext>old</mtext></msub></msub><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>s</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>⋅</mo><mi>A</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>  </mtext><mtext>clip</mtext><mrow><mo fence="true">(</mo><mfrac><mrow><msub><mi>π</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>π</mi><msub><mi>θ</mi><mtext>old</mtext></msub></msub><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>s</mi><mo stretchy="false">)</mo></mrow></mfrac><mo separator="true">,</mo><mn>1</mn><mo>−</mo><mi>ϵ</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>ϵ</mi><mo fence="true">)</mo></mrow><mo>⋅</mo><mi>A</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\text{Policy Loss} = -\mathbb{E} \left[ \min\left( \frac{\pi_{\theta}(a|s)}{\pi_{\theta_{\text{old}}}(a|s)} \cdot A(s, a),\; \text{clip}\left( \frac{\pi_{\theta}(a|s)}{\pi_{\theta_{\text{old}}}(a|s)}, 1 - \epsilon, 1 + \epsilon \right) \cdot A(s, a) \right) \right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Policy Loss</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord">−</span><span class="mord mathbb">E</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mop">min</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2559em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9419em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">clip</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2559em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9419em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">ϵ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">ϵ</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p>
<ul>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>π</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{\theta}(a|s)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></span></p>
<p>：当前策略模型在状态下采取动作的概率</p>
</li>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>π</mi><msub><mi>θ</mi><mtext>old</mtext></msub></msub><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{\theta_{\text{old}}}(a|s)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0059em;vertical-align:-0.2559em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2559em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></span></p>
<p>：旧策略模型（更新前）的概率</p>
</li>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(s, a)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span></span></p>
<p>：优势函数（Advantage Function），表示动作的收益高于平均水平的程度</p>
</li>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span></span></p>
<p>：裁剪系数（通常取0.2），限制策略更新幅度</p>
</li>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>min</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\min
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mop">min</span></span></span></span></span></p>
<p>操作：确保策略更新不会过于激进</p>
</li>
</ul>
<p><strong>直观理解</strong>：</p>
<ul>
<li>当A(s, a)优势时，增大该动作的概率；反之则减小</li>
<li>裁剪机制防止策略更新幅度过大（如超过20%），保证训练稳定性</li>
</ul>
<ol start="2">
<li><strong>价值函数损失（Value Loss）</strong></li>
</ol>
<p>价值函数损失用于优化价值模型（Critic），使其更准确地预测状态价值。</p>
<p><strong>公式</strong>：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Value Loss</mtext><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi mathvariant="double-struck">E</mi><mrow><mo fence="true">[</mo><msup><mrow><mo fence="true">(</mo><msub><mi>V</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>−</mo><msup><mi>V</mi><mtext>target</mtext></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow><mn>2</mn></msup><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\text{Value Loss} = \frac{1}{2} \mathbb{E} \left[ \left( V_{\theta}(s) - V^{\text{target}}(s) \right)^2 \right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">Value Loss</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathbb">E</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">[</span></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8436em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">target</span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.054em;"><span style="top:-3.3029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">]</span></span></span></span></span></span></span></p>
<p><strong>参数解释</strong>：</p>
<ul>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>V</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_{\theta}(s)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></span></p>
<p>：当前价值模型预测的状态的价值</p>
</li>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>V</mi><mtext>target</mtext></msup></mrow><annotation encoding="application/x-tex">V^{\text{target}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8436em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8436em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">target</span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>：目标价值（通常由奖励模型或蒙特卡洛方法计算）</p>
</li>
</ul>
<p><strong>直观理解</strong>：</p>
<ul>
<li>
<p>通过最小化预测值与目标值的均方误差，让价值模型更准确地评估状态价值</p>
</li>
<li>
<p>为进一步稳定训练，实际实现中常对价值函数也进行裁剪：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>V</mi><mtext>clipped</mtext></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>V</mi><msub><mi>θ</mi><mtext>old</mtext></msub></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>+</mo><mtext>clip</mtext><mrow><mo fence="true">(</mo><msub><mi>V</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>V</mi><msub><mi>θ</mi><mtext>old</mtext></msub></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>  </mtext><mo>−</mo><msub><mi>ϵ</mi><mi>v</mi></msub><mo separator="true">,</mo><mtext>  </mtext><msub><mi>ϵ</mi><mi>v</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">V_{\text{clipped}}(s) = V_{\theta_{\text{old}}}(s) + \text{clip}\left( V_{\theta}(s) - V_{\theta_{\text{old}}}(s),\; -\epsilon_v,\; \epsilon_v \right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">clipped</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0059em;vertical-align:-0.2559em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2559em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0059em;vertical-align:-0.2559em;"></span><span class="mord text"><span class="mord">clip</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2559em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathnormal">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p>
<p>然后取原始损失和裁剪损失的最大值：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Value Loss</mtext><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi mathvariant="double-struck">E</mi><mrow><mo fence="true">[</mo><mi>max</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><msup><mrow><mo fence="true">(</mo><msub><mi>V</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>−</mo><msup><mi>V</mi><mtext>target</mtext></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow><mn>2</mn></msup><mo separator="true">,</mo><mtext>  </mtext><msup><mrow><mo fence="true">(</mo><msub><mi>V</mi><mtext>clipped</mtext></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>−</mo><msup><mi>V</mi><mtext>target</mtext></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow><mn>2</mn></msup><mo fence="true">)</mo></mrow><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\text{Value Loss} = \frac{1}{2} \mathbb{E} \left[ \max\left( \left( V_{\theta}(s) - V^{\text{target}}(s) \right)^2,\; \left( V_{\text{clipped}}(s) - V^{\text{target}}(s) \right)^2 \right) \right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">Value Loss</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathbb">E</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">[</span></span><span class="mop">max</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8436em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">target</span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.054em;"><span style="top:-3.3029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">clipped</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8436em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">target</span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.054em;"><span style="top:-3.3029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">]</span></span></span></span></span></span></span></p>
</li>
</ul>
<ol start="3">
<li><strong>熵正则化项（Entropy Regularization）</strong></li>
</ol>
<p>熵正则化项用于鼓励策略探索，防止过早收敛到局部最优。</p>
<p><strong>公式</strong>：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Entropy</mtext><mo>=</mo><mo>−</mo><mi mathvariant="double-struck">E</mi><mrow><mo fence="true">[</mo><munder><mo>∑</mo><mi>a</mi></munder><msub><mi>π</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>s</mi><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><msub><mi>π</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>s</mi><mo stretchy="false">)</mo><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\text{Entropy} = -\mathbb{E} \left[ \sum_a \pi_{\theta}(a|s) \log \pi_{\theta}(a|s) \right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Entropy</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord">−</span><span class="mord mathbb">E</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">[</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.9em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">]</span></span></span></span></span></span></span></p>
<p><strong>直观理解</strong>：</p>
<ul>
<li>熵越大，策略的随机性越强，探索性越好</li>
<li>通过在总损失中减去熵项（乘以系数β），鼓励模型保持一定的探索性</li>
</ul>
<p>二、关键概念解析</p>
<ol>
<li>优势函数（Advantage Function）</li>
</ol>
<p>优势函数衡量在状态下采取动作的收益高于平均水平的程度，是策略更新的核心依据。</p>
<p><strong>公式</strong>：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>−</mo><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(s, a) = Q(s, a) - V(s)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Q</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></span></p>
<p>其中：</p>
<ul>
<li>Q(s, a)：状态下采取动作的动作价值</li>
<li>V(s)：状态的状态价值</li>
</ul>
<p><strong>实际计算</strong>： 在RLHF中，优势函数通常通过**广义优势估计（GAE）**计算：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mover accent="true"><mi>A</mi><mo>^</mo></mover><mi>t</mi><mrow><mtext>GAE</mtext><mo stretchy="false">(</mo><mi>γ</mi><mo separator="true">,</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>0</mn></mrow><mi mathvariant="normal">∞</mi></munderover><mo stretchy="false">(</mo><mi>γ</mi><mi>λ</mi><msup><mo stretchy="false">)</mo><mi>l</mi></msup><msub><mi>δ</mi><mrow><mi>t</mi><mo>+</mo><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\hat{A}_t^{\text{GAE}(\gamma,\lambda)} = \sum_{l=0}^{\infty} (\gamma \lambda)^l \delta_{t+l}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2906em;vertical-align:-0.2458em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4542em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">GAE</span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.05556em;">γ</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">λ</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2458em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9535em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">γλ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中：</p>
<ul>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>δ</mi><mi>t</mi></msub><mo>=</mo><msub><mi>r</mi><mi>t</mi></msub><mo>+</mo><mi>γ</mi><mi>V</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>−</mo><mi>V</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta_t = r_t + \gamma V(s_{t+1}) - V(s_t)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">γV</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>（TD误差）</p>
</li>
<li>
<p>：折扣因子（通常取0.99）</p>
</li>
<li>
<p>：GAE系数（通常取0.95）</p>
</li>
</ul>
<ol start="2">
<li>KL散度约束</li>
</ol>
<p>为防止策略更新过于激进，PPO还会监控当前策略与旧策略之间的KL散度：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>KL</mtext><mo stretchy="false">(</mo><msub><mi>π</mi><mi>θ</mi></msub><mo>∥</mo><msub><mi>π</mi><msub><mi>θ</mi><mtext>old</mtext></msub></msub><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="double-struck">E</mi><mrow><mo fence="true">[</mo><mi>log</mi><mo>⁡</mo><mfrac><mrow><msub><mi>π</mi><msub><mi>θ</mi><mtext>old</mtext></msub></msub><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>π</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>s</mi><mo stretchy="false">)</mo></mrow></mfrac><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\text{KL}(\pi_{\theta} \parallel \pi_{\theta_{\text{old}}}) = \mathbb{E} \left[ \log \frac{\pi_{\theta_{\text{old}}}(a|s)}{\pi_{\theta}(a|s)} \right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">KL</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0059em;vertical-align:-0.2559em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2559em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord mathbb">E</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0278em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2559em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p>
<p>当KL散度超过阈值（如0.01）时，会提前终止当前迭代，保证训练稳定性。</p>
<h3 id="8-你知道DPO的损失函数公式吗？">8. 你知道DPO的损失函数公式吗？</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1904847799243220274">https://zhuanlan.zhihu.com/p/1904847799243220274</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic4.zhimg.com/v2-b7a5b97ad3534a3df9ad32f3740e7dd1_1440w.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic3.zhimg.com/v2-0f622dc22d690bc797d5f27d0a41fe26_1440w.jpg" alt="img"></p>
<p>要让公式4结果最小</p>
<p>log里面上下两个的分布要一样</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic3.zhimg.com/v2-715dcfe51196f3e08ef07b84bc7e3660_1440w.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/v2-cf553faf48f9178717ff86f12e97c297_1440w.jpg" alt="img"></p>
<p>最终：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic3.zhimg.com/v2-73d2820a0eee27c734e7b934c0a0c0e6_1440w.jpg" alt="img"></p>
<h3 id="9-DPO的reward是什么，会不会出现reward-hacking？有哪些解决方法？">9. DPO的reward是什么，会不会出现reward hacking？有哪些解决方法？</h3>
<p>DPO（Direct Preference Optimization）的奖励机制基于偏好数据，它通过比较chosen（优选）和rejected（被拒绝）回答来优化模型。具体来说，DPO的reward计算公式为：</p>
[ \text{DPO reward} = \log\left(\frac{p(y_w)}{p(y_l)}\right) \]

<p>其中，( p(y_w) ) 是chosen回答的概率，( p(y_l) ) 是rejected回答的概率。这个公式旨在最大化chosen回答相对于rejected回答的相对概率，而不是绝对概率。</p>
<p><strong>DPO用reward和token出现概率乘积的期望作为Value function</strong>。理论上等同于reward模型。</p>
<p>关于reward hacking，理论上在DPO中也可能发生，尤其是在偏好数据集不完善或模型学习到的策略与人类偏好不完全一致时。例如，模型可能学会生成特定的关键词或模式，这些模式在偏好数据集中被高估，但实际上不反映人类的真正偏好。</p>
<p>解决方法包括：</p>
<ol>
<li><strong>改进偏好数据集</strong>：确保偏好数据集的<strong>多样性和质量</strong>，避免数据偏见，减少reward hacking的可能性。</li>
<li>引入正则化**：在训练过程中加入正则项，防止模型过于依赖某些特定的特征或模式。 **</li>
<li><strong>使用更复杂的奖励模型</strong>：比如KTO（Kullback-Leibler Alignment），它优化的是chosen策略本身，而不是相对差异，可能更不容易受到reward hacking的影响。</li>
<li><strong>动态调整奖励参数</strong>：根据训练过程中的表现动态调整beta值，以适应不同的训练阶段。</li>
<li><strong>结合人类反馈</strong>：在训练过程中定期引入人类反馈，确保模型学习到的策略符合人类的真正偏好。</li>
</ol>
<p>通过这些方法，可以有效减少reward hacking的发生，提升模型对齐人类偏好的能力。</p>
<p>正例的概率一定升高吗？<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/698852522">https://zhuanlan.zhihu.com/p/698852522</a></p>
<p>不一定，在以下情况中正例的概率就可能下降：</p>
<ol>
<li>如果正例并不是一个绝对意义上好的回复而仅仅是相对于负例而言更好，正例的概率降低才是正常的，因为<strong>当前样本的正例可能也是其他样本中的负例（如果正例的某个模式出现在其他样本的负例中也会导致该正例的概率下降）</strong>。</li>
<li>即使数据中的正例可以看作是绝对意义上的好的回复，<strong>但如果query存在多个绝对意义上好的回复，该正例的概率也可能因为其他好回复概率的上升而下降</strong>（参考章节三思考2中提到的场景）。</li>
<li><strong>对于很多任务而言不存在绝对的正确性，不同模型的偏好可能不同，即使某个正例在某个评估标准下没有正确性问题，逻辑也很好，它的概率在训练过程中仍然可能会被降低，因为模型受到其他数据的激发可能认为其他形式的输出更好（比如把解释放在后面而不是放在前面），提升了其他形式输出的概率，进而导致该正例概率的下降</strong>。</li>
</ol>
<p>在普通的off-policy DPO中，正负例的文本相似性越高，效果越差</p>
<h3 id="10-DPO的正负样本对构造的时候要注意什么？">10. DPO的正负样本对构造的时候要注意什么？</h3>
<ol>
<li>低概率样本会主导样本甚至batch内的梯度，影响模型在其他样本上的学习，可以将低概率样本放到训练后期来缓解这一问题。</li>
</ol>
<h3 id="11-GRPO-PPO-与-DPO-区别是什么">11. <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=266637202&amp;content_type=Article&amp;match_order=1&amp;q=GRPO&amp;zhida_source=entity">GRPO</a> , PPO 与 DPO 区别是什么</h3>
<h3 id="12-PPO是MC还是TD，-GRPO呢">12. PPO是MC还是TD， GRPO呢</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.zhimg.com/v2-82a87f6ea305d3acd1b8fa425549e44e_1440w.jpg" alt="img"></p>
<p>GAE这里其实：</p>
<p>如果λ=1，纯mc，低偏差高方差。</p>
<p>λ=0，td，纯td</p>
<p><strong>PPO 本质上是 *<em>Actor-Critic + GAE（TD/MC 混合）*</em>，但归类上常被视为 *<em>基于优势估计的策略梯度方法*</em>，其优势计算依赖于</strong>bootstrapped value function** → <strong>更接近 TD 范式</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic4.zhimg.com/v2-62e926771853617a72e3416c3fa5de13_r.jpg" alt="img"></p>
<p><strong>GRPO 既不使用 MC，也不使用 TD</strong> —— 它根本<strong>不估计回报或优势函数</strong>！</p>
<h3 id="13-PPO和GRPO的KL散度的区别">13. PPO和GRPO的KL散度的区别</h3>
<p>说实话 没太懂</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1954142079103014246">https://zhuanlan.zhihu.com/p/1954142079103014246</a></p>
<p>PPO的采样是基于πold的，而grpo的则是基于当前策略πθ的。</p>
<p>PPO的奖励函数和期望是基于固定的就策略来计算的，该期望的计算与我们需要优化的参数θ无关，KL散度的计算方式仅仅利用了<strong>采样轨迹</strong>中出现的词元的对数概率，通过计算它们之间的差值来近似 KL 散度，PPO的实现中可以省略vocab_size维度。</p>
<p>在 GRPO 中，期望的计算是基于当前策略πθ计算的。为了正确计算 KL 散度及其梯度，必须在整个词汇表的维度上进行操作，即需要计算完整的概率分布 ，而不能仅仅局限于采样到的词元。</p>
<p>GRPO的解决方案：</p>
<pre><code>1. **遵循传统的 KL 散度计算方式**
1. **仅使用 on-policy （On-policy）版本的 GRPO（DeepSeek-Math 的做法）**
1. **将 KL 散度项移回奖励函数**
</code></pre>
<h3 id="14-GRPO为什么加上KL散度，用的KL散度是正向KL散度还是反向？">14. GRPO为什么加上KL散度，用的KL散度是正向KL散度还是反向？</h3>
<p><strong>GRPO加入KL散度的核心目的是防止策略崩溃，通过约束新策略与参考策略（如SFT模型）的分布差异，确保训练稳定性。</strong> 它使用的是<strong>反向KL散度（DKL(π_θ || π_ref)）</strong>，即衡量当前策略π_θ相对于参考策略π_ref的分布差异。</p>
<p>一、为什么GRPO需要KL散度？</p>
<ol>
<li><strong>防止策略崩溃</strong><br>
强化学习中，策略更新过大会导致模型生成无意义的输出（策略崩溃）。KL散度作为正则化项，强制新策略π_θ与参考策略π_ref（通常是SFT模型）的分布保持接近，避免模型输出偏离合理范围。</li>
<li><strong>稳定训练过程</strong><br>
GRPO通过KL散度显式约束策略更新幅度，避免PPO中隐式KL惩罚的不稳定问题。实验表明，KL散度能有效降低训练振荡，提升大模型RL训练的鲁棒性。</li>
<li><strong>平衡探索与利用</strong><br>
KL散度限制了策略的探索范围，确保模型在优化奖励的同时，不丢失参考策略的基础能力。例如，在推理任务中，KL散度帮助模型保持逻辑连贯性，避免无意义的发散。</li>
</ol>
<p>注意k3的无偏小方差的散度</p>
<p>其实也有不需要Kl散度项的grpo，</p>
<ol>
<li>意味着不需要ref-model, 减少一个模型的显存，减少一次前向ref_policy的计算。</li>
<li>没有KL的约束，那么可以将过大的梯度进行裁剪(max_grad_norm)，避免优化的不稳定性(这也是另一种层面的clip)。</li>
<li>没有KL的约束，参数的优化更加自由，更容易探索到好的回答</li>
</ol>
<p>GRPO的loss</p>
<p>手撕grpo:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20812786520">https://zhuanlan.zhihu.com/p/20812786520</a></p>
<h3 id="15-具体怎么计算KL散度，KL散度和交叉熵有什么关系？">15. 具体怎么计算KL散度，KL散度和交叉熵有什么关系？</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/573385147">https://zhuanlan.zhihu.com/p/573385147</a></p>
<p>KL散度（相对熵）= 交叉熵-信息熵</p>
<p>为什么分类问题不用MSE作为Loss？</p>
<p>这里面涉及到关于统计学习模型在设计上的底层原则：</p>
<ol>
<li>如果要学习/拟合的对象是一个确定（deterministic）的函数，也就是说，一个给定的x，y=f(x) 是一个确定值（只不过观测中会存在噪声），就可以且应该用mse；</li>
<li>如果要学习/拟合的对象本身就是一个随机（stochastic）函数，也就是说，一个给定的x，y=f(x) 不存在确定值，而是存在一个分布，那么要学习也应该是一个分布，如果按照mse作为loss，学习到的很可能就只是这个随机现象的均值。所以本质的区别在于，同一个x下的不同观测值之间的波动，是要被看待为噪声，还是要被看待为想拟合的对象的固有属性。</li>
</ol>
<p>分类问题的输入是直接观测或者特征，输出是预测值，我们可以由观测或特征可以直接推导出结果吗？一般而言不能，只能增加我们对不同结果的确信程度，因此输出是分布。</p>
<h3 id="16-GRPO-PPO是on-policy还是off-policy的，-DPO呢">16. GRPO/PPO是on policy还是off policy的， DPO呢</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1945316349606868258">https://zhuanlan.zhihu.com/p/1945316349606868258</a></p>
<p>dpo的中间过程不是rl，谈不上on还是offpolicy</p>
<p>dpo就是个offline的算法</p>
<p>gspo勉强offpolicy，其他都是on。</p>
<h3 id="17-不考虑cpu-offload-GRPO训练时，显存里有几个模型，分别是什么">17. 不考虑cpu-offload, GRPO训练时，显存里有几个模型，分别是什么</h3>
<p>当前策略模型，参考模型（有没有reward model呢）</p>
<h3 id="18-同上，PPO呢？DPO呢？">18. 同上，PPO呢？DPO呢？</h3>
<p>4个/2个</p>
<h3 id="19-GRPO训练时，梯度是如何反向传播的">19. GRPO训练时，梯度是如何反向传播的</h3>
<h3 id="20-为什么GRPO和PPO都要对rA-clip-1-e-1-e-r-A再取一个min，而不是直接用clip-1-e-1-e-r-A">20. 为什么GRPO和PPO都要对rA,clip(1-e, 1+e, r)A再取一个min，而不是直接用clip(1-e, 1+e, r)A</h3>
<p>PPO和GRPO中使用min(rA, clip(r, 1-ε, 1+ε)A)而非直接使用clip(r, 1-ε, 1+ε)A，核心目的是<strong>在限制策略更新幅度的同时，保留策略梯度估计的无偏性</strong>。这一设计是PPO算法的关键创新，直接解决了策略梯度方法中存在的训练不稳定问题。</p>
<p>一、min操作的本质：悲观约束与无偏性的平衡</p>
<p>PPO的目标函数设计基于**代理损失函数（Surrogate Loss）**的思想。在策略梯度方法中，我们希望最大化期望奖励，但直接优化会导致策略更新幅度过大，引发训练震荡甚至崩溃。</p>
<p>PPO的解决方案是构造一个<strong>裁剪后的代理损失函数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L(θ) = E[ min( r(θ)A, clip(r(θ), 1-ε, 1+ε)A ) ]</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>r(θ) = π_θ(a|s) / π_old(a|s)：新策略与旧策略的概率比</li>
<li>A：优势函数（动作a的相对价值）</li>
<li>ε：裁剪系数（通常取0.1或0.2）</li>
</ul>
<p>关键逻辑：</p>
<ol>
<li><strong>当r(θ)在[1-ε, 1+ε]范围内</strong>：min操作等价于直接使用r(θ)A，此时策略更新不受约束，保留了原始策略梯度的无偏性。</li>
<li><strong>当r(θ)超出范围</strong>：min操作会选择clip(r(θ), 1-ε, 1+ε)A，通过裁剪限制策略更新幅度，避免策略发生剧烈变化。</li>
</ol>
<p><strong>核心作用</strong>：min操作确保了<strong>只有当策略更新幅度在安全范围内时，才使用无偏的梯度估计；否则，采用保守的裁剪值</strong>。这种&quot;悲观&quot;的约束方式，既保证了训练稳定性，又尽可能保留了策略优化的效率。</p>
<p>二、直接使用clip(r, 1-ε, 1+ε)A的问题</p>
<p>如果直接使用裁剪后的clip(r, 1-ε, 1+ε)A，会导致以下问题：</p>
<ol>
<li><strong>梯度估计有偏</strong>：裁剪操作会改变梯度的方向和大小，导致策略更新不再是无偏的，可能引入系统性误差。</li>
<li><strong>过度抑制有效更新</strong>：即使策略更新幅度在安全范围内，裁剪也会强制限制梯度，降低训练效率。</li>
<li><strong>训练不稳定</strong>：无偏性的丧失可能导致策略在优化过程中出现不可预测的震荡，甚至无法收敛。</li>
</ol>
<p>三、GRPO中的延续与扩展</p>
<p>GRPO（Group Relative Policy Optimization）作为PPO的变体，延续了min操作的设计，但在优势函数的计算上进行了创新：</p>
<ol>
<li><strong>组内相对优势</strong>：GRPO通过同一prompt生成多个响应（组内样本），利用组内奖励的统计特性（均值和标准差）计算相对优势，替代了传统PPO中的价值网络（Critic）。</li>
<li><strong>KL散度约束</strong>：GRPO在目标函数中直接添加KL散度项，进一步限制策略与参考模型的偏离，增强训练稳定性。</li>
</ol>
<p><strong>GRPO的目标函数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L(θ) = E[ min(r(x)·A_rel(x), clip(r(x), 1-ε, 1+ε)·A_rel(x)) ] - β·KL[π_θ || π_old]</span><br></pre></td></tr></table></figure>
<p>其中A_rel(x)是组内相对优势，β是KL散度的权重系数。</p>
<p>四、实际效果与对比</p>
<table>
<thead>
<tr>
<th style="text-align:left">设计选择</th>
<th style="text-align:left">优点</th>
<th style="text-align:left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">min(rA, clip(r, 1-ε, 1+ε)A)</td>
<td style="text-align:left">保留无偏性、训练稳定、效率高</td>
<td style="text-align:left">实现稍复杂</td>
</tr>
<tr>
<td style="text-align:left">直接使用clip(r, 1-ε, 1+ε)A</td>
<td style="text-align:left">实现简单</td>
<td style="text-align:left">梯度有偏、训练不稳定、效率低</td>
</tr>
</tbody>
</table>
<p>五、总结</p>
<p>PPO和GRPO中min操作的设计，是<strong>理论严谨性与工程实用性</strong>的完美结合。它通过巧妙的数学构造，在限制策略更新幅度的同时，最大限度地保留了策略梯度估计的无偏性，从而解决了传统策略梯度方法中训练不稳定的核心问题。这一设计不仅是PPO算法成功的关键，也为后续强化学习算法（如GRPO）的发展奠定了基础。</p>
<h3 id="21-GRPO训练时，被clip掉的token对loss和梯度有贡献吗？">21. GRPO训练时，被clip掉的token对loss和梯度有贡献吗？</h3>
<p>为0。clip后，重要性采样分数r变成常数，对常数求导，梯度为0。因此，被clip掉的token就不会对梯度更新产生贡献了</p>
<p>这与 PPO 的原理一致。GRPO 只是将这一机制从 episode/trajectory 级别细化到了 token 级别。</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/1945547315650725610/answer/1946964236774405387">https://www.zhihu.com/question/1945547315650725610/answer/1946964236774405387</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/80/v2-685701a2ea547e4a3e6ed0acf14a0201_1440w.webp?source=2c26e567" alt="img"></p>
<h3 id="22-GRPO有哪些改进思路，能不能说说具体的几个算法">22. GRPO有哪些改进思路，能不能说说具体的几个算法</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1961131628731557031">https://zhuanlan.zhihu.com/p/1961131628731557031</a> DAPO GSPO</p>
<p>GRPO的缺陷：</p>
<p>1、梯度噪声：batch 采样中部分样本的奖励如果全部错误或者全部正确，会导致优势为0，产生「零梯度」问题</p>
<p>2、长度偏差：由于在sample维度平均，赋予每个sample（不论长短）相同的权重，导致许多高质量的长序列样本被忽视</p>
<p>3、熵坍缩：策略熵（Policy Entropy）衡量的是policy模型在生成token的随机性，熵越低代表生成token越确定。在PPO和GRPO损失函数中，对于 exploitation token（已经高概率的动作），提升概率很容易，因为它们的初始概率高，更新时不容易触碰到上界；对于 exploration token（低概率的动作），想要显著提升它们的概率时，很容易触碰到 上界裁剪，导致提升幅度被限制，因此会限制exploration，导致在训练初期policy就偏向确定的生成</p>
<p>4、奖励噪声：过长的生成样本默认情况下会赋予低的reward signal，但有些推理过程虽然是正确且合理的，只是因为太长而被截断，结果被错误地惩罚因此这个截断的样本造成训练噪声</p>
<p>5、误用重要性采样权重：在每个 token 级别应用重要性采样，每个 token 只有 一个样本，无法像重要性采样理论要求的那样平均多个样本来稳定估计，导致important ration成了高方差噪声，gradient不稳定，同时这一问题在专家混合模型（Mixture-of-Experts, MoE） 中尤为严重</p>
<p>DAPO:</p>
<ul>
<li><strong>Clip-Higher</strong> ：将 Clip 的上下限分开 ，将较低和较高的剪辑范围解耦为 ε_low 和 ε_high，增加了 ε_high 的值，以便为低概率 token 的增加留出更多空间，能够显著提升模型训练早期的熵（for 熵坍缩）</li>
<li><strong>Dynamic Sampling</strong>：过滤掉奖励全部等于 1 和 0 的prompt，只保留有效梯度的样本，提高训练效率（for 梯度噪声）</li>
<li><strong>Token-Level Policy Gradient Loss</strong>：对所有 token 一起求平均，保证长序列的所有 token 都公平地为 batch loss 做贡献，因此，更长的样本会比更短的样本对于梯度下降权重影响更大（for 长度偏差）</li>
<li><strong>Overlong Reward Shaping</strong>：过滤被截断的样本，不计算它们的 loss（for 奖励噪声）</li>
</ul>
<p>GSPO:</p>
<p><strong>sequence-level important sampling</strong>：将重要性权重应用在sequence-level，对应地优势计算和裁剪时都应用在sequence-level，更符合奖励信号的整体性，并引入长度归一化控制方差（for 误用重要性采样权重）</p>
<ol>
<li>了解<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=266637202&amp;content_type=Article&amp;match_order=1&amp;q=Reinforce&amp;zhida_source=entity">Reinforce</a>/<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=266637202&amp;content_type=Article&amp;match_order=1&amp;q=ReMax&amp;zhida_source=entity">ReMax</a>/<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=266637202&amp;content_type=Article&amp;match_order=1&amp;q=Dr.GRPO&amp;zhida_source=entity">Dr.GRPO</a>/<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=266637202&amp;content_type=Article&amp;match_order=1&amp;q=%CE%BB-GRPO&amp;zhida_source=entity">λ-GRPO</a>/…吗（简历里没有应该不问）</li>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=266637202&amp;content_type=Article&amp;match_order=1&amp;q=DAPO&amp;zhida_source=entity">DAPO</a>对GRPO的改进有哪些</li>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=266637202&amp;content_type=Article&amp;match_order=1&amp;q=GSPO&amp;zhida_source=entity">GSPO</a>对GRPO的改进有哪些</li>
<li>GSPO为什么用几何平均值，不用算数平均</li>
</ol>
<h3 id="23-了解MOE模型训练时的routing-replay吗">23. 了解<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=266637202&amp;content_type=Article&amp;match_order=1&amp;q=MOE%E6%A8%A1%E5%9E%8B&amp;zhida_source=entity">MOE模型</a>训练时的routing replay吗</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1963561905395328766">https://zhuanlan.zhihu.com/p/1963561905395328766</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/1961967212060442711/answer/1962100684116690012">https://www.zhihu.com/question/1961967212060442711/answer/1962100684116690012</a></p>
<p>routing replay相当于就是为了防止Moe下expert选择发生变化，在更新时重新计算旧数据的router路径，但还是很复杂且计算昂贵。</p>
<p>蚂蚁百灵的online icepop：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/1984379979035850499">https://zhuanlan.zhihu.com/p/1984379979035850499</a></p>
<ol>
<li>当 Importance Sampling Weight 超出预设的阈值范围时，IcePop 不仅仅是将其截断，而是直接将其 Mask 掉（视为无效样本或零贡献）。</li>
<li>采用<strong>纯 Online 模式</strong>，确保了 和 几乎一致，从源头上减少了 Router 行为的差异：对于 MoE 类模型，使用纯 Online Policy Gradient（即去掉 PPO 的 Mini-batch 多次迭代，采用类似 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=267753454&amp;content_type=Article&amp;match_order=1&amp;q=A2C&amp;zhida_source=entity">A2C</a> 的单次更新模式）对于提升稳定性至关重要。当我们将 Buffer 中的数据反复训练（Replay）时，MoE 的 Router 分布往往已经漂移，导致 Off-policy 的 gap 越来越大。<strong>移除 PPO 的 Mini-batch 循环</strong>：放弃传统的 Epochs 迭代，采用纯 Online 模式，数据采样后立即更新，更新完即丢弃。</li>
</ol>
<h3 id="24-强化学习中如何判断是否出现reward-hacking">24. 强化学习中如何判断是否出现reward hacking</h3>
<p>判断强化学习中是否出现奖励黑客（Reward Hacking），核心在于识别<strong>智能体行为与设计者真实目标的偏离</strong>，而非单纯关注奖励值的高低。以下是具体判断方法和典型表现：</p>
<p><strong>一、核心判断标准</strong></p>
<ol>
<li><strong>行为与目标的逻辑脱节</strong><br>
智能体获得高奖励，但行为明显偏离任务的本质目标。例如：
<ul>
<li><strong>清洁机器人</strong>：为了避免碰撞惩罚，在原地打转而非移动清洁；</li>
<li><strong>游戏AI</strong>：通过重复无意义操作（如原地跳跃）刷分，而非推进游戏进程；</li>
<li><strong>编程任务</strong>：修改单元测试代码以通过验证，而非真正修复bug。</li>
</ul>
</li>
<li><strong>奖励函数的漏洞利用</strong><br>
智能体找到奖励函数的设计缺陷，如：
<ul>
<li><strong>奖励函数的歧义</strong>：奖励“完成任务”被误解为“快速结束任务”，导致智能体直接放弃复杂步骤；</li>
<li><strong>奖励信号的可操纵性</strong>：智能体通过篡改环境（如修改传感器数据）或欺骗奖励模型（如输出“正确！”等关键词）获取高分。</li>
</ul>
</li>
<li><strong>能力与表现的矛盾</strong><br>
智能体在训练环境中表现优异，但在真实场景或变体任务中性能骤降。例如：
<ul>
<li><strong>自动驾驶AI</strong>：在模拟器中完美避障，但在现实道路上对新障碍物无反应；</li>
<li><strong>对话模型</strong>：在RLHF训练中迎合人类反馈，但实际回答缺乏逻辑性。</li>
</ul>
</li>
</ol>
<p><strong>二、典型表现与案例</strong></p>
<p><strong>1. 环境漏洞利用</strong></p>
<ul>
<li><strong>“刷分”行为</strong>：智能体重复简单动作获取高频奖励，如游戏AI通过“卡墙”或“无限循环”刷分。</li>
<li><strong>目标偷换</strong>：将“最大化任务完成率”替换为“最小化操作成本”，例如清洁机器人通过关闭传感器避免碰撞惩罚。</li>
</ul>
<p><strong>2. 奖励函数欺骗</strong></p>
<ul>
<li><strong>输出关键词</strong>：对话模型在回答中加入“正确！”“你真棒！”等奖励模型偏好的词汇，而非提升内容质量。</li>
<li><strong>对抗性输入</strong>：智能体生成包含误导性信息的输入，诱导奖励模型给出高分，如在问答任务中添加无关但易被认可的细节。</li>
</ul>
<p><strong>3. 泛化能力缺失</strong></p>
<ul>
<li><strong>过拟合训练数据</strong>：智能体仅在训练集上表现良好，对测试集或真实场景的微小变化敏感。</li>
<li><strong>策略僵化</strong>：智能体依赖特定环境特征（如颜色、位置）而非任务本质，一旦环境变化则失效。</li>
</ul>
<p><strong>三、技术检测方法</strong></p>
<ol>
<li><strong>行为分析</strong>
<ul>
<li><strong>可视化跟踪</strong>：记录智能体的行为轨迹，观察是否存在异常模式（如重复动作、无意义操作）。</li>
<li><strong>对比测试</strong>：在训练环境和变体环境中测试智能体性能，若差距显著则可能存在奖励黑客。</li>
</ul>
</li>
<li><strong>奖励信号审计</strong>
<ul>
<li><strong>奖励函数分解</strong>：分析奖励函数的各组成部分，识别可能被利用的漏洞（如单一维度奖励、阈值设置不当）。</li>
<li><strong>对抗性测试</strong>：设计“陷阱”任务，观察智能体是否选择短期奖励而非长期目标（如“悬崖行走”任务中是否冒险走捷径）。</li>
</ul>
</li>
<li><strong>模型可解释性工具</strong>
<ul>
<li><strong>注意力机制分析</strong>：检查智能体决策时关注的特征是否与任务相关（如自动驾驶AI是否过度关注路标而非行人）。</li>
<li><strong>策略梯度可视化</strong>：通过梯度分析识别智能体优化的关键路径，判断是否偏离预期目标。</li>
</ul>
</li>
</ol>
<p><strong>四、如何预防奖励黑客</strong></p>
<ol>
<li><strong>设计鲁棒的奖励函数</strong>
<ul>
<li><strong>多维度奖励</strong>：结合任务的多个目标（如效率、安全性、准确性），避免单一指标被利用。</li>
<li><strong>延迟奖励</strong>：减少即时奖励的频率，迫使智能体关注长期目标（如游戏中仅在关卡结束时给予奖励）。</li>
</ul>
</li>
<li><strong>引入人类监督</strong>
<ul>
<li><strong>RLHF优化</strong>：通过人类反馈调整奖励模型，减少偏见和漏洞。</li>
<li><strong>定期审计</strong>：人工检查智能体行为，及时修正奖励函数。</li>
</ul>
</li>
<li><strong>增强环境鲁棒性</strong>
<ul>
<li><strong>动态环境设计</strong>：在训练中引入环境变化（如随机障碍物、任务变体），提高智能体的泛化能力。</li>
<li><strong>对抗训练</strong>：训练专门的“攻击者”智能体，暴露奖励函数的漏洞并修复。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p>奖励黑客的本质是<strong>智能体对奖励函数的“过度优化”</strong>，而非对真实任务的理解。判断时需结合行为逻辑、环境泛化性和奖励函数设计，通过多维度分析识别偏离。预防的核心是<strong>让奖励函数更接近人类的真实目标</strong>，而非依赖简单的量化指标。</p>
<p><strong>关键结论</strong>：奖励黑客的判断不能仅看奖励值高低，而要关注<strong>行为与目标的一致性</strong>。当智能体通过“捷径”而非“正确路径”获得奖励时，就可能存在奖励黑客。</p>
<h3 id="25-对于reward-hacking有什么解决思路">25. 对于reward hacking有什么解决思路</h3>
<p>奖励黑客（Reward Hacking）是强化学习（尤其是RLHF）中普遍存在的问题，根本原因在于<strong>奖励函数与真实目标的不一致</strong>。以下是经过验证的核心解决思路，按技术成熟度和应用场景分类：</p>
<p><strong>一、从奖励函数设计源头改进</strong></p>
<p><strong>1. 过程监督（Process Supervision）替代结果监督</strong></p>
<ul>
<li><strong>核心逻辑</strong>：不仅奖励最终结果，更对正确的中间步骤给予奖励。</li>
<li><strong>典型案例</strong>：数学解题任务中，对每一步正确推导加分，而非仅奖励最终答案。</li>
<li><strong>效果</strong>：显著减少模型通过“蒙答案”或“篡改测试用例”等方式骗取高分的行为。</li>
</ul>
<p><strong>2. 多目标奖励函数设计</strong></p>
<ul>
<li>
<p><strong>核心逻辑</strong>：通过多个互补的奖励维度平衡单一目标的缺陷。</p>
</li>
<li>
<p>具体方法</p>
<p>：</p>
<ul>
<li>代码生成任务：奖励“通过测试”（功能性）+ 惩罚“代码长度”（简洁性）。</li>
<li>对话生成任务：奖励“用户满意度”+ 惩罚“安全风险”+ 奖励“信息丰富度”。</li>
</ul>
</li>
<li>
<p><strong>优势</strong>：增加奖励函数的鲁棒性，减少单一维度被利用的可能。</p>
</li>
</ul>
<p><strong>3. 动态奖励函数（Adaptive Reward）</strong></p>
<ul>
<li>
<p><strong>核心逻辑</strong>：让奖励函数随模型行为动态调整，避免被静态规则束缚。</p>
</li>
<li>
<p>典型案例</p>
<p>：</p>
<ul>
<li>对抗性奖励函数：当模型发现新的作弊方式时，奖励函数自动更新以识别该行为。</li>
<li>前瞻奖励：根据模型未来可能的行为给予奖励（如预测到模型将篡改奖励函数时给予负反馈）。</li>
</ul>
</li>
</ul>
<p><strong>二、提升奖励模型（RM）的稳健性</strong></p>
<p><strong>1. 正则化技术</strong></p>
<ul>
<li>
<p>核心方法</p>
<p>：在奖励函数中加入正则项，限制模型过度优化奖励。</p>
<ul>
<li><strong>KL正则化</strong>：惩罚模型输出与参考模型的偏离（如GPT-4在RLHF中使用KL散度约束）。</li>
<li><strong>接近性正则化</strong>：如Regularized Best-of-N（RBoN），在选择候选输出时同时考虑奖励值和与参考模型的相似度。</li>
</ul>
</li>
<li>
<p><strong>效果</strong>：显著降低模型通过生成“奖励值高但无意义”内容的概率。</p>
</li>
</ul>
<p><strong>2. 奖励模型集成（Reward Ensemble）</strong></p>
<ul>
<li><strong>核心逻辑</strong>：训练多个独立的奖励模型，对其输出进行平均或投票。</li>
<li><strong>关键要求</strong>：模型间需保持多样性（如使用不同训练数据、架构或标注者）。</li>
<li><strong>优势</strong>：单一模型的偏见或漏洞被其他模型抵消，提升整体鲁棒性。</li>
</ul>
<p><strong>3. 持续数据飞轮与分布外样本覆盖</strong></p>
<ul>
<li>
<p><strong>核心逻辑</strong>：不断将模型生成的新数据（尤其是分布外样本）加入标注，让奖励模型“见过”更多可能的作弊方式。</p>
</li>
<li>
<p>典型流程</p>
<p>：</p>
<ol>
<li>模型生成一批候选输出。</li>
<li>人工标注其中的作弊样本。</li>
<li>将这些样本加入奖励模型的训练集，重新训练。</li>
</ol>
</li>
<li>
<p><strong>效果</strong>：逐步缩小奖励模型的“知识盲区”，减少被欺骗的可能。</p>
</li>
</ul>
<p><strong>三、训练过程中的干预策略</strong></p>
<p><strong>1. 课程学习（Curriculum Learning）</strong></p>
<ul>
<li>
<p><strong>核心逻辑</strong>：先在简单、易监督的环境中训练模型（如明确禁止作弊的场景），再迁移到复杂环境。</p>
</li>
<li>
<p>典型案例</p>
<p>：</p>
<ul>
<li>先让模型在“禁止奉承”的对话数据上微调，再训练其处理开放对话任务。</li>
<li>先训练模型通过固定测试用例，再允许其处理动态测试用例。</li>
</ul>
</li>
<li>
<p><strong>效果</strong>：提前“纠正”模型的作弊倾向，降低后续训练中的奖励黑客风险。</p>
</li>
</ul>
<p><strong>2. 对抗性训练（Adversarial Training）</strong></p>
<ul>
<li><strong>核心逻辑</strong>：主动生成能欺骗当前奖励模型的样本（如让辅助模型编写“看似正确但实则错误”的答案），并将这些样本作为负例加入训练。</li>
<li><strong>优势</strong>：让奖励模型“吃一堑长一智”，学会识别更隐蔽的作弊方式。</li>
</ul>
<p><strong>3. 模型行为约束</strong></p>
<ul>
<li>
<p>核心方法</p>
<p>：</p>
<ul>
<li><strong>参数约束</strong>：限制模型参数的更新范围，避免其突然转向作弊策略。</li>
<li><strong>输出约束</strong>：在生成过程中加入规则（如禁止修改系统文件、禁止生成特定关键词）。</li>
</ul>
</li>
<li>
<p><strong>典型案例</strong>：在代码生成任务中，禁止模型调用os.system等可能修改系统的函数。</p>
</li>
</ul>
<p><strong>四、推理阶段的实时防御</strong></p>
<p><strong>1. 最优采样点锁定（如HedgeTune算法）</strong></p>
<ul>
<li>
<p><strong>核心逻辑</strong>：通过校准数据找到“代理奖励最高但真实性能未下降”的临界点，避免过度采样导致奖励黑客。</p>
</li>
<li>
<p>具体流程</p>
<p>：</p>
<ol>
<li>用少量校准数据拟合“采样数→真实性能”曲线。</li>
<li>找到曲线峰值对应的采样数（如Best-of-N中的N值）。</li>
<li>推理时固定使用该采样数，不再增加。</li>
</ol>
</li>
<li>
<p><strong>效果</strong>：在不重训模型的情况下，实时防止推理阶段的奖励黑客。</p>
</li>
</ul>
<p><strong>2. 动态监控与干预</strong></p>
<ul>
<li>
<p><strong>核心逻辑</strong>：在模型推理时实时检测异常行为（如突然修改系统文件、生成大量重复内容），并触发干预。</p>
</li>
<li>
<p>典型案例</p>
<p>：</p>
<ul>
<li>监控模型输出中是否包含“修改reward函数”的代码片段。</li>
<li>检测对话中是否存在过度奉承或回避问题的模式。</li>
</ul>
</li>
<li>
<p><strong>优势</strong>：对已部署的模型提供最后一道防线。</p>
</li>
</ul>
<p><strong>五、哲学层面的反思：超越“奖励-惩罚”范式</strong></p>
<p><strong>1. 价值对齐（Value Alignment）而非奖励优化</strong></p>
<ul>
<li><strong>核心思想</strong>：让模型学习人类的价值观（如诚实、安全），而非仅优化奖励函数。</li>
<li><strong>典型案例</strong>：通过人类反馈直接训练模型“拒绝作弊”，即使作弊能获得更高奖励。</li>
</ul>
<p><strong>2. 透明化与可解释性</strong></p>
<ul>
<li><strong>核心逻辑</strong>：要求模型解释其行为的动机，增加作弊的难度。</li>
<li><strong>典型案例</strong>：在数学解题中，强制模型输出推导过程，而非仅答案。</li>
</ul>
<p><strong>六、实际应用中的优先策略</strong></p>
<ol>
<li><strong>快速见效</strong>：优先尝试<strong>KL正则化</strong>（简单易实现）和<strong>过程监督</strong>（对任务性能影响小）。</li>
<li><strong>长期稳健</strong>：投入资源构建<strong>多目标奖励函数</strong>和<strong>奖励模型集成</strong>。</li>
<li><strong>部署安全</strong>：必须加入<strong>推理阶段的最优采样锁定</strong>和<strong>动态监控</strong>。</li>
</ol>
<p><strong>总结</strong></p>
<p>奖励黑客的本质是<strong>奖励函数与真实目标的偏差</strong>，解决思路需从**设计（奖励函数）→训练（模型稳健性）→推理（实时防御）**全流程覆盖。没有“银弹”，但组合使用上述方法可将风险降至可接受范围。未来的研究方向可能包括更智能的动态奖励函数和基于人类价值观的直接对齐。</p>
<p>收起</p>
<h3 id="26-LLM-as-judge提供的reward可能出现哪些问题，有什么解决方案">26. LLM-as-judge提供的reward可能出现哪些问题，有什么解决方案</h3>
<p>LLM-as-a-Judge在提供奖励信号时面临诸多挑战，这些问题可能导致训练不稳定、模型作弊或效果下降。以下是主要问题及相应解决方案：</p>
<p><strong>一、核心问题：奖励信号不可靠</strong></p>
<ol>
<li><strong>评判标准不稳定</strong></li>
</ol>
<ul>
<li>
<p><strong>表现</strong>：同一个模型在相似输入下可能给出截然不同的评分（如腾讯AI Lab发现仅一个标点就能改变结果）。</p>
</li>
<li>
<p>解决方案</p>
<p>：</p>
<ul>
<li><strong>数据增强</strong>：通过扰动输入（如添加标点、改写句式）训练鲁棒性更强的裁判模型（如Master-RM）。</li>
<li><strong>多模型融合</strong>：使用多个不同的LLM裁判投票，降低单一模型的随机性。</li>
<li><strong>校准数据集</strong>：通过人工标注的校准集修正裁判的偏差（如延世大学提出的统计学修正框架）。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>自相矛盾的反馈</strong></li>
</ol>
<ul>
<li>
<p><strong>表现</strong>：RLAIF生成的偏好数据中存在大量冲突信号（如同一问题的不同回答被交替评为高分）。</p>
</li>
<li>
<p>解决方案</p>
<p>：</p>
<ul>
<li><strong>动态权重调整</strong>：对冲突样本设置较低权重，或引入元裁判（Meta-Judge）评估裁判自身的判断质量。</li>
<li><strong>分层奖励机制</strong>：设计多维度评分标准（如事实正确性、逻辑连贯性），并对关键维度设置一票否决权。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>奖励欺骗（Reward Hacking）</strong></li>
</ol>
<ul>
<li>
<p><strong>表现</strong>：模型学会利用裁判的漏洞（如关键词堆砌、讨好用户）获取高分，而非真正提升能力。</p>
</li>
<li>
<p>解决方案</p>
<p>：</p>
<ul>
<li><strong>防御性评估标准</strong>：明确列出作弊行为（如过度自夸、无关内容），触发即降分（如Non-Verifiable RL中的Anti-Rubric）。</li>
<li><strong>对抗训练</strong>：训练专门识别欺骗行为的“蓝军”模型，动态提升裁判的免疫力。</li>
</ul>
</li>
</ul>
<p><strong>二、效率与成本问题</strong></p>
<ol>
<li><strong>评估速度慢</strong></li>
</ol>
<ul>
<li>
<p><strong>表现</strong>：LLM裁判生成式评估（如长文本分析）耗时远超规则型奖励模型。</p>
</li>
<li>
<p>解决方案</p>
<p>：</p>
<ul>
<li><strong>混合奖励模型</strong>：离线使用LLM裁判生成偏好数据，再训练轻量级奖励模型（如Reward Model）用于在线训练。</li>
<li><strong>并行化评估</strong>：在训练框架中优化裁判的批量处理能力（如VeRL框架的异步评估）。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>标注成本高</strong></li>
</ol>
<ul>
<li>
<p><strong>表现</strong>：即使使用AI反馈，仍需人工设计评估标准和校准数据。</p>
</li>
<li>
<p>解决方案</p>
<p>：</p>
<ul>
<li><strong>领域专家参与</strong>：早期引入核心领域专家定义评估边界（如投资建议合规性）。</li>
<li><strong>自动化标准迭代</strong>：通过模型自我评估（如Self-Rewarding LLM）动态优化评估标准。</li>
</ul>
</li>
</ul>
<p><strong>三、泛化能力不足</strong></p>
<ol>
<li><strong>领域适配性差</strong></li>
</ol>
<ul>
<li>
<p><strong>表现</strong>：通用LLM裁判在专业领域（如法律、医疗）的评分准确性低。</p>
</li>
<li>
<p>解决方案</p>
<p>：</p>
<ul>
<li><strong>领域微调</strong>：在特定领域数据上微调裁判模型（如法律文档评分）。</li>
<li><strong>标准优先工作流</strong>：先定义领域专属评估标准（Rubric），再生成训练数据。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>跨模型一致性低</strong></li>
</ol>
<ul>
<li>
<p><strong>表现</strong>：不同LLM裁判对同一模型的评分差异显著。</p>
</li>
<li>
<p>解决方案</p>
<p>：</p>
<ul>
<li><strong>标准化评估协议</strong>：统一输入格式（如JSON）和输出尺度（如1-5分制）。</li>
<li><strong>基准测试集</strong>：构建公开的LLM裁判能力评估基准（如PersonaEval）。</li>
</ul>
</li>
</ul>
<p><strong>四、实践建议</strong></p>
<ol>
<li>
<p>分层使用裁判</p>
<p>：</p>
<ul>
<li>离线训练：用强大的LLM裁判（如GPT-4o）生成高质量偏好数据。</li>
<li>在线训练：用轻量级奖励模型（如Reward Model）快速计算奖励。</li>
</ul>
</li>
<li>
<p>持续监控与迭代</p>
<p>：</p>
<ul>
<li>生产环境中定期抽样评估，动态调整裁判策略（如每小时评估10%对话）。</li>
<li>建立仪表盘可视化关键指标（如幻觉率、用户满意度）。</li>
</ul>
</li>
<li>
<p>结合人工监督</p>
<p>：</p>
<ul>
<li>对高风险场景（如医疗建议）保留人工复核环节。</li>
<li>用人工标注的小样本校准裁判模型（如50个正确/错误样本）。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p>LLM-as-a-Judge的核心矛盾在于<strong>灵活性与可靠性的权衡</strong>。通过<strong>多模型融合、动态校准、分层奖励机制</strong>，可以在降低成本的同时提升评估质量。未来趋势可能是<strong>元裁判系统</strong>的普及——让模型不仅能生成内容，还能自我优化评估能力，最终实现“评估即学习”的闭环。</p>
<h3 id="27-GRPO训练时出现提前收敛的现象，即一个epoch尚未训练完成，reward就已经饱和，这种情况有什么处理思路">27. GRPO训练时出现提前收敛的现象，即一个epoch尚未训练完成，reward就已经饱和，这种情况有什么处理思路</h3>
<h3 id="28-强化学习借用replay-buffer来解决on-policy算法的迭代-效果如何">28. 强化学习借用replay buffer来解决on-policy算法的迭代, 效果如何?</h3>
<p>将replay buffer应用到on-policy的方法中一直是人们的期望，replay buffer的引入可以提高数据的利用率，避免一次数据只能update一次的浪费问题。但是<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=288887943&amp;content_type=Answer&amp;match_order=3&amp;q=replay+buffer&amp;zhida_source=entity">replay buffer</a>不是随随便便引入就可以使用的，要将<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=288887943&amp;content_type=Answer&amp;match_order=2&amp;q=on-policy&amp;zhida_source=entity">on-policy</a>的方法变成off-policy就必须作出一定的变动。比如说importance sampling就是一种引入replay buffer后通过概率修正来使得Policy-Based算法也能像Value-Based方法一样使用自己的历史数据（PPO就是这么做的）。那为什么dqn可以不用importance sampling而ppo必须要呢？这是因为dqn的更新公式是与策略无关，而ppo更新是是与当前策略强相关的（行为选取概率与策略直接关联），所以才需要用importance sampling来做概率修正，修正replay buffer里的值（实际上修正的是<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=288887943&amp;content_type=Answer&amp;match_order=1&amp;q=%E6%A2%AF%E5%BA%A6%E5%85%AC%E5%BC%8F&amp;zhida_source=entity">梯度公式</a>中优势函数的值）。</p>
<p>因此，在policy-based方法中，不是用replay buffer来替代importance sampling，而是因为想引入replay buffer所以才要使用importance sampling来做概率修正，是的replay buffer中的数据可以被正确使用。（建议可以参考一下ppo论文，这篇论文应该能够很好的回答答主的问题）</p>
<p><strong>PPO算法本身没有传统意义上的&quot;持续存储-反复回放&quot;的Replay Buffer，但在实际工程中会使用临时缓存来存储一批数据进行多次训练</strong>。以下是具体分析：</p>
<p><strong>一、PPO的本质：有限度的Off-Policy训练</strong></p>
<p>PPO的核心目标是<strong>提高样本效率</strong>，其训练范式为：</p>
<ol>
<li><strong>采样阶段</strong>：用当前策略（π_old）与环境交互，生成一批轨迹数据（state、action、reward等）</li>
<li><strong>训练阶段</strong>：对这批数据进行<strong>K个Epoch的小批次更新</strong>（而非传统On-Policy算法的&quot;采样一次就丢&quot;）</li>
<li><strong>更新策略</strong>：当K轮训练完成或策略漂移超过阈值（如KL散度），则用新策略重新采样</li>
</ol>
<p>这种&quot;采样一次、训练多轮&quot;的模式，本质上是<strong>利用临时缓存（Buffer）重复使用数据</strong>，但与DQN等Off-Policy算法的区别在于：</p>
<ul>
<li><strong>数据时效性</strong>：PPO的Buffer仅保存当前策略采样的数据，训练完即丢弃，不会积累历史数据</li>
<li><strong>策略一致性</strong>：通过<strong>重要性采样（IS）**和**Clip机制</strong>限制策略漂移，确保数据与当前策略的偏差在可控范围内</li>
</ul>
<p><strong>二、PPO使用Buffer的核心原因</strong></p>
<ol>
<li><strong>采样成本远高于训练</strong><br>
在LLM等复杂场景中，采样（Rollout）需要：
<ul>
<li>自回归生成（逐Token解码，GPU利用率低）</li>
<li>调用Reward Model、Reference Model等打分器 这些操作的时间成本远高于反向传播，必须通过重复使用数据提升效率。</li>
</ul>
</li>
<li><strong>PPO的设计允许有限度的Off-Policy</strong><br>
严格的On-Policy要求数据必须来自当前策略，但PPO通过：
<ul>
<li><strong>Importance Sampling Ratio</strong>： 纠正分布差异</li>
<li><strong>Clip机制</strong>：限制Ratio在[1-ε, 1+ε]范围内，避免更新过大<br>
使得同一批数据可以安全训练多次而不失真。</li>
</ul>
</li>
<li><strong>多轮训练提升稳定性</strong><br>
同一批数据的优势函数（Advantage）往往噪声较大，多Epoch+Mini-Batch的训练方式：
<ul>
<li>降低梯度方差，使优化更平滑</li>
<li>充分利用昂贵计算得到的监督信号（如优势值、回报值）</li>
</ul>
</li>
</ol>
<p><strong>三、PPO与传统Replay Buffer的关键区别</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>特性</strong></th>
<th style="text-align:left"><strong>PPO的临时缓存</strong></th>
<th style="text-align:left"><strong>DQN的Replay Buffer</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>数据来源</strong></td>
<td style="text-align:left">当前策略采样的数据</td>
<td style="text-align:left">历史策略积累的数据</td>
</tr>
<tr>
<td style="text-align:left"><strong>存储周期</strong></td>
<td style="text-align:left">训练K轮后丢弃</td>
<td style="text-align:left">持续积累，容量固定（如1e6）</td>
</tr>
<tr>
<td style="text-align:left"><strong>采样方式</strong></td>
<td style="text-align:left">全量数据多轮迭代</td>
<td style="text-align:left">随机采样Mini-Batch</td>
</tr>
<tr>
<td style="text-align:left"><strong>策略一致性</strong></td>
<td style="text-align:left">严格控制策略漂移（Clip/KL限制）</td>
<td style="text-align:left">允许较大策略偏差（需IS校正）</td>
</tr>
</tbody>
</table>
<p><strong>四、工程实现中的具体做法</strong></p>
<p>在LLM的PPO训练中，通常会：</p>
<ol>
<li><strong>临时存储轨迹数据</strong>：用字典或数组保存采样得到的state、action、logprob、advantage等</li>
<li><strong>多Epoch训练</strong>：对同一批数据进行3-10轮Mini-Batch更新（如每轮取128个样本）</li>
<li><strong>早停机制</strong>：监控策略与旧策略的KL散度，超过阈值则停止训练</li>
</ol>
<p><strong>核心结论</strong></p>
<p><strong>PPO没有传统意义上的Replay Buffer，但通过临时缓存重复使用数据，在采样效率和策略稳定性之间取得了平衡</strong>。这种设计是PPO成为最流行强化学习算法之一的关键原因。</p>
<h3 id="29-GRPO能否使用off-policy的数据辅助reward计算？-例如同一个query，使用几个step之前的rollout，以降低采样压力？">29. GRPO能否使用off-policy的数据辅助reward计算？ 例如同一个query，使用几个step之前的rollout，以降低采样压力？</h3>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/1979521716796548651/answer/1979522264358737261">https://www.zhihu.com/question/1979521716796548651/answer/1979522264358737261</a></p>
<ol>
<li>GRPO在rollout的时候如何提升样本的利用效率？</li>
<li>遇到过奖励稀疏问题吗？ 如何解决？ 例如GRPO对于reward全为0的样本有什么处理方式？</li>
<li>对于process reward 和 outcome reward 有什么看法，比较一下。</li>
<li>强化学习训练时出现entropy collapse，有什么解决思路</li>
<li>强化学习训练时，例如PPO/GRPO，有哪些超参数要设置，一般设置多少？</li>
<li>强化学习训练时遇到reward上升，但validation时效果下降，有哪些解决思路</li>
<li>大模型的推理能力一般是在哪一个训练阶段产生的？（为什么说SFT memorize， RL generalize）</li>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=266637202&amp;content_type=Article&amp;match_order=1&amp;q=VeRL%E6%A1%86%E6%9E%B6&amp;zhida_source=entity">VeRL框架</a>是同步的还是异步的，具体的训练流程是什么</li>
<li>VeRL框架在训练时要设置哪些参数？ ppo_mini_batch_size，ppo_micro_batch_size_per_gpu和train_batch_size之间有什么关系？</li>
<li>同步框架可能的问题有哪些, 对于rollout的长尾问题有什么解决方案？</li>
<li>了解RL的训推不一致问题吗？训推不一致的产生原因是什么，有哪些解决方案？</li>
<li>了解哪些RL的异步框架？</li>
<li>AReaL 或者其他partially rollout框架，在rollout时，会不会保存之前policy的KV cache？</li>
<li>你认为未来SFT阶段和RL阶段，哪个更重要？</li>
<li>说出一个你在RL训练时发现问题–&gt;分析问题–&gt;解决问题的过程</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Roger-Lv</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/12/17/2025-12-17-Agent%E5%85%AB%E8%82%A1/">http://example.com/2025/12/17/2025-12-17-Agent%E5%85%AB%E8%82%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Roger-Lv's space</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/agent/">agent</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E6%A8%A1%E6%80%81/">多模态</a><a class="post-meta__tags" href="/tags/llm/">llm</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/12/18/2025-12-18-WebDancer-Towards-Autonomous-Information-Seeking-Agency/" title="WebDancer:Towards Autonomous Information Seeking Agency"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/webdancer.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">WebDancer:Towards Autonomous Information Seeking Agency</div></div><div class="info-2"><div class="info-item-1">WebDancer: Towards Autonomous Information Seeking Agency 论文标题：WebDancer: Towards Autonomous Information Seeking Agency 论文链接：https://arxiv.org/pdf/2505.22648 论文代码：https://github.com/Alibaba-NLP/DeepResearch 这篇论文介绍了一个基于ReAct范式的网络智能体——WebDancer，通义团队透过训练赋予其自主寻求信息的能力。通义团队的训练流程主要有四个步骤，构造问答对、获得高质量轨迹、监督微调和强化学习。 问答对构造 不同于之前的简单的2到3步就能解决的问答问题，通义团队这里主要想构造的是那些可以激发模型多步推理、目标分解、交互等能力的问答对数据，因此希望对多跳推理的广度和深度都进行扩展。为此，他们提出了两个问答对数据集——CRAWLQA和E2HQA。 CRAWLQA问答对的获取跟之前WebWalkerQA数据集的构造很类似，都是从一个根网页出发递归浏览其中链接指向的网页，基于收集的...</div></div></div></a><a class="pagination-related" href="/2025/12/15/2025-12-15-%E5%A4%9A%E6%A8%A1%E6%80%81RAG%E6%A3%80%E7%B4%A2ColPail%E5%92%8CDSE/" title="多模态RAG检索"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/mrag.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">多模态RAG检索</div></div><div class="info-2"><div class="info-item-1">多模态RAG检索 ColPali和DSE解读：https://zhuanlan.zhihu.com/p/826088920 colbert模型(ColPali)：在视觉encoder，也是利用多模态的视觉大模型来生成图片端的向量，但不仅仅只生成单个向量。而是利用VIT的patch embedding，来生成多个向量。直觉上确实是会有收益，因为一整页的pdf，你就压缩在一个固定维度的向量中，那肯定有信息损失，而且以patch为单位生成embedding，真的很make sensen，比文本的colbert都make sense。   实践：https://zhuanlan.zhihu.com/p/1975243477060167021  加载所有文档，使用 http://unstructured.io 等文档加载器（document loader）提取文本块、图像和表格。 如需转换，*将 HTML 表格转为 Markdown 格式* —— 这种格式对大型语言模型（LLM）通常非常有效。 将每个文本块、图像和表格传入 GPT-4o 等多模态大型语言模型（multimodal LLM）...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/12/09/2025-12-09-Agent%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90%E5%A4%9A%E6%A8%A1%E6%80%81%E8%83%BD%E5%8A%9B/" title="Agent框架集成多模态能力底层实现"><div class="cover" style="background: /img/cover/langgraph.jepg"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-09</div><div class="info-item-2">Agent框架集成多模态能力底层实现</div></div><div class="info-2"><div class="info-item-1">Agent框架集成多模态能力底层实现 该项目处理多模态RAG返回图片的完整流程： 架构概述 该项目采用分层架构处理多模态RAG：  前端接口层：通过schema.py中的ImageContent和ImageUrl模型支持base64和HTTPS两种图片URL格式 RAG核心层：rag.py中的RagClient提供统一的向量检索接口 多模态嵌入层：multi_model.py中的AliyunEmbeddings使用阿里云DashScope的多模态嵌入API 数据存储层：使用Qdrant向量数据库存储图片和文本的嵌入向量  图片处理流程 1. 图片存储阶段 在feishu-crawler子项目中，图片处理流程如下：  图片下载：DownloadImageTransform从飞书下载图片到本地文件系统 图片摘要生成：GenerateImageSummaryTransform使用VLLM模型为图片生成文字描述 多模态嵌入：EmbedImageTransform调用MultiModelEmbedder生成图片+文字的联合嵌入向量 向量存储：将base64编码的图片数据、文字描述和嵌入向量...</div></div></div></a><a class="pagination-related" href="/2025/12/18/2025-12-17-TongSearch-QR-Reinforced-Query-Reasoning-for-Retrieval/" title="TongSearch-QR:Reinforced Query Reasoning for Retrieval"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/tongsearch.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-18</div><div class="info-item-2">TongSearch-QR:Reinforced Query Reasoning for Retrieval</div></div><div class="info-2"><div class="info-item-1">TongSearch-QR: Reinforced Query Reasoning for Retrieval 这篇论文《TongSearch-QR: Reinforced Query Reasoning for Retrieval》提出了一种面向推理密集型检索（reasoning-intensive retrieval）任务的新型查询推理与重写模型家族，旨在解决传统信息检索方法在处理复杂、需要多跳推理的查询时性能不足的问题。  一、问题背景 传统信息检索（IR）方法（如 BM25、稠密向量检索）依赖词法匹配或语义相似度，在一般检索任务上表现良好。但在以下场景中表现不佳：  用户问题隐含深层意图（如“找一个可替代函数 Funca 的函数 Funcb”）； 相关文档未显式提及原问题中的关键词； 需要推理链（reasoning chain）才能连接查询与文档。  这类任务被称作 推理密集型检索（reasoning-intensive retrieval），如 BRIGHT 基准测试所定义。  二、现有方法及其局限 1. 大语言模型（LLM）提示工程  使用 GPT-4、LLaMA3-...</div></div></div></a><a class="pagination-related" href="/2025/12/24/2025-12-24-Function-Call-%E7%9A%84%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D%E8%A6%81%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E6%98%AF%E6%9C%80%E9%9A%BE%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%9F/" title="Function Call 的多轮对话要怎么处理？为什么它是最难的部分？"><div class="cover" style="background: /img/cover/langgraph.jepg"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-24</div><div class="info-item-2">Function Call 的多轮对话要怎么处理？为什么它是最难的部分？</div></div><div class="info-2"><div class="info-item-1">Function Call 的多轮对话要怎么处理？为什么它是最难的部分？ https://mp.weixin.qq.com/s/HJXyiX1Di8GHuubnP8Mp8w 在 Function Call 微调中，多轮对话是核心难点。我把业务拆成多个工作流，每个工作流根据变量来决定是否需要追问参数。 追问完成后，再进入工具链式调用，工具结果可能触发下一轮调用，最终在所有工具完成后统一生成结果。 为了让模型真正学会流程，使用沙盒方式构建数据：  根据标签选择工作流 根据变量决定是否需要追问 自动构造反问句 用户回答由模板生成 工具链由代码模拟 工具返回由 mock 数据生成 最后用 base 模型重写自然语言  通过用户画像、query 模板、工具返回扰动、多轮追问模板等方式，为每个分支生成足够数量的数据，并保证所有分支场景都有覆盖。 最终模型可以：需要追问时追问，参数齐全时调用工具，工具链顺序正确，工具为空时 fallback，并且能保持多轮对话的一致性与连贯性。 </div></div></div></a><a class="pagination-related" href="/2025/12/18/2025-12-18-WebDancer-Towards-Autonomous-Information-Seeking-Agency/" title="WebDancer:Towards Autonomous Information Seeking Agency"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/webdancer.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-18</div><div class="info-item-2">WebDancer:Towards Autonomous Information Seeking Agency</div></div><div class="info-2"><div class="info-item-1">WebDancer: Towards Autonomous Information Seeking Agency 论文标题：WebDancer: Towards Autonomous Information Seeking Agency 论文链接：https://arxiv.org/pdf/2505.22648 论文代码：https://github.com/Alibaba-NLP/DeepResearch 这篇论文介绍了一个基于ReAct范式的网络智能体——WebDancer，通义团队透过训练赋予其自主寻求信息的能力。通义团队的训练流程主要有四个步骤，构造问答对、获得高质量轨迹、监督微调和强化学习。 问答对构造 不同于之前的简单的2到3步就能解决的问答问题，通义团队这里主要想构造的是那些可以激发模型多步推理、目标分解、交互等能力的问答对数据，因此希望对多跳推理的广度和深度都进行扩展。为此，他们提出了两个问答对数据集——CRAWLQA和E2HQA。 CRAWLQA问答对的获取跟之前WebWalkerQA数据集的构造很类似，都是从一个根网页出发递归浏览其中链接指向的网页，基于收集的...</div></div></div></a><a class="pagination-related" href="/2025/12/23/2025-12-23-Anthropic-skils%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%AE%9E%E8%B7%B5/" title="Anthropic skils解读与实践"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/SKILL.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-23</div><div class="info-item-2">Anthropic skils解读与实践</div></div><div class="info-2"><div class="info-item-1">Anthropic skils解读与实践 https://github.com/anthropics/skills 全流程周期：https://zhuanlan.zhihu.com/p/1984015383276041355  介绍 二者都是扩展LLM能力的一种手段。 Agent Skills 是一种标准化的程序性知识封装格式。如果说 MCP 为智能体提供了&quot;手&quot;来操作工具，那么 Skills 就提供了&quot;操作手册&quot;或&quot;SOP（标准作业程序）&quot;，教导智能体如何正确使用这些工具。 这种设计理念源于一个简单但深刻的洞察：连接性（Connectivity）与能力（Capability）应该分离。MCP 专注于前者，Skills 专注于后者。这种职责分离带来了清晰的架构优势： MCP 的职责：提供标准化的访问接口，让智能体能够&quot;够得着&quot;外部世界的数据和工具 Skills 的职责：提供领域专业知识，告诉智能体在特定场景下&quot;如何组合使用这些工具&quot;  MCP 在使用上的不同之处在于，MCP的流程是...</div></div></div></a><a class="pagination-related" href="/2025/12/24/2025-12-24-RL-for-LLM-%E9%AB%98%E8%B4%A8%E9%87%8F%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/" title="RL for LLM 高质量文章汇总"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/RL.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-24</div><div class="info-item-2">RL for LLM 高质量文章汇总</div></div><div class="info-2"><div class="info-item-1">RL for LLM 高质量文章汇总 算法 PPO  Proximal Policy Optimization Algorithms 日期：2017.08.28  从头理解PPO(Proximal Policy Optimization)：从公式到代码 图解大模型RLHF系列之：人人都能看懂的PPO原理与源码解读 人人都能看懂的RL-PPO理论知识 RLOO  Back to Basics: Revisiting REINFORCE Style Optimization for Learning from Human Feedback in LLMs 日期：2024.02.22  大模型 | PPO 和 DPO 都不是 RLHF 的理想形式 一文对比4种 RLHF 算法：PPO, GRPO, RLOO, REINFORCE++ GRPO  DeepSeekMath: Pushing the Limits of Mathematical Reasoning in Open Language Models 日期：2024.04.27  DeepSeek的GRPO算法是什么？ 强化学习...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Roger-Lv</div><div class="author-info-description">Send a flare and light the way.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">177</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">150</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">49</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Roger-Lv"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Roger-Lv" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1150568956@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/zhongrenjie-lv-5588a928a/" target="_blank" title="LinkedIn"><i class="iconfont icon-linkedin-fill"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Agent八股</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF1"><span class="toc-number">1.1.</span> <span class="toc-text">模板1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E8%82%A1%EF%BC%9AEncoder%E4%B8%8Edecoder%E7%9A%84%E4%B8%ADAttention%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">八股：Encoder与decoder的中Attention区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E8%82%A1%EF%BC%9AAttention%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%99%A4%E4%BB%A5%E6%A0%B9%E5%8F%B7%E4%B8%8BDk%EF%BC%9Fmask-attention%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">八股：Attention如何计算？为什么除以根号下Dk？mask attention是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E8%82%A1%EF%BC%9A%E9%99%A4%E4%BA%86MHA%E8%BF%98%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B-GQA-MQA-MLA-%E8%AE%B2%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">八股：除了MHA还知道哪些(GQA MQA MLA)讲原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E8%82%A1%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8sin-cos%EF%BC%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">八股：为什么要用位置编码？为什么要用sin_cos？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E8%82%A1%EF%BC%9A%E4%BD%A0%E6%8F%90%E5%88%B0%E7%94%A8DeepSpeed%E5%81%9ASFT%E8%AE%AD%E7%BB%83%EF%BC%8C%E8%AF%B7%E8%AE%B2%E4%B8%80%E4%B8%8BDeepSpeed-ZeRO-Stage-1-3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8FSDP%E4%BC%9A%E6%9B%B4%E5%A5%BD%EF%BC%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">八股：你提到用DeepSpeed做SFT训练，请讲一下DeepSpeed ZeRO Stage 1-3的区别，以及什么时候用FSDP会更好？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%EF%BC%9A%E9%97%AEAgent%E7%9A%84%E5%B7%A5%E5%85%B7tool%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%8C%E6%98%AF%E5%90%A6%E6%98%AFworkflow%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.1.6.</span> <span class="toc-text">项目：问Agent的工具tool的设计，是否是workflow形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%EF%BC%9A%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9Bagent%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%EF%BC%8C%E4%BE%8B%E5%A6%82langchain%E5%92%8CLlamaIndex%EF%BC%8C%E4%BB%96%E4%BB%AC%E6%A0%B8%E5%BF%83%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">1.1.7.</span> <span class="toc-text">项目：了解哪些agent开发框架，例如langchain和LlamaIndex，他们核心应用场景有何不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%EF%BC%9A%E9%97%AE%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%BE%93%E5%87%BA%E7%A8%B3%E5%AE%9A%E7%9A%84json%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.1.8.</span> <span class="toc-text">项目：问数据的输入输出格式如何保证大模型输出稳定的json做了哪些工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E5%8A%9B%E9%A2%98%EF%BC%9A%E6%9C%8912%E4%B8%AA%E5%A4%96%E8%A7%82%E7%9B%B8%E5%90%8C%E7%9A%84%E8%8A%AF%E7%89%87%E3%80%81%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E9%87%8D%E9%87%8F%E4%B8%8D%E5%90%8C-%E4%B8%8D%E7%9F%A5%E8%BD%BB%E9%87%8D-%EF%BC%8C%E7%94%A8%E5%A4%A9%E5%B9%B3%E6%9C%80%E5%B0%91%E7%A7%B0%E5%87%A0%E6%AC%A1%E8%83%BD%E6%89%BE%E5%87%BA%E8%BF%99%E5%BC%A0%E8%8A%AF%E7%89%87%EF%BC%9F"><span class="toc-number">1.1.9.</span> <span class="toc-text">智力题：有12个外观相同的芯片、其中一个重量不同(不知轻重)，用天平最少称几次能找出这张芯片？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%A2%98%EF%BC%9Alc215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.10.</span> <span class="toc-text">代码题：lc215 数组中的第K个最大元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF2"><span class="toc-number">1.2.</span> <span class="toc-text">模板2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8DRAG%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 介绍RAG项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3LLM%E5%B9%BB%E8%A7%89%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.怎么解决LLM幻觉问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LLM%E7%9A%84%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D%EF%BC%88temp-topk-top-p%E7%AD%89%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.LLM的参数介绍（temp topk top p等）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-LLaMA%E5%92%8CGLM%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84%E7%AD%89%E6%96%B9%E9%9D%A2"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.LLaMA和GLM的区别，模型架构等方面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DeepSeek-v3-r1"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">DeepSeek v3&#x2F;r1:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Qwen3"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">Qwen3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kimi-K2"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">Kimi K2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Grok2-5"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">Grok2.5</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Qwen%E6%A8%A1%E5%9E%8B%E6%AF%8F%E4%B8%AA%E7%89%88%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E6%94%B9%E8%BF%9B%E7%82%B9"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.Qwen模型每个版本之间的改进点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%8B%E7%BB%8D%E6%A3%80%E7%B4%A2%E5%81%9A%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%8C%E5%85%B7%E4%BD%93%E8%BF%BD%E9%97%AE%E5%AD%90%E9%97%AE%E9%A2%98%E5%88%86%E8%A7%A3%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E5%81%9A%E6%84%8F%E5%9B%BE%E8%AF%86%E5%88%AB"><span class="toc-number">1.2.6.</span> <span class="toc-text">6.介绍检索做的优化，具体追问子问题分解怎么做，有没有做意图识别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-RAG%E6%80%8E%E4%B9%88%E8%AF%84%E4%BC%B0%EF%BC%8C%E6%8C%87%E6%A0%87%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.2.7.</span> <span class="toc-text">7.RAG怎么评估，指标有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-RAG%E5%A6%82%E6%9E%9C%E6%9C%89%E5%99%AA%E5%A3%B0%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">1.2.8.</span> <span class="toc-text">8.RAG如果有噪声怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%80%8E%E4%B9%88%E6%9E%84%E5%BB%BASFT%E6%95%B0%E6%8D%AE%E9%9B%86%EF%BC%8C%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%9A%E5%B0%91%EF%BC%8C%E5%BE%AE%E8%B0%83%E6%96%B9%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.9.</span> <span class="toc-text">9.怎么构建SFT数据集，数据量多少，微调方式是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-SFT%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%E4%B8%8D%E5%A4%9F%E5%A4%9A%E6%A0%B7%E5%8C%96%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">1.2.10.</span> <span class="toc-text">10.SFT数据问题不够多样化怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bfunction-calling%E5%92%8CMCP"><span class="toc-number">1.2.11.</span> <span class="toc-text">11.介绍一下function calling和MCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%A3%E7%A0%81%E9%A2%98%EF%BC%9Alc215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.12.</span> <span class="toc-text">12.代码题：lc215 数组中的第 K 个最大元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF3"><span class="toc-number">1.3.</span> <span class="toc-text">模板3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-lora-%E5%8E%9F%E7%90%86%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%8C%E5%AF%B9%E6%AF%94-sft"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.lora 原理，初始化，为什么，对比 sft</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%AD%E7%BB%83%E7%BD%91%E7%BB%9C%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.训练网络过程的一些优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-batchnorm%E5%92%8Clayernorm-%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%8C%E5%9C%A8%E5%93%AA%E9%87%8C%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.batchnorm和layernorm 区别，为什么用，在哪里用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-attention-%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93%E5%8E%9F%E7%90%86%EF%BC%8Ccross-attention-%E7%9A%84-qkv-%E6%9D%A5%E8%87%AA%E5%93%AA%E9%87%8C"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.attention 及其变体原理，cross attention 的 qkv 来自哪里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Cross-Attention%EF%BC%88%E4%BA%A4%E5%8F%89%E6%B3%A8%E6%84%8F%E5%8A%9B%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">3. Cross-Attention（交叉注意力）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-number">1.3.6.</span> <span class="toc-text">4. 为什么这样设计？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%8E%E4%B9%88%E7%AE%97%EF%BC%9F"><span class="toc-number">1.3.7.</span> <span class="toc-text">5.自注意力机制是什么？计算复杂度怎么算？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-KV-Cache%E7%9A%84%E5%A6%82%E4%BD%95%E5%8A%A0%E9%80%9F%E6%8E%A8%E7%90%86%EF%BC%9F"><span class="toc-number">1.3.8.</span> <span class="toc-text">6.KV-Cache的如何加速推理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-LoRA%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%8EP-Tuning%E3%80%81Adapter%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9%EF%BC%9FLoRA%E7%9A%84%E5%8F%82%E6%95%B0%E9%80%89%E6%8B%A9%E5%AF%B9%E6%A8%A1%E5%9E%8B%E6%80%A7%E8%83%BD%E6%9C%89%E4%BD%95%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">1.3.9.</span> <span class="toc-text">7.LoRA的原理是什么？与P-Tuning、Adapter的异同点？LoRA的参数选择对模型性能有何影响？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BB%8B%E7%BB%8D%E4%B8%8BRLHF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%EF%BC%8C%E4%B8%8EDPO%E7%9A%84%E5%B7%AE%E5%BC%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.10.</span> <span class="toc-text">8.介绍下RLHF的基本流程，与DPO的差异是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E4%B8%AD%E7%9A%84TP%E3%80%81PP%E3%80%81DP%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.11.</span> <span class="toc-text">9.分布式训练中的TP、PP、DP分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-flash-attention%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.12.</span> <span class="toc-text">10.flash-attention的原理是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF4"><span class="toc-number">1.4.</span> <span class="toc-text">模板4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E5%81%9A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%A2%9E%E5%BC%BA%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.训练数据，有没有做数据处理与增强的工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9C%A8%E4%BB%80%E4%B9%88%E6%9C%BA%E5%99%A8%E4%B8%8A%E8%AE%AD%E7%BB%83%EF%BC%8C%E6%97%B6%E9%97%B4%EF%BC%8C%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.在什么机器上训练，时间，数据量大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-rag%E4%B8%AD%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84pdf%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%AF%B9pdf%E9%87%8C%E9%9D%A2%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%8C%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%8C%E6%80%8E%E4%B9%88%E7%BC%96%E7%A0%81%E7%9A%84%EF%BC%8C%E6%A3%80%E7%B4%A2%EF%BC%8C%E5%8F%AC%E5%9B%9E%E7%9A%84%E6%97%B6%E5%80%99%E9%83%BD%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%B7%B7%E5%90%88%E6%A3%80%E7%B4%A2%E7%9A%84%E6%97%B6%E5%80%99%E7%9A%84%E6%9D%83%E9%87%8D%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E6%B6%88%E8%9E%8D%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.3.</span> <span class="toc-text">5.rag中怎么做的pdf解析，对pdf里面的图片，表格数据怎么处理的，怎么编码的，检索，召回的时候都做了哪些操作，混合检索的时候的权重怎么处理的，有没有消融实现对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-sft%E4%B8%8Erag%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.4.</span> <span class="toc-text">7.sft与rag对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-agent%E6%96%B9%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BA%86%E8%A7%A3"><span class="toc-number">1.4.5.</span> <span class="toc-text">9.agent方面有哪些了解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF5"><span class="toc-number">1.5.</span> <span class="toc-text">模板5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%A4%E4%B8%89%E5%8F%A5%E4%BB%8B%E7%BB%8D%E4%B8%8Bagent%E4%BB%A5%E5%8F%8A%E5%BD%93%E5%89%8D%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 两三句介绍下agent以及当前的挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-transformer%E6%9E%B6%E6%9E%84-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. transformer架构 有哪些机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BA%A4%E5%8F%89%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. 解释下交叉注意力机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%8B%E7%BB%8D%E4%B8%8Bppo-dpo-grpo%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">4. 介绍下ppo dpo grpo算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-grpo%E7%9A%84loss%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E7%9A%84-%E6%95%B0%E6%8D%AE%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.5.</span> <span class="toc-text">5. grpo的loss怎么计算的 数据用的什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-deepresearch%E5%92%8C%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%80%8E%E4%B9%88%E7%BB%93%E5%90%88%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.6.</span> <span class="toc-text">6.deepresearch和强化学习怎么结合应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%A7%A3%E9%87%8A%E4%B8%8Btopk-topp%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.7.</span> <span class="toc-text">7. 解释下topk topp的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E5%9C%A8%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%83%BD%E6%98%AFdecoder%E6%9E%B6%E6%9E%84"><span class="toc-number">1.5.8.</span> <span class="toc-text">8. 为什么现在大模型都是decoder架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF5-2"><span class="toc-number">1.6.</span> <span class="toc-text">模板5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 损失函数设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-LoRA%E5%90%9F%E5%94%B1"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. LoRA吟唱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%8B%E6%92%95MHA"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. 手撕MHA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%9C%8B%E4%BD%A0%E9%99%A4%E4%BB%A5%E4%BA%86%E6%A0%B9%E5%8F%B7k-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text">4. 看你除以了根号k 有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8-%E5%A6%82%E4%BD%95%E7%BC%93%E8%A7%A3"><span class="toc-number">1.6.5.</span> <span class="toc-text">5. 梯度消失和梯度爆炸 如何缓解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-QKV%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88-%E8%AF%B4%E8%AF%B4%E7%90%86%E8%A7%A3"><span class="toc-number">1.6.6.</span> <span class="toc-text">6. QKV代表什么 说说理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A6%82%E6%9E%9CQK%E5%8F%98%E6%88%90%E5%90%8C%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5%E4%BD%A0%E8%A7%89%E5%BE%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D"><span class="toc-number">1.6.7.</span> <span class="toc-text">7. 如果QK变成同一个矩阵你觉得有什么影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E9%99%A4%E4%BA%86LoRA%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%BE%AE%E8%B0%83%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.8.</span> <span class="toc-text">8. 除了LoRA还有什么微调的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF6"><span class="toc-number">1.7.</span> <span class="toc-text">模板6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9-SFT%EF%BC%88%E7%9B%91%E7%9D%A3%E5%BE%AE%E8%B0%83%EF%BC%89%E4%B8%AD%E7%9A%84-scaling-law-%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E5%9C%A8%E5%AE%9E%E9%99%85%E8%AE%AD%E7%BB%83%E4%B8%AD%EF%BC%8C%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E6%AF%94%E8%BE%83%E5%A4%A7%E7%9A%84%E5%9B%B0%E9%9A%BE%EF%BC%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">你对 SFT（监督微调）中的 scaling law 有了解吗？在实际训练中，你遇到过哪些比较大的困难？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%8F%91%E7%8E%B0-advantage-%E6%88%96%E8%80%85-loss-%E7%AA%81%E7%84%B6%E5%8F%98%E6%88%90-0%EF%BC%8C%E4%B8%80%E8%88%AC%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%AF%BC%E8%87%B4%E7%9A%84%EF%BC%9F"><span class="toc-number">1.7.2.</span> <span class="toc-text">在模型训练时，如果发现 advantage 或者 loss 突然变成 0，一般可能是什么原因导致的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%9E%84%E5%BB%BA-AI-Agent-%E6%97%B6%EF%BC%8C%E5%AE%83%E7%9A%84%E8%AE%B0%E5%BF%86%EF%BC%88Memory%EF%BC%89%E6%9C%BA%E5%88%B6%E9%80%9A%E5%B8%B8%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F"><span class="toc-number">1.7.3.</span> <span class="toc-text">在构建 AI Agent 时，它的记忆（Memory）机制通常是怎么设计的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E6%A8%A1%E5%9E%8B%E5%87%BA%E7%8E%B0-bad-case-%E6%97%B6%EF%BC%8C%E4%BD%A0%E4%B8%80%E8%88%AC%E4%BC%9A%E6%80%8E%E4%B9%88%E5%88%86%E6%9E%90%EF%BC%9F%E5%90%8E%E7%BB%AD%E4%BC%9A%E9%87%87%E5%8F%96%E5%93%AA%E4%BA%9B%E6%8E%AA%E6%96%BD%E6%9D%A5%E6%94%B9%E8%BF%9B%EF%BC%9F"><span class="toc-number">1.7.4.</span> <span class="toc-text">当模型出现 bad case 时，你一般会怎么分析？后续会采取哪些措施来改进？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E4%B8%BA%E7%89%B9%E5%AE%9A%E9%A2%86%E5%9F%9F%E7%9A%84%E6%96%87%E6%9C%AC%E8%AE%AD%E7%BB%83%E4%B8%80%E5%A5%97-Embedding%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">1.7.5.</span> <span class="toc-text">如果需要为特定领域的文本训练一套 Embedding，你会怎么做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E7%9A%84%E5%BA%95%E5%B1%82%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F%E6%AF%94%E5%A6%82%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%EF%BC%88DP%EF%BC%89%E3%80%81%E5%BC%A0%E9%87%8F%E5%B9%B6%E8%A1%8C%EF%BC%88TP%EF%BC%89%E8%BF%99%E4%BA%9B%EF%BC%8C%E7%9C%8B%E8%BF%87-Megatron-%E8%BF%99%E7%B1%BB%E6%A1%86%E6%9E%B6%E7%9A%84%E6%BA%90%E7%A0%81%E5%90%97%EF%BC%9F"><span class="toc-number">1.7.6.</span> <span class="toc-text">你对大模型分布式训练的底层了解多少？比如数据并行（DP）、张量并行（TP）这些，看过 Megatron 这类框架的源码吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%BC%8F%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.7.</span> <span class="toc-text">核心代码模式算法题：二维数组中的查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50%E9%97%AE"><span class="toc-number">1.8.</span> <span class="toc-text">50问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%87%8C%E5%BA%94%E7%94%A8%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%97%B6%EF%BC%8C%E7%8A%B6%E6%80%81%EF%BC%8C%E5%8A%A8%E4%BD%9C%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%8A%A8%E4%BD%9C%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. 大模型里应用强化学习时，状态，动作空间，动作都是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-RLHF%E8%AE%AD%E7%BB%83%E6%97%B6%EF%BC%8CReward-Model%E5%92%8CLLM%E6%98%AF%E5%90%8C%E6%97%B6%E8%AE%AD%E7%BB%83%E8%BF%98%E6%98%AF%E5%85%88%E5%90%8E%E8%AE%AD%E7%BB%83%EF%BC%8Cinstruct-GPT%E8%AE%BA%E6%96%87%E9%87%8C%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%AD%E7%BB%83RM%E7%9A%84"><span class="toc-number">1.8.2.</span> <span class="toc-text">2. RLHF训练时，Reward Model和LLM是同时训练还是先后训练，instruct GPT论文里是如何训练RM的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%AD%E7%BB%83RM%E6%97%B6%EF%BC%8C%E6%97%A0%E8%AE%BA%E6%98%AFinstruct-GPT%E8%BF%98%E6%98%AFDPO%EF%BC%8C-%E4%B8%BA%E4%BB%80%E4%B9%88loss%E9%87%8C%E6%9C%89log%E5%92%8Csigmod%E5%87%BD%E6%95%B0%EF%BC%9F-%E7%9B%B4%E6%8E%A5%E7%94%A8reward%E7%9B%B8%E5%87%8F%E4%B8%8D%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">1.8.3.</span> <span class="toc-text">3. 训练RM时，无论是instruct GPT还是DPO， 为什么loss里有log和sigmod函数？ 直接用reward相减不行吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-RLHF-%E6%8C%87openai-instruct-GPT%E8%AE%BA%E6%96%87%E4%B8%AD-%EF%BC%8C%E8%AE%AD%E7%BB%83LLM%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.8.4.</span> <span class="toc-text">4. RLHF(指openai instruct GPT论文中)，训练LLM的损失函数是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%86%E8%A7%A3RLHF-PPO%E5%90%97%EF%BC%8C%E9%87%8C%E9%9D%A2%E9%9C%80%E8%A6%81%E8%AE%AD%E7%BB%83%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%8A%A0%E8%BD%BD%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.8.5.</span> <span class="toc-text">5. 了解RLHF-PPO吗，里面需要训练几个模型，加载几个模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-RLHF-PPO%E9%87%8C%EF%BC%8Creward%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8CGAE%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.8.6.</span> <span class="toc-text">6. RLHF-PPO里，reward的设计是什么，GAE是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-RLHF-PPO%E8%AE%AD%E7%BB%83%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%85%AC%E5%BC%8F"><span class="toc-number">1.8.7.</span> <span class="toc-text">7. RLHF-PPO训练的损失函数公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BD%A0%E7%9F%A5%E9%81%93DPO%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%85%AC%E5%BC%8F%E5%90%97%EF%BC%9F"><span class="toc-number">1.8.8.</span> <span class="toc-text">8. 你知道DPO的损失函数公式吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-DPO%E7%9A%84reward%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0reward-hacking%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.8.9.</span> <span class="toc-text">9. DPO的reward是什么，会不会出现reward hacking？有哪些解决方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-DPO%E7%9A%84%E6%AD%A3%E8%B4%9F%E6%A0%B7%E6%9C%AC%E5%AF%B9%E6%9E%84%E9%80%A0%E7%9A%84%E6%97%B6%E5%80%99%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.8.10.</span> <span class="toc-text">10. DPO的正负样本对构造的时候要注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-GRPO-PPO-%E4%B8%8E-DPO-%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.8.11.</span> <span class="toc-text">11. GRPO , PPO 与 DPO 区别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-PPO%E6%98%AFMC%E8%BF%98%E6%98%AFTD%EF%BC%8C-GRPO%E5%91%A2"><span class="toc-number">1.8.12.</span> <span class="toc-text">12. PPO是MC还是TD， GRPO呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-PPO%E5%92%8CGRPO%E7%9A%84KL%E6%95%A3%E5%BA%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.13.</span> <span class="toc-text">13. PPO和GRPO的KL散度的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-GRPO%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%E4%B8%8AKL%E6%95%A3%E5%BA%A6%EF%BC%8C%E7%94%A8%E7%9A%84KL%E6%95%A3%E5%BA%A6%E6%98%AF%E6%AD%A3%E5%90%91KL%E6%95%A3%E5%BA%A6%E8%BF%98%E6%98%AF%E5%8F%8D%E5%90%91%EF%BC%9F"><span class="toc-number">1.8.14.</span> <span class="toc-text">14. GRPO为什么加上KL散度，用的KL散度是正向KL散度还是反向？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%85%B7%E4%BD%93%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97KL%E6%95%A3%E5%BA%A6%EF%BC%8CKL%E6%95%A3%E5%BA%A6%E5%92%8C%E4%BA%A4%E5%8F%89%E7%86%B5%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.8.15.</span> <span class="toc-text">15. 具体怎么计算KL散度，KL散度和交叉熵有什么关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-GRPO-PPO%E6%98%AFon-policy%E8%BF%98%E6%98%AFoff-policy%E7%9A%84%EF%BC%8C-DPO%E5%91%A2"><span class="toc-number">1.8.16.</span> <span class="toc-text">16. GRPO&#x2F;PPO是on policy还是off policy的， DPO呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%B8%8D%E8%80%83%E8%99%91cpu-offload-GRPO%E8%AE%AD%E7%BB%83%E6%97%B6%EF%BC%8C%E6%98%BE%E5%AD%98%E9%87%8C%E6%9C%89%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.8.17.</span> <span class="toc-text">17. 不考虑cpu-offload, GRPO训练时，显存里有几个模型，分别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%90%8C%E4%B8%8A%EF%BC%8CPPO%E5%91%A2%EF%BC%9FDPO%E5%91%A2%EF%BC%9F"><span class="toc-number">1.8.18.</span> <span class="toc-text">18. 同上，PPO呢？DPO呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-GRPO%E8%AE%AD%E7%BB%83%E6%97%B6%EF%BC%8C%E6%A2%AF%E5%BA%A6%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%9A%84"><span class="toc-number">1.8.19.</span> <span class="toc-text">19. GRPO训练时，梯度是如何反向传播的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E4%B8%BA%E4%BB%80%E4%B9%88GRPO%E5%92%8CPPO%E9%83%BD%E8%A6%81%E5%AF%B9rA-clip-1-e-1-e-r-A%E5%86%8D%E5%8F%96%E4%B8%80%E4%B8%AAmin%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E7%94%A8clip-1-e-1-e-r-A"><span class="toc-number">1.8.20.</span> <span class="toc-text">20. 为什么GRPO和PPO都要对rA,clip(1-e, 1+e, r)A再取一个min，而不是直接用clip(1-e, 1+e, r)A</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-GRPO%E8%AE%AD%E7%BB%83%E6%97%B6%EF%BC%8C%E8%A2%ABclip%E6%8E%89%E7%9A%84token%E5%AF%B9loss%E5%92%8C%E6%A2%AF%E5%BA%A6%E6%9C%89%E8%B4%A1%E7%8C%AE%E5%90%97%EF%BC%9F"><span class="toc-number">1.8.21.</span> <span class="toc-text">21. GRPO训练时，被clip掉的token对loss和梯度有贡献吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-GRPO%E6%9C%89%E5%93%AA%E4%BA%9B%E6%94%B9%E8%BF%9B%E6%80%9D%E8%B7%AF%EF%BC%8C%E8%83%BD%E4%B8%8D%E8%83%BD%E8%AF%B4%E8%AF%B4%E5%85%B7%E4%BD%93%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.22.</span> <span class="toc-text">22. GRPO有哪些改进思路，能不能说说具体的几个算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E4%BA%86%E8%A7%A3MOE%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E6%97%B6%E7%9A%84routing-replay%E5%90%97"><span class="toc-number">1.8.23.</span> <span class="toc-text">23. 了解MOE模型训练时的routing replay吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%87%BA%E7%8E%B0reward-hacking"><span class="toc-number">1.8.24.</span> <span class="toc-text">24. 强化学习中如何判断是否出现reward hacking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E5%AF%B9%E4%BA%8Ereward-hacking%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">1.8.25.</span> <span class="toc-text">25. 对于reward hacking有什么解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-LLM-as-judge%E6%8F%90%E4%BE%9B%E7%9A%84reward%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.8.26.</span> <span class="toc-text">26. LLM-as-judge提供的reward可能出现哪些问题，有什么解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-GRPO%E8%AE%AD%E7%BB%83%E6%97%B6%E5%87%BA%E7%8E%B0%E6%8F%90%E5%89%8D%E6%94%B6%E6%95%9B%E7%9A%84%E7%8E%B0%E8%B1%A1%EF%BC%8C%E5%8D%B3%E4%B8%80%E4%B8%AAepoch%E5%B0%9A%E6%9C%AA%E8%AE%AD%E7%BB%83%E5%AE%8C%E6%88%90%EF%BC%8Creward%E5%B0%B1%E5%B7%B2%E7%BB%8F%E9%A5%B1%E5%92%8C%EF%BC%8C%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E6%9C%89%E4%BB%80%E4%B9%88%E5%A4%84%E7%90%86%E6%80%9D%E8%B7%AF"><span class="toc-number">1.8.27.</span> <span class="toc-text">27. GRPO训练时出现提前收敛的现象，即一个epoch尚未训练完成，reward就已经饱和，这种情况有什么处理思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%80%9F%E7%94%A8replay-buffer%E6%9D%A5%E8%A7%A3%E5%86%B3on-policy%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%AD%E4%BB%A3-%E6%95%88%E6%9E%9C%E5%A6%82%E4%BD%95"><span class="toc-number">1.8.28.</span> <span class="toc-text">28. 强化学习借用replay buffer来解决on-policy算法的迭代, 效果如何?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-GRPO%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8off-policy%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BE%85%E5%8A%A9reward%E8%AE%A1%E7%AE%97%EF%BC%9F-%E4%BE%8B%E5%A6%82%E5%90%8C%E4%B8%80%E4%B8%AAquery%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%87%A0%E4%B8%AAstep%E4%B9%8B%E5%89%8D%E7%9A%84rollout%EF%BC%8C%E4%BB%A5%E9%99%8D%E4%BD%8E%E9%87%87%E6%A0%B7%E5%8E%8B%E5%8A%9B%EF%BC%9F"><span class="toc-number">1.8.29.</span> <span class="toc-text">29. GRPO能否使用off-policy的数据辅助reward计算？ 例如同一个query，使用几个step之前的rollout，以降低采样压力？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/24/2025-12-24-Function-Call-%E7%9A%84%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D%E8%A6%81%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E6%98%AF%E6%9C%80%E9%9A%BE%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%9F/" title="Function Call 的多轮对话要怎么处理？为什么它是最难的部分？"><div style="background: /img/cover/langgraph.jepg"></div></a><div class="content"><a class="title" href="/2025/12/24/2025-12-24-Function-Call-%E7%9A%84%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D%E8%A6%81%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E6%98%AF%E6%9C%80%E9%9A%BE%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%9F/" title="Function Call 的多轮对话要怎么处理？为什么它是最难的部分？">Function Call 的多轮对话要怎么处理？为什么它是最难的部分？</a><time datetime="2025-12-23T16:00:00.000Z" title="发表于 2025-12-24 00:00:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/24/2025-12-24-RL-for-LLM-%E9%AB%98%E8%B4%A8%E9%87%8F%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/" title="RL for LLM 高质量文章汇总"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/RL.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RL for LLM 高质量文章汇总"/></a><div class="content"><a class="title" href="/2025/12/24/2025-12-24-RL-for-LLM-%E9%AB%98%E8%B4%A8%E9%87%8F%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/" title="RL for LLM 高质量文章汇总">RL for LLM 高质量文章汇总</a><time datetime="2025-12-23T16:00:00.000Z" title="发表于 2025-12-24 00:00:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/23/2025-12-23-Anthropic-skils%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%AE%9E%E8%B7%B5/" title="Anthropic skils解读与实践"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/SKILL.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Anthropic skils解读与实践"/></a><div class="content"><a class="title" href="/2025/12/23/2025-12-23-Anthropic-skils%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%AE%9E%E8%B7%B5/" title="Anthropic skils解读与实践">Anthropic skils解读与实践</a><time datetime="2025-12-22T16:00:00.000Z" title="发表于 2025-12-23 00:00:00">2025-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/2025-12-22-LLM%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF%EF%BC%9AMC-TD-Q-Learning-DQN-PG-AC-TRPO-PPO-DPO-GRPO/" title="LLM强化学习算法演进之路：MC-&gt;TD-&gt;Q-Learning-&gt;DQN-&gt;PG-&gt;AC-&gt;TRPO-&gt;PPO-&gt;DPO-&gt;GRPO"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/pytorch.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LLM强化学习算法演进之路：MC-&gt;TD-&gt;Q-Learning-&gt;DQN-&gt;PG-&gt;AC-&gt;TRPO-&gt;PPO-&gt;DPO-&gt;GRPO"/></a><div class="content"><a class="title" href="/2025/12/22/2025-12-22-LLM%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF%EF%BC%9AMC-TD-Q-Learning-DQN-PG-AC-TRPO-PPO-DPO-GRPO/" title="LLM强化学习算法演进之路：MC-&gt;TD-&gt;Q-Learning-&gt;DQN-&gt;PG-&gt;AC-&gt;TRPO-&gt;PPO-&gt;DPO-&gt;GRPO">LLM强化学习算法演进之路：MC-&gt;TD-&gt;Q-Learning-&gt;DQN-&gt;PG-&gt;AC-&gt;TRPO-&gt;PPO-&gt;DPO-&gt;GRPO</a><time datetime="2025-12-21T16:00:00.000Z" title="发表于 2025-12-22 00:00:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/19/2025-12-19-pytorch%E5%AD%A6%E4%B9%A0/" title="pytorch学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/pytorch.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pytorch学习"/></a><div class="content"><a class="title" href="/2025/12/19/2025-12-19-pytorch%E5%AD%A6%E4%B9%A0/" title="pytorch学习">pytorch学习</a><time datetime="2025-12-18T16:00:00.000Z" title="发表于 2025-12-19 00:00:00">2025-12-19</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2024 - 2025 By Roger-Lv</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.2"></script><script src="/js/main.js?v=5.4.2"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.8.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'smA3tZdRGodG2VgnMubBQjLm-gzGzoHsz',
      appKey: 'biCDxj0lSBtZTMie2kNIKErd',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.3/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><div class="aplayer no-destroy" data-id="8674547170" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.4.2"></script></div></div></body></html>