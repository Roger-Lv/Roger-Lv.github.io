---
title: xxl-job学习笔记
date: 2024-08-25
updated:
tags: [Java,后端,微服务,分布式任务调度]
categories: 后端
keywords:
description:
top_img: /img/default_top_img.jpg
comments:
cover: /img/cover/java.gif
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
abcjs:


---

# xxl-job学习笔记

## 基础概念

xxl-job是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。

## 任务执行流程

![image-20240825111454492.png](https://s2.loli.net/2024/08/25/iCr1DvLhW2K94eR.png)

**执行流程**

1. 任务执行器根据配置的调度中心的地址，自动注册到调度中心

2. 达到任务出发条件，调度中心下发任务
3. 执行器基于线程池执行任务，并把执行结果放入内存队列、把执行日志写入日志文件中
4. 执行器消费内存队列中的执行结果，主动上报给调度中心
5. 当用户在调度中心查看任务日志，调度中心请求任务执行器，任务执行器读取任务日志文件并返回日志详情

## 搭建xxl-job

[xxl-job: 一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 (gitee.com)](https://gitee.com/xuxueli0323/xxl-job)

### 使用docker搭建xxl-job

```shell
docker search xxl-job
docker pull xuxueli/xxl-job-admin:2.4.0

docker run  -d \
        -p 8088:8088\
        -v /tool/xxl-job/logs:/data/applogs \
        -v /tool/xxl-job/application.properties:/xxl-job/xxl-job-admin/src/main/resources/application.properties \
        -e PARAMS="--server.port=8088\
        --spring.datasource.url=jdbc:mysql://xxx.xx.xx.xxx:3306/xxl_job?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&serverTimezone=Asia/Shanghai \
        --spring.datasource.username=root \
        --spring.datasource.password=Wing1Q2W#E" \
        --name xxl-job-admin  \
xuxueli/xxl-job-admin:2.4.0
```

使用docker ps命令可以查看是否运行成功。

### 常规搭建

1. 下载项目并解压，执行数据库初始化SQL脚本（在doc/db目录下），根据数据库脚本创建数据库，有以下八张表（MySQL配置：[Mysql超详细安装配置教程(保姆级)_mysql安装及配置超详细教程-CSDN博客](https://blog.csdn.net/weixin_47406082/article/details/131867849?ops_request_misc=%7B%22request%5Fid%22%3A%22172455767816800226561928%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=172455767816800226561928&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-131867849-null-null.142^v100^pc_search_result_base8&utm_term=MYSQL安装&spm=1018.2226.3001.4187)）（navicat:[Navicat16\17安装和激活详细讲解（全网最简单且靠谱）_navicat 16-CSDN博客](https://blog.csdn.net/weixin_50670076/article/details/136350060?ops_request_misc=%7B%22request%5Fid%22%3A%22172455932816800207023974%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=172455932816800207023974&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-136350060-null-null.142^v100^pc_search_result_base8&utm_term=navicat&spm=1018.2226.3001.4187)）

   ![image-20240825111113486.png](https://s2.loli.net/2024/08/25/1uCKvHfTnWPLipR.png)

   - **xxl_job_lock：**任务调度锁表；
   - **xxl_job_group：**执行器信息表，维护任务执行器信息；
   - **xxl_job_info：**调度扩展信息表： 用于保存XXL-JOB调度任务的扩展信息，如任务分组、任务名、机器地址、执行器、执行入参和报警邮件等等；
   - **xxl_job_log：**调度日志表： 用于保存XXL-JOB任务调度的历史信息，如调度结果、执行结果、调度入参、调度机器和执行器等等；
   - **xxl_job_logglue：**任务GLUE日志：用于保存GLUE更新历史，用于支持GLUE的版本回溯功能；
   - **xxl_job_registry**：执行器注册表，维护在线的执行器和调度中心机器地址信息；
   - **xxl_job_user：**系统用户表；

   注意事项：

   - 调度中心（即xxl-job）支持集群部署，集群情况下各节点务必连接同一个mysql实例;
   - 如果mysql做主从,调度中心集群节点务必强制走主库;
   - 默认账号密码：admin/123456

2. 部署配置调度中心

   - 调度中心项目：xxl-job-admin

   - 作用：统一管理任务调度平台上调度任务，负责触发调度执行，并且提供任务管理平台。

   - 调度中心配置文件地址：/xxl-job/xxl-job-admin/src/main/resources/application.properties

     ![image-20240825133654385.png](https://s2.loli.net/2024/08/25/MlOS5o38knEebrQ.png)

     如图所示，这里配置的有对应的数据库的地址、用户名和密码等内容。

3. 启动xxl-job

   启动成功，访问**http://localhost:8080/xxl-job-admin/**，默认登录账号密码 “**admin/123456**”, 登录后运行界面如下图所示。

   ![image-20240825133630704.png](https://s2.loli.net/2024/08/25/nzdXia3VHRfDNvL.png)

   

## 案例使用(pku-service，进行接入)

前置条件：xxl-job的服务端已经起好。

目录结构（需要从xxl-job的项目中将xxl-job-executor-sample-springboot目录copy出来）：

![image-20240825145410259.png](https://s2.loli.net/2024/08/25/TK1eRXJpIgALwt6.png)

1. **java连接xxl-job**

   **添加依赖**maven（pom.xml）

   ```xml
   <dependencies>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-web</artifactId>
               <version>2.4.2</version>
           </dependency>
   
           <!--xxl-job-->
           <dependency>
               <groupId>com.xuxueli</groupId>
               <artifactId>xxl-job-core</artifactId>
               <version>2.3.0</version>
           </dependency>
       </dependencies>
   ```

   **yaml文件添加**(或者直接application.properties也行)

   ```yaml
   xxl:
     job:
       admin:
         addresses: http://*******:8080/xxl-job-admin/  #**** 更换服务器地址  
       executor:
         appname: pku-service         #执行器名字
         address:
         ip:
         port: 9999
         logpath: /data/applogs/xxl-job-jobhandler
         logretentiondays: 30
       accessToken: default_token
   ```

2. **配置xxl-job的执行器**

   - 将示例工程下的配置类拷贝到pku-service工程下，该类中的属性就是获取配置文件中的配置得到的，同时提供了一个执行器的Bean

     ```java
     import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;
     import org.slf4j.LoggerFactory;
     import org.springframework.beans.factory.annotation.Value;
     import org.springframework.context.annotation.Bean;
     import org.springframework.context.annotation.Configuration;
     
     import java.util.logging.Logger;
     
     @Configuration
     public class XxlJobConfig {
         private Logger logger = (Logger) LoggerFactory.getLogger(XxlJobConfig.class);
     
         @Value("${xxl.job.admin.addresses}")
         private String adminAddresses;
     
         @Value("${xxl.job.accessToken}")
         private String accessToken;
     
         @Value("${xxl.job.executor.appname}")
         private String appname;
     
         @Value("${xxl.job.executor.address}")
         private String address;
     
         @Value("${xxl.job.executor.ip}")
         private String ip;
     
         @Value("${xxl.job.executor.port}")
         private int port;
     
         @Value("${xxl.job.executor.logpath}")
         private String logPath;
     
         @Value("${xxl.job.executor.logretentiondays}")
         private int logRetentionDays;
     
     
         @Bean
         public XxlJobSpringExecutor xxlJobExecutor() {
             logger.info(">>>>>>>>>>> xxl-job config init.");
             XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();
             xxlJobSpringExecutor.setAdminAddresses(adminAddresses);
             xxlJobSpringExecutor.setAppname(appname);
             xxlJobSpringExecutor.setAddress(address);
             xxlJobSpringExecutor.setIp(ip);
             xxlJobSpringExecutor.setPort(port);
             xxlJobSpringExecutor.setAccessToken(accessToken);
             xxlJobSpringExecutor.setLogPath(logPath);
             xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);
     
             return xxlJobSpringExecutor;
         }
     
         /**
          * 针对多网卡、容器内部署等情况，可借助 "spring-cloud-commons" 提供的 "InetUtils" 组件灵活定制注册IP；
          *
          *      1、引入依赖：
          *          <dependency>
          *             <groupId>org.springframework.cloud</groupId>
          *             <artifactId>spring-cloud-commons</artifactId>
          *             <version>${version}</version>
          *         </dependency>
          *
          *      2、配置文件，或者容器启动变量
          *          spring.cloud.inetutils.preferred-networks: 'xxx.xxx.xxx.'
          *
          *      3、获取IP
          *          String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress();
          */
     
     }
     
     ```

3. 编写执行器代码（SampleXxlJob.java）

   注意这里的jobHandler的名称要匹配

   ```java
   /**
        * 1、简单任务示例（Bean模式）
        */
       @XxlJob("PKUJobHandler")
       public void demoJobHandler() throws Exception {
           XxlJobHelper.log("XXL-JOB, Hello World.");
           System.out.println("XXL-JOB, Hello World.");
           for (int i = 0; i < 5; i++) {
               XxlJobHelper.log("beat at:" + i);
               TimeUnit.SECONDS.sleep(2);
           }
           // default success
       }
   ```

   

4. **新增执行器**

   ![image-20240825134502190.png](https://s2.loli.net/2024/08/25/pe5PfDoUkBvqQ38.png)

   ![image-20240825135245256.png](https://s2.loli.net/2024/08/25/CAtXTZEYodl32Up.png)

   | 属性名称 | 说明                                                         |
   | -------- | ------------------------------------------------------------ |
   | AppName  | 是每个执行器集群的唯一标示AppName, 执行器会周期性以AppName为对象进行自动注册。可通过该配置自动发现注册成功的执行器, 供任务调度时使用; |
   | 名称     | 执行器的名称, 因为AppName限制字母数字等组成,可读性不强, 名称为了提高执行器的可读性; |
   | 排序     | 执行器的排序, 系统中需要执行器的地方,如任务新增, 将会按照该排序读取可用的执行器列表; |
   | 注册方式 | 调度中心获取执行器地址的方式；                               |
   | 机器地址 | 注册方式为"手动录入"时有效，支持人工维护执行器的地址信息；   |

5. 创建任务

   登录调度中心，点击下图所示“新建任务”按钮，新建示例任务：

   ![image-20240825150227329.png](https://s2.loli.net/2024/08/25/xGND9ycV3aznuvF.png)

   注意这里的JobHandler的名称要匹配。

   **基础配置：**

   - 执行器：每个任务必须绑定一个执行器, 方便给任务进行分组
   - 任务描述：任务的描述信息，便于任务管理；
   - 负责人：任务的负责人；
   - 报警邮件：任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔

   **调度配置：**

   - 调度类型：

     - 无：该类型不会主动触发调度；

     - CRON：该类型将会通过CRON，触发任务调度；

     - 固定速度：该类型将会以固定速度，触发任务调度；按照固定的间隔时间，周期性触发；

   **任务配置：**

   - 运行模式：
     - BEAN模式：任务以JobHandler方式维护在执行器端；需要结合 "JobHandler" 属性匹配执行器中任务；
   - JobHandler：运行模式为 "BEAN模式" 时生效，对应执行器中新开发的JobHandler类“@JobHandler”注解自定义的value值；
   - 任务参数：任务执行所需的参数；

   **高级配置**：

   - **阻塞处理策略：**
     - 阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；
     - 单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO(First Input First Output)队列并以串行方式运行；
     - 丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；
     - 覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；

   - **路由策略：**

     当执行器集群部署时，提供丰富的路由策略，包括；

     - FIRST（第一个）：固定选择第一个机器；
     - LAST（最后一个）：固定选择最后一个机器；
     - ROUND（轮询）
     - RANDOM（随机）：随机选择在线的机器；
     - CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。
     - LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；
     - LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；
     - FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；
     - BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；
     - SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；

6. 启动JobExecutorApplication

   ![image-20240825150957492.png](https://s2.loli.net/2024/08/25/dGneOK7hab5pNtI.png)

   这里已经能够成功调度了。同时注意到执行器这里已经自动注册上了：

   ![image-20240825151112157.png](https://s2.loli.net/2024/08/25/gDEbZwI95W3xmuJ.png)

## 补充：执行器和jobhandler的区别

![image-20240825111406289.png](https://s2.loli.net/2024/08/25/O6C7zl8WNDEnrd2.png)

XXL-JOB是一个分布式任务调度平台，它具有简单易用、轻量级和易扩展的特点。在XXL-JOB中，执行器（Executor）和任务处理器（JobHandler）是两个核心组件，它们共同协作来完成定时任务的执行。

执行器是任务的实际执行者，可以理解为承载任务的具体服务实例。每个执行器有自己独特的名称，通常设置为服务名以方便识别。执行器的主要职责是接收来自调度中心的调度请求，并执行相应的任务逻辑。执行器支持集群部署，以实现任务的高可用性和负载均衡  。

JobHandler则是任务的抽象表示，它负责编写和处理具体的任务代码。开发者需要实现JobHandler接口中的`execute`方法，该方法是任务执行的入口点。在执行器启动时，会初始化JobHandler并将它们注册到执行器的容器中，以便在接收到调度请求时能够找到并执行相应的任务逻辑  。

在XXL-JOB的架构中，"调度中心"负责管理调度信息并发出调度请求，而"执行器"则负责接收这些请求并执行JobHandler中的业务逻辑。这种设计使得调度和任务可以相互解耦，提高了系统整体的稳定性和扩展性  。

总结来说，执行器和JobHandler在XXL-JOB中的区别主要在于：
- 执行器（Executor）：任务的实际执行者，接收调度请求并执行任务。
- 任务处理器（JobHandler）：任务的抽象，包含具体的业务逻辑代码，由执行器执行。   