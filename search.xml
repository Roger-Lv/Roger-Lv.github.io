<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入理解分布式系统（七）案例研究</title>
      <link href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/"/>
      <url>/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="案例研究"><a href="#案例研究" class="headerlink" title="案例研究"></a>案例研究</h1><h4 id="7-1-分布式文件系统"><a href="#7-1-分布式文件系统" class="headerlink" title="7.1 分布式文件系统"></a>7.1 分布式文件系统</h4><p>GFS</p><p><a href="https://blog.csdn.net/tianwailaibin/article/details/6722956/?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8D%B7%E6%98%AF%E4%BB%80%E4%B9%88&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-6722956.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(459条消息) 什么是簇：什么是卷_tianwailaibin的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/354450124">【MIT 6.824】学习笔记 3: GFS - 知乎 (zhihu.com)</a></p><p><img src="https://s2.loli.net/2024/06/26/zCHi1YPJGlQMZUo.webp" alt="v2-75851b9c18c4b4b4b84507a9122129fa_1440w[1].webp"></p><h4 id="7-2-分布式协调服务"><a href="#7-2-分布式协调服务" class="headerlink" title="7.2 分布式协调服务"></a>7.2 分布式协调服务</h4><p>Zookeeper</p><p><a href="https://zhuanlan.zhihu.com/p/62526102">什么是ZooKeeper？ - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/64702090">zookeeper原理详解 - 知乎 (zhihu.com)</a></p><p>[(460条消息) Zookeeper纸上谈兵——Zookeeper与CAP原则_cap zookeeper_Amazing Coder的博客-CSDN博客](</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 深入理解分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分布式系统（三）分布式系统基础</title>
      <link href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系统基础"><a href="#分布式系统基础" class="headerlink" title="分布式系统基础"></a>分布式系统基础</h1><h2 id="3-1-分区"><a href="#3-1-分区" class="headerlink" title="3.1 分区"></a>3.1 分区</h2><p>在分布式系统中，分区是指将数据分成若干个部分，分别存储在不同的节点上，以达到提高系统性能和可扩展性的目的。分区是分布式系统中数据管理的基础。</p><p>在分区中，通常采用哈希算法对数据进行划分。具体来说，首先根据数据的某个属性进行哈希计算，得到一个哈希值，然后将这个哈希值映射到某个节点上，将对应的数据存储到这个节点上。通过这种方式，相同属性的数据会被分配到同一个节点上，从而提高数据访问的效率。</p><p>分区可以带来以下好处：</p><ol><li>提高系统的可扩展性：由于数据被分割成多个部分，每个部分可以分别存储在不同的节点上，因此可以更容易地进行横向扩展，增加节点数量来提高系统的处理能力。</li><li>提高系统的性能：由于相同属性的数据被分配到同一个节点上，因此可以更快地访问这些数据，从而提高系统的处理效率。</li><li>提高系统的容错性：当某个节点发生故障时，只有该节点上的数据会受到影响，而其他节点上的数据仍然可以正常访问，从而提高了系统的容错性。</li></ol><p>但是，分区也会带来一些挑战和问题，如数据的一致性和分区策略的选择等。因此，在设计分布式系统时，需要仔细考虑分区策略和数据一致性等问题，以确保系统的正确性和稳定性。</p><p>水平分区、垂直分区、列式数据库和行式数据库是关系型数据库的四种常见的数据分区和存储方式。</p><ol><li><strong>水平分区</strong></li></ol><p>水平分区是指将数据按照行进行切分，将每个分区的数据存储在不同的节点上。每个节点独立维护一个数据子集，这些数据子集之间相互独立。通常，水平分区的数据切分依据是数据的关键字或者某个属性，以便于查询时能够快速地定位数据。</p><p>使用场景：水平分区通常适用于<strong>数据访问压力比较大的场景</strong>，如互联网应用、金融等领域，这些场景中<strong>需要高效的读写操作和数据访问</strong>。</p><p>特点：水平分区的优点是能够将数据分散在多个节点上，减少单节点的压力，提高系统性能和可扩展性。缺点是需要考虑数据一致性的问题，当某个节点发生故障时，需要采取相应的措施保证数据的一致性。</p><ol start="2"><li><strong>垂直分区</strong></li></ol><p>垂直分区是指将数据按照列进行切分，将不同的列存储在不同的节点上。不同的节点维护不同的数据子集，但是数据之间存在关联关系。垂直分区的目的是将数据分开存储，减少节点之间的冗余数据。</p><p>使用场景：垂直分区适用于需要对数据进<strong>行复杂查询和分析</strong>的场景，如数据仓库等。</p><p>特点：垂直分区的优点是可以减少冗余数据，提高系统性能和存储效率，同时也能提高数据的安全性。缺点是可能会增加系统的复杂度，同时需要进行多表连接查询，对系统性能有一定影响。</p><ol start="3"><li>列式数据库</li></ol><p>列式数据库是指将数据按照列进行存储和访问的数据库系统。相比于传统的行式数据库，列式数据库更加适用于大规模数据的分析和查询，能够提供更高的查询效率和存储效率。列式数据库将每列数据存储在一个独立的文件或数据块中，这样可以避免读取不必要的数据，从而提高查询效率。</p><p>使用场景：列式数据库适用于大规模数据的分析和查询，如数据仓库、在线分析处理等领域。</p><p>特点：列式数据库的优点是<strong>查询效率高，存储效率高，能够快速响应复杂查询请求。缺点是更新效率相对较低，不适用于需要频繁进行更新操作的场景</strong>。</p><ol start="4"><li>行式数据库</li></ol><p>行式数据库是指将数据按照行进行存储和访问的数据库系统。行式数据库将同一行的数据存储在一起，这样能够提高数据的插入和更新效率。相比于列式数据库，行式数据库更适用于需要频繁进行更新操作的场景。</p><p>使用场景：行式数据库适用于需要频繁进行更新操作的场景，如在线交易系统、客户关系管理等领域。</p><p>特点：行式数据库的优点是<strong>支持高并发的写入操作，适用于需要频繁进行更新操作的场景。缺点是查询效率相对较低，尤其是对于大规模数据的查询</strong>，查询效率明显低于列式数据库。</p><h3 id="3-1-1-水平分区算法"><a href="#3-1-1-水平分区算法" class="headerlink" title="3.1.1 水平分区算法"></a>3.1.1 水平分区算法</h3><p>水平分区算法是指将数据按照某个属性值进行分区的一种算法。以下是几种常见的水平分区算法：</p><ol><li>范围分区</li></ol><p>范围分区是将数据按照某个属性值的范围进行分区的算法。例如，对于一个学生表，可以将学生按照年龄范围进行分区，比如0-10岁、11-20岁、21-30岁等等。</p><ol start="2"><li>哈希分区</li></ol><p>哈希分区是将数据按照某个属性值的哈希值进行分区的算法。例如，对于一个学生表，可以将学生按照学生编号进行哈希分区，将相同哈希值的学生存储在同一个分区中。</p><ol start="3"><li>轮询分区</li></ol><p>轮询分区是将数据按照一定的轮询方式进行分区的算法。例如，对于一个负载均衡系统，可以将请求按照轮询的方式分配给不同的服务器处理，以达到负载均衡的效果。</p><p>以上算法只是水平分区的几种常见方法，实际应用中还可以根据具体的需求和数据特点进行适当的调整和优化。</p><p><strong>一致性哈希：</strong></p><p><strong>一致性哈希</strong>（Consistent Hashing）是一种分布式哈希算法，它可以将数据和节点映射到同一个哈希环上，从而方便进行数据的分布式存储和访问。一致性哈希算法的核心思想是通过哈希函数将数据和节点映射到同一个环上，然后根据数据的哈希值在环上查找节点，从而实现分布式存储和访问。</p><p>一致性哈希算法的优点是可以有效地解决节点的动态增加和删除问题。当新的节点加入系统时，只需要将它的哈希值插入到哈希环上，然后将相邻的数据重新映射到新节点上即可。当节点离开系统时，只需要将它的哈希值从哈希环上移除，然后将相邻的数据重新映射到其他节点上即可。</p><p>另外，一致性哈希算法也可以有效地解决数据倾斜问题。由于哈希函数的随机性，一些节点可能会负责更多的数据，从而导致负载不均衡的问题。为了解决这个问题，一致性哈希算法引入了虚拟节点的概念，将每个物理节点映射到多个虚拟节点上，从而平衡节点的负载。</p><p>总之，一致性哈希算法是一种简单有效的分布式哈希算法，可以在分布式系统中实现数据的高效分布式存储和访问。</p><h3 id="3-1-2-分区的挑战"><a href="#3-1-2-分区的挑战" class="headerlink" title="3.1.2 分区的挑战"></a>3.1.2 分区的挑战</h3><p>查询困难和事务</p><h2 id="3-2-复制"><a href="#3-2-复制" class="headerlink" title="3.2 复制"></a>3.2 复制</h2><p>  在分布式系统中，复制（Replication）是一种常见的技术，它将数据和计算资源复制到多个节点上。复制的好处包括：</p><ol><li>高可用性：如果一个节点失效，复制的数据和计算资源可以在其他节点上继续运行，保证系统的可用性。</li><li>改善性能：通过将数据和计算资源复制到多个节点上，可以减少网络延迟和瓶颈，提高系统的响应速度和吞吐量。</li><li>容错性：复制可以提高系统的容错性，即使某个节点发生故障，也可以在其他节点上继续运行，从而保障数据的完整性和可用性。</li><li>提高可扩展性：复制可以提高系统的可扩展性，因为复制的数据和计算资源可以在不同的节点上进行并行处理，从而提高系统的处理能力。</li></ol><p>需要注意的是，复制也会带来一些负面影响，例如增加系统的复杂度和维护成本，以及可能导致数据一致性的问题。因此，在使用复制技术时，需要仔细考虑各种因素，并根据具体情况进行权衡。</p><h3 id="3-2-1-单主复制"><a href="#3-2-1-单主复制" class="headerlink" title="3.2.1 单主复制"></a>3.2.1 单主复制</h3><p>单主复制是指在分布式系统中，只有一个节点拥有写入权限，其他节点只能进行读取操作，并且该节点负责将写入的数据复制到其他节点上。单主复制的好处包括：</p><ol><li>简单易用：单主复制相对于其他复制方案来说比较简单，易于实现和维护。</li><li>数据一致性：由于只有一个节点拥有写入权限，所以数据的一致性相对较容易维护，可以避免多个节点同时对同一数据进行写入操作导致的数据不一致问题。</li><li>安全性：单主复制可以避免多个节点同时写入数据可能导致的数据冲突问题，从而保证数据的安全性。</li></ol><p>需要注意的是，单主复制也有一些缺点，例如：</p><ol><li>单点故障：由于只有一个节点拥有写入权限，如果该节点发生故障，整个系统将不可用。</li><li>性能瓶颈：由于所有的写入操作都要经过单个节点，可能会成为性能瓶颈，限制了系统的扩展性和吞吐量。</li><li>可用性问题：如果节点之间的网络连接出现问题，可能会导致数据无法及时复制到其他节点，从而影响系统的可用性。</li></ol><p>因此，在使用单主复制技术时，需要仔细考虑各种因素，并根据具体情况进行权衡。</p><p>在单主复制中，可以进一步分为以下两种类型：</p><ol><li>主从复制（Master-Slave Replication）：在主从复制中，只有一个节点（主节点）拥有写入权限，其他节点（从节点）只能进行读取操作，并且主节点负责将写入的数据复制到从节点上。主节点的写入操作会被异步地复制到从节点上，从节点的数据与主节点可能<strong>存在一定的延迟</strong>，但从节点的数据最终会与主节点保持一致。主从复制可以提供高可用性和数据一致性，并且相对简单易用。</li><li>主备复制（Master-Standby Replication）：在主备复制中，也只有一个节点（主节点）拥有写入权限，其他节点（备节点）只能进行读取操作，并且备节点与主节点之间的数据同步是<strong>实时的</strong>。当主节点发生故障时，备节点会接管主节点的功能，成为新的主节点，从而保证系统的高可用性。主备复制相对于主从复制来说，可用性更高，但是实现和维护的复杂度更高。</li></ol><p><strong>脑裂：</strong></p><p>脑裂（Split-Brain）是指在分布式系统中，由于网络分区或者其他原因，导致系统中的节点失去联系，无法进行通信，进而导致系统出现数据不一致或者操作冲突的问题。</p><p>当出现网络分区时，系统中的节点可能会被分为两个或者多个独立的部分，每个部分都认为自己是整个系统的唯一部分，而且可能会独立地进行写入操作，导致数据不一致的问题。这种情况被称为脑裂。</p><p>脑裂可能会导致系统数据的不一致性，从而影响系统的正确性和可用性。为了避免脑裂的发生，可以采取以下措施：</p><ol><li>使用复制技术：通过将数据和计算资源复制到多个节点上，可以提高系统的可用性和容错性，减少脑裂的可能性。</li><li>使用投票机制：在系统中使用投票机制，可以避免脑裂的发生。例如，在主从复制中，主节点可以将写入操作同步到多个从节点上，然后通过投票机制来确定哪个从节点应该成为新的主节点，从而避免脑裂的发生。</li><li>限制节点的数量：在分布式系统中，可以限制节点的数量，从而减少系统的复杂度和容错难度，降低脑裂的风险。</li><li>监控系统状态：对系统状态进行监控，及时发现和解决潜在的问题，可以有效地避免脑裂的发生。</li></ol><p>需要注意的是，虽然可以通过上述措施来减少脑裂的风险，但是完全避免脑裂是非常困难的，因此需要在设计和实现分布式系统时充分考虑脑裂的风险，并制定相应的应对策略。</p><h3 id="3-2-2-多主复制"><a href="#3-2-2-多主复制" class="headerlink" title="3.2.2 多主复制"></a>3.2.2 多主复制</h3><p>在分布式系统中，多主复制（Multi-Master Replication）是指多个节点拥有写入权限，并且可以同时进行写入操作的一种复制方式。每个节点都可以独立地进行写入操作，写入的数据会被异步地复制到其他节点上，从而实现数据的复制和同步。</p><p>多主复制相对于单主复制来说，具有以下几个优点：</p><ol><li><strong>高并发性</strong>：多主复制允许多个节点同时进行写入操作，可以提高系统的并发性和吞吐量，从而满足高并发场景下的需求。</li><li><strong>高可用性</strong>：多主复制允许多个节点同时拥有写入权限，当某个节点出现故障时，其他节点可以继续进行写入操作，从而保证系统的高可用性和容错性。</li><li><strong>灵活性</strong>：多主复制可以根据实际需求进行灵活配置，可以在多个节点之间平衡负载，提高系统的稳定性和可靠性。</li></ol><p>但是，多主复制也存在一些挑战和限制：</p><ol><li>冲突问题：当多个节点同时进行写入操作时，可能会发生数据冲突的问题，需要采取相应的冲突解决策略来避免数据不一致的问题。</li><li>一致性问题：多主复制需要保证节点之间数据的一致性，需要使用相应的协调机制来保证数据的正确性和一致性。</li><li>实现和维护的复杂度：多主复制的实现和维护相对复杂，需要考虑节点之间的同步和冲突解决等问题，增加了系统的复杂度和维护难度。</li></ol><p>需要注意的是，在设计和实现多主复制时，需要综合考虑系统的性能、可用性和一致性等方面的需求，以及各种冲突解决和协调机制的复杂度和实现难度，从而选择最合适的复制方式。</p><p><strong>解决冲突：</strong></p><p>在多主复制中，当多个节点同时对同一个数据进行写入操作时，可能会发生冲突，从而导致数据的不一致性。为了避免冲突问题，可以采用以下几种解决办法：</p><ol><li><p>乐观锁机制：每个节点在进行写入操作前，先获取当前数据的版本号，并在写入时附带版本号信息。当其他节点进行写入时，会发现版本号不一致，从而引发冲突。此时，节点可以根据具体的策略进行相应的处理，例如选择最新的版本进行更新，或者放弃当前的写入操作等。</p></li><li><p>悲观锁机制：每个节点在进行写入操作时，先尝试获取对应的锁，如果获取不到，则说明有其他节点正在进行写入操作，此时可以等待一段时间后再次尝试获取锁，或者放弃当前的写入操作。</p></li><li><p>时序复制机制：在多主复制中，通过使用全局唯一的时间戳或序列号来协调多个节点之间的写入操作，从而避免冲突。每个节点在进行写入操作时，需要带上对应的时间戳或序列号，当其他节点接收到写入请求时，会根据时间戳或序列号来确定写入的先后顺序，从而保证数据的一致性。</p></li><li><p>基于版本向量的机制：每个节点在进行写入操作时，不仅记录当前数据的版本号，还记录其他节点最近的版本号信息。当其他节点进行写入时，会将自己的版本号信息传递给其他节点，从而形成一个版本向量，用于判断不同节点之间的数据冲突和一致性。</p></li><li><p>由客户端解决冲突</p></li><li><p>“最后写入胜利”（Last Writer Wins，LWW）是一种常见的多主复制冲突解决策略。该策略的基本思想是，当多个节点对同一个数据进行写入时，以最后写入的节点为准，即后来的写入操作会覆盖之前的写入操作。</p><p>具体实现时，每个节点在进行写入操作时，都会记录对应的时间戳或版本号，当其他节点收到写入请求时，会比较当前节点的时间戳或版本号和自身记录的时间戳或版本号，以此来判断哪个写入操作更晚，从而决定是否接受该写入请求。当发生冲突时，以最后写入的节点为准，更新数据。</p><p>需要注意的是，LWW策略虽然简单易实现，但也存在一些潜在的问题，例如可能导致数据的丢失、数据的不一致性等。因此，在选择冲突解决策略时，需要根据具体的应用场景和需求进行综合考虑，权衡不同策略的优缺点。</p></li><li><p>因果关系跟踪</p><p>因果关系跟踪（Causal tracing）是一种在分布式系统中用于跟踪不同节点之间交互的技术。在分布式系统中，不同节点之间的交互往往是异步的，并且可能经过多个中间节点，因此需要一种机制来跟踪交互的因果关系，以便分析和调试系统的行为。</p><p>因果关系跟踪通常基于事件模型，即将系统的行为抽象为一系列事件，并记录事件之间的因果关系。具体来说，当一个节点发送请求给另一个节点时，需要将请求的相关信息（例如请求ID、时间戳等）附加到请求中，并在接收到响应时将响应的相关信息（例如响应ID、时间戳等）附加到响应中。这样，每个事件就可以通过相关的信息与之前和之后的事件建立因果关系。</p><p>通过因果关系跟踪，可以实现分布式系统中的故障定位、性能调优、容错处理等功能。例如，在进行故障定位时，可以根据事件之间的因果关系，追溯出故障的来源；在进行性能调优时，可以通过分析事件之间的时间关系，找出系统中的瓶颈和优化空间；在进行容错处理时，可以根据因果关系判断不同节点之间的依赖关系，从而决定如何进行容错处理。</p><p>目前，因果关系跟踪已经成为分布式系统中的一个重要组成部分，并且在开源工具和云服务平台中得到了广泛应用，例如OpenTelemetry、Zipkin、Jaeger等。</p></li></ol><p>需要注意的是，不同的解决办法适用于不同的场景和需求，选择合适的冲突解决策略需要综合考虑多方面的因素，包括系统的性能、可靠性、一致性和复杂度等。</p><h3 id="3-2-3-无主复制"><a href="#3-2-3-无主复制" class="headerlink" title="3.2.3 无主复制"></a>3.2.3 无主复制</h3><p>无主复制（Masterless replication）是一种分布式系统中常见的数据复制策略，与单主复制和多主复制不同，无主复制不需要指定特定的节点作为主节点，而是让<strong>所有节点都能够读取和写入数据</strong>。具体来说，无主复制通常采用以下两种方式实现：</p><ol><li>基于<strong>副本集</strong>：无主复制可以基于副本集实现，即将数据复制到多个节点上，并保证每个节点上的数据副本是一致的。当进行写入操作时，所有节点都可以接受写入请求，并将<strong>写入操作广播</strong>给其他节点进行更新。当进行读取操作时，每个节点都可以从自己本地的数据副本中读取数据。</li><li>基于<strong>分片</strong>：无主复制也可以基于分片实现，即将数据划分为多个分片，并将每个分片复制到多个节点上。当进行写入操作时，只需要将<strong>写入操作发送给对应的分片所在的节点</strong>，并更新该节点上的数据副本。当进行读取操作时，只需要根据读取请求所涉及的分片，从对应的节点中读取数据。</li></ol><p>无主复制相比于单主复制和多主复制，具有<strong>更好的可伸缩性和容错性</strong>，因为每个节点都可以独立地接受读写请求，并且可以通过增加节点数目来提高系统的容错能力和吞吐量。但同时，无主复制也需要考虑数据一致性和冲突解决等问题，例如如何解决并发写入操作导致的冲突，如何保证数据的一致性等。</p><p>Dynamo架构中的两种数据修复方法：</p><ol><li><p>读修复（Read repair）：读修复是一种在读取数据时自动修复损坏或不一致数据的技术。在分布式系统中，由于数据副本之间可能存在网络分区或写冲突等问题，导致某些节点上的数据副本可能已经过期或损坏。当客户端<strong>从一个节点读取数据时，如果发现该节点上的数据副本已经过期或与其他节点上的副本不一致，该节点会尝试从其他节点中读取最新的数据，并将其与自己的数据副本进行比较和合并，从而实现数据的修复。</strong></p></li><li><p>反熵过程（Anti-entropy）：反熵过程是一种<strong>定期检查</strong>和修复数据不一致问题的技术。在分布式系统中，由于网络故障或其他原因，不同节点上的数据副本可能会出现不一致的情况，为了解决这个问题，系统可以定期启动反熵过程来检查和修复数据不一致。具体来说，反熵过程会<strong>周期性地比较不同节点之间的数据副本，将不同的数据副本进行合并，从而实现数据的一致性。</strong></p><p><strong>反熵过程通常会使用Merkle树来检测和修复数据不一致问题。</strong></p><p>Merkle树是一种树形结构，它可以用来验证分布式系统中的数据一致性。在Merkle树中，每个叶子节点都是数据块的哈希值，每个非叶子节点都是其子节点哈希值的哈希值。通过比较不同节点之间的Merkle树，可以快速检测数据不一致的位置，并将不同的数据块进行合并。</p><p>在反熵过程中，系统会对不同节点之间的Merkle树进行比较，检测不一致的位置，并将不同的数据块进行合并。具体来说，反熵过程会周期性地对所有节点的Merkle树进行比较，如果发现两个节点的Merkle树有不一致的位置，系统会将不同的数据块进行合并，并更新相应的节点。</p><p>使用Merkle树来进行反熵过程有以下优点：</p><ol><li>高效性：Merkle树具有高效的验证和合并性能，可以快速检测和修复数据不一致问题。</li><li>安全性：Merkle树可以有效地保护数据的安全性，因为如果任何一个节点的数据发生了改变，其对应的哈希值也会发生改变，从而导致整个Merkle树的哈希值发生改变。</li></ol><p>因此，Merkle树是反熵过程中常用的技术之一，可以有效地检测和修复分布式系统中的数据不一致问题。</p></li></ol><p><strong>Quorum的数据冗余机制：</strong></p><p>Quorum是一种基于Raft协议的分布式一致性算法，它允许在一个集群中同时运行多个副本来提高系统的可靠性和容错性。在Quorum中，数据冗余机制通常通过副本集群来实现。</p><p>具体来说，Quorum通过将数据复制到多个节点来实现数据冗余。在一个Quorum集群中，通常会有多个节点运行相同的应用程序，每个节点上都有一个或多个副本存储相同的数据。这些副本可以保证在节点故障或网络故障时，数据仍然可用。</p><p>Quorum的数据冗余机制具有以下特点：</p><ol><li>多副本：每个节点上通常会运行多个副本，确保数据的可靠性和容错性。</li><li>复制同步：Quorum使用Raft协议来保证多个副本之间的数据同步，确保每个副本都存储相同的数据。</li><li>副本数量：Quorum要求在集群中<strong>至少有一半以上的节点存储相同的数据</strong>，这样可以确保在一定程度上抵御节点故障和网络故障。</li><li>容错性：Quorum可以在节点故障或网络故障的情况下继续工作，确保数据的可用性。</li></ol><p>除了数据冗余机制，Quorum还支持其他一些功能，如数据复制和数据恢复。数据复制是指在集群中将数据从一个节点复制到另一个节点，以确保数据的可靠性和容错性。数据恢复是指在节点故障或网络故障的情况下，将数据从备份节点恢复到故障节点，以确保数据的可用性。这些功能都可以提高Quorum集群的可靠性和容错性。</p><p>W&gt;N&#x2F;2</p><p>W和R通常比N小（因为为了降低延迟）</p><h2 id="3-3-CAP定理"><a href="#3-3-CAP定理" class="headerlink" title="3.3 CAP定理"></a>3.3 CAP定理</h2><p>CAP定理是指在一个分布式系统中，一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）这三个特性无法同时满足，只能满足其中的两个。</p><p>具体来说：</p><ul><li>一致性：所有节点在同一时刻看到的数据是相同的。</li><li>可用性：客户端能够获得系统的响应，即使某些节点出现故障。</li><li>分区容错性：即使网络中断或节点故障，系统仍能继续运行。</li></ul><p>CAP定理的核心观点是，在分布式系统中，当网络分区发生时，系统必须要做出选择：是保证一致性还是可用性。由于分布式系统不可避免地会发生网络分区，因此系统必须要容忍分区，否则会导致系统的不可用性。因此，CAP定理的实质是，在网络分区发生时，系统必须要在一致性和可用性之间做出取舍。</p><p>需要注意的是，CAP定理中提到的一致性和可用性是指强一致性和高可用性，而不是最终一致性和可接受的可用性。最终一致性是指在一定时间内，系统最终会达到一致的状态；而可接受的可用性是指系统可以在一定时间内保证响应客户端的请求，但可能不是实时的。</p><p>CAP定理是分布式系统设计和实现的基础原则之一，它提醒我们在设计分布式系统时要充分考虑系统的一致性、可用性和分区容错性之间的关系，并根据具体需求进行取舍。</p><p>在网络分区发生时，分布式系统可能无法同时满足高可用性和强一致性，但是可以通过实现最终一致性来保证系统的可用性，并在一定时间内达到一致的状态。同时，如果系统对一致性要求不是非常高，也可以采用可接受的可用性来满足系统的需求。</p><p>需要注意的是，最终一致性并不是一个具体的算法或协议，而是一种设计思想或范式。不同的分布式系统可以采用不同的最终一致性策略，例如基于版本的控制、基于时间戳的控制、基于向量时钟的控制等，来保证数据在不同节点之间的最终一致性。</p><p><strong>意义：</strong></p><ul><li>系统开发需要取舍！不存在完美的系统！</li><li>CP</li><li>AP</li></ul><h3 id="3-3-1-PACELC定理"><a href="#3-3-1-PACELC定理" class="headerlink" title="3.3.1 PACELC定理"></a>3.3.1 PACELC定理</h3><p><a href="https://zhuanlan.zhihu.com/p/348923238">分布式理论 PACELC 了解么？ - 知乎 (zhihu.com)</a></p><p>PACELC定理是指，在分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）三者不可同时兼备，只能选择其中的两项。</p><p>PACELC定理是基于CAP定理发展而来的。CAP定理指出，在一个分布式系统中，Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性）这三个因素不可同时保证。在分布式系统出现网络分区时，必须选择放弃一致性还是可用性中的一项，以保证系统的可靠性。</p><p>PACELC定理是对CAP定理的进一步扩展和细化，将一致性进一步划分为了强一致性（Strong Consistency）和弱一致性（Weak Consistency），并在此基础上提出了三种情况：当出现网络分区时，系统只能保证两项中的其中之一，而具体保证哪两项则取决于分布式系统的设计和应用场景。</p><p>具体来说，PACELC定理认为，在分布式系统中，当发生网络分区时，可以选择以下三种策略：</p><ol><li>保证分区容错性和强一致性，放弃可用性（PA&#x2F;EC）：这种情况下，系统会在网络分区发生时，停止接受请求，以保证数据的一致性。</li><li>保证分区容错性和可用性，放弃强一致性（PA&#x2F;EL）：这种情况下，系统会允许不同节点的数据出现短时间的不一致，以保证系统的可用性。</li><li>保证可用性和强一致性，放弃分区容错性（CA&#x2F;EL）：这种情况下，系统会在网络分区发生时，仍然继续接受请求，但可能会导致节点之间的数据不一致，以保证系统的可用性和数据的一致性。</li></ol><p>在实际应用中，选择哪种策略取决于具体的应用场景和需求，需要根据系统的性能要求、可用性要求、数据一致性要求以及成本等因素进行权衡和选择。</p><h3 id="3-3-2-BASE"><a href="#3-3-2-BASE" class="headerlink" title="3.3.2 BASE"></a>3.3.2 BASE</h3><p>在分布式系统的上下文中，BASE 是 “Basically Available, Soft state, Eventually consistent” 的缩写。这是一组原则，可用于设计和实现分布式系统，优先考虑可用性和分区容忍性，而不是强一致性。</p><p>Basically Available 指的是分布式系统应始终能够响应客户端请求，即使系统遇到故障或网络分区。Soft state 指的是系统状态随时间变化的想法，只要变化不是关键的，系统最终能够收敛到一致的状态，就是可接受的。Eventually consistent 指的是在足够的时间和适当的同步下，系统最终会在所有节点上变得一致。</p><p>与优先考虑强一致性的 ACID（原子性，一致性，隔离性，持久性）原则不同，BASE 是一种更为松散的方法，可以在分布式系统中实现更高的可用性和可伸缩性，但代价是一些一致性上的权衡。</p><h2 id="3-4-一致性模型"><a href="#3-4-一致性模型" class="headerlink" title="3.4 一致性模型"></a>3.4 一致性模型</h2><p>一致性模型是指在分布式计算中，确保多个节点之间数据的一致性和可靠性的模型。在分布式系统中，节点可能会同时读取和写入共享数据，因此必须确保在所有节点上数据的状态是一致的。</p><p>常见的一致性模型包括：</p><ol><li>强一致性模型（线性一致性）：在任何时候，所有节点都能够读取到相同的数据。强一致性模型可以保证数据的完全一致性，但可能会影响系统的性能。</li><li>弱一致性模型：在任何时候，不同节点读取到的数据可能会不一样。弱一致性模型通常可以提高系统的性能，但需要更复杂的算法来确保数据的一致性。</li><li>最终一致性模型：在一定时间内，所有节点最终都能够读取到相同的数据。最终一致性模型通常是弱一致性模型和强一致性模型之间的一种妥协方案。</li></ol><p>一致性模型的选择取决于系统的需求和设计目标，需要综合考虑系统的性能、可靠性、一致性和可扩展性等方面。</p><h3 id="3-4-1-线性一致性模型"><a href="#3-4-1-线性一致性模型" class="headerlink" title="3.4.1 线性一致性模型"></a>3.4.1 线性一致性模型</h3><p>线性一致性模型是一种强一致性模型，它保证在分布式系统中所有节点读取到的数据是一致的，即如果一个节点在时间轴上比另一个节点先写入数据，则先写入的数据一定先于后写入的数据被读取到。线性一致性模型是对强一致性模型的一种加强形式，它要求所有节点读取到的数据的顺序与它们写入的顺序一致，即数据的全局顺序与它们的时间戳有关。</p><p>线性一致性模型的实现通常需要使用一些特殊的算法和技术，例如基于向量时钟（vector clock）的数据版本控制机制、分布式锁机制等。这些技术可以确保所有节点读取到的数据的顺序是一致的，同时还可以保证系统的性能和可扩展性。</p><p>线性一致性模型通常用于需要强一致性保证的分布式应用，例如金融交易系统、在线游戏等。</p><p><strong>向量时钟：</strong></p><p>向量时钟是一种用于分布式系统中维护事件顺序的数据结构。它可以帮助分布式系统中的不同节点确定事件的先后顺序，并保证在不同节点中的时间戳的一致性。</p><p>向量时钟的基本思想是：每个节点都维护一个向量，向量的长度等于节点的数量，每个节点的向量元素表示该节点上的事件数目。当节点上发生一个事件时，它会将该节点的向量元素加1，并将整个向量发送给其它节点。接收到向量后，节点会将它的本地向量与接收到的向量进行合并，并更新本地向量的元素值，以反映出其它节点上发生的事件情况。这样，每个节点都可以通过比较向量来判断事件的先后顺序。</p><p>具体来说，如果向量V和W都是节点数为N的向量时钟，则V &lt;&#x3D; W的含义是V中的每个元素都小于等于W中对应元素。如果V &lt;&#x3D; W并且W &lt;&#x3D; V，则V和W是相等的。当向量V和W不相等时，就可以根据它们的比较结果来判断事件的先后顺序。</p><p>向量时钟通常用于实现一些需要维护事件顺序的分布式应用，例如分布式数据库系统、分布式文件系统、分布式共识算法等。</p><p><strong>分布式锁：</strong></p><p>分布式锁是一种在分布式系统中实现互斥访问的机制，它可以帮助不同节点之间协调并发操作，避免出现冲突和竞争条件。</p><p>在分布式系统中，多个节点可能同时访问共享资源，例如数据库、文件系统等。为了避免多个节点同时修改同一份数据，需要使用分布式锁来保证资源的互斥访问。当一个节点想要访问共享资源时，它需要先获取一个分布式锁，确保其他节点不能同时访问该资源。当节点完成操作后，需要释放锁，以允许其他节点继续访问资源。</p><p>实现分布式锁的方法有很多种，其中比较常见的包括：</p><ol><li>基于数据库实现的分布式锁：将锁状态保存在数据库中，节点需要先获取数据库的一个排他锁，才能对锁进行操作。</li><li>基于ZooKeeper实现的分布式锁：利用ZooKeeper提供的原子操作和临时节点机制，实现分布式锁。</li><li>基于Redis实现的分布式锁：利用Redis提供的SETNX命令和expire命令，实现分布式锁。</li></ol><p>需要注意的是，在使用分布式锁时，需要考虑锁的粒度和性能等问题。如果锁的粒度过大，可能会导致锁竞争和性能瓶颈；如果锁的粒度过小，可能会导致锁冲突和死锁等问题。因此，在实际应用中，需要根据具体情况选择合适的锁粒度，并进行性能测试和优化。</p><p><a href="https://blog.csdn.net/m0_67645544/article/details/124768505?ops_request_misc=%7B%22request_id%22:%22168594407216800192234961%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168594407216800192234961&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124768505-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&spm=1018.2226.3001.4187">(459条消息) 什么是分布式锁？几种分布式锁分别是怎么实现的？_Java后端架构猛猛的博客-CSDN博客</a></p><h3 id="3-4-2-线性一致性的代价"><a href="#3-4-2-线性一致性的代价" class="headerlink" title="3.4.2 线性一致性的代价"></a>3.4.2 线性一致性的代价</h3><p>线性一致性通常需要付出较高的代价，因为要保证数据的全局顺序一致性，需要牺牲一定的可用性和延迟。</p><p>在实现线性一致性时，需要考虑以下几个方面的代价：</p><ol><li>通信代价：为了保证数据的一致性，需要不断进行节点间的通信和同步操作，这会增加网络带宽的使用和延迟。</li><li>吞吐量代价：由于要对所有的操作进行全局排序，需要在整个系统范围内协调所有节点的操作，这会对系统的吞吐量产生影响。</li><li>可用性代价：在实现线性一致性时，如果某个节点发生故障，会影响整个系统的可用性。因此，在实现线性一致性时，需要采取一些机制来保证故障时的容错和恢复能力。</li><li>性能代价：由于要保证全局顺序一致性，系统可能需要进行多轮操作和协调，这会增加系统的延迟和响应时间。</li></ol><p>因此，在实际应用中，需要根据具体需求和场景，综合考虑各种代价，选择合适的一致性模型和实现方式，以达到最优的性能和可用性。</p><h3 id="3-4-3-顺序一致性"><a href="#3-4-3-顺序一致性" class="headerlink" title="3.4.3 顺序一致性"></a>3.4.3 顺序一致性</h3><p>顺序一致性是一种弱一致性模型，它要求系统的操作按照提交的顺序执行，但不要求所有节点都看到相同的执行顺序。</p><p>具体来说，对于任意两个操作，如果它们在一个节点上执行并且提交的顺序是相同的，则在所有节点上的执行顺序必须保持一致。但是，如果两个操作在不同节点上执行，则可能存在不同的执行顺序，即存在并发执行的可能性。因此，顺序一致性保证了操作的有序性，但是不保证全局的一致性。</p><p>在实现顺序一致性时，系统可以采用一些机制来保证操作的有序性，例如对操作进行时间戳或序列号标记，或者采用基于向量时钟的算法来实现。</p><p>相对于线性一致性来说，顺序一致性的代价较低，因为它不需要保证所有节点都看到相同的执行顺序。因此，顺序一致性通常用于一些对一致性要求不是特别高的场景，例如社交网络应用、在线游戏等。</p><h3 id="3-4-4-因果一致性（微信朋友圈）"><a href="#3-4-4-因果一致性（微信朋友圈）" class="headerlink" title="3.4.4 因果一致性（微信朋友圈）"></a>3.4.4 因果一致性（微信朋友圈）</h3><p>因果一致性是一种弱一致性模型，它要求系统的操作按照因果关系执行，即如果一个操作A在另一个操作B之前发生，那么操作B在所有节点上的执行必须在操作A之后。这意味着，因果一致性可以保证操作的有序性和因果关系，但不要求所有节点都看到相同的执行顺序。</p><p>具体来说，因果一致性要求系统中的所有节点都按照相同的因果顺序执行操作。在实现因果一致性时，通常采用向量时钟或其他类似的机制来维护操作的因果关系。</p><p>因果一致性相对于线性一致性和顺序一致性来说，代价更低，因为它不需要对所有操作进行全局排序，只需要保证操作的因果关系即可。因此，因果一致性通常用于一些对一致性要求不是特别高的场景，例如分布式日志系统、分布式数据库等。</p><p>值得注意的是，因果一致性仅仅保证了操作的因果关系和有序性，而不保证操作的结果和值。因此，在使用因果一致性时，需要考虑数据一致性和可用性等方面的问题。</p><h3 id="3-4-5-最终一致性（搜索引擎、社交网络）"><a href="#3-4-5-最终一致性（搜索引擎、社交网络）" class="headerlink" title="3.4.5 最终一致性（搜索引擎、社交网络）"></a>3.4.5 最终一致性（搜索引擎、社交网络）</h3><p>最终一致性是一种弱一致性模型，它允许系统中的不同节点在一段时间内保持数据的不一致性，但最终会达到一致的状态。这意味着，当系统中存在多个副本时，这些副本在某个时间点上的状态可能不同，但经过一段时间的同步和协调后，最终会达到一致的状态。</p><p>在实现最终一致性时，通常采用异步复制或延迟复制的方式，即不要求所有节点在短时间内达到一致的状态，而是允许节点在本地更新数据，并在后续的时间点上将更新的数据同步到其他节点。这样做可以提高系统的可用性和性能，并减少系统之间的通信负担。</p><p>最终一致性适用于一些对数据一致性要求不是特别高的场景，例如<strong>搜索引擎、社交网络</strong>等。但是，最终一致性也存在一些问题，例如数据冲突和合并、数据同步的延迟等，需要在实际应用中进行适当的处理和解决。</p><h3 id="3-4-6-以客户端为中心的一致性模型"><a href="#3-4-6-以客户端为中心的一致性模型" class="headerlink" title="3.4.6 以客户端为中心的一致性模型"></a>3.4.6 以客户端为中心的一致性模型</h3><p> 以客户端为中心的一致性模型是一种应用程序在客户端上维护数据一致性的模型。在这个模型中，客户端负责维护数据的一致性，而不是依赖于分布式系统来维护数据的一致性。</p><p>具体来说，以客户端为中心的一致性模型通常采用乐观并发控制的策略。在这个策略中，客户端通过在本地缓存中保存数据副本来维护数据的一致性，并在修改数据时对缓存中的数据进行验证。如果数据未被其他客户端修改，则客户端可以直接提交修改。否则，客户端需要处理数据冲突，并根据一些策略来解决冲突。</p><p>以客户端为中心的一致性模型适用于一些对一致性要求不是特别高的场景，例如移动应用、离线应用等。这种模型具有良好的可用性和性能，因为客户端可以通过本地缓存快速读写数据，而不必依赖于分布式系统进行通信。但是，它也存在一些问题，例如数据冲突和合并、数据同步的延迟等，需要在实际应用中进行适当的处理和解决。</p><p>单调读（Monotonic Reads）和单调写（Monotonic Writes）是指一个线程对于一个特定变量的读操作或写操作，必须按照执行顺序，按照先后顺序看到最近的操作结果。</p><p>例如，如果线程A先写入变量x，然后线程B读取变量x，那么线程B必须看到线程A的写入结果，而不是之前的旧值。</p><p>读你所写（Read Your Writes，RYW）是指一个线程对于一个特定变量的读操作，必须在它自己的最近的写操作之后进行。这个特性在分布式系统中非常重要，因为它可以保证一个线程在写入某个变量之后，能够看到它自己的写入结果，而不是其他线程的旧值。</p><p>PRAM（Parallel Random Access Machine）是一种并行计算模型，它描述了一种在共享内存并行计算机上进行并行计算的方式。PRAM模型中，所有处理器共享一个全局内存，并且可以在O(1)时间内进行读写操作。</p><p>在PRAM模型中，单调读、单调写和读你所写是非常重要的一些性质，因为它们可以保证在并行计算中不会发生数据冲突和数据不一致的问题，从而保证并行计算的正确性和性能。</p><h2 id="3-5-隔离级别"><a href="#3-5-隔离级别" class="headerlink" title="3.5 隔离级别"></a>3.5 隔离级别</h2><p>隔离级别是指在数据库事务中不同事务之间对数据的读写所采用的不同的隔离策略。常见的隔离级别有四种：读未提交、读已提交、可重复读和串行化。</p><ol><li>读未提交（Read Uncommitted）：最低的隔离级别，允许一个事务读取另一个事务未提交的数据，可能导致脏读、不可重复读、幻读等问题。</li><li>读已提交（Read Committed）：在一个事务中，读取数据时只能读取已经提交的数据，可以避免脏读问题，但是可能会出现不可重复读和幻读问题。</li><li>可重复读（Repeatable Read）：保证一个事务在多次读取同一数据时，能够看到同样的数据，即同一事务内多次查询结果集相同。但是，其他事务可以向该数据表中插入新的数据，导致幻读问题。</li><li>串行化（Serializable）：最高的隔离级别，完全隔离每个事务，事务只能一个接一个地执行，避免了所有并发问题，但是效率较低。</li></ol><p>不同的隔离级别在事务处理中的性能和正确性上有不同的影响，需要根据具体的业务需求进行选择。一般来说，读已提交和可重复读是应用比较广泛的隔离级别。</p><h2 id="3-6-一致性和隔离级别的对比"><a href="#3-6-一致性和隔离级别的对比" class="headerlink" title="3.6 一致性和隔离级别的对比"></a>3.6 一致性和隔离级别的对比</h2><p>线性一致性和串行化都是数据库中保证事务正确性的机制，但是它们有不同的实现方式和应用场景。</p><p>线性一致性（Linearizability）是指，在分布式系统中，每个操作都有一个全局的先后顺序，该顺序满足原子性、顺序性、一致性和实时性的要求。也就是说，线性一致性保证了分布式系统中的操作顺序与单个系统中的操作顺序相同，而且保证了操作的原子性、一致性和实时性。线性一致性保证了分布式系统中的操作表现出和单个系统一样的行为，对于应用程序来说，感知不到分布式环境的存在。</p><p>串行化（Serialization）是指，在多个事务并发访问同一份数据时，数据库系统会把这些事务串行执行，以保证数据的正确性。串行化可以消除脏读、不可重复读和幻读等问题，但是会降低并发性能。</p><p>虽然线性一致性和串行化都能保证数据的正确性，但是它们的应用场景不同。线性一致性更适用于分布式环境下的系统，例如分布式缓存、分布式队列等。而串行化更适用于事务并发访问同一份数据时，需要严格控制并发执行顺序的场景，例如银行转账、订单处理等。</p><p>需要注意的是，线性一致性和串行化都会影响数据库的并发性能，因此需要根据具体的业务需求和系统架构来选择适合的一致性控制机制，以保证系统的正确性和并发性能。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 深入理解分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分布式系统（五）分布式事务</title>
      <link href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="5-1-什么是分布式事务"><a href="#5-1-什么是分布式事务" class="headerlink" title="5.1 什么是分布式事务"></a>5.1 什么是分布式事务</h2><p><strong>ACID:</strong></p><ul><li>原子性（Atomicity）：一个事务被视为一个不可分割的最小工作单位，事务中的所有操作要么全部完成，要么全部撤销回滚，不允许出现部分完成的情况。</li><li>一致性（Consistency）：事务开始前和结束后，数据库必须处于一致的状态，即事务执行后所得的结果必须符合预期的规定的结构和约束条件。</li><li>隔离性（Isolation）：多个事务相互隔离不受干扰，每个事务只能“看到”其所执行的数据和其他事务已提交的数据，而看不到其他事务未提交的数据。</li><li>持久性（Durability）：一个事务提交后，它对数据库的改变必须被永久保存到数据库中，即使出现断电等故障，其对数据库的改变也不能丢失。</li></ul><p>分布式事务两种变体：</p><ul><li>同一份数据需要在多个副本上更新，一个分布式事务需要更新所有的副本，如果有的节点提交了事务，有的节点回滚了事务，那么这样的结果对于用户来说是无法接受的。（可利用单主复制解决）</li><li>数据进行了分区，事务跨越多个节点，还要同时保证整体数据一致和事务的ACID属性。（常见且重点）</li></ul><p>分布式事务通常不讨论ACID中的一致性。</p><p>想要实现持久性，只需在向客户端返回响应之前，确保将数据存储再非易失性存储设备即可，通常还会包括一些WAL或其他日志文件，虽然非易失性存储设备可能会损坏，但不考虑极端的情况，通过备份就可以解决该问题。、</p><p>原子性：原子提交（Atomic Commit）</p><p>隔离性：并发控制（Concurrency Control）(锁和MVCC)</p><h2 id="5-2-原子提交"><a href="#5-2-原子提交" class="headerlink" title="5.2 原子提交"></a>5.2 原子提交</h2><p>原子性的保证在分布式和单机系统中都很难。</p><p>方法：日志&#x2F;WAL，可以回滚，撤销</p><p>分布式的原子性的实现：</p><ul><li>原子提交协议（Atomic Commit Protocol）<ul><li>协定性：所有的都同意一个值，那么所有进程要么一起提交事务，要么一起终止事务</li><li>有效性：如果所有进程都没问题，就提交，但凡有一个有问题，就终止</li><li>终止性：<ul><li>弱终止条件：如果没有任何故障发生，那么<strong>所有进程</strong>最终都会作出决议</li><li>强终止条件：<strong>没有发生故障的进程</strong>最终会做出决议</li></ul></li></ul></li></ul><h3 id="5-2-1-两阶段提交协议"><a href="#5-2-1-两阶段提交协议" class="headerlink" title="5.2.1 两阶段提交协议"></a>5.2.1 两阶段提交协议</h3><p><img src="https://s2.loli.net/2024/06/26/ngkdOJCI5bAxcLz.png" alt="两阶段提交.png"></p><p><a href="https://blog.csdn.net/a1102325298/article/details/96481642">(443条消息) 两阶段提交协议（two phase commit protocol，2PC）详解_两阶段协议_延迟满足的博客-CSDN博客</a></p><p>两阶段协议存在的问题：</p><ul><li>同步阻塞问题</li><li>单点故障问题</li><li>数据不一致问题</li><li>提交阶段不确定问题</li></ul><p>基于 2PC 存在的问题，后来有人提出了三阶段提交协议，在其中引入超时的机制，将阶段 1 分解为两个阶段：在超时发生以前，系统处于不确定阶段；在超时发生以后，系统则转入确定阶段。</p><p>还有解决方法：Parallel Commits，第一阶段的结果已知（写入全局日志中），返回给客户端，异步执行第二阶段，该方法要跟共识算法一起工作。</p><h3 id="5-2-2-三阶段提交"><a href="#5-2-2-三阶段提交" class="headerlink" title="5.2.2 三阶段提交"></a>5.2.2 三阶段提交</h3><p>非阻塞协议，可以在协调者寄了的时候选出新的协调者推进事务执行</p><p><a href="https://blog.csdn.net/m0_37840000/article/details/119743288?ops_request_misc=%7B%22request_id%22:%22168174759216800225586584%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168174759216800225586584&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-119743288-null-null.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&utm_term=%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE&spm=1018.2226.3001.4187">(443条消息) 三阶段提交协议(3PC)_愿好的博客-CSDN博客</a></p><p>缺点：并没有解决所有的问题。</p><ul><li>可用性以正确性为代价，同时很容易收到网络分区的影响（导致脑裂选出多个协调者）</li><li>至少三轮往返消息，增加了事务的完成时间</li></ul><p>满足强终止性</p><p>二阶段提交依然是</p><h3 id="5-2-3-Paxos提交算法"><a href="#5-2-3-Paxos提交算法" class="headerlink" title="5.2.3 Paxos提交算法"></a>5.2.3 Paxos提交算法</h3><p><img src="https://s2.loli.net/2024/06/26/zKvrtxhjepDL52d.jpg" alt="B8468E68C68D719758DFA7091B1C834D.jpg"></p><h3 id="5-2-4-基于Quorum的提交协议"><a href="#5-2-4-基于Quorum的提交协议" class="headerlink" title="5.2.4 基于Quorum的提交协议"></a>5.2.4 基于Quorum的提交协议</h3><p>每个节点有一票，总共V票：</p><ul><li>Vc：最小提交票数，要提交必须达到这个票数，0&lt;Vc&lt;&#x3D;V</li><li>Va：最小中止票数，要中止必须达到这个票数，0&lt;Va&lt;&#x3D;V</li></ul><p>Vc+Va&gt;V</p><p>三个子协议：</p><ul><li>提交协议：事务开始时使用（类似三阶段中的pre commit，但是需要等待Vc票数）</li><li>中止协议：网络分区时开始使用（出现网络分区，会在与协调者失联的分区中选出代理协调者，如果在失联分区中有在提交&#x2F;中止状态（哪怕一个），都推进所有参与者到该状态；如果至少有一个参与者处于预提交状态，并且至少Vc个参与者在等待提交投票的结果，则代理协调者向所有参与者发送预提交消息，如果有超过Vc个参与者恢复响应，那么代理协调者就会发送真正的提交消息;如果没有处于准备提交状态的参与者，并且至少Va个参与者在等待中止事务的投票结果，那么代理协调者就会发送真正的中止消息）</li><li>合并协议：当系统从网络分区中恢复过来的时候使用</li></ul><h3 id="5-2-5-Saga事务"><a href="#5-2-5-Saga事务" class="headerlink" title="5.2.5 Saga事务"></a>5.2.5 Saga事务</h3><p>用来处理长活事务（Long-Lived Transaction，LLT）</p><p><a href="https://blog.csdn.net/flynetcn/article/details/124592621?ops_request_misc=%7B%22request_id%22:%22168183647416800211561980%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168183647416800211561980&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-124592621-null-null.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&utm_term=saga%E4%BA%8B%E5%8A%A1&spm=1018.2226.3001.4187">(443条消息) 分布式事务系列：Saga_saga事务_码出钞能力的博客-CSDN博客</a></p><h2 id="5-3-并发控制"><a href="#5-3-并发控制" class="headerlink" title="5.3 并发控制"></a>5.3 并发控制</h2><p>悲观并发控制（Pessimistic Concurrency Control）：假设多个事务之间会相互干扰，因此在任何时候都将资源加锁，避免其他事务修改该资源。悲观并发控制的主要优点是简单易懂，但由于频繁加锁导致效率低下，不适合高并发场景。</p><p>乐观并发控制（Optimistic Concurrency Control）：假设多个事务之间不会相互干扰，并行访问数据，而在提交时进行冲突检测。如果两个事务的修改发生冲突，则其中一个事务必须回滚并重试。乐观并发控制可以最大程度地提高并发性，但需要开发人员自己实现数据版本控制，相对较为复杂。</p><p>多版本并发控制（Multi-Version Concurrency Control）：每当一个事务对数据库进行更新操作时，会将当前数据的快照存储为新的版本，并使用版本号进行标识。在读取数据时，事务不会阻塞其他事务的读写操作，同时也不会锁定当前版本的数据。如果发现其他事务已经更新了数据，则会从前一个版本中获取数据。多版本并发控制的主要优点是高效、可扩展性好，但需要占用更多的磁盘空间。</p><h3 id="5-3-1-两阶段锁"><a href="#5-3-1-两阶段锁" class="headerlink" title="5.3.1 两阶段锁"></a>5.3.1 两阶段锁</h3><p>两阶段锁（Two-Phase Locking）是一种常用于并发控制的技术，旨在解决并发操作下出现的数据一致性问题。</p><p>在两阶段锁策略中，事务必须分为两个阶段：增长阶段和收缩阶段。</p><ol><li><p>增长阶段：当事务请求资源时，该事务会先申请锁定所需资源。在此阶段中，锁可以被占用但不能被释放，每个事务只能逐渐获得锁，不能释放锁。</p></li><li><p>收缩阶段：当事务完成所需工作时，它将释放所有已经锁定的资源，并且这些锁不再被使用。在此阶段中，锁可以被释放但不能被继续占用，每个事务只能逐渐释放锁。</p></li></ol><p>在这个过程中，锁的状态保持不变。所有的事务都必须遵循这些规则，以确保并发操作的正确性和一致性。</p><p>两阶段锁的优点是可以避免死锁的发生，但是也有一些缺点，例如可能会导致事务等待时间较长，从而影响系统的响应速度。此外，还有许多其他的并发控制技术，如乐观并发控制、基于时间戳的并发控制等，可以用于替代或补充两阶段锁。</p><p><strong>三种方法避免死锁：</strong></p><p>死锁是一种并发控制问题，指两个或多个事务或进程相互等待释放已经占用的资源，导致所有事务或进程都无法继续执行。为了避免死锁，可以采取以下几种方法：</p><ol><li>死锁预防（破坏死锁条件）：通过约定加锁顺序、引入超时机制、限制某些进程对资源的访问等方式，在程序设计时直接避免死锁发生。</li><li>死锁避免（银行家算法）：通过安全序列算法对每个事务或进程的资源请求进行安全性检查，只有当该事务或进程的资源请求不会导致死锁时才会被允许。<ul><li>等待-死亡：该方案是基于非剥夺方法。当进程Pi请求的资源正被进程Pj占有时，只有当Pi的时间戳比进程Pj的时间戳小时，Pi才能等待。否则Pi被卷回（roll-back），即死亡。</li><li>伤害-等待：它是一种基于剥夺的方法。当进程Pi请求的资源正被进程Pj占有时，只有当进程Pi的时间戳比进程Pj的时间戳大时，Pi才能等待。否则Pj被卷回（roll-back），即死亡。</li></ul></li><li>死锁检测与恢复：在程序运行过程中，周期性地监测系统中是否发生了死锁，一旦检测到死锁，就采取资源抢夺或事务回滚等方式，进行死锁恢复。</li></ol><p>以上三种方法可以单独或组合使用，以达到更好的死锁预防效果。同时，在程序设计时，应注意不要通过不合理的代码逻辑、数据库设计等导致死锁现象的出现。</p><h3 id="5-3-2-乐观并发控制（不要锁）"><a href="#5-3-2-乐观并发控制（不要锁）" class="headerlink" title="5.3.2 乐观并发控制（不要锁）"></a>5.3.2 乐观并发控制（不要锁）</h3><p>两类，基于检查的并发控制和基于时间戳的并发控制。</p><ol><li><p>基于检查的并发控制</p><ul><li>读取：创建副本，放到私有空间，读是读的副本，写操作被记录到私有空间的临时文件中。</li><li>校验：没有冲突就提交，有冲突就中止。</li><li>写入：校验没问题，就把私有空间的数据持久化存储。</li></ul></li><li><p>基于时间戳的并发控制</p><p>每个数据项有两个时间戳</p><ul><li><p>写时间戳： W-TS(X)</p></li><li><p>读时间戳：R-TS(X)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#1.读操作</span><br><span class="line">if TS(T_i) &lt; W-TS(X)&#123;</span><br><span class="line">abort(R_i(X))</span><br><span class="line">&#125;else&#123;</span><br><span class="line">accept(R_i(X))</span><br><span class="line">R-TS(X)=TS(T_i)</span><br><span class="line">&#125;</span><br><span class="line">#2.写操作</span><br><span class="line">TS(T_i)必须大于R-TS(X)和W-TS(X)，否则丢弃</span><br><span class="line">if TS(T_i)&lt;R-TS(X)||TS(T_i)&lt;W-TS(X)&#123;</span><br><span class="line">abort(W_i(X))</span><br><span class="line">&#125;else &#123;</span><br><span class="line">accept(W_i(X))</span><br><span class="line">W-TS(X)=TS(T_i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难点：</p><ol><li>时间戳的精确性</li><li>可能产生不可恢复的操作（后面的读事务基于前面的写事务，但前面的写事务回滚）</li></ol><p>看起来没有锁，但是实际上在修改时间戳的时候，仍可能要获取锁</p></li></ul></li></ol><h3 id="5-3-3-多版本并发控制（很像celldb啊）"><a href="#5-3-3-多版本并发控制（很像celldb啊）" class="headerlink" title="5.3.3 多版本并发控制（很像celldb啊）"></a>5.3.3 多版本并发控制（很像celldb啊）</h3><p>可以看作在乐观并发控制的基础上增加了多个版本，为每个数据项存储多个版本</p><p>读到的是某个版本的数据，写是增加版本而并非覆盖</p><p>衍生出三种主流多版本并发控制：</p><ul><li>多版本两阶段锁</li><li>多版本乐观并发控制</li><li>多版本时间戳排序</li></ul><p>元数据（Tuple存储到数据项头部）：</p><ul><li><p>Tid：唯一单调递增的时间戳（事务开始的时间戳）</p></li><li><p>txn-id：获得当前写锁的事务的Tid，如果没有事务持有该数据的写锁，则为0，可通过<strong>CAS</strong>来修改此字段，避免使用锁</p><ul><li><p>CAS，即 Compare-And-Swap，是一种原子操作，用于实现并发控制。在多线程编程中，CAS可以保证对共享变量的操作在多线程情况下能够正确地执行。</p><p>CAS操作需要三个参数：内存地址 V、旧的预期值 A 和新值 B。当且仅当当前内存地址的值等于旧的预期值 A 时，才会将该内存地址的值更新为新值 B。否则，不做任何操作。</p><p>CAS操作的基本流程如下：</p><ol><li>线程读取内存地址 V 的当前值；</li><li>线程比较内存地址 V 的当前值与旧的预期值 A 是否相等；</li><li>如果相等，线程将新值 B 写入内存地址 V，并返回操作成功；</li><li>如果不相等，线程不做任何操作，并返回操作失败。</li></ol><p>通过CAS操作，可以避免传统并发控制方法（如锁定）的一些问题，例如死锁和竞争条件。但同时，也存在一些限制。例如，CAS只能应用于单个变量的操作；如果需要对多个变量进行联合操作，则需要使用其他并发控制方式。</p></li></ul></li><li><p>begin-ts: 创建该版本的数据项的事务提交的时间戳（开始肯定是提交了才有嘛）,Tcommit</p></li><li><p>end-ts：最新版本的话，则为无限大，否则该数据项等于上一个或下一个版本数据项的begin-ts</p></li></ul><ol><li><p>多版本两阶段锁(这里的锁，是根据对于数据的元数据的版本来进行判断来实现的)：</p><p>代表MySQL,Oracle,Postgres</p><ul><li><p>txn-id</p></li><li><p>read-cnt：当前数据的读锁的数量。可以将read-cnt和txn-id组合成一个64位整型值，用CAS来更新两个</p></li><li><p>begin-ts</p></li><li><p>end-ts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#对于读操作Ti Xv为版本</span><br><span class="line">find Xv where begin-ts(Xv) &lt;= Ti &lt;end-ts(Xv)</span><br><span class="line">if txn-id(Xv)==0 || txn-id(Xv)==Ti&#123;</span><br><span class="line">read-cnt(Xv)+=1</span><br><span class="line">accept(Read(Xv))</span><br><span class="line">&#125;else&#123;</span><br><span class="line">abort()and rollback(T)</span><br><span class="line">&#125;</span><br><span class="line">#对于写操作 找到最新版本Xv</span><br><span class="line">finx Xv where end-ts(Xv) ==INF</span><br><span class="line">if txn-id(Xv)==0||txn-id(Xv)==Ti&#123;</span><br><span class="line">txn-id(Xv)=Ti</span><br><span class="line">new(Xv+1)</span><br><span class="line">txn-id(Xv+1)=Ti</span><br><span class="line">accept(Write(Xv+1))</span><br><span class="line">&#125;else&#123;</span><br><span class="line">abort() and rollback(T)</span><br><span class="line">&#125;</span><br><span class="line">#善后</span><br><span class="line">#for write</span><br><span class="line">for all write data item&#123;</span><br><span class="line">txn-id(Xv+1)=0</span><br><span class="line">begin-ts(Xv+1)=Tcommit</span><br><span class="line">end-ts(Xv+1)=INF</span><br><span class="line">txn-id(Xv)=0</span><br><span class="line">end-ts(Xv)=Tcommit</span><br><span class="line">&#125;</span><br><span class="line">#for read</span><br><span class="line">for all read data item&#123;</span><br><span class="line">read-cnt(Xv) -=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>多版本乐观并发控制</p><p>MemSQL用这个</p><p>Metadata:</p><ul><li>txn-id</li><li>begin-ts</li><li>end-ts</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#读</span><br><span class="line">find Xv where begin-ts(Xv)&lt;= Ti &lt; end-ts(Xv)</span><br><span class="line">if txn-id(Xv)==0 || txn-id(Xv)==Ti&#123;</span><br><span class="line">accept(Read(Xv))</span><br><span class="line">&#125;else&#123;</span><br><span class="line">abort()and rollback(T)</span><br><span class="line">&#125;</span><br><span class="line">#写</span><br><span class="line">find Xv where end-ts(Xv) == INF //确保最新</span><br><span class="line">if txn-id(Xv) == 0 ||txn-id(Xv)==Ti&#123;</span><br><span class="line">txn-id(Xv) = Ti</span><br><span class="line">new(Xv+1)</span><br><span class="line">txn-id(Xv+1) = Ti</span><br><span class="line">begin-ts(Xv+1) = INF</span><br><span class="line">accept(Write(Xv+1))</span><br><span class="line">&#125;else&#123;</span><br><span class="line">abort() and rollback(T)</span><br><span class="line">&#125;</span><br><span class="line">#提交事务</span><br><span class="line">for all read data item&#123;</span><br><span class="line">if begin-ts(Xv) &gt;Ti&#123;</span><br><span class="line"> //数据项被其他事务修改过，读到了过期的数据</span><br><span class="line"> abort() and rollback(T)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for all write data item&#123;</span><br><span class="line">txn-id(Xv+1) = 0</span><br><span class="line">begin-ts(Xv+1) = Tcommit</span><br><span class="line">end-ts(Xv+1) = INF</span><br><span class="line">txn-id(Xv) = 0</span><br><span class="line">end-ts(Xv) = Tcommit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多版本时间戳排序</p><ul><li><p>txn-id</p></li><li><p>read-ts(最大的读过的事务的Tid)</p></li><li><p>begin-ts</p></li><li><p>end-ts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#读</span><br><span class="line">find Xv where begin-ts(Xv)&lt;=Ti&lt;end-ts(Xv)</span><br><span class="line">if txn-id(Xv) == 0 || txn-id(Xv) == Ti&#123;</span><br><span class="line">accept(read(Xv))</span><br><span class="line">read-ts(Xv)=max(Ti,read-ts(xV))</span><br><span class="line">&#125;else&#123;</span><br><span class="line"> abort() rollback(T)</span><br><span class="line">&#125;</span><br><span class="line">#写</span><br><span class="line">find Xv where end-ts(Xv) ==INF</span><br><span class="line">if txn-id(Xv)=0&amp;&amp;Ti &gt; read-ts(Xv)&#123;</span><br><span class="line">txn-id(Xv) = Ti</span><br><span class="line">new(Xv+1)</span><br><span class="line">txn-id(Xv+1) =Ti</span><br><span class="line">read-ts(Xv+1) = 0</span><br><span class="line">accept(Write(Xv+1))</span><br><span class="line">&#125;else &#123;</span><br><span class="line">abort() and rollback(T)</span><br><span class="line">&#125;</span><br><span class="line">#善后</span><br><span class="line">for all write data item&#123;</span><br><span class="line">txn-id(Xv+1) = 0</span><br><span class="line">begin-ts(Xv+1) = Ti</span><br><span class="line">end-ts(Xv+1) = INF</span><br><span class="line">txn-id(Xv) = 0</span><br><span class="line">end-ts(Xv) = Ti</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>版本存储和垃圾回收</p><p>版本存储：</p><ol><li>仅追加存储（Append-Only Storage）<ul><li>有指针</li><li>如果说恰好有很大数据的一个属性，在新版本中又不发生改变，则很占空间（所以要复用）</li><li>MemSQL、PG</li></ul></li><li>时间旅行存储（Time-Travel Storage）<ul><li>单独用一个时间旅行表来存储历史版本</li><li>最新版本的数据存储到主表</li></ul></li><li>增量存储（Delta Storage）<ul><li>只将发生变化的字段信息存储到增量存储中</li><li>增量存储在MySQL和Oracle中被称为回滚段</li><li>对于更新频繁的工作负载，可以减少内存分配，对于读操作频繁的工作负载，需要访问回滚段才能重新拼出需要的信息，开销会更高</li></ul></li></ol><p>垃圾回收：</p><ol><li>元组级别（Tuple-Level Garbage Collection) ：<ul><li>后台清理（Background Vaccuuming, VAC）:后台线程周期性清理:star2:</li><li>协同清理 (Cooperative Cleaning, COOP)：遍历最老到最新，事务执行时清理</li></ul></li><li>事务级别垃圾回收（Transaction-Level Garbage Collection）:<ul><li>如果一个事务创建的版本不被任何活跃事务访问，意味着该事务已经过期。</li><li>系统会根据该事务读写的数据集合（Read&#x2F;Write Sets）清理相对应的版本</li></ul></li></ol></li></ol><h2 id="5-4-Percolator"><a href="#5-4-Percolator" class="headerlink" title="5.4 Percolator"></a>5.4 Percolator</h2><p>分布式事务解决方案：Percolator</p><p>构建于Bigtable的基础上，主要用于网页搜索索引等服务</p><p>支持多行事务</p><p>依赖一个单点授时，单时间源的授时服务（TSO，Timestamp Oracle）</p><p>使用多版本时间戳排序来实现快照隔离</p><p>利用如下元数据实现快照隔离：</p><ul><li>lock:锁信息</li><li>write：事务提交时间戳</li><li>data：数据</li></ul><p>事务处理步骤：</p><ol><li><p>分配事务开始时间戳:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_ts=oracle.GetTimestamp()</span><br></pre></td></tr></table></figure></li><li><p>将所有写操作缓冲起来，直到提交时再一并写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void set(Write w)&#123;</span><br><span class="line">writes_.push_back(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>preWrite:</p><ul><li><p>所有写操作挑选一个作为主锁（随意挑选，固定使用第一个写操作作为主锁）：锁住事务中写操作涉及的所有数据</p></li><li><p>其他写操作作为次锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool preWrite(Write w,Write primary)&#123;</span><br><span class="line"> Column c = w.col;</span><br><span class="line"> bigtable::Txn T = bigtable::StartRowTransaction(w.row);</span><br><span class="line"> //如果事务开始后该数据被修改，则中止事务</span><br><span class="line"> if (T.Read(w.row,c+&quot;write&quot;,[start_ts,INF]))return false;</span><br><span class="line"> //尝试获取锁</span><br><span class="line"> if (T.Read(w.row,c+&quot;lock&quot;,[0,INF]))return fasle;</span><br><span class="line">  </span><br><span class="line"> T.Write(w.row,c+&quot;data&quot;,start_ts,w.value);</span><br><span class="line"> T.Write(w.row,c+&quot;lock&quot;,start_ts,&#123;primary.row,primary.col&#125;);</span><br><span class="line"> return T.Commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>提交事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#写</span><br><span class="line">bool Commit()&#123;</span><br><span class="line">Write Primary = writes_[0];</span><br><span class="line">vector&lt;Write&gt; secondaries(writes_.begin()+1,wirtes_.end());</span><br><span class="line">if (!PreWrite(primary,primary))return false;</span><br><span class="line">for (Write w:secondaries)</span><br><span class="line">if (!PreWrite(w,parimary)) return false;</span><br><span class="line"></span><br><span class="line">int commit_ts = oracle.GetTimestamp();</span><br><span class="line">//先提交主锁的写操作</span><br><span class="line">Write p = primary;</span><br><span class="line">bigtable::Txn T= bigtable::StartRowTransaction(p.row);</span><br><span class="line">if (!T.Read(p.row,p.col+&quot;lock&quot;,[start_ts,start_ts]))</span><br><span class="line">return false;</span><br><span class="line">T.Write(p.row,p.col+&quot;write&quot;,commit_ts,start_ts);</span><br><span class="line">T.Erase(p.row,p.col+&quot;lock&quot;,commit_ts);</span><br><span class="line">if (!T.commit())return false;</span><br><span class="line">//第二阶段，更新所有次(secondary)锁的写操作</span><br><span class="line">for (Write w:secondaries)&#123;</span><br><span class="line">bigtable::Write(w.row,w.rol+&quot;write&quot;,commit_ts,start_ts);</span><br><span class="line">bigtable::Erase(w.row,w.rol+&quot;lock&quot;,commit_ts);</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">#读</span><br><span class="line">bool Get(Row row,Column c,string *value)&#123;</span><br><span class="line">while(true)&#123;</span><br><span class="line">bigtable::Txn T = bigtable::StartRowTransaction(row);</span><br><span class="line">//检查是否有并发写入的锁</span><br><span class="line">if (T.Read(row,c+&quot;lock&quot;,[0,start_ts]))&#123;</span><br><span class="line">//存在锁，尝试清理并等待锁释放</span><br><span class="line">BackoffAndMaybeCleanupLock(row,c);</span><br><span class="line">Continue;</span><br><span class="line">&#125;</span><br><span class="line">//找到小于开始时间戳的最新写入版本</span><br><span class="line">latest_write=T.Read(row,c+&quot;write&quot;,[0,start_ts]);</span><br><span class="line">if (!latest_write.found()) return false; //没有找到</span><br><span class="line">int data_ts =latest_write.start_timestamp();</span><br><span class="line">*value = T.Read(row,c+&quot;data&quot;,[data_ts,data_ts]);</span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 深入理解分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分布式系统（六）时间和事件顺序</title>
      <link href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89%E6%97%B6%E9%97%B4%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A1%BA%E5%BA%8F/"/>
      <url>/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89%E6%97%B6%E9%97%B4%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="时间和事件顺序"><a href="#时间和事件顺序" class="headerlink" title="时间和事件顺序"></a>时间和事件顺序</h1><h2 id="6-1-物理时钟"><a href="#6-1-物理时钟" class="headerlink" title="6.1 物理时钟"></a>6.1 物理时钟</h2><ul><li>机械时钟</li><li>石英时钟</li><li>原子钟：原子共振频率标准来计算</li><li>GPS</li></ul><h2 id="6-2-时钟同步"><a href="#6-2-时钟同步" class="headerlink" title="6.2 时钟同步"></a>6.2 时钟同步</h2><p>NTP:<a href="https://blog.csdn.net/weixin_45057618/article/details/120200341?ops_request_misc=%7B%22request_id%22:%22168243248816800182751293%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168243248816800182751293&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-120200341-null-null.142%5Ev86%5Einsert_down38v5,239%5Ev2%5Einsert_chatgpt&utm_term=NTP%E5%8D%8F%E8%AE%AE&spm=1018.2226.3001.4187">(430条消息) NTP详解(网络时间协议)_127.127.1.0 ntp含义_思福迪小白的博客-CSDN博客</a></p><p>针对NTP同步导致时间回退甚至是负数的情况–单调时钟，保证返回的时间严格单调增长</p><p>Cloudflare没用单调时钟，而是在发现时间差为负数或者0时变为一个默认值（golang没暴露单调时钟）</p><p>单调时钟的局限性：以自身所在的计算机的某个时间为起点，也就是说，来自同一个节点的单调时钟才有意义。</p><p>如何发明分布式系统中的单调时钟？</p><h2 id="6-3-逻辑时钟"><a href="#6-3-逻辑时钟" class="headerlink" title="6.3 逻辑时钟"></a>6.3 逻辑时钟</h2><p>Lamport Clock</p><p>Happens-Before:</p><p>​if a-&gt;b</p><ul><li>if a and b are in the same process, and a is before b, then a-&gt;b</li><li>if a is the event that sends a message , b is the event that receives the message, then a-&gt;b.</li><li>if a-&gt;b and b-&gt;c, then a-&gt;c; if a &#x2F;-&gt;b or b&#x2F;-&gt;a, then a and b are in concurrency(a||b).</li></ul><p>a-&gt;b, then C(a)&lt;C(b)</p><p>C(a)&lt;C(b), a&#x2F;-&gt;b</p><ul><li>每个进程都有自己的逻辑时钟，初始值为0</li><li>如果进程i内部发生一个新的事件，那么将其逻辑时钟加一，即Ci&#x3D; Ci+1</li><li>if process i sends a message to process j , and the logic clock in process i is C(i), then, firstly, C(i)&#x3D;C(i)+1, and then, i sends Ci and the message to process j, and then, process j updates its logic clock Cj&#x3D; max(Ci,Cj)+1</li></ul><p>根据离散数学的关系而言，逻辑时钟和物理时钟的区别在于，物理时钟的先后关系是一种total ordering，是全局可见的一种关系，谁先谁后一目了然；然而逻辑时钟 is a kind of partial ordering，只有部分元素的先后关系（本质原因是，我们不能根据逻辑时间的先后去判定逻辑业务的先后）</p><p>如何使逻辑时钟也具有全序关系？给进程加上优先级，但是赋予进程不同的优先级排序会有不同的全序关系</p><p>RAFT的任期、选举算法、日志和状态机的思想等都出自这篇论文（Lamport,Leslie.”Time,clocks,and the ordering of events in a distributed system.”Concurrency: the Works of Leslie Lamport. 2019.179-196）：</p><ul><li>一个<strong>去中心化的算法</strong>，通过逻辑时钟实现分布式资源互斥来分配资源</li><li>每个进程维护一个消息队列，消息的格式为Tm: Pi, 即为第i个进程在Tm的逻辑时钟下发送的消息</li><li>进程维护自己的消息，也接收别人的消息，决定自己是否能够获取资源的条件<ul><li>消息队列中除开自己的消息之外的消息的逻辑时间，均大于自己的消息</li><li>排在队头的消息是自己的消息（这里消息的插入可以是对头队尾，也可以是中间）</li></ul></li></ul><h2 id="6-4-向量时钟"><a href="#6-4-向量时钟" class="headerlink" title="6.4 向量时钟"></a>6.4 向量时钟</h2><p>跟逻辑时钟很类似，只不过逻辑时钟只考虑了本地的逻辑时间，而向量时钟的维度为节点数，维护全局的时间。</p><p>向量时钟（Vector Clock）是一种在分布式系统中用于记录事件发生顺序的机制。它通过给每个节点分配一个独特的向量来跟踪每个节点上的事件发生次数，这个向量被称为向量时钟。</p><p>向量时钟的大小等于节点数，每个元素代表了一个节点的时间戳。当一个事件发生时，对应节点的时间戳会自增1。如果两个事件发生在不同的节点上，那么它们的时间戳是相互独立的，无法比较先后顺序；但如果它们发生在同一个节点上，就可以用向量时钟来比较它们的先后顺序。比如说，设有A,B,C三个节点，此时在A节点上发生了一个事件，那么其向量时钟会变为[1,0,0]，因为这是A节点上第一个事件。如果随后在C节点上发生了一个事件，那么其向量时钟会变为[0,0,1]，因为这是C节点上第一个事件。如果再在B节点上发生了一个事件，那么其向量时钟会变为[0,1,0]，因为这是B节点上第一个事件。这样，在整个分布式系统中，我们得到了A为[1,0,0]，B为[0,1,0]，C为[0,0,1]的向量时钟。</p><p>当一条消息从一个节点传递到另一个节点时，消息中会包含发送方的向量时钟。接收方在收到消息后，将它自己的向量时钟和接收到的消息中的向量时钟进行比较，取每个位置上较大的值作为新的时间戳。然后将接收到的消息的时间戳同步到本地，再加上1，表示接收到了这条消息。这样，接收方就可以知道这条消息是在哪个节点上发送的，以及这条消息的先后顺序。</p><p>向量时钟不仅能够帮助我们比较事件间的先后关系，还能检测出并发事件。比如说，如果两个事件A和B同时发生，那么它们对各自持有的向量时钟都会影响到相应的位置上，导致这两个节点上的向量时钟不一致。这样，我们就可以检测出这两个事件的并发性。</p><p>缺点在于，向量的维度与节点数正相关，随着节点增多，向量时钟越大，向量时钟需要大量的磁盘和内存空间，同时需要更长的时间来计算和比较。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 深入理解分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分布式系统（四）分布式共识</title>
      <link href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86/"/>
      <url>/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a>分布式共识</h1><h2 id="4-1-分布式共识简介"><a href="#4-1-分布式共识简介" class="headerlink" title="4.1 分布式共识简介"></a>4.1 分布式共识简介</h2><p>分布式共识（Distributed Consensus）是指在分布式系统中，多个节点（或进程）协同完成某个任务或达成某个决策的过程。在这个过程中，每个节点需要就该任务或决策达成一致，并且能够互相通信、协调、协作。</p><p>分布式共识的一个重要应用是在区块链技术中，用于解决双花问题（Double-spending problem）和确定哪些交易会被写入区块链。比特币等加密货币就是通过共识算法来实现去中心化的交易记录。</p><p>常见的分布式共识算法包括拜占庭将军问题（Byzantine fault tolerance, BFT）、Raft、Paxos、Proof of Work（PoW）、Proof of Stake（PoS）等。这些算法都有各自的优缺点，适用于不同的场景。例如，PoW 算法被应用在比特币等加密货币中，而 PoS 算法则被用在以太坊等区块链平台中。</p><h3 id="4-1-1-什么是分布式共识"><a href="#4-1-1-什么是分布式共识" class="headerlink" title="4.1.1 什么是分布式共识"></a>4.1.1 什么是分布式共识</h3><p>分布式共识是指在一个分布式系统中，多个节点之间需要就某些决策达成一致意见的过程。在这个过程中，各个节点通过相互通信和协作来达成共识，以保证系统能够正常运作并避免出现错误或冲突。</p><p>在分布式系统中，由于节点之间的网络延迟、节点故障等原因，不同节点的状态可能存在不一致的情况。因此，需要通过分布式共识算法来解决这些问题。常用的分布式共识算法包括 Paxos、Raft、Byzantine Fault Tolerance 等。</p><p>分布式共识算法的基本思路是，通过节点之间的通信和协作，选出一个“领导者”节点来负责提出某个决策，其他节点通过投票和确认的方式来达成共识，以保证系统在多个节点之间的一致性和可靠性。这种算法在分布式数据库、区块链等系统中都得到了广泛应用。</p><h3 id="4-1-2-为什么要达成共识"><a href="#4-1-2-为什么要达成共识" class="headerlink" title="4.1.2 为什么要达成共识"></a>4.1.2 为什么要达成共识</h3><p>在分布式系统中，节点之间的状态可能存在不一致的情况，如果不对这些状态进行协调，就可能导致系统出现错误或冲突。为了避免这种情况的发生，需要在分布式系统中实现共识机制，保证各个节点之间的状态达成一致，从而保证系统的正确性和可靠性。</p><p>具体来说，如果在一个分布式系统中，某些节点的状态发生了变化，但其他节点还没有收到这个变化的通知，那么这些节点就会基于过期的状态进行操作，从而导致数据不一致或操作冲突。通过分布式共识算法，可以确保所有节点在进行操作前都已经达成了共识，从而保证了数据的一致性和操作的正确性。</p><p>另外，分布式共识还能够防止拜占庭错误的发生。拜占庭错误是指分布式系统中存在恶意节点或网络攻击，导致节点之间的通信受到干扰或伪造。通过分布式共识算法，可以检测和排除这些恶意行为，确保系统的安全性和可靠性。</p><h2 id="4-2-异步系统中的共识"><a href="#4-2-异步系统中的共识" class="headerlink" title="4.2 异步系统中的共识"></a>4.2 异步系统中的共识</h2><h3 id="4-2-1-FLP不可能定理"><a href="#4-2-1-FLP不可能定理" class="headerlink" title="4.2.1 FLP不可能定理"></a>4.2.1 FLP不可能定理</h3><p>FLP不可能定理是指，<strong>在一个异步的分布式系统中，不存在一个算法能够保证在存在至少一个节点故障的情况下，仍然能够保证所有节点能够在有限时间内达成共识。</strong></p><p>该定理由Fischer、Lynch和Paterson在1985年提出，是分布式共识领域的一个重要理论。其基本思想是，由于节点之间的通信存在延迟和不可靠性，因此在存在故障节点的情况下，无法确定某个节点是否已经停止工作或者只是延迟。这种不确定性会导致共识过程无法完成。</p><p>FLP不可能定理的证明使用了卡慕尔异步通信模型，即假设节点之间的消息传输可以无限制地延迟，但必须保证每个节点最终能够收到所有消息。基于这种通信模型，可以证明在存在至少一个节点故障的情况下，无法保证所有节点能够在有限时间内达成共识。</p><p>虽然FLP不可能定理指出了分布式共识问题的困难性，但是在实际应用中，往往会使用一些近似算法来解决共识问题。例如，Paxos算法、Raft算法等就是通过一些特殊的约束条件来实现了共识，从而在实际应用中得到了广泛的应用。</p><ul><li>安全性: 在一个任期内只会确定一个值（something wrong not happen）</li><li>活性：分布式系统最终会认同某一个值(something right must happen)</li><li>容错性</li></ul><p><a href="https://lrita.github.io/2018/10/23/safety-and-liveness-in-distributed/">分布式系统中的 safety 和 liveness — 源代码 (lrita.github.io)</a></p><p>和CAP一样，三选二</p><p><strong>证明：</strong></p><p>FLP不可能定理的证明是基于卡慕尔异步通信模型的，该模型假设节点之间的消息传输可以无限制地延迟，但必须保证每个节点最终能够收到所有消息。在这种通信模型下，证明FLP不可能定理的基本思路是，通过构造一个反例来说明在异步通信模型下，不存在一个算法能够保证在存在至少一个节点故障的情况下，仍然能够保证所有节点能够在有限时间内达成共识。</p><p>具体来说，假设有一个分布式系统，其中包含n个节点，节点之间通过消息传递来达成共识。为了方便起见，假设系统中只有两种状态：0和1。初始状态下，每个节点的状态都是不确定的。节点之间的通信是异步的，消息传输可以无限制地延迟，且无法保证消息的可靠性。</p><p>接下来，假设有一个算法A，可以在存在至少一个节点故障的情况下，仍然能够保证所有节点能够在有限时间内达成共识。为了证明FLP不可能定理，需要构造一个反例来说明这个算法是不可行的。</p><p>具体来说，假设存在两个节点p和q，它们的状态初始时均为不确定状态。为了达成共识，节点p发送一个消息m给节点q，告诉节点q它当前的状态是0。但由于通信是异步的，消息m可能会被延迟或者丢失，导致节点q无法知道节点p的状态。因此，节点q可以选择继续等待消息m，或者猜测节点p的状态是1。如果节点q猜测节点p的状态是1，那么节点q会发送一个消息n给节点p，告诉节点p它当前的状态是1。由于节点p也无法确定节点q的状态，节点p也有可能会猜测节点q的状态是0，从而发送一个消息k给节点q，告诉节点q它当前的状态是0。这样，就形成了一个死锁状态，导致节点p和q无法达成共识。</p><p>从上述分析可以看出，由于异步通信模型的存在，无法保证消息的可靠性和节点状态的一致性，从而导致FLP不可能定理的存在。虽然该定理证明了在异步通信模型下，不存在一个算法能够保证在存在至少一个节点故障的情况下，仍然能够保证所有节点能够在有限时间内达成共识，但在实际应用中，可以采用一些近似算法来解决共识问题。</p><ul><li>故障屏蔽</li><li>使用故障检测器</li><li>使用随机性算法</li></ul><p>这三种方法可以绕开FLP不可能定理</p><h3 id="4-2-2-故障屏蔽"><a href="#4-2-2-故障屏蔽" class="headerlink" title="4.2.2 故障屏蔽"></a>4.2.2 故障屏蔽</h3><p>故障屏蔽（Fault tolerance）和故障检测器（Fault detection）是分布式系统中常用的技术，用于提高系统的可靠性和鲁棒性。使用随机性算法是实现这些技术的一种常用方法。</p><p>故障屏蔽是一种技术，可以在系统中发生故障时保证系统的正常运行。一种常见的故障屏蔽技术是冗余备份（Redundancy），即在系统中增加多个备份，当一个节点发生故障时，备份节点可以接管其任务，保证系统的正常运行。在实现冗余备份时，常常使用随机性算法，如随机化选举（Randomized election）和随机化复制（Randomized replication）等技术，来提高系统的可靠性和鲁棒性。</p><h3 id="4-2-3-使用故障检测器"><a href="#4-2-3-使用故障检测器" class="headerlink" title="4.2.3 使用故障检测器"></a>4.2.3 使用故障检测器</h3><p>故障检测器是一种技术，用于检测分布式系统中的故障节点。一种常见的故障检测器是心跳检测（Heartbeat detection），即每个节点定期向其他节点发送心跳消息，检测是否有节点故障。在实现心跳检测时，常常使用随机性算法，如随机化时间间隔（Randomized interval）和随机化路线（Randomized routing）等技术，来避免故障检测过程中的死锁和瓶颈等问题，提高检测的准确性和效率。</p><p>虽然完美的故障检测器具备以下条件：</p><ul><li>完全性：每一个故障的进程都会被每一个正确的进程怀疑</li><li>精确性：每一个正确的进程都不会被其他进程怀疑</li></ul><p>但实际上，实现困难。而论文证明，即使使用”不完美”的故障检测器，只要通信可靠，失效进程不超过一半，依然可以用来解决共识问题。因此实现最终弱故障检测器：</p><ul><li>最终弱完全性：每一个故障的进程最终都会被一些正确的进程检测到。</li><li>最终弱精确性：经过一段时间后，一个正确的进程不会被其他正确的进程怀疑。</li></ul><h3 id="4-2-4-使用随机性算法"><a href="#4-2-4-使用随机性算法" class="headerlink" title="4.2.4 使用随机性算法"></a>4.2.4 使用随机性算法</h3><p>随机性算法是指在算法设计和实现中引入随机性的一种技术，可以用于解决一些分布式系统中的复杂问题，如分布式计算、分布式存储、分布式共识等问题。随机性算法具有一些优点，如简单、快速、容易实现和分布式化等特点，可以提高分布式系统的性能和效率。</p><p><strong>区块链：</strong></p><p>Proof of Work（PoW）和Proof of Stake（PoS）是两种常见的区块链共识机制，用于保证区块链的安全性和去中心化特性。它们的主要区别在于如何选举出下一个区块的记账节点。</p><p>PoW机制是通过计算一定难度的工作量来选举出下一个区块的记账节点。矿工需要通过计算一个随机数，使得计算结果符合一定的规则，以此获得记账权。这种机制需要大量的计算能力和电力消耗，因此存在能源浪费和环境污染等问题。</p><p>PoS机制则是通过拥有一定数量的代币来选举出下一个区块的记账节点。持有更多代币的用户会有更大的概率被选中作为记账节点。这种机制可以避免计算资源和能源的浪费，但需要考虑如何避免寡头垄断和激励机制的问题。</p><p>以下是PoW和PoS机制的一些优缺点：</p><p>Proof of Work（PoW）:</p><ul><li>优点：安全性高，攻击成本高，可预测性好。</li><li>缺点：能源浪费，环境污染，效率低，中心化问题。</li></ul><p>Proof of Stake（PoS）:</p><ul><li>优点：节省能源，环保，效率高，可扩展性好，分散化程度高。</li><li>缺点：可能导致寡头垄断，激励机制难以设计，安全性有待验证。</li></ul><p>[(459条消息) [区块链]共识算法（POW,POS,DPOS,PBFT）介绍和心得_dpos共识机制_乐扣老师lekkoliu的博客-CSDN博客](<a href="https://blog.csdn.net/lsttoy/article/details/61624287?ops_request_misc=%7B%22request_id%22:%22168594614916800186538613%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168594614916800186538613&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-61624287-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=pow">https://blog.csdn.net/lsttoy/article/details/61624287?ops_request_misc=%7B%22request%5Fid%22%3A%22168594614916800186538613%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168594614916800186538613&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-61624287-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=pow</a> pos&amp;spm&#x3D;1018.2226.3001.4187)</p><p>[(459条消息) 区块链必知基础知识、POS、POW、DPOS、公有链、私有链、联盟链_区块链pos_yida&amp;yueda的博客-CSDN博客](<a href="https://blog.csdn.net/qq_40585384/article/details/124678390?ops_request_misc=&request_id=&biz_id=102&utm_term=pow">https://blog.csdn.net/qq_40585384/article/details/124678390?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=pow</a> pos&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-124678390.142^v88^control_2,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="4-3-同步系统中的共识"><a href="#4-3-同步系统中的共识" class="headerlink" title="4.3 同步系统中的共识"></a>4.3 同步系统中的共识</h2><p>Dolev-Strong算法是一种用于解决密码学中的安全多方计算（Secure Multiparty Computation，SMC）问题的算法。该算法由Danny Dolev和Hadas Shachnai-Strong于1991年提出。</p><p>安全多方计算是一种加密技术，允许多个参与者在不泄露私有信息的情况下共同计算出一个结果。在安全多方计算中，每个参与者需要负责保护自己的私有信息，同时协调计算过程以达到预期的结果。Dolev-Strong算法就是一种用于实现安全多方计算的算法之一。</p><p>Dolev-Strong算法基于一种名为交互式验证协议（Interactive Verification Protocol，IVP）的技术，通过多轮的通信和验证来确保计算的正确性和安全性。该算法可以在不需要信任第三方的情况下完成安全计算，因此具有很好的去中心化特性。</p><p>Dolev-Strong算法的主要思想是，<strong>将计算任务分解成多个子任务，每个参与者只负责计算其中的一部分，并将计算结果加密后传递给下一个参与者。在每个子任务之间，参与者需要进行验证，以确保计算的正确性和安全性。通过多轮的交互和验证，参与者最终可以得到正确的计算结果，同时保护自己的私有信息不被泄露。</strong></p><p>总的来说，Dolev-Strong算法是一种基于<strong>交互式验证协议</strong>的安全多方计算算法，可以在不需要信任第三方的情况下实现安全计算，具有很好的<strong>去中心化特性</strong>，被广泛应用于密码学、区块链和分布式系统等领域。</p><h2 id="4-4-Paxos"><a href="#4-4-Paxos" class="headerlink" title="4.4 Paxos"></a>4.4 Paxos</h2><p><a href="https://blog.csdn.net/weixin_45525272/article/details/127698249?ops_request_misc=%7B%22request_id%22:%22168174848616800213085420%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168174848616800213085420&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-127698249-null-null.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&utm_term=paxos&spm=1018.2226.3001.4187">(443条消息) 分布式共识算法——Paxos算法（图解）_杨 戬的博客-CSDN博客</a></p><p>Paxos算法是一种用于解决分布式系统中达成一致性的算法，由Leslie Lamport于1998年提出。Paxos算法的目的是保证分布式系统中各个节点之间的状态一致性，即在不可靠的网络环境下，保证不同节点对共享资源的操作具有相同的效果。</p><p>Paxos算法的核心思想是通过一个协调者（coordinator）和多个参与者（acceptor）之间的协作来达成共识。在Paxos算法中，协调者的主要任务是向参与者发起提案（proposal），而参与者的主要任务是接受并决策是否通过提案，进而达成一致性。</p><p>具体来说，Paxos算法分为三个阶段：</p><ol><li>准备阶段（prepare phase）：协调者向参与者发起提案，并请求参与者发送自己曾经接受的最大提案编号（proposal number），以便协调者了解当前的提案状态。</li><li>接受阶段（accept phase）：如果协调者获得了大多数参与者的反馈，并且没有其他提案正在进行，那么协调者就可以向参与者发起新的提案，并请求参与者接受该提案。</li><li>学习阶段（learn phase）：一旦协调者成功地向大多数参与者发送了新的提案，并得到了反馈，那么协调者就可以通知所有参与者接受该提案，从而完成一致性达成的过程。</li></ol><p>总的来说，Paxos算法是一种用于解决分布式系统中达成一致性的算法，通过协调者和参与者之间的协作来实现共识。该算法被广泛应用于分布式存储、分布式计算、分布式数据库和区块链等领域。</p><p>Paxos算法是一种非常复杂的算法，实现和理解上有一些细节需要注意：</p><ol><li>提案编号（proposal number）的生成方式需要确保唯一性和可比较性，一般使用时间戳和节点编号等信息组合而成。</li><li>在准备阶段，参与者需要检查当前提案的编号是否比自己之前接受的所有提案编号都要大。如果有更大的提案编号，参与者就需要返回该提案的编号和对应的值，以便协调者做出决策。</li><li>在接受阶段，协调者需要确保至少有半数的参与者接受了新的提案，并将其值写入日志。如果无法达成一致，协调者需要回退并重新发起提案。</li><li>在学习阶段，协调者需要通知所有参与者已经达成共识，并将提案值写入共享存储中。</li><li>Paxos算法还需要考虑一些异常情况，例如节点宕机、网络延迟和网络分区等，需要通过复杂的协议来保证系统的可用性和一致性。</li></ol><p>需要注意的是，Paxos算法是一种非常复杂的算法，对于初学者来说理解起来比较困难。因此，建议在实践中结合阅读相关文献和代码实现，逐步理解其细节和原理。</p><p><strong>为什么要提案编号？</strong></p><ul><li>分布式系统使用时间戳之类的物理时间可能并不准确</li><li>轮次+服务器id</li></ul><h2 id="4-5-Go实现Paxos"><a href="#4-5-Go实现Paxos" class="headerlink" title="4.5 Go实现Paxos"></a>4.5 Go实现Paxos</h2><h2 id="4-6-Multi-Paxos"><a href="#4-6-Multi-Paxos" class="headerlink" title="4.6 Multi-Paxos"></a>4.6 Multi-Paxos</h2><p>Multi-Paxos是Paxos算法的一个变种，用于优化Paxos算法在多次提案的情况下的性能。在Paxos算法中，每次提案都需要执行一次完整的Paxos流程，包括准备、接受和学习三个阶段，这会导致Paxos算法的性能比较低。</p><p>Multi-Paxos通过引入领导者（leader）的概念来优化Paxos算法的性能。在Multi-Paxos中，领导者负责向参与者发起提案，而参与者则只需要根据领导者的指示来决策是否接受提案。因此，领导者可以在一段时间内发起多个提案，从而避免了每次提案都需要执行完整的Paxos流程的问题。</p><p>具体来说，Multi-Paxos的流程如下：</p><ol><li>领导者向参与者发起一个提案，包括提案编号和提案值。</li><li>参与者根据提案编号进行决策：如果当前的提案编号比之前接受的所有提案编号都要大，那么参与者就接受该提案，并向领导者发送接受消息；否则，参与者就拒绝该提案，并向领导者发送拒绝消息。</li><li>如果领导者收到了大多数参与者的接受消息，那么该提案就被确定，并向所有参与者发送确定消息，完成该提案的学习阶段。</li><li>如果领导者收到了大多数参与者的拒绝消息，那么领导者就需要重新选择一个提案编号，并重新发起提案。</li></ol><p>需要注意的是，Multi-Paxos仍然需要保证Paxos算法的正确性和一致性，但通过引入领导者来优化性能，使得Multi-Paxos在实际应用中更加高效。</p><h2 id="4-8-Raft算法"><a href="#4-8-Raft算法" class="headerlink" title="4.8 Raft算法"></a>4.8 Raft算法</h2><p><strong>要持久化存储的信息：</strong></p><ul><li>currentTerm：当前任期，用于恢复</li><li>votefor:向谁投票，只投个第一个发送RequestVote RPC的人而拒绝其他发送RequestVote RPC的人</li><li>日志：包含索引位置，任期号，命令本身，如果日志在半数节点上被存储，则该记录可提交。注意，领导者先将日志持久化存储到本地，再并行用AppendEntries RPC发送到其他节点上。这时，如果收到超过半数的响应，则领导者将命令应用于自己的状态机，提交该日志，然后向客户端返回响应。后续的日志复制RPC中还包含LeaderCommit表明领导者已经提交的日志的最大索引，跟随者收到此RPC时也会提交所有小于该索引的日志</li></ul><p><strong>两个RPC：</strong></p><ul><li>RequestVote RPC ：用于领导者选举，包含term,id,lastLogIndex,lastLogTerm，同样在用于领导者选举中，最后两个属性若term&gt;跟随者的term或者term相等但index大于跟随者最后一条日志的index，则跟随者才会投票，同理也需要一半投票才行，这确保了领导者在超过半数给他投票的节点中拥有最完整的日志。</li><li>AppendEntries RPC ： 用于复制日志&#x2F;发送心跳信息，后续的日志复制RPC中还包含LeaderCommit表明领导者已经提交的日志的最大索引，跟随者收到此RPC时也会提交所有小于该索引的日志</li></ul><p><strong>节点转换流程：</strong></p><ul><li><p><img src="https://s2.loli.net/2024/06/26/Ta59hwiKOP8bEAI.jpg" alt="184BF7AF3986E254E406FB773D48170F.jpg"></p></li><li><p>只有发生以下三种情况之一才更新自己的状态</p><ul><li>RequestVote RPC收到超过半数的选票，变为领导者</li><li>收到来自其他领导者的AppendEntries，退化为跟随者</li><li>没发生上述两种情况，任期++，投自己一票</li><li><img src="https://s2.loli.net/2024/06/26/PAk64Yw2OWc7rzm.jpg" alt="D2DEF7CFA7530BD2C2B1301FAA8C0159.jpg"></li></ul></li></ul><p><strong>保证两个特性：</strong></p><ul><li>安全性：一个任期内最多只有一个领导者被选出来</li><li>活性：系统最终能选出一个领导者</li></ul><p><strong>解决活锁问题（没人可以获得超过一半选票）：</strong></p><ul><li>节点随机选择超时时间（T-2T期间，T越大于网络传播时间效果越加，但同时不能太大，否则性能会受到影响）</li></ul><p><strong>两个特性：</strong></p><ul><li>如果任期和索引相同，则日志条目完全相同，日志内容相同，且之前的日志也完全相同（数学归纳法？）</li><li>RAFT不允许出现日志空洞，必须连续提交日志</li><li>为了维护这两个特性，在AppendEntries中还有之前一个日志的prevLogIndex和任期prevLogTerm，跟随者收到后，会检查自己最后一条日志的index和term是否匹配，若匹配，则接受，否则拒绝。（一致性检查）</li></ul><p><strong>延迟提交：</strong></p><ul><li>为什么需要延迟提交？<ul><li>若出现网络分区，导致B分区中的一个服务器拥有更新任期的日志（比如3），而A分区中的领导者（此时在任期4，而最新的日志任期为2），若提交后宕机（而A分区中其他服务器的日志任期也为2，但未提交），而B分区中的服务器此时恰好又成为新的领导者（任期5），此时则会覆盖掉A分区中未提交任期为日志2的服务器的日志，而实际上，A分区之前的领导者实际上已经提交了该日志，这不符合已提交日志不能被修改的需求</li></ul></li><li>怎么延迟提交<ul><li>日志必须存储在超过半数节点上</li><li>领导者必须看到超过半数节点上还存储着至少一条自己任期内的记录</li><li>领导者只能提交自己任期的日志，从而间接提交之前任期的日志</li><li>no-op日志：只有索引和日期，保持领导者的权威<ul><li>在领导者刚选举成功时，就本地追加no-op日志（只包含任期），同时appendEntries到其他的节点，显然，no-op日志的任期就是领导者当前的任期，当然能提交，从而间接提交之前的任期的日志</li></ul></li></ul></li></ul><p><strong>清理不一样的日志：</strong></p><ul><li>两种不一样的日志，缺失&#x2F;多出来的<ul><li>前者直接AppendEntries来补齐（也要用到nextIndex）</li><li>后者，领导者为每个跟随者保存nextIndex[]变量，存储领导者最后一条日志的索引+1</li></ul></li><li>流程<ul><li>针对缺失的：领导者检查自己的日志，最新index为10，然后比如对于跟随者1，nextIndex[1]&#x3D;11,带上前一个日志条目的唯一标识（10，任期6），跟随者1索引为10处没有日志，递减nextIndex[1],直到nextIndex[1]&#x3D;5,索引4且任期4的日志匹配，补齐索引5-10</li><li>针对多出来的，跟上面一样，直到找到匹配的index，而之后的全部删除即可</li></ul></li></ul><p><strong>处理旧领导者：</strong></p><ul><li>RPC请求有自己的任期，如果发生网络分区，老的领导者还以为自己是领导者，他的RPC在被其他Follower接收到的时候，但凡Follower已知的任期比他新，都会返回拒绝消息，但凡接收到拒绝消息，老的领导者就跟咽了气的皮球似的变为跟随者。</li></ul><p><strong>配置变更：</strong></p><ul><li>使用 <strong>Joint Consensus</strong>（联合共识）完成两阶段协议<ul><li>第一阶段,C<strong>old+new</strong>，多数派，提交</li><li>第二阶段,Cnew，多数派，提交，提交后后续配置都基于Cnew（不在Cnew的领导者下台）<ul><li>不在Cnew的领导者下台会导致一个问题就是，不在Cnew的跟随者将不再收到心跳，因此其会参与领导者选举（尽管会因为日志不够新而导致竞选失败，但是还是会影响竞选过程导致可用性变差）<ul><li>解决：Pre-Vote阶段，就还是发送Pre-Vote请求询问整个系统“我到底有没有资格参与竞选”（这个资格还是根据任期以及日志Index来判断的）。但这样会有个问题就是，如果在Cnew集群中的领导者还没有把Cnew的日志发到其跟随者上，也就是说，跟随者的日志还不够新，那么就算有Pre-Vote，可能还是会影响选举，导致不在Cnew的服务节点竞选成功</li><li>增强Pre-Vote判断条件：<ul><li>任期更大，或者任期相同索引更大</li><li>至少一次选举时间内没有收到领导者心跳</li></ul></li><li>注意到在Pre-Vote阶段不会增加自己的任期，所以Pre-Vote不仅可以解决配置更改干扰领导者的问题，还能解决网络分区脑裂和任期爆炸增长的问题</li><li>示例：etcd，将候选者细分为预候选者和候选者，前者发送Pre-Vote，不增加日期，后者发送RequestVote，会增加任期</li></ul></li></ul></li></ul></li></ul><p><strong>日志压缩：</strong></p><ul><li>关注最终状态</li><li>压缩后得到快照，持久化存储</li><li>每个服务器独立地压缩其已提交的日志</li><li>保存最后一条被丢弃的日志的索引和任期，用AppendEntries进行日志一致性的检查</li><li>一旦丢弃了前面部分的日志，领导者要承担两个责任：<ul><li>如果服务器重启了，则需要将最新的快照加载到状态机后再接收日志</li><li>向较慢的跟随着发送一致的状态快照(InstrallSnapshot RPC)</li></ul></li><li>LastIncludeIndex和LastIncludeTerm，记录状态，之前的日志全部丢弃</li><li>在正常运行期间通过写时复制技术（COW）生成快照（开源LogCabin）</li></ul><h2 id="4-9-Raft和Paxos"><a href="#4-9-Raft和Paxos" class="headerlink" title="4.9 Raft和Paxos"></a>4.9 Raft和Paxos</h2><p>Raft和Paxos都是分布式一致性算法，它们都被广泛应用于构建高可用性、高可靠性的分布式系统。</p><p>Paxos是最早提出的分布式一致性算法之一，由Leslie Lamport在1990年代初期提出。Paxos算法包含了两个主要的组件：leader选举和状态复制。它的核心思想是通过在节点之间达成共识来实现状态的复制和一致性。</p><p>Raft是一种新近出现的分布式一致性算法，由Diego Ongaro和John Ousterhout于2013年提出。Raft算法也包含了leader选举和状态复制两个主要部分，它强化了容错机制和可读性，使得它更容易被理解和实现。</p><p>相比而言，Raft与Paxos相比较具有以下优势：</p><ol><li>理解和实现容易：Raft算法把分布式一致性问题分成了几个独立的子问题，分别处理，每个子问题都比较容易理解和实现，使得整个算法更加容易理解和实现。</li><li>更好的可读性：Raft的算法描述更接近日常使用中的术语，更容易理解，在阅读和修改代码时更加方便。</li><li>更好的性能：Raft算法的性能比Paxos算法更好，特别是在网络不稳定或者出现网络分区的情况下，Raft算法的表现更加优秀。</li></ol><p>总之，虽然Raft和Paxos都是用于实现分布式一致性的算法，但是它们有着不同的设计思路和实现方式。Raft算法在易用性和可读性方面，相对Paxos算法更胜一筹，但在实际的应用场景中，不同的问题需要选择最适合的算法来解决。</p><h2 id="4-10-拜占庭容错和PBFT算法"><a href="#4-10-拜占庭容错和PBFT算法" class="headerlink" title="4.10 拜占庭容错和PBFT算法"></a>4.10 拜占庭容错和PBFT算法</h2><p>Raft和Paxos，都是非常高效的算法，他们只支持CFT（Crash fault tolerance），只允许系统内节点宕机（crash），并不考虑系统内有作恶节点。</p><p><a href="https://zhuanlan.zhihu.com/p/53897982">共识算法系列：PBFT算法关键点综述、优缺点总结 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/35847127">共识算法系列之一：raft和pbft算法 - 知乎 (zhihu.com)</a></p><p><img src="https://s2.loli.net/2024/06/26/KorHVJc7exkftXw.webp" alt="v2-1b29af254f0cc338876f232e32415878_1440w[1].webp"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 深入理解分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4&amp;SRV6</title>
      <link href="/2024/06/24/B-EP2/"/>
      <url>/2024/06/24/B-EP2/</url>
      
        <content type="html"><![CDATA[<h1 id="B-EP2"><a href="#B-EP2" class="headerlink" title="B-EP2"></a>B-EP2</h1><p>背景：互联网变得臃肿，网络管理员迫切需要一种快速高效的<strong>网络遥测方案</strong>，能够利用采集到的实时准确的网络状态信息来快速检测和定位常见网络故障，然后需要一个有效的<strong>网络控制和管理（NC&amp;M）方案</strong>，以实现只能及时决策以在网络路径上<strong>梳理和路由流量</strong>，以同时实现<strong>高效的利用和高质量的服务（QoS</strong>）。</p><ul><li>采集网络信息，定位故障</li><li>有效的网络控制和管理方案</li></ul><p><a href="https://blog.csdn.net/hjxzb/article/details/91141685?ops_request_misc=%7B%22request_id%22:%22168753985816782427413509%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168753985816782427413509&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-91141685-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=P4&spm=1018.2226.3001.4187">(465条消息) P4学习笔记（一）初识P4_p4接口是干嘛的_程序员学编程的博客-CSDN博客</a></p><ol><li><p>基于P4的主动遥测</p><ul><li><p>探针代替数据分组进行遥测，降低了遥测开销（因为数组分组比如INT即带内网络遥测<a href="https://blog.csdn.net/weixin_47104688/article/details/123229563?ops_request_misc=%7B%22request_id%22:%22168606788516800222871187%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168606788516800222871187&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-123229563-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=INT%E5%B8%A6%E5%86%85&spm=1018.2226.3001.4187">(460条消息) 带内网络遥测INT–In-band Network Telemetry_袁冬至的博客-CSDN博客</a></p><p><img src="https://s2.loli.net/2024/06/24/pdxWMcIf7mgeRLJ.jpg" alt="SDN.png"></p><p><a href="https://www.sdnlab.com/23822.html">https://www.sdnlab.com/23822.html</a></p><p><a href="https://blog.csdn.net/changqing1234/article/details/103669835?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-103669835-blog-123229563.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-103669835-blog-123229563.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=1">(465条消息) Telemetry 技术概述_LeocenaY的博客-CSDN博客</a></p><p>，在转发数据分组时能够在数据在网络结构流动的过程中，通过在路径中间节点插入元数据，监控系统可以通过这些元数据进行收集网络状态，但这样载荷比就大)，INT之类的带内网络遥测也存在一些局限性，难以获取全局网络试图。这样就加入了探针进行主动遥测，提高数据分组的有效载荷比。</p><p><a href="https://www.sdnlab.com/23822.html">一文读懂带内网络遥测技术 | SDNLAB | 专注网络创新技术</a></p></li></ul></li><li><p>基于段路由（基于IPV6的一向技术）</p><p><img src="https://s2.loli.net/2024/06/26/CJNZUQIAzHT2E6O.png" alt="image-20230607005803362.png"></p><p><a href="https://blog.csdn.net/m0_49864110/article/details/123591943?ops_request_misc=%7B%22request_id%22:%22168606977016800225513092%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168606977016800225513092&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123591943-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=SRV6&spm=1018.2226.3001.4187">(460条消息) 广域网技术——SRv6 SID讲解_静下心来敲木鱼的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/Ether_Dzh/article/details/119847548?ops_request_misc=%7B%22request_id%22:%22168754187716800227440687%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168754187716800227440687&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-119847548-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=SRV6&spm=1018.2226.3001.4187">(465条消息) 1.2、SRv6(Segment Routing Over IPv6) 介绍_srv6技术是什么_Ether_Dzh的博客-CSDN博客</a></p><p><img src="https://s2.loli.net/2024/06/24/zMpDeVWXRC46Fnd.jpg" alt="网络编程.png"></p><ul><li>改变SR标签和排列顺序指定探测路径</li><li>探针加入SR标签栈获取全面的网络视图，环形探测路径，单个探测点具备探针发送端和接收端功能，减少多个探测点之间同步协调探针等复杂操作。</li><li>减少遥测冗余，探针分组中加入遥测指示域，指定需要采集的遥测数据</li><li>将可编程设备的内部状态的状态信息嵌入到探针中，通过可编程设备的定制化能力自定义数据分组处理逻辑来是实现。</li></ul></li></ol><p>SDN控制面：可编程环境</p><p>可集中控制网络：SDN域由集中统一的控制单元实施管理</p><p>转发和控制分离</p><p>P4：</p><ul><li><p>可以对网络设备芯片逻辑进行编程</p></li><li><p>可重配置性：支持转发逻辑代码经过编译部署到具体平台上之后动态修改报文</p></li><li><p>不绑定某个具体的网络协议</p></li><li><p>平台无关性：独立于特定的底层运行平台来编写数据报文处理逻辑</p></li><li><p>需要特定交换机的支持</p></li><li><p>数据采集与感知：</p><ol><li>通过ONOS（一体化的网络操作系统）的Restful北向接口查询得到的ONOS特有数据库内的全局网络信息（但忽略细节）<a href="https://blog.csdn.net/weixin_34384681/article/details/91849632?ops_request_misc=%7B%22request_id%22:%22168606907716800227458444%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168606907716800227458444&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-6-91849632-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=ONOS&spm=1018.2226.3001.4187">(460条消息) ONOS预热篇之ONOS简介_weixin_34384681的博客-CSDN博客</a></li><li>数据层交换机中的数据流，插入探针，数据采集服务链，提取各个包的特征进行统计</li><li>基于段路由机制，进行INT主动遥测（INT本身是有局限性的，探测路径需要提前指定，而借助段路由机制进行主动网络遥测，降低成本提高了灵活性），流量包中插入探针，快速获取探测包路径上的第一手数据平面遥测数据</li></ol></li><li><p>这里的智能分析与决策采用深度学习相关的东西</p></li><li><p>可编程动态管控（P4）：仅管理数据平面如何处理数据包，定义控制平面与数据平面通信的接口，但不描述控制平面功能</p></li><li><p>传统交换机和P4交换机</p><p>在传统交换机中，制造商定义了数据平面的功能，控制平面通过一些管理表（如路由表）中的条目以及处理控制数据包（如路由协议数据包）或异步事件（如链路状态更改或学习通知）来控制数据平面。</p><p>P4可编程交换机与传统交换机的区别主要体现在两个方面：</p><ul><li>数据平面功能不是预先固定的，而是由 P4 程序定义的。数据平面在初始化时配置为实现 P4 程序描述的功能（由红色长箭头显示），并且没有现有网络协议的内置知识。</li><li>控制平面使用与固定功能设备中相同的通道与数据平面进行通信，但数据平面中的表集合和其他对象不再是固定的，因为它们由 P4 程序定义。P4 编译器生成控制平面用于与数据平面通信的 API。</li></ul></li><li><p>控制平面（SDN控制器）如何与P4的设备进行通信？</p><ul><li><p>P4Runtime（基于gRPC框架）</p></li><li><p>OpenFlow协议中，控制器和设备是由控制器开放端口，设备才能连接上控制器；而P4Runtime是设备上开始gRPC,控制器连接设备，因此，在支持P4的设备上也会有一个代理的Agent去处理控制器来的连接</p></li></ul></li></ul><p>鉴于基于P4的被动网络遥测可扩展性不足的缺点，首先要保证的就是主动遥测的探测路径在运行时是灵活可控的，我们采用段路由机制来灵活控制探针的探测路径（这里的路径生成采用了<a href="https://blog.csdn.net/KCDCY/article/details/124732427?ops_request_misc=%7B%22request_id%22:%22168606887816800222897225%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168606887816800222897225&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124732427-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%AC%A7%E6%8B%89%E9%80%9A%E8%B7%AF%E7%AE%97%E6%B3%95">Hierholzer <em>算法</em>，欧拉回路</a>）。段路由机制简单易用，不需要额外的协议支持，通过组合一系列简单的网络操作指令就可以完全控制数据分组的转发路径。在降低了网络成本的同时也提高了灵活性。最后段路由能够支持增量部署，降低了部署难度，可行性好。该系统下可以灵活定义遥测路径，按需探测可能或已经出现问题的路径，快速定位故障位置。同时，可以在探针格式中加入探测遥测数据类型的字段来支持按需获取遥测数据。同时要保证能够采集到网络设备内部的状态信息等细粒度准确的遥测数据，我们可以通过修改可编程设备的数据平面处理逻辑来区分正常数据分组和探针数据分组，对于正常数据分组直接正常转发，而对于探针数据分组匹配其中的路径转发标签以及遥测指令字段，将实时的网络状态信息封装在探针数据分组中。</p>]]></content>
      
      
      <categories>
          
          <category> SDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN </tag>
            
            <tag> P4 </tag>
            
            <tag> SRV6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研复习准备</title>
      <link href="/2024/06/24/%E4%BF%9D%E7%A0%94/"/>
      <url>/2024/06/24/%E4%BF%9D%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h1><p><a href="https://blog.csdn.net/zqm_0015/article/details/109236372">(453条消息) 2021年计算机保研面试题_一个主机将两个端口接到网络上是否会提升吞吐量_Challow的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/Baoyan_cs/article/details/124314177">(453条消息) 吐血整理，20个计算机保研常见问题及回答模板_计算机专业20个面试常见问题_Baoyan_cs的博客-CSDN博客</a></p><p>[(453条消息) 2021计算机保研经历(清软, 北深, 浙大, 南大, 中科大, 北航, 哈深, 南开, 华科, 武大, 中大)_inicho的博客-CSDN博客](<a href="https://blog.csdn.net/qq_43280818/article/details/123450451?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">https://blog.csdn.net/qq_43280818/article/details/123450451?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=计算机网络</a> 保研&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-9-123450451.142^v87^insert_down28,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><p>[(453条消息) 计算机网络保研面试题整理（自用）_乌鸡摸鱼的博客-CSDN博客](<a href="https://blog.csdn.net/m0_52571748/article/details/119513761?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">https://blog.csdn.net/m0_52571748/article/details/119513761?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=计算机网络</a> 保研&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-1-119513761.142^v87^insert_down28,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><p>[(453条消息) 计算机专业保研面试复习笔记——计算机网络_计算机保研复习_欧二lord的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_43117620/article/details/109198194?ops_request_misc=%7B%22request_id%22:%22168433738716800227438825%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168433738716800227438825&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-109198194-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">https://blog.csdn.net/weixin_43117620/article/details/109198194?ops_request_misc=%7B%22request%5Fid%22%3A%22168433738716800227438825%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168433738716800227438825&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-109198194-null-null.142^v87^insert_down28,239^v2^insert_chatgpt&amp;utm_term=计算机网络</a> 保研&amp;spm&#x3D;1018.2226.3001.4187)</p><p><a href="https://blog.csdn.net/weixin_46893257/article/details/116306838?ops_request_misc=%7B%22request_id%22:%22168470925916800215052847%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168470925916800215052847&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-116306838-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=IPv6%E6%B5%81%E6%A0%87%E7%AD%BE&spm=1018.2226.3001.4187">(454条消息) IPV6基本报头_ipv6报头_yibasuo18176的博客-CSDN博客</a></p><p>[(454条消息) BGP、IBGP、EBGP、IGP、EGP_bgp和egp的区别_zhaomax的博客-CSDN博客](<a href="https://blog.csdn.net/zhaomax/article/details/52399403?ops_request_misc=&request_id=&biz_id=102&utm_term=IGP">https://blog.csdn.net/zhaomax/article/details/52399403?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=IGP</a> BGP&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-4-52399403.142^v87^insert_down28,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><a href="https://blog.csdn.net/m0_52571748/article/details/119512934">(453条消息) 计算机操作系统保研面试题整理（自用）_乌鸡摸鱼csdn_乌鸡摸鱼的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/love521314123/article/details/119682266">(453条消息) 操作系统笔记（含王道计算机考研——操作系统课件）_操作系统考研笔记_一只不吃老鼠的猫的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/lishanleilixin/article/details/89709194">(454条消息) OS之存储管理 — 磁盘调度算法_os 对磁盘操作 写优先_如是说如是的博客-CSDN博客</a></p><h2 id="计组"><a href="#计组" class="headerlink" title="计组"></a>计组</h2><p><a href="https://blog.csdn.net/m0_52571748/article/details/119530739?ops_request_misc=%7B%22request_id%22:%22168433894316800197057897%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168433894316800197057897&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-119530739-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BF%9D%E7%A0%94&spm=1018.2226.3001.4187">(453条消息) 计算机组成原理保研面试题整理（自用）_计算机组成原理面试题_乌鸡摸鱼的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/love521314123/article/details/122825247#comments_26524593">(453条消息) 王道计算机考研——计算机组成原理笔记_王道计算机组成原理_一只不吃老鼠的猫的博客-CSDN博客</a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="https://blog.csdn.net/weixin_43790779/article/details/120934734?ops_request_misc=%7B%22request_id%22:%22168433902416800226547104%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168433902416800226547104&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120934734-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BF%9D%E7%A0%94&spm=1018.2226.3001.4187">(453条消息) 保研面试复习之数据结构篇_数据结构保研复习_abtgu的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_40113925/article/details/100938378?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-100938378-blog-120934734.235%5Ev36%5Epc_relevant_anti_vip&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-100938378-blog-120934734.235%5Ev36%5Epc_relevant_anti_vip&utm_relevant_index=3">(453条消息) 数据结构基础概念知识点_保研&#x2F;考研&#x2F;面试复习_顺序哈希分块折半_Raising_的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/whz_zb/article/details/7425152?ops_request_misc=%7B%22request_id%22:%22168465798116800182114693%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168465798116800182114693&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-7425152-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%83%9C%E8%80%85%E6%A0%91%E5%92%8C%E8%B4%A5%E8%80%85%E6%A0%91&spm=1018.2226.3001.4187">(454条消息) 胜者树与败者树_胜者树和败者树_whz_zb的博客-CSDN博客</a></p><p>[(454条消息) 详解全局变量，全局变量与静态变量的区别_静态变量和全局变量_舒泱的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_43222324/article/details/106989714?ops_request_misc=%7B%22request_id%22:%22168474123716800226594104%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168474123716800226594104&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-106989714-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">https://blog.csdn.net/weixin_43222324/article/details/106989714?ops_request_misc=%7B%22request%5Fid%22%3A%22168474123716800226594104%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168474123716800226594104&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-106989714-null-null.142^v87^insert_down28,239^v2^insert_chatgpt&amp;utm_term=全局变量</a> 静态变量&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><p><a href="https://uestc.feishu.cn/file/boxcnT7mKncOLwyhbDjSGrCPhed">概率论.pdf - 成电飞书云文档 (feishu.cn)</a></p><h2 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h2><p><a href="https://uestc.feishu.cn/file/QdMtbKWaDofazmxMw6EcHqFyndc">高等数学知识点最全汇总.pdf - 成电飞书云文档 (feishu.cn)</a></p><p><a href="https://blog.csdn.net/crj0926/article/details/101761433?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%E5%92%8C%E5%8F%98%E6%8D%A2%E5%8C%BA%E5%88%AB&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-101761433.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(454条消息) 傅里叶级数和傅里叶变换简介和推导_傅里叶级数和傅里叶变换的区别和联系_HKDER的博客-CSDN博客</a></p><h2 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h2><p><a href="https://uestc.feishu.cn/file/PjBcbDESvoKrngxSYHScvkCInJd">离散数学.docx - 成电飞书云文档 (feishu.cn)</a></p><h2 id="线代"><a href="#线代" class="headerlink" title="线代"></a>线代</h2><p><a href="https://uestc.feishu.cn/file/HzV3b1Wxno1LFaxF6G9c1VKunzg">线代.pdf - 成电飞书云文档 (feishu.cn)</a></p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><a href="https://uestc.feishu.cn/file/boxcn0xg2vSIlKrccY2Y32c7Hye">数据库.pdf - 成电飞书云文档 (feishu.cn)</a></p><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><h2 id="JAVA-C"><a href="#JAVA-C" class="headerlink" title="JAVA&amp;C++"></a>JAVA&amp;C++</h2><p>[(454条消息) java—垃圾回收算法(GC)_会飞的猪zhu的博客-CSDN博客](<a href="https://blog.csdn.net/m0_58196614/article/details/126426266?ops_request_misc=&request_id=&biz_id=102&utm_term=Java">https://blog.csdn.net/m0_58196614/article/details/126426266?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Java</a> 的垃圾回收算法&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-126426266.142^v87^insert_down28,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="经验贴"><a href="#经验贴" class="headerlink" title="经验贴"></a>经验贴</h2><p><a href="https://zhuanlan.zhihu.com/p/415169966">2021年计算机保研经验帖 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/569448591">2022南大cs夏令营笔试面试准备 - 知乎 (zhihu.com)</a></p><p><a href="https://www.rstk.cn/news/624725.html?action=onClick">https://www.rstk.cn/news/624725.html?action=onClick</a></p><p><a href="https://zhuanlan.zhihu.com/p/377444777">2021年半跨CS保研经历（已上岸pku） - 知乎 (zhihu.com)</a></p><h2 id="机试真题"><a href="#机试真题" class="headerlink" title="机试真题"></a>机试真题</h2><p><a href="https://github.com/Muyiyunzi/BUAA-CS-Codes">Muyiyunzi&#x2F;BUAA-CS-Codes: 北京航空航天大学计算机学院研究生考试复试上机部分往年试题及解答 (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java刷题</title>
      <link href="/2024/06/24/Java%20algo/"/>
      <url>/2024/06/24/Java%20algo/</url>
      
        <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p><a href="https://blog.csdn.net/leader_song/article/details/132094080?ops_request_misc=%7B%22request_id%22:%22171151104816800211548110%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171151104816800211548110&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-132094080-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%872023&spm=1018.2226.3001.4187">2024年 Java 面试八股文（20w字）_java八股文2023-CSDN博客</a></p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>[Spring中的IOC和AOP是什么意思？-CSDN博客](<a href="https://blog.csdn.net/weixin_45704311/article/details/124295453?ops_request_misc=%7B%22request_id%22:%22171152017116777224421689%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171152017116777224421689&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-124295453-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=IOC">https://blog.csdn.net/weixin_45704311/article/details/124295453?ops_request_misc=%7B%22request%5Fid%22%3A%22171152017116777224421689%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171152017116777224421689&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-124295453-null-null.142^v100^pc_search_result_base2&amp;utm_term=IOC</a> AOP&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p><a href="https://blog.csdn.net/crazymakercircle/article/details/125059491?ops_request_misc=%7B%22request_id%22:%22171164453116800225568300%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171164453116800225568300&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125059491-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=sentinel&spm=1018.2226.3001.4187">sentinel （史上最全）-CSDN博客</a></p><h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p><a href="https://flydean.blog.csdn.net/article/details/113803536?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-113803536-blog-133955312.235%5Ev43%5Epc_blog_bottom_relevance_base7&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-113803536-blog-133955312.235%5Ev43%5Epc_blog_bottom_relevance_base7&utm_relevant_index=2">gradle中的build script详解_gradle buildscript-CSDN博客</a></p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>[JAVA内存分配原理解析–栈、堆、常量池_堆,栈,常量池详解-CSDN博客](<a href="https://blog.csdn.net/gb702250823/article/details/92801716?ops_request_misc=%7B%22request_id%22:%22171151029816800225558425%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171151029816800225558425&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-92801716-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=java">https://blog.csdn.net/gb702250823/article/details/92801716?ops_request_misc=%7B%22request%5Fid%22%3A%22171151029816800225558425%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171151029816800225558425&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-92801716-null-null.142^v100^pc_search_result_base2&amp;utm_term=java</a> 常量池 栈 堆&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><p><a href="https://blog.csdn.net/CodePlayMe/article/details/130724568?ops_request_misc=%7B%22request_id%22:%22170261719316777224420083%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170261719316777224420083&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-130724568-null-null.142%5Ev96%5Epc_search_result_base2&utm_term=java%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1018.2226.3001.4187">java刷题前常用的数据结构及方法_java刷题常用方法-CSDN博客</a></p><h3 id="int-转Integer"><a href="#int-转Integer" class="headerlink" title="int 转Integer"></a>int 转Integer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(num);</span><br></pre></td></tr></table></figure><h3 id="int到string数据类型的转换"><a href="#int到string数据类型的转换" class="headerlink" title="int到string数据类型的转换"></a><strong>int到string数据类型的转换</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">Integer.toString(num);</span><br></pre></td></tr></table></figure><p>或者<strong>String.valueOf(num);</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="comment">// 引号带上数据</span></span><br><span class="line">    <span class="type">int</span> num=<span class="number">100</span>;</span><br><span class="line">    String a=<span class="string">&quot;&quot;</span>+num;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">   <span class="comment">// 直接类型转换</span></span><br><span class="line">    Integer num2=<span class="number">100</span>;</span><br><span class="line">    String b=Integer.toString(num2);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串定义</span></span><br><span class="line">    String c=String.valueOf(num2);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String到int类型的转换"><a href="#String到int类型的转换" class="headerlink" title="String到int类型的转换"></a><strong>String到int类型的转换</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line">    <span class="comment">// parseInt</span></span><br><span class="line">    <span class="comment">// 加上static的方法，方法属于类，需要使用类名进行调用，没有加上static的，方法属于对象，可以new一个对象再调用</span></span><br><span class="line">    <span class="type">int</span> e=Integer.parseInt(s);</span><br><span class="line">    System.out.println(e);</span><br></pre></td></tr></table></figure><h3 id="ArrayList动态转换为Array数组"><a href="#ArrayList动态转换为Array数组" class="headerlink" title="ArrayList动态转换为Array数组"></a>ArrayList动态转换为Array数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String [] array=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[size]);</span><br></pre></td></tr></table></figure><p>除此之外，<strong>ArrayList</strong>还有以下的常用的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void add(int index, E element) 将指定元素插入此列表中的指定位置。</span><br><span class="line">boolean add(E e)将指定的元素追加到此列表的末尾。</span><br><span class="line">boolean contains(Object o)如果此列表包含指定的元素，则返回 true 。</span><br><span class="line">E get(int index) 返回此列表中指定位置的元素。</span><br><span class="line">int indexOf(Object o) 返回此列表中第一次出现的指定元素的索引，如果此列表不包含该元素，则返回-1。</span><br><span class="line">boolean isEmpty() 如果此列表不包含任何元素，则返回 true 。</span><br><span class="line">int lastIndexOf(Object o)返回此列表中指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-1。</span><br><span class="line">E remove(int index) 删除此列表中指定位置的元素。</span><br><span class="line">boolean remove(Object o)从该列表中删除指定元素的第一个匹配项（如果存在）</span><br><span class="line">E set(int index, E element) 用指定的元素替换此列表中指定位置的元素。</span><br><span class="line">int size() 返回此列表中的元素数。</span><br></pre></td></tr></table></figure><h3 id="Array数组转为ArrayList"><a href="#Array数组转为ArrayList" class="headerlink" title="Array数组转为ArrayList"></a>Array数组转为ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;list= Arrays.asList(array)</span><br></pre></td></tr></table></figure><h3 id="Arrays的常用方法"><a href="#Arrays的常用方法" class="headerlink" title="Arrays的常用方法"></a>Arrays的常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建数组</span></span><br><span class="line"><span class="type">int</span> nums[]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//获取长度</span></span><br><span class="line">nums.length;</span><br><span class="line"></span><br><span class="line">Arrays.toString(nums)</span><br><span class="line">Arrays.sort(nums)<span class="comment">//升序</span></span><br><span class="line">Arrays.fill(nums)<span class="comment">//初始化数组的时候会用到（比如全部给-1）</span></span><br><span class="line">Arrays.equal(nums)</span><br><span class="line">Arrays.copyof(nums)</span><br><span class="line">Arrays.compare(nums)</span><br><span class="line">Arrays.binarySearch(nums)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ArrayList的常用用法"><a href="#ArrayList的常用用法" class="headerlink" title="ArrayList的常用用法"></a>ArrayList的常用用法</h3><p>Array：只可存储基本数据类型和对象。被设置为<strong>固定大小</strong>。所包含的方法没有ArrayList多<br>ArrayList：只能<strong>存储对象</strong>。是一个<strong>可变数组</strong>，大小可自动调整。有很多操作方法：<a href="https://so.csdn.net/so/search?q=addAll&spm=1001.2101.3001.7020">addAll</a>、removeAll、iteration等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        sites.remove(<span class="number">3</span>); <span class="comment">// 删除第四个元素</span></span><br><span class="line"><span class="comment">//计算大小</span></span><br><span class="line">sites.size();</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">Collections.sort(sites);</span><br><span class="line"><span class="comment">//是否包含</span></span><br><span class="line">sites.contains();</span><br><span class="line"><span class="comment">//addAll()</span></span><br><span class="line">这个方法括号中类型是list，拼接</span><br><span class="line">    </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> 将指定元素插入此列表中的指定位置。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>将指定的元素追加到此列表的末尾。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>如果此列表包含指定的元素，则返回 <span class="literal">true</span> 。</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> 返回此列表中指定位置的元素。</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> 返回此列表中第一次出现的指定元素的索引，如果此列表不包含该元素，则返回-<span class="number">1</span>。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> 如果此列表不包含任何元素，则返回 <span class="literal">true</span> 。</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>返回此列表中指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-<span class="number">1</span>。</span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> 删除此列表中指定位置的元素。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>从该列表中删除指定元素的第一个匹配项（如果存在）</span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> 用指定的元素替换此列表中指定位置的元素。</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> 返回此列表中的元素数。</span><br></pre></td></tr></table></figure><h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a><strong>Collections类</strong></h3><p>对list进行反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.reverse(list)</span><br></pre></td></tr></table></figure><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String获取长度是.length()（要加括号）</p><p><a href="https://blog.csdn.net/weixin_62756510/article/details/124698100?ops_request_misc=%7B%22request_id%22:%22171013865416777224481954%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171013865416777224481954&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124698100-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=stringbuilder&spm=1018.2226.3001.4187">String、StringBuilder类超详细笔记_stringbuilder可以用equalsignorecase-CSDN博客</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">重要：<span class="type">char</span> charAt​(<span class="type">int</span> index) 返回指定索引处的 <span class="type">char</span>值。</span><br><span class="line"><span class="type">int</span> indexOf​(<span class="type">int</span> ch) 返回指定字符第一次出现的字符串中的索引。</span><br><span class="line">- <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> ，当且仅当， length()是 <span class="number">0</span> 返回 <span class="literal">true</span></span><br><span class="line"><span class="type">int</span> lastIndexOf​(<span class="type">int</span> ch) 返回指定字符最后一次出现的字符串中的索引。</span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> 返回此字符串的长度。</span><br><span class="line">String replace​(CharSequence target, CharSequence replacement) 将此字符串中与文字目标序列匹配的每个子字符串替换为指定的文字替换序列。</span><br><span class="line">String replaceAll​(String regex, String replacement) 将给定替换的给定 regular expression匹配的此字符串的每个子字符串替换。</span><br><span class="line">String[] split​(String regex) 将此字符串拆分为给定 regular expression的匹配 项 。</span><br><span class="line"><span class="type">boolean</span> startsWith​(String prefix) 测试此字符串是否以指定的前缀开头。</span><br><span class="line">String substring​(<span class="type">int</span> beginIndex) 返回一个字符串，该字符串是此字符串的子字符串。</span><br><span class="line"><span class="type">char</span>[] toCharArray() 将此字符串转换为新的字符数组。</span><br><span class="line">String <span class="title function_">toLowerCase</span><span class="params">()</span> 使用默认语言环境的规则将此 String所有字符转换为小写。</span><br><span class="line">String <span class="title function_">toUpperCase</span><span class="params">()</span> 使用默认语言环境的规则将此 String所有字符转换为大写。</span><br><span class="line">比较大小的话</span><br><span class="line">    String c= <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">c.compareTo(b);</span><br><span class="line">或者</span><br><span class="line">    c.equals(b);</span><br></pre></td></tr></table></figure><h3 id="字符类Chracter"><a href="#字符类Chracter" class="headerlink" title="字符类Chracter"></a>字符类Chracter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Character.compare(<span class="type">char</span> x, <span class="type">char</span> y) 以数字方式比较两个 <span class="type">char</span>值。</span><br><span class="line">Character.equals(Object obj) 将此对象与指定的对象进行比较。</span><br><span class="line">Character.isDigit(<span class="type">char</span> ch) 确定指定的字符是否为数字。</span><br><span class="line">Character.isLetter(<span class="type">char</span> ch) 确定指定的字符是否为字母。</span><br><span class="line">Character.isLowerCase(<span class="type">char</span> ch) 确定指定的字符是否为小写字符。</span><br><span class="line">Character.isUpperCase(<span class="type">char</span> ch) 确定指定的字符是否为大写字符。</span><br><span class="line">Character.toString(<span class="type">char</span> c) 返回表示指定的 <span class="type">char</span>的 String对象。</span><br><span class="line">Character.valueOf(<span class="type">char</span> c) 返回表示指定的 <span class="type">char</span>值的 Character实例。</span><br><span class="line">Character.toLowerCase(<span class="string">&quot;A&quot;</span>); 转为小写</span><br><span class="line">Character.toUpperCase(<span class="string">&quot;a&quot;</span>); 转为大写</span><br><span class="line"><span class="comment">//char数组转String</span></span><br><span class="line"><span class="type">char</span>[] data = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data);</span><br><span class="line">System.out.println(str);  <span class="comment">//输出abc</span></span><br></pre></td></tr></table></figure><h3 id="字符串构造器StringBuilder"><a href="#字符串构造器StringBuilder" class="headerlink" title="字符串构造器StringBuilder"></a>字符串构造器StringBuilder</h3><p><a href="https://blog.csdn.net/qq_46634307/article/details/126283200?ops_request_misc=%7B%22request_id%22:%22171014028016800192229813%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=171014028016800192229813&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-126283200-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=stringbuilder%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%AD%97%E7%AC%A6&spm=1018.2226.3001.4187">Java-修改 String 指定位置的字符最全方法总结（StringBuilder 和 StringBuffer 的使用以及区别）_string替换指定位置字符-CSDN博客</a></p><p><a href="https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-89966303-blog-124698100.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-89966303-blog-124698100.235%5Ev43%5Epc_blog_bottom_relevance_base1&utm_relevant_index=1">String、StringBuffer与StringBuilder之间区别_string stringbuffer stringbuilder区别-CSDN博客</a></p><p>可变字符串，StringBuilder对象的内容可以修改。</p><ol><li><p>StringBuilder类的常用方法</p><ol><li><p>append()方法<br>使用append()方法可实现字符串的拼接操作，返回拼接后的StringBuilder对象。</p></li><li><p>reverse()方法<br>使用reverse()方法可实现StringBuilder字符串的反转操作。</p></li><li><p>delete(int start, int end)方法<br>删除字符串中指定索引范围为 [start,end) 的所有内容。</p><p>Java中大多数范围均为左闭右开区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">sb.delete(<span class="number">5</span>,<span class="number">8</span>);  <span class="comment">//删除索引范围为[5,8)内的所有内容，即从w开始删除到l之前</span></span><br><span class="line">System.out.println(sb);  <span class="comment">//输出hellold</span></span><br></pre></td></tr></table></figure></li><li><p>insert(int start, 任意数据类型)方法<br>在索引start处开始插入任意数据类型的内容。插入内容的起始索引是start。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">sb1.insert(<span class="number">2</span>,<span class="number">77</span>);</span><br><span class="line">System.out.println(sb1);  <span class="comment">//输出he77llo</span></span><br><span class="line">sb1.insert(<span class="number">3</span>,<span class="string">&quot;ooo&quot;</span>);</span><br><span class="line">System.out.println(sb1);  <span class="comment">//输出he7ooo7llo</span></span><br></pre></td></tr></table></figure></li><li><p>setCharAt(index,character)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.setCharAt(j,Character.toUpperCase(sb.charAt(j)));</span><br></pre></td></tr></table></figure></li></ol></li><li><p>StringBuilder与String的相互转换<br> 1）String转为StringBuilder<br> ① 构造方法StringBuilder(String str)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>② 字符串拼接方法append(String str)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><p>2）StringBuilder转为String<br>通过StringBuilder对象调用toString()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">String、StringBuilder、StringBuffer的区别</span><br><span class="line">String为不可变字符串类，StringBuilder、StringBuffer为可变字符串类。</span><br><span class="line">StringBuilder类性能较高，但存在线程安全问题; StringBuffer类线程安全，但性能较差。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="双链表LinkedList"><a href="#双链表LinkedList" class="headerlink" title="双链表LinkedList"></a>双链表LinkedList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> <span class="comment">// 判断链表中是否存在元素o 复杂度O(N)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span></span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span> <span class="comment">//删除，返回的是删除的元素</span></span><br><span class="line">E getFirst/Last()</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">( E e)</span></span><br><span class="line">Collections.reverse(link); <span class="comment">// 翻转链表</span></span><br></pre></td></tr></table></figure><h3 id="哈希表Hashmap"><a href="#哈希表Hashmap" class="headerlink" title="哈希表Hashmap"></a>哈希表Hashmap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>如果这个映射包含指定键映射，则返回<span class="literal">true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> 如果此映射将一个或多个键映射到指定值，则返回 <span class="literal">true</span> 。</span><br><span class="line">V <span class="title function_">get</span><span class="params">(Object key)</span> 返回指定键映射到的值，如果此映射不包含键的映射，则返回 <span class="literal">null</span> 。</span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span> 将指定的值与此映射中的指定键相关联。</span><br><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span> 从此映射中删除指定键的映射（如果存在）。</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> 返回此映射中键 - 值映射的数量。</span><br><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> 返回此映射中包含的值的Collection视图。</span><br><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> 返回此映射中包含的键的Set视图。</span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> 返回指定键映射到的值，如果此映射不包含键的映射，则返回 defaultValue 。这个方法继承自Map接口</span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> 如果key存在则什么都不做，否则put()，并且返回当前值</span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射的Set视图。</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 初始化哈希表 */</span></span><br><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加操作 */</span></span><br><span class="line"><span class="comment">// 在哈希表中添加键值对 (key, value)</span></span><br><span class="line">map.put(<span class="number">12836</span>, <span class="string">&quot;小哈&quot;</span>);   </span><br><span class="line">map.put(<span class="number">15937</span>, <span class="string">&quot;小啰&quot;</span>);   </span><br><span class="line">map.put(<span class="number">16750</span>, <span class="string">&quot;小算&quot;</span>);   </span><br><span class="line">map.put(<span class="number">13276</span>, <span class="string">&quot;小法&quot;</span>);</span><br><span class="line">map.put(<span class="number">10583</span>, <span class="string">&quot;小鸭&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询操作 */</span></span><br><span class="line"><span class="comment">// 向哈希表中输入键 key ，得到值 value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> map.get(<span class="number">15937</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除操作 */</span></span><br><span class="line"><span class="comment">// 在哈希表中删除键值对 (key, value)</span></span><br><span class="line">map.remove(<span class="number">10583</span>);</span><br></pre></td></tr></table></figure><h3 id="哈希集合HashSet"><a href="#哈希集合HashSet" class="headerlink" title="哈希集合HashSet"></a>哈希集合HashSet</h3><p>[【Java 基础篇】Java Set 详解-CSDN博客](<a href="https://blog.csdn.net/qq_21484461/article/details/131383848?ops_request_misc=%7B%22request_id%22:%22171015290416800180682690%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171015290416800180682690&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131383848-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=Java">https://blog.csdn.net/qq_21484461/article/details/131383848?ops_request_misc=%7B%22request%5Fid%22%3A%22171015290416800180682690%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171015290416800180682690&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131383848-null-null.142^v99^pc_search_result_base2&amp;utm_term=Java</a> set&amp;spm&#x3D;1018.2226.3001.4187)</p><p>不能保证集合迭代的顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> 如果指定的元素尚不存在，则将其添加到此集合中。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> 如果存在，则从该集合中移除指定的元素。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> 如果此set包含指定的元素，则返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h3><p>栈，后进先出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化栈 */</span></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入栈 */</span></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出栈 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> stack.isEmpty();</span><br></pre></td></tr></table></figure><h3 id="队列Queue、双端队列Deque（都可用LinkedList来实例化，因为二者都是接口）"><a href="#队列Queue、双端队列Deque（都可用LinkedList来实例化，因为二者都是接口）" class="headerlink" title="队列Queue、双端队列Deque（都可用LinkedList来实例化，因为二者都是接口）"></a>队列Queue、双端队列Deque（都可用LinkedList来实例化，因为二者都是接口）</h3><p>队列，先进先出，Queue和Deque都是接口，而LinkedList类继承了这两个队列，<strong>可以是用LinkedList来实例化Queue或者Deque</strong>，可以作为单向队列或者双向队列来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Queue</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> 将指定元素插入此列表中的指定位置。</span><br><span class="line">E <span class="title function_">element</span><span class="params">()</span> 检索但不删除此列表的头部（第一个元素）。</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> 返回此列表中指定位置的元素。</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> 返回此列表中第一次出现的指定元素的索引，如果此列表不包含该元素，则返回-<span class="number">1</span>。</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> 返回此列表中指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-<span class="number">1</span>。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> 将指定的元素添加为此列表的尾部（最后一个元素）。</span><br><span class="line">E <span class="title function_">peek</span><span class="params">()</span> 检索但不删除此列表的头部（第一个元素）</span><br><span class="line">E <span class="title function_">poll</span><span class="params">()</span> 检索并删除此列表的头部（第一个元素）。</span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> 用指定的元素替换此列表中指定位置的元素。</span><br><span class="line"><span class="comment">/* 翻转队列 */</span></span><br><span class="line">Collections.reverse(queue) </span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> queue.isEmpty();</span><br></pre></td></tr></table></figure><p>双端队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化双向队列 */</span></span><br><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">deque.offerLast(<span class="number">2</span>);   <span class="comment">// 添加至队尾</span></span><br><span class="line">deque.offerLast(<span class="number">5</span>);</span><br><span class="line">deque.offerLast(<span class="number">4</span>);</span><br><span class="line">deque.offerFirst(<span class="number">3</span>);  <span class="comment">// 添加至队首</span></span><br><span class="line">deque.offerFirst(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peekFirst</span> <span class="operator">=</span> deque.peekFirst();  <span class="comment">// 队首元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peekLast</span> <span class="operator">=</span> deque.peekLast();    <span class="comment">// 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">popFirst</span> <span class="operator">=</span> deque.pollFirst();  <span class="comment">// 队首元素出队</span></span><br><span class="line"><span class="type">int</span> <span class="variable">popLast</span> <span class="operator">=</span> deque.pollLast();    <span class="comment">// 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> deque.isEmpty();</span><br></pre></td></tr></table></figure><p>…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList可以作为堆栈使用，并且在类中实现了对应的方法</span><br><span class="line">E <span class="title function_">pop</span><span class="params">()</span> 弹出此列表所代表的堆栈中的元素。</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> 将元素推送到此列表所表示的堆栈上。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优先队列-作为堆来用"><a href="#优先队列-作为堆来用" class="headerlink" title="优先队列(作为堆来用)"></a>优先队列(作为堆来用)</h3><p>默认小顶堆，但如果是数据结构就还是要重写comparator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//读</span></span><br><span class="line">minHeap.peek();</span><br><span class="line">minHeap.poll();(会弹出)</span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line">minHeap.add();</span><br><span class="line">minHeap.offer();</span><br><span class="line"><span class="comment">//优先队列自然排序示例</span></span><br><span class="line">Queue&lt;Integer&gt; integerPriorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">7</span>);<span class="comment">//容量为7</span></span><br><span class="line"><span class="comment">//优先队列使用示例</span></span><br><span class="line">Queue&lt;Customer&gt; customerPriorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(idComparator);</span><br><span class="line"><span class="comment">//匿名Comparator实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Customer&gt; idComparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Customer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Customer c1, Customer c2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (c1.getId() - c2.getId());<span class="comment">//这是小顶堆，反着写就是大顶堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化堆 */</span></span><br><span class="line"><span class="comment">// 初始化小顶堆</span></span><br><span class="line">Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 初始化大顶堆（使用 lambda 表达式修改 Comparator 即可）</span></span><br><span class="line">Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入堆 */</span></span><br><span class="line">maxHeap.offer(<span class="number">1</span>);</span><br><span class="line">maxHeap.offer(<span class="number">3</span>);</span><br><span class="line">maxHeap.offer(<span class="number">2</span>);</span><br><span class="line">maxHeap.offer(<span class="number">5</span>);</span><br><span class="line">maxHeap.offer(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取堆顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> maxHeap.peek(); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 堆顶元素出堆 */</span></span><br><span class="line"><span class="comment">// 出堆元素会形成一个从大到小的序列</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 5</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 4</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 3</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 2</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取堆大小 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> maxHeap.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断堆是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> maxHeap.isEmpty();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入列表并建堆 */</span></span><br><span class="line">minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>邻接矩阵</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于邻接矩阵实现的无向图类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjMat</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; vertices; <span class="comment">// 顶点列表，元素代表“顶点值”，索引代表“顶点索引”</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; adjMat; <span class="comment">// 邻接矩阵，行列索引对应“顶点索引”</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphAdjMat</span><span class="params">(<span class="type">int</span>[] vertices, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertices = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.adjMat = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vertices) &#123;</span><br><span class="line">            addVertex(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加边</span></span><br><span class="line">        <span class="comment">// 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">            addEdge(e[<span class="number">0</span>], e[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取顶点数量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertices.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加顶点 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addVertex</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> size();</span><br><span class="line">        <span class="comment">// 向顶点列表中添加新顶点的值</span></span><br><span class="line">        vertices.add(val);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中添加一行</span></span><br><span class="line">        List&lt;Integer&gt; newRow = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            newRow.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        adjMat.add(newRow);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中添加一列</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; row : adjMat) &#123;</span><br><span class="line">            row.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除顶点 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeVertex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="comment">// 在顶点列表中移除索引 index 的顶点</span></span><br><span class="line">        vertices.remove(index);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中删除索引 index 的行</span></span><br><span class="line">        adjMat.remove(index);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中删除索引 index 的列</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; row : adjMat) &#123;</span><br><span class="line">            row.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加边 */</span></span><br><span class="line">    <span class="comment">// 参数 i, j 对应 vertices 元素索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引越界与相等处理</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= size() || j &gt;= size() || i == j)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="comment">// 在无向图中，邻接矩阵关于主对角线对称，即满足 (i, j) == (j, i)</span></span><br><span class="line">        adjMat.get(i).set(j, <span class="number">1</span>);</span><br><span class="line">        adjMat.get(j).set(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除边 */</span></span><br><span class="line">    <span class="comment">// 参数 i, j 对应 vertices 元素索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引越界与相等处理</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= size() || j &gt;= size() || i == j)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        adjMat.get(i).set(j, <span class="number">0</span>);</span><br><span class="line">        adjMat.get(j).set(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印邻接矩阵 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;顶点列表 = &quot;</span>);</span><br><span class="line">        System.out.println(vertices);</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接矩阵 =&quot;</span>);</span><br><span class="line">        PrintUtil.printMatrix(adjMat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邻接表的BFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 广度优先遍历 */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line">List&lt;Vertex&gt; <span class="title function_">graphBFS</span><span class="params">(GraphAdjList graph, Vertex startVet)</span> &#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    List&lt;Vertex&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    Set&lt;Vertex&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    visited.add(startVet);</span><br><span class="line">    <span class="comment">// 队列用于实现 BFS</span></span><br><span class="line">    Queue&lt;Vertex&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    que.offer(startVet);</span><br><span class="line">    <span class="comment">// 以顶点 vet 为起点，循环直至访问完所有顶点</span></span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">vet</span> <span class="operator">=</span> que.poll(); <span class="comment">// 队首顶点出队</span></span><br><span class="line">        res.add(vet);            <span class="comment">// 记录访问顶点</span></span><br><span class="line">        <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">        <span class="keyword">for</span> (Vertex adjVet : graph.adjList.get(vet)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(adjVet))</span><br><span class="line">                <span class="keyword">continue</span>;        <span class="comment">// 跳过已被访问的顶点</span></span><br><span class="line">            que.offer(adjVet);   <span class="comment">// 只入队未访问的顶点</span></span><br><span class="line">            visited.add(adjVet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回顶点遍历序列</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邻接表的DFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 深度优先遍历辅助函数 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(GraphAdjList graph, Set&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet)</span> &#123;</span><br><span class="line">    res.add(vet);     <span class="comment">// 记录访问顶点</span></span><br><span class="line">    visited.add(vet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex adjVet : graph.adjList.get(vet)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(adjVet))</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过已被访问的顶点</span></span><br><span class="line">        <span class="comment">// 递归访问邻接顶点</span></span><br><span class="line">        dfs(graph, visited, res, adjVet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 深度优先遍历 */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line">List&lt;Vertex&gt; <span class="title function_">graphDFS</span><span class="params">(GraphAdjList graph, Vertex startVet)</span> &#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    List&lt;Vertex&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    Set&lt;Vertex&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    dfs(graph, visited, res, startVet);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="构建树（前序-中序）"><a href="#构建树（前序-中序）" class="headerlink" title="构建树（前序+中序）"></a>构建树（前序+中序）</h4><p><a href="https://www.hello-algo.com/chapter_divide_and_conquer/build_binary_tree_problem/#3">12.3  构建树问题 - Hello 算法 (hello-algo.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构建二叉树：分治 */</span></span><br><span class="line">TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] preorder, Map&lt;Integer, Integer&gt; inorderMap, <span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 子树区间为空时终止</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 初始化根节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[i]);</span><br><span class="line">    <span class="comment">// 查询 m ，从而划分左右子树</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> inorderMap.get(preorder[i]);</span><br><span class="line">    <span class="comment">// 子问题：构建左子树</span></span><br><span class="line">    root.left = dfs(preorder, inorderMap, i + <span class="number">1</span>, l, m - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 子问题：构建右子树</span></span><br><span class="line">    root.right = dfs(preorder, inorderMap, i + <span class="number">1</span> + m - l, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//构建右子树稍微复杂一些。首先，需要确定右子树的根节点在前序遍历中的位置。由于左子树的根节点之后的所有元素都属于右子树，所以右子树的根节点在前序遍历中的位置是 i + 1 + (m - l)。这里的 m - l 表示左子树的大小，即左子树有多少个节点。</span></span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构建二叉树 */</span></span><br><span class="line">TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化哈希表，存储 inorder 元素到索引的映射</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; inorderMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        inorderMap.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> dfs(preorder, inorderMap, <span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回溯问题"><a href="#回溯问题" class="headerlink" title="回溯问题"></a>回溯问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(State state, List&lt;Choice&gt; choices, List&lt;State&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否为解</span></span><br><span class="line">    <span class="keyword">if</span> (isSolution(state)) &#123;</span><br><span class="line">        <span class="comment">// 记录解</span></span><br><span class="line">        recordSolution(state, res);</span><br><span class="line">        <span class="comment">// 不再继续搜索</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (Choice choice : choices) &#123;</span><br><span class="line">        <span class="comment">// 剪枝：判断选择是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (isValid(state, choice)) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            makeChoice(state, choice);</span><br><span class="line">            backtrack(state, choices, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            undoChoice(state, choice);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：全排列 I */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span>[] choices, <span class="type">boolean</span>[] selected, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 当状态长度等于元素数量时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (state.size() == choices.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; choices.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">choice</span> <span class="operator">=</span> choices[i];</span><br><span class="line">        <span class="comment">// 剪枝：不允许重复选择元素</span></span><br><span class="line">        <span class="keyword">if</span> (!selected[i]) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            selected[i] = <span class="literal">true</span>;</span><br><span class="line">            state.add(choice);</span><br><span class="line">            <span class="comment">// 进行下一轮选择</span></span><br><span class="line">            backtrack(state, choices, selected, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            selected[i] = <span class="literal">false</span>;</span><br><span class="line">            state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全排列 I */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permutationsI</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    backtrack(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(), nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length], res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子集和问题"><a href="#子集和问题" class="headerlink" title="子集和问题"></a>子集和问题</h4><p>类似于全排列问题，我们可以把子集的生成过程想象成一系列选择的结果，并在选择过程中实时更新“元素和”，当元素和等于 <code>target</code> 时，就将子集记录至结果列表。</p><p>而与全排列问题不同的是，<strong>本题集合中的元素可以被无限次选取</strong>，因此无须借助 <code>selected</code> 布尔列表来记录元素是否已被选择。我们可以对全排列代码进行小幅修改，初步得到解题代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：子集和 I */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span> target, <span class="type">int</span> total, <span class="type">int</span>[] choices, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (total == target) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; choices.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝：若子集和超过 target ，则跳过该选择</span></span><br><span class="line">        <span class="keyword">if</span> (total + choices[i] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新元素和 total</span></span><br><span class="line">        state.add(choices[i]);</span><br><span class="line">        <span class="comment">// 进行下一轮选择</span></span><br><span class="line">        backtrack(state, target, total + choices[i], choices, res);</span><br><span class="line">        <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">        state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解子集和 I（包含重复子集） */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumINaive</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 状态（子集）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子集和</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 结果列表（子集列表）</span></span><br><span class="line">    backtrack(state, target, total, nums, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样的问题是，其在进行选取的时候，会造成重复，解决办法是先排序</p><ul><li>在开启搜索前，先将数组 <code>nums</code> 排序。在遍历所有选择时，<strong>当子集和超过 <code>target</code> 时直接结束循环</strong>，因为后边的元素更大，其子集和一定超过 <code>target</code> 。</li><li>省去元素和变量 <code>total</code> ，<strong>通过在 <code>target</code> 上执行减法来统计元素和</strong>，当 <code>target</code> 等于 0 时记录解。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：子集和 I */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span> target, <span class="type">int</span>[] choices, <span class="type">int</span> start, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="comment">// 剪枝二：从 start 开始遍历，避免生成重复子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; choices.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝一：若子集和超过 target ，则直接结束循环</span></span><br><span class="line">        <span class="comment">// 这是因为数组已排序，后边元素更大，子集和一定超过 target</span></span><br><span class="line">        <span class="keyword">if</span> (target - choices[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新 target, start</span></span><br><span class="line">        state.add(choices[i]);</span><br><span class="line">        <span class="comment">// 进行下一轮选择</span></span><br><span class="line">        backtrack(state, target - choices[i], choices, i, res);</span><br><span class="line">        <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">        state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解子集和 I */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumI</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 状态（子集）</span></span><br><span class="line">    Arrays.sort(nums); <span class="comment">// 对 nums 进行排序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 遍历起始点</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 结果列表（子集列表）</span></span><br><span class="line">    backtrack(state, target, nums, start, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="N皇后问题（经典）"><a href="#N皇后问题（经典）" class="headerlink" title="N皇后问题（经典）"></a>N皇后问题（经典）</h4><p><a href="https://www.hello-algo.com/chapter_backtracking/n_queens_problem/#3">13.4  N 皇后问题 - Hello 算法 (hello-algo.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：n 皇后 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> n, List&lt;List&lt;String&gt;&gt; state, List&lt;List&lt;List&lt;String&gt;&gt;&gt; res,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span>[] cols, <span class="type">boolean</span>[] diags1, <span class="type">boolean</span>[] diags2)</span> &#123;</span><br><span class="line">    <span class="comment">// 当放置完所有行时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; copyState = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; sRow : state) &#123;</span><br><span class="line">            copyState.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(sRow));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(copyState);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">// 计算该格子对应的主对角线和次对角线</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">diag1</span> <span class="operator">=</span> row - col + n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diag2</span> <span class="operator">=</span> row + col;</span><br><span class="line">        <span class="comment">// 剪枝：不允许该格子所在列、主对角线、次对角线上存在皇后</span></span><br><span class="line">        <span class="keyword">if</span> (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) &#123;</span><br><span class="line">            <span class="comment">// 尝试：将皇后放置在该格子</span></span><br><span class="line">            state.get(row).set(col, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 放置下一行</span></span><br><span class="line">            backtrack(row + <span class="number">1</span>, n, state, res, cols, diags1, diags2);</span><br><span class="line">            <span class="comment">// 回退：将该格子恢复为空位</span></span><br><span class="line">            state.get(row).set(col, <span class="string">&quot;#&quot;</span>);</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解 n 皇后 */</span></span><br><span class="line">List&lt;List&lt;List&lt;String&gt;&gt;&gt; <span class="title function_">nQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化 n*n 大小的棋盘，其中 &#x27;Q&#x27; 代表皇后，&#x27;#&#x27; 代表空位</span></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        List&lt;String&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            row.add(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        state.add(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span>[] cols = <span class="keyword">new</span> <span class="title class_">boolean</span>[n]; <span class="comment">// 记录列是否有皇后</span></span><br><span class="line">    <span class="type">boolean</span>[] diags1 = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>]; <span class="comment">// 记录主对角线上是否有皇后</span></span><br><span class="line">    <span class="type">boolean</span>[] diags2 = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>]; <span class="comment">// 记录次对角线上是否有皇后</span></span><br><span class="line">    List&lt;List&lt;List&lt;String&gt;&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    backtrack(<span class="number">0</span>, n, state, res, cols, diags1, diags2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记忆化搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] mem)</span> &#123;</span><br><span class="line">    <span class="comment">// 已知 dp[1] 和 dp[2] ，返回之</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || i == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">// 若存在记录 dp[i] ，则直接返回之</span></span><br><span class="line">    <span class="keyword">if</span> (mem[i] != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> mem[i];</span><br><span class="line">    <span class="comment">// dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> dfs(i - <span class="number">1</span>, mem) + dfs(i - <span class="number">2</span>, mem);</span><br><span class="line">    <span class="comment">// 记录 dp[i]</span></span><br><span class="line">    mem[i] = count;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 爬楼梯：记忆化搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">climbingStairsDFSMem</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// mem[i] 记录爬到第 i 阶的方案总数，-1 代表无记录</span></span><br><span class="line">    <span class="type">int</span>[] mem = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(mem, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dfs(n, mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>暴力搜索 O(2^n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：暴力搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">knapsackDFS</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> i, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 若已选完所有物品或背包无剩余容量，则返回价值 0</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若超过背包容量，则只能选择不放入背包</span></span><br><span class="line">    <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">        <span class="keyword">return</span> knapsackDFS(wgt, val, i - <span class="number">1</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算不放入和放入物品 i 的最大价值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> knapsackDFS(wgt, val, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yes</span> <span class="operator">=</span> knapsackDFS(wgt, val, i - <span class="number">1</span>, c - wgt[i - <span class="number">1</span>]) + val[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 返回两种方案中价值更大的那一个</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(no, yes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间优化加动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：空间优化后的动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">knapsackDPComp</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cap + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 倒序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> cap; c &gt;= <span class="number">1</span>; c--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &lt;= c) &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[c] = Math.max(dp[c], dp[c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><p>空间优化加动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 完全背包：空间优化后的动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unboundedKnapsackDPComp</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cap + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">                <span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">                dp[c] = dp[c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[c] = Math.max(dp[c], dp[c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="零钱兑换问题2"><a href="#零钱兑换问题2" class="headerlink" title="零钱兑换问题2"></a>零钱兑换问题2</h4><p>凑硬币</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换 II：动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">coinChangeIIDP</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][amt + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) &#123;</span><br><span class="line">                <span class="comment">// 若超过目标金额，则不选硬币 i</span></span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选硬币 i 这两种方案之和</span></span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a] + dp[i][a - coins[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加空间优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换 II：空间优化后的动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">coinChangeIIDPComp</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amt + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) &#123;</span><br><span class="line">                <span class="comment">// 若超过目标金额，则不选硬币 i</span></span><br><span class="line">                dp[a] = dp[a];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选硬币 i 这两种方案之和</span></span><br><span class="line">                dp[a] = dp[a] + dp[a - coins[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h4><p><a href="https://www.hello-algo.com/chapter_dynamic_programming/edit_distance_problem/#1">14.6  编辑距离问题 - Hello 算法 (hello-algo.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> datastructure.dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Levenshtein</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">distance</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> a.length();</span><br><span class="line">         <span class="type">int</span> <span class="variable">length2</span> <span class="operator">=</span> b.length();</span><br><span class="line">         <span class="type">int</span> dp[][] = <span class="keyword">new</span> <span class="title class_">int</span>[length1+<span class="number">1</span>][length2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=length1;i++)&#123;</span><br><span class="line">             dp[i][<span class="number">0</span>]=i;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=length2;j++)&#123;</span><br><span class="line">             dp[<span class="number">0</span>][j]=j;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ;i&lt;=length1;i++)&#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=length2;j++)&#123;</span><br><span class="line">                 <span class="keyword">if</span> (a.charAt(i-<span class="number">1</span>)==b.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;kitten&quot;</span>;</span><br><span class="line">          <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;sitting&quot;</span>;</span><br><span class="line">          <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> distance(s1,s2);</span><br><span class="line">          System.out.println(ans);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>一般情况下，贪心算法的适用情况分以下两种。</p><ol><li><strong>可以保证找到最优解</strong>：贪心算法在这种情况下往往是最优选择，因为它往往比回溯、动态规划更高效。</li><li><strong>可以找到近似最优解</strong>：贪心算法在这种情况下也是可用的。对于很多复杂问题来说，寻找全局最优解非常困难，能以较高效率找到次优解也是非常不错的。</li></ol><p>贪心问题的解决流程大体可分为以下三步。</p><ol><li><strong>问题分析</strong>：梳理与理解问题特性，包括状态定义、优化目标和约束条件等。这一步在回溯和动态规划中都有涉及。</li><li><strong>确定贪心策略</strong>：确定如何在每一步中做出贪心选择。这个策略能够在每一步减小问题的规模，并最终解决整个问题。</li><li><strong>正确性证明</strong>：通常需要证明问题具有贪心选择性质和最优子结构。这个步骤可能需要用到数学证明，例如归纳法或反证法等。</li></ol><h4 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumGas</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumCost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sumCost += cost[i];</span><br><span class="line">            sumGas += gas[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sumCost &gt; sumGas)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hasPassed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; hasPassed &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == n)</span><br><span class="line">                    j = <span class="number">0</span>;</span><br><span class="line">                rest += gas[j];</span><br><span class="line">                <span class="keyword">if</span> (rest &gt;= cost[j]) &#123;</span><br><span class="line">                    rest -= cost[j];</span><br><span class="line">                    hasPassed++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasPassed == n)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCP-03-机器人大冒险"><a href="#LCP-03-机器人大冒险" class="headerlink" title="LCP 03. 机器人大冒险"></a><a href="https://leetcode.cn/problems/programmable-robot/">LCP 03. 机器人大冒险</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">robot</span><span class="params">(String cmd, <span class="type">int</span>[][] obstacles, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cmd.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sx</span> <span class="operator">=</span> <span class="number">0</span>, sy = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录走完一轮后机器人的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cmd.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;U&#x27;</span>) ++ sy;</span><br><span class="line">            <span class="keyword">else</span> ++ sx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先计算能否到达终点 不考虑障碍物</span></span><br><span class="line">        <span class="comment">// 若不能直接返回false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">canFinish</span> <span class="operator">=</span> canReach(cmd, x, y, sx, sy);</span><br><span class="line">        <span class="keyword">if</span> (!canFinish) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 判断在终点前会不会遇到障碍物 </span></span><br><span class="line">        <span class="comment">// 若遇到则返回false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] o : obstacles) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o[<span class="number">0</span>] &gt; x || o[<span class="number">1</span>] &gt; y)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (canReach(cmd, o[<span class="number">0</span>], o[<span class="number">1</span>], sx, sy)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断能否从坐标(x, y)到达(tx, ty)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canReach</span><span class="params">(String cmd, <span class="type">int</span> tx, <span class="type">int</span> ty, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// round记录走到目标点至少要走多少轮</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">round</span> <span class="operator">=</span> Math.min(tx/x, ty/y);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> round*x, ny = round*y;</span><br><span class="line">        <span class="keyword">if</span> (nx == tx &amp;&amp; ny == ty) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cmd.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cmd.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;U&#x27;</span>) ++ ny;</span><br><span class="line">            <span class="keyword">else</span> ++ nx;</span><br><span class="line">            <span class="keyword">if</span> (nx &gt; tx || ny &gt; ty) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (nx == tx &amp;&amp; ny == ty) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研经验贴</title>
      <link href="/2024/06/24/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
      <url>/2024/06/24/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="保研经验贴"><a href="#保研经验贴" class="headerlink" title="保研经验贴"></a>保研经验贴</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天被两三个25届的同学问到保研的事 尘封许久的记忆再次打开 再次汇总了之前收到的所有信息和仅存的记忆 给一点模板上的参考<br>注:是疫情解封后第一次线下 故之前很多经验贴没有参考性</p><p>bg: 985本SE</p><p>rank: 3&#x2F;181 3.99&#x2F;4.00</p><p>论文: 无</p><p>竞赛: 双国三 双省一 一省三 n校奖</p><p>奖学金: 两年国奖</p><p>方向: 分布式系统&#x2F;存储 偏架构和系统设计方向</p><p>实习: 某自驾公司地图存储系统&#x2F;字节抖音电商开发岗</p><p>由于夏令营已经上岸 故没有参加后续预推免</p><p>入营:</p><p>夏令营:</p><p>①北大计算机 直博（放弃且意愿不强 真不想读博）</p><p>②北大软微 硕士（计算机学院组➕老师 最终去向）</p><p>③中国科学院计算所 硕士</p><p>④上海交通大学电院 硕士</p><p>⑤南京大学计算机学院 硕士</p><p>⑥北京航空航天大学计算机学院 硕士（放弃）</p><p>⑦中国人民大学信院 硕士</p><p>⑧西安交通大学计算机学院 硕士</p><p>被拒:</p><p>①复旦大学计算机学院（只要第一我也没办法）</p><p>参加:</p><p>由于在实习真抽不开时间去其他地方参营</p><p>①北大软微</p><p>②北航计算机</p><p>③南大计算机（参加了部分 获得软件所的通过了但后面不是很想去参加了…跟北大有冲突也是个重要原因）<br>优营</p><p>①北大软微</p><p>②北航计算机</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>数学方面:</p><p>①概率论②线性代数③微积分④离散数学</p><p>这部分需要从头到尾过一遍 相关概念、联系一定要熟，各部分重点其实网上总结🉐十分详细了 一定好好准备！</p><p>英语方面:</p><p>①各种日常口语➕部分计算机相关专业的词汇 不需要特别详细 但我建议提早一个月进入状态</p><p>专业知识:</p><p>①数据结构②计算机网络③操作系统④计组⑤编译原理⑥机试！！！（别说其他语言了 现在学c++还来得及 STL弄熟➕王道机试指南➕力扣➕到处搜集真题 爆！！！）</p><p>四五很少考 南大计算机的笔试特别喜欢考编译原理——题简直又多又长又难 数据结构重中之重 机试一定好好准备！！！</p><h2 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h2><p>南大计算机（流程繁琐）</p><p>①最开始我记得是软件所有个面试，线上的，会问一些离散数学（平面图 哈密顿图等等）和一些数据结构的题 差不多十五分钟（这一部分是提前了差不多两个月进行的）</p><p>②后续在临近夏令营的时候还有一轮线上笔试 巨难（如果没学过编译原理就寄了）</p><p>③后续就是去线下啦 但遗憾没去看看美丽的仙林校区😭</p><p>北航计算机（特色大模拟➕不报销车费路费 甚至不包吃）</p><p>①第一天就是两道机试 总共两小时 第一道大模拟真的搞的头大（好在还是写对了） 第二道真是完全一点不会（不是常规的算法题） 这一轮🉐至少做对一个才能进入下一轮</p><p>②第二天面试 数学➕英语➕各种专业问题 甚至还问了我前端➕后端➕java和c++ python语言特性使用场景（好在哥们也是实习面试了几十轮还是信手拈来的）</p><p>老师全程压力面，不能怂！</p><p>然后优营发的很快，我记得是7月2号就发了，也是我第一个优营</p><p>北大软微</p><p>软微从22年开始比较特殊，首先据说要退学费，其次夏令营的师资和实验室可以是计算机学院&#x2F;智能学院的，加上还是硕士简直不要太香好吧</p><p>①第一天闲聊吹水 我就记得紫燕百味鸡外卖还挺好吃</p><p>②先来三道算法题！（30min 我们组跟系统方向强相关三道分别是mid mid hard难度的 可以写伪代码）其实我第三道有点问题但由于太自信甚至后续面试当场给出来数学证明让老师也疑惑住了</p><p>③面试: 自我介绍➕各种问题的提问 甚至问到我一些关于实习用到的juiceFS和一些底层的概念&#x2F;分布式共识&#x2F;运维&#x2F;缓存等，还问到代码量（必然是多多），以及数学上面的证明➕算法题复盘➕一些其他的问题，其实都还好，虽然没全准备过但意外达的非常好（最终拟录取看复试分数排名竟然差不多前1％）</p><p>优营隔了几天就发了 </p><h2 id="一些被问到的问题"><a href="#一些被问到的问题" class="headerlink" title="一些被问到的问题"></a>一些被问到的问题</h2><ol><li><p>论文是必须的吗？</p><p>有最好，如果搞ai必须有相关实习&#x2F;科研经历，如果走system路线有实习或者经历都行</p></li><li><p>四六级真的重要吗？</p><p>我觉得一般重要 不要太低就行</p></li><li><p>给计算机专业课重要程度排个序</p><p>数据结构＞计算机网络&#x3D;操作系统＞计组＞编译原理</p></li><li><p>事先套磁了吗？</p><p>五月份套了一个，但强com。我建议现在3月份就可以开始套了，越早越好！</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 经验贴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研夏令营他人经验总结</title>
      <link href="/2024/06/24/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%BA%90/"/>
      <url>/2024/06/24/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="保研夏令营"><a href="#保研夏令营" class="headerlink" title="保研夏令营"></a><strong>保研夏令营</strong></h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h2><ul><li>CSP，最好300+？（<strong>对于北航有效</strong>）</li><li>报名一般5月开始，联系老师建议4月</li></ul><h2 id="入营"><a href="#入营" class="headerlink" title="入营"></a><strong>入营</strong></h2><ul><li>主要看<strong>成绩</strong>，<strong>高质量科研</strong>成果加分，实习经历、获奖<strong>无用</strong>，入营后成绩影响不大（rank1可加<strong>印象分</strong>）——郑博文</li><li>清北上交学硕rank1都不一定进得去</li><li>都留给本校学生了</li><li>复旦卡rank1</li><li>南大比较海rank5&#x2F;6好像就行</li><li>中科大有点歧视非计科出身，软院入营看运气</li><li>自动化所要rank1&#x2F;2</li><li>计算所联系老师</li><li>清深热门专业也比较难入</li><li>其他方向还好</li><li>北大整个都是联系老师流的</li><li>浙大夏令营没有学硕，就不说了</li><li>清华也没学硕，直博也不给offer</li><li>人大高瓴要rank1&#x2F;2        ——郑博文</li></ul><h2 id="机试"><a href="#机试" class="headerlink" title="机试"></a><strong>机试</strong></h2><ul><li>非常不推荐力扣（不需要自己设计数据结构、不需要自己处理输入输出），不推荐其他语言</li><li>语言：<strong>C++</strong>        平台：<strong>洛谷、AcWing</strong>        ——郑博文</li><li>狠抓，因为很多学校都因为这个初筛，人工智能机试卷中卷，尽量现在就连起来  leetcode（主要看思想） pat要相对难一点，重点！！！要看输入输出；在保研成绩稳的情况下，准备机试（我摔了很多次的地方一定要在强调很多遍） 数据结构——刘欣宇</li><li>计算所机试vipl实验室如果用c++的话  不能调用stl库  考的也就是用c实现了  其他的都是可以调用库的——刘欣宇</li><li>有一本王道机试指南  你可以找找电子版  里面题很经典 前面的比较简单  尽量早点过  后面图论也比较容易考，算法里面很爱考贪心  动态规划，你也可以看看时间函数  我遇到过两次机试  是考时间的  题目大概是  上班打卡，下班也要打卡，打卡方式有很多种，但是都是同一个人的，这个人会进出公司，看谁累计上班时间长 ——刘欣宇</li></ul><h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a><strong>笔试</strong></h2><ul><li>看是计算机学院还是ai学院，数据结构比较重视，其他三门专业课主要看知识点，数据结构刷了一本王道        ——郑博文</li><li>大多数学校没有笔试，南大、计算所有，南大难，考底层，计算所  有单独的数学考试（他还考了少量的微积分  极少极少）——刘欣宇</li></ul><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><ul><li>408和数学也要复习 面试会问你，408里面 数据结构》计网》操作系统  计组</li><li>先看数据结构  数学（线代很爱问正定矩阵  概率论很爱问大数定律和中心极限定理） 然后在看计网 os ，计组基本上没问——刘欣宇</li></ul><h2 id="科研"><a href="#科研" class="headerlink" title="科研"></a><strong>科研</strong></h2><ul><li>最好找个<strong>外校</strong>的实验室，<strong>计院</strong>的也行，本校实验室不算实习，但可以让老师帮挂公司</li><li>一定要<strong>高质量</strong>科研成果        ——郑博文</li></ul><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><ul><li>突然想起来  心态也很重要  有可能夏令营啥也没拿到  或者只有一个  但是别慌 预推免还有  预推免先都报上  如只要能面试  就有很大概率候补到  不要全都选很好的专业  很容易落得一场空  坚信  只要我面试了 肯定会有候补到的时候；今年浙软  南大计算机  北航计算机 国防科大都快被鸽穿了 ——刘欣宇</li></ul><h2 id="一些文章链接"><a href="#一些文章链接" class="headerlink" title="一些文章链接"></a>一些文章链接</h2><p><a href="https://blog.csdn.net/mengwuyaaa/article/details/82918032?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-82918032-blog-125315403.pc_relevant_vip_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-82918032-blog-125315403.pc_relevant_vip_default&utm_relevant_index=2">https://blog.csdn.net/mengwuyaaa/article/details/82918032?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-82918032-blog-125315403.pc_relevant_vip_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-82918032-blog-125315403.pc_relevant_vip_default&amp;utm_relevant_index=2</a></p><h1 id="经验贴的一些阅读"><a href="#经验贴的一些阅读" class="headerlink" title="经验贴的一些阅读"></a>经验贴的一些阅读</h1><h2 id="人品"><a href="#人品" class="headerlink" title="人品"></a>人品</h2><p>导师人品最重要，千万不要去坑导直博，即使是清北的。</p><p>可以先去导师评价网找找，目前可用的有 <a href="https://link.zhihu.com/?target=https://www.yankong.org/">研控</a> 、<a href="https://link.zhihu.com/?target=https://www.daoshipingjia.xyz/">硕博导师评价网</a>，另外我这里还有导师评价网后台数据库 excel（包含全国各大院校 1 万条导师评价信息），以及上交电院导师评价，不方便发，需要的话可以私戳。</p><p>然后就是在百度、谷歌上搜，还可以去问组内 &#x2F; 隔壁组学长学姐。如何联系学长学姐？<strong>一种方法是找本校保研到该校或在绿群找到保研到该校的学长学姐，请他介绍介绍；另一种方法是通过导师的论文，推测出学长学姐的名字，然后在论文网站里找邮箱发邮件问。注意要兼听则明</strong></p><h2 id="专业课怎么复习"><a href="#专业课怎么复习" class="headerlink" title="专业课怎么复习"></a>专业课怎么复习</h2><p>如果时间不是很充裕，不要全面撒网，每门课要复习的也就一二十个常见问题，找找保研 &#x2F; 考研面试重点问题来看看就行。</p><p>要复习的课有：</p><ul><li>数学：线性代数、概率论、高数</li><li>计算机：数据结构、计组、操作系统、计网、算法、数据库、软件工程、编译原理、编程语言</li><li>人工智能：机器学习、深度学习</li></ul><p>注意这些课不必完全复习，挑几门和研究方向相关的看看重点就行，比如对于 AI 方向，最重要的是数学、数据结构、人工智能。</p><h2 id="没有科研经历咋办"><a href="#没有科研经历咋办" class="headerlink" title="没有科研经历咋办"></a>没有科研经历咋办</h2><p>和老师方向一致的科研经历非常重要，即使没有产出论文，也是巨大的加分项，这就像去找工作，实习经历是巨大的加分项一样。</p><p>如果你现在是大三下学期开学之前的话，可以去联系本校老师进实验室做科研。如果已经很晚了，如六月份了，可以去找一些论文，复现或者读懂代码，掌握好细节，包装成一个项目，耗时半个月左右，前提是不能被问穿，得答得上来。</p><p>一段科研经历，老师更关注你做了什么，而不是这个科研做的结果。要讲好一个项目，需要讲好 motivation（为什么做）、method（做了什么）、result（做得咋样）、contribution（你做了啥），其中最重要的是 contribution 和 motivation。不要说得太直白，尽量学术化一点。（可以参考顶会论文的 Introduction，看看怎样讲好一个故事）。老师也非常喜欢问你的科研项目里面用到的东西的底层原理，而这些东西你可能就是在 PyTorch 里面调了个库，需要注意一下。</p><p>如果有论文，论文的内容、细节一定要清楚，还有 EI 会议之类的水文不建议写在简历，如果被问穿了，可能是减分项</p><h2 id="要准备哪些文书"><a href="#要准备哪些文书" class="headerlink" title="要准备哪些文书"></a>要准备哪些文书</h2><p>文书材料的模板后续我会整理发出来。</p><ul><li>简历：推荐 <a href="https://link.zhihu.com/?target=https://www.wondercv.com/">超级简历WonderCV</a> ，内容写保研要素中比较重要的就行，包括：联系方式、学校、专业、成绩、排名、获奖、项目、数学、编程、英语、读博意向等，自己的劣势部分不要往上面写。</li><li>个人陈述：准备 1000 字、2000 字的，就是简历的扩充，重点是讲做过的项目，研究规划等。</li><li>推荐信：准备 2 封教授推荐信即可，这东西没人看，注意复旦、北航等学校需正教授推荐信，清华、复旦等学校要求老师本人在线填写或用本人的邮箱发送推荐信。</li><li>套磁信：既要简洁了当，直言主题，又不能不客套。edu邮箱比较正式，gmail有邮件追踪插件mailtrack。</li><li>PPT：相当于把简历讲出来，大部分的篇幅应该讲项目，和学习无关的不要讲太多。</li><li>各种证明材料：成绩单、排名证明、获奖证书、身份证、学生证、英语证明，都扫描成pdf。</li></ul><h2 id="一些有用的网站"><a href="#一些有用的网站" class="headerlink" title="一些有用的网站"></a>一些有用的网站</h2><ul><li>邮件追踪：Gmail 有个插件 mailtrack，可以看到你发的邮件什么时候被老师打开了，打开了几次。</li><li>查老师学术水平：<a href="https://link.zhihu.com/?target=https://scholar.google.com/">Google Scholar</a>、<a href="https://link.zhihu.com/?target=https://dblp.org/">dblp</a>、<a href="https://link.zhihu.com/?target=https://www.aminer.cn/">AMiner</a>、<a href="https://link.zhihu.com/?target=https://csrankings.org/%23/index?all&cn">CSRankings</a>、<a href="https://link.zhihu.com/?target=https://www.semanticscholar.org/">Semantic Scholar</a></li><li>查国家自然科学基金：<a href="https://link.zhihu.com/?target=https://www.ceshigo.com/Nsfc/fund">测试狗基金查询</a>、<a href="https://link.zhihu.com/?target=https://grants.nsfc.gov.cn/egrantindex/funcindex/prjsearch-list">基金委查询系统</a></li><li>导师评价网：<a href="https://link.zhihu.com/?target=https://www.yankong.org/">研控</a> 、<a href="https://link.zhihu.com/?target=https://www.daoshipingjia.xyz/">硕博导师评价网</a></li><li>机试刷题平台：<a href="https://link.zhihu.com/?target=https://www.acwing.com/">AcWing</a></li><li>夏令营 &#x2F; 预推免开营信息：<a href="https://link.zhihu.com/?target=http://pc.baoyanwang.com.cn/">保研信息网</a></li><li>中科院计算所各实验室介绍：<a href="https://link.zhihu.com/?target=http://cskaoyan.com/thread-237791-1-2.html">中科院计算所实验室情况简要介绍-王道论坛</a></li></ul><h1 id="清北华五院系分析"><a href="#清北华五院系分析" class="headerlink" title="清北华五院系分析"></a>清北华五院系分析</h1><h2 id="1-清华大学"><a href="#1-清华大学" class="headerlink" title="1 清华大学"></a>1 清华大学</h2><p>清华的 offer 基本在预推免发，夏令营发 offer 的只有叉院、深研院。除了软件、深研院外，外校基本只能拿直博。夏令营各院系自己组织，可以报多个，但有些院系没有夏令营。预推免是学校系统上报，最多报两个。</p><ul><li>计算机系（贵系）：国内计算机 top1，需要尽早联系导师。开夏令营，但不发 offer，通过机试的，预推免免试。机试很难，3 道编程题，难度和 CSP 第 3-4 题差不多。</li><li>自动化系（雷系）：有做 AI 的老师，注意自动化系的硕士分三种，学硕、大数据工程（要去贵州）、校企联培（要去企业）。</li><li>叉院：国内 bar 最高的学院，至少要 985 rk1 + 在投顶会 &#x2F; ACM，6 月初就开营。</li><li>软件学院：没有夏令营，基本上是专硕，强com，主要看机试成绩，机试难度中等。</li><li>网研院：相当于贵系网安专业，难度比贵系低。</li><li>深研院：有计算机技术、人工智能、大数据、TBSI 四个方向，TBSI 是学硕，其他都是专硕，计算机技术机试很难，人工智能最卷，TBSI 要求六级 500+。</li><li>高等研究院：有 msra 校企联培博士，导师郭百宁，但是好像没啥人知道，可以早点联系捡漏。</li></ul><h2 id="2-北京大学"><a href="#2-北京大学" class="headerlink" title="2 北京大学"></a>2 北京大学</h2><p>北大的 offer 大多是夏令营发出去，预推免相当于补录了，可以报多个院系。</p><ul><li><p>计算机学院：超弱 com，完全取决于老师要不要你，夏令营无机试，面试走过场，需要尽早联系导师，去进组实习，bar 比贵系低，985 前 5% 就可以试试。夏令营之后，软件所一般鸽的比较多，还有外校基本只能拿直博。</p></li><li><p>智能学院：原信科智能所，和计算机学院的情况差不多。</p></li><li><p>软微：基本全是专硕，纯就业向，强com，入营主要看排名，不过据说从今年开始，也要做科研了。</p></li><li><p>深研院：基本全是学硕，弱com，不过坑导较多。</p></li><li><p>软微：</p><ul><li><p>不得不说北京真的是大城市，这是我第一次来北京，真的感受到了首都的魅力。</p><p>   复试分为两个部分：手撕算法题 + 面试</p><pre><code>  手撕算法题部分，当天面试的所有人都在一起写题，一共有三道题，选其中一道题手撕代码就可以了，难度大概是 easy 到 medium 之间吧，手撕快排也有，大模拟也有。  面试部分，首先你要给每位老师发你的简历，老师看到我是湖大的，就要我英文描述一下湖大的风景，其实我早有准备，当时背的是介绍长沙，我就活用了。然后老师让我抽一道基础题，我抽到了数据库系统，其实很不巧我就数据库没怎么复习，但是还是凭自己的记忆说了一通，然后老师还问了数据库系统和数据库管理系统的区别，我记得他说的是 DBS 和 DBMS 的区别，当时我秒懂，DBMS 我会啊，所以我又说了一通。  接着老师会拿出刚刚手撕的算法题问你觉得怎么样，写得对不对，你要尽可能展现出你的算法功底就好了，比方说一个很简单的求平方和，没有给你数据范围时，其实是一个大数乘法 + 大数加法。然后老师开始问我项目了，大概问了我的代码量和实现难点。</code></pre></li><li></li></ul></li></ul><h2 id="3-中科院"><a href="#3-中科院" class="headerlink" title="3 中科院"></a>3 中科院</h2><p>中科院各所差别极大，所内各组也差别极大，所谓“强组清北，弱组211”。中科院的师生比很高，一般硕导一年 0-1 个硕士名额，博导一年1硕1博，中科院可以报任意多个所（多准备几个邮箱多注册几个号就行）。计算机相关的研究所有：</p><p>表格 还在加载中，请等待加载完成后再尝试复制</p><p>各所基本是夏令营就招完学生，预推免相当于补录，另外，国科大计算机学院、人工智能学院也招生（比两所容易一些），导师基本是两所的。最后再说一下，虽然两所的实力要略强于华五，如果你以后从事专业相关的事情（如：学术届、企业技术岗），可以来两所；但如果以后从事非专业相关的事情（如：考公），更建议去华五。</p><ul><li>计算所：体系结构方向亚洲第一，AI 方向实力也很强，超弱com，你甚至没入营都可以拿 offer，有霸面机制，即如果你没有入营，老师也可以邀请你来面试，和入营的没区别。计算所是分组来考核的，所里不管，牛组竞争非常激烈（如寒武纪、龙芯、vipl等）。体系结构和 AI 的大牛很多，就不细说了。还有要注意很多组要求博士延毕一年。</li><li>自动化所：体量很大，光模式识别国重就 100 多位老师，AI 方向特别 CV 很强，模式识别国重有很多 AI 大牛。强 com，bar 985 前 5，以“未来的邀约”闻名于保研圈。</li><li>软件所：有计算机科学国重（软件与理论方向），另外中文信息实验室的孙l、韩xp老师也比较强（NLP 方向）。</li><li>信工所：有网安国重，有个 CV 组也很强（操xc组），不过，操老师去年跳槽到中山当院长了。</li><li>神仙院：深圳先进技术研究院，下面的数字所有个 MM Lab 很强，和港中大那个 MM Lab 、商汤、上海浦江实验室关系密切，负责人是乔y老师（3万引），另外组里董c老师也是大牛。</li></ul><h2 id="4-上海交通大学"><a href="#4-上海交通大学" class="headerlink" title="4 上海交通大学"></a>4 上海交通大学</h2><p>招生主要在夏令营，预推免招的少。注意上交电院博士毕业是出了名的难，据说基本 6 年起步。密西根是单独报名，其他院系在学校系统上报名，只能报一个。</p><ul><li>计算机系、网安：上交计算机系像贵系那样，各方向都有，都比较强。硕士非常难，2021 年非华五只录了 4 个，有机试。直博入营容易，没有机试，关键是要找到导师接收（直博没有导师接收，拿了优营也没用）。上交牛导很多，AI 方向有几个年轻老师特别火，如卢cw、张wn、张qs、严jc 等。</li><li>软件学院：国内最强的软件学院，以 ipads实验室（分布式系统方向）闻名，机试听说是开发软件，比较硬核。</li><li>网安学院：比计算机系要容易。</li><li>密西根学院：想去上交，密西根最容易，不过学费贵，导师一般。</li></ul><h2 id="5-浙江大学"><a href="#5-浙江大学" class="headerlink" title="5 浙江大学"></a>5 浙江大学</h2><p>浙大的计算机图形学国内第一，计算机学院体量也非常大。浙大只能报一个学院。</p><ul><li>计算机学院：夏令营只有直博，要去做一个多月的项目，内容由报名老师指定，8月下旬，每个博导可以推荐 1 名学生（院士 2 名），进入学院答辩环节（走过场）。浙大大量名额（含所有硕士名额）在预推免，不过要跟浙大本校竞争。CAD&amp;CG 国重里面有很多 CG、CV 大牛。</li><li>软件学院：在宁波，纯就业向，夏令营入营点击就送，千人海王营，考核要做项目，优营容易拿，但没什么用，还是要参加预推免，预推免有机试。</li><li>工程师学院：夏令营、预推免都有，比计算机学院容易。</li><li>国际联合学院：在嘉兴市海宁市（县级市），不太了解，招计算机专业的学生。</li></ul><h2 id="6-复旦大学"><a href="#6-复旦大学" class="headerlink" title="6 复旦大学"></a>6 复旦大学</h2><p>复旦的计算机是 B+，但是人工智能方向很强，学校 title 好，魔都位置好。复旦只能报一个学院。</p><ul><li>计算机学院：发放 offer 夏令营：预推免 &#x3D; 1 : 2，夏令营的 bar 巨高，985 一个专业只能入一个。有机试但不算分。NLP 组（黄邱张）很强，CV 方向姜yg组、薛xy组也比较强。</li><li>大数据学院：发统计学或金融学位证，难度不比计算机学院低，对数学要求高。</li><li>工研院：难度比计算机学院低。</li><li>类脑智能研究院：有部分老师做 AI 和生物交叉。</li></ul><h2 id="7-南京大学"><a href="#7-南京大学" class="headerlink" title="7 南京大学"></a>7 南京大学</h2><p>南大三个学院都可以报，但只能入一个，海王营，入营后有线上笔试，考408等专业课，没有机试，南大是超强 com。</p><ul><li>计算机系：软件所非常强，软件所在学院夏令营前有自己办的夏令营，另外 MCG 组的王lm老师是南大 CV 最强的老师，NLP 组黄sj老师也比较强。</li><li>人工智能学院：lamda（周zh组）非常强，主要是做机器学习、数据挖掘的， lamda 在学院夏令营前也有自己办的夏令营，lamda 一共两轮面试，第一轮学长面，第二轮报考老师面。注意拿了 lamda offer 后，还需要人工智能学院优营才能录取，南大的 com 非常强。</li><li>软件学院：比 CS、AI 容易一些，纯就业型。</li></ul><h2 id="8-中国科学技术大学"><a href="#8-中国科学技术大学" class="headerlink" title="8 中国科学技术大学"></a>8 中国科学技术大学</h2><p>中科大没有直博，全是硕士，系统里可以报三个志愿，只能入一个，基本上只有一志愿有用，中科大是弱 com。还有入营中科大后会收到入营大礼包！！！</p><ul><li>计算机学院：入营歧视软件专业，我校计算机前5%可入，软件只能入1%，没有预推免。AI方向做数据挖掘的多，几乎没有做CV的（都在自动化系、电子系）。BDAA（陈eh组）很强，陈eh老师是杰青，组里还有刘q、连df两位优青，人好学术好。网络方向李xy（ACM &#x2F; IEEE fellow）组很牛，组里张yy老师也是IEEE fellow，做智能感知的。另外计算机学院还有网红教授张l（逃）</li><li>自动化系（10系）：自动化系和电子系虽然同属信息学院，但招生是分开的，必须导师推荐才能入营，预推免有少量名额。CV 方向的张tz，查zj老师很强，都是优青+万引。</li><li>电子系（6系）：虽然叫电子系，其实很多老师是做人工智能的，大牛很多。何xn组（巨牛，30岁，2.2万引）非常强，何老师组里两位小老板也很强，王x（7k引）、冯fl（4k引），都是30岁出头。电子系AI方向还有吴f（院士候选人）、李hq、张yd等杰青，周wg、刘d、谢ht、王j等优青，实力非常强。</li><li>大数据学院：就是计算机、自动化、电子的老师，一般科大本校喜欢拿大数据学院名额，所以外校入营难，没有预推免。</li><li>网安学院：何xn的两个小老板都挂在网安学院，这里甚至还能找到潘建伟。</li><li>软件学院：一共就几个保研招生名额，主要招考研。</li><li>苏州研究院：比本部简单一些，值得一提的是，中科院计算所奇迹组的周sh老师（IEEE fellow，万引，医学影像大牛）全职来中科大，在这里招生物医学工程专业的学生（医学 CV 方向）。</li><li>先研院：比本部简单一些。</li><li>科学岛：中科院合肥物质研究院，发中科大毕业证，入营点击就送，最容易上岸华五的地方。</li></ul><h2 id="9-中国人民大学"><a href="#9-中国人民大学" class="headerlink" title="9 中国人民大学"></a>9 中国人民大学</h2><p>人大在中关村，位置好，学术强的老师大多在高瓴，强 com。人大信息和高瓴可以都报，也可以都入营，</p><ul><li>信息学院（王老吉）：夏令营 4 月 20 号左右就开放报名了，然后愣是 6 月 29 才发入营名单，官网通告栏一直是王老吉奖学金获奖公示，绿群群友们天天去刷学院官网都等不到入营名单，故称为王老吉学院。王老吉招生人数少，之前入营也少，bar 很高（学硕卡 985 rk2 左右），但今年是海王营了。王老吉数据库方向比较强，无预推免。</li><li>高瓴人工智能学院（加多宝）：王老吉的 hxd 当然是加多宝了。高瓴的老师基本都是做 AI 的（偏信息检索、数据挖掘），没有什么比较差的，下限很高，都做学术。高瓴只有学硕和直博，都在夏令营招生，没有预推免，鸽子比较多，一般入营即 offer，学硕 bar 挺高，可能 985 2% 左右，直博低一些。文jr、徐j等老师都是 msra 过来的，IR 大牛，严r老师是北大王选所过来的，NLP 大牛，还有几个姚班毕业的 AP 也很强。高瓴最大的劣势就是人大这个 title 不够好了吧。</li></ul><h2 id="10-其他学校的部分AI牛组"><a href="#10-其他学校的部分AI牛组" class="headerlink" title="10 其他学校的部分AI牛组"></a>10 其他学校的部分AI牛组</h2><p>我保研过程中了解到的其他学校的一些 AI 牛组（还有很多没列上来）：</p><p>南开大学程mm组（CV）、哈工大SCIR实验室（刘t组，NLP）、北航VR国重（CV）、厦门大学mac实验室（纪rr组，CV）、东南大学palm实验室（耿x组）、中山大学郑ws组（CV）、华科白x组（OCR）、上科大虞jy组（CV）、西湖大学李zq组（原自动化所大牛）、西湖大学张y组（NLP）。</p>]]></content>
      
      
      <categories>
          
          <category> 经验贴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 夏令营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于动态规划/性价比/背包问题的思考</title>
      <link href="/2024/06/24/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%E6%80%A7%E4%BB%B7%E6%AF%94%E9%97%AE%E9%A2%98%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2024/06/24/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%E6%80%A7%E4%BB%B7%E6%AF%94%E9%97%AE%E9%A2%98%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="关于动态规划-性价比-背包问题的思考"><a href="#关于动态规划-性价比-背包问题的思考" class="headerlink" title="关于动态规划&#x2F;性价比&#x2F;背包问题的思考"></a>关于动态规划&#x2F;性价比&#x2F;背包问题的思考</h1><p>01背包本质上就可以用空间换时间，动规本质上也是那空间换时间，本身也就是一个贪心算法，所以<br>01背包&lt;–&gt;贪心&lt;–&gt;动态规划</p><p>如果说是0-1背包问题，需要逆序更新，原因是东西只有一个，不能影响之前的部分</p><p>如果是东西有无数个，则直接顺序更新</p><p>如果东西是牛奶之类的，有性价比，并且可以买非整数数量的，可以退化为贪心来做，结构体：数量，价格，性价比，sort一下就完事儿了。</p><p>讲究序列（排列问题），先遍历背包，不要求序列（组合问题），先遍历物品</p><p>滚动数组</p><p>另外，0-1背包要求倒序，若要求组合而非排列，即为先物品，再背包，且倒顺序，滚动数组添加</p><p>而且，如果是算有多少种，直接加就行,dp[0]&#x3D;1，其他为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[j]+=dp[j-nums[i]]</span><br><span class="line">    <span class="comment">//这里怎么去理解呢，会导致重复吗？</span></span><br><span class="line">    <span class="comment">//不会重复</span></span><br></pre></td></tr></table></figure><p>如果是要算最多&#x2F;最少，还要min和max比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j]=<span class="built_in">max</span>(dp[j],dp[j-nums[i]]+value[i])</span><br></pre></td></tr></table></figure><p>[(425条消息) 背包问题（背包九讲）_你好世界wxx的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_42638946/article/details/114028588?ops_request_misc=%7B%22request_id%22:%22167933155516800186567314%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=167933155516800186567314&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-6-114028588-null-null.142%5Ev74%5Epc_new_rank,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">https://blog.csdn.net/weixin_42638946/article/details/114028588?ops_request_misc=%7B%22request%5Fid%22%3A%22167933155516800186567314%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=167933155516800186567314&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-6-114028588-null-null.142^v74^pc_new_rank,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=01背包问题</a> 凑整&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by WXX on 2021/2/24 14:36</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j--) <span class="comment">//倒叙</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by WXX on 2021/2/24 15:21</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; j++)<span class="comment">//顺序</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by WXX on 2021/2/24 16:07</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  <span class="comment">// 先循环物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)  <span class="comment">// 再循环容量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++)  <span class="comment">// 最后循环决策</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分布式系统（一）认识分布式系统</title>
      <link href="/2024/06/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/06/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="认识分布式系统"><a href="#认识分布式系统" class="headerlink" title="认识分布式系统"></a>认识分布式系统</h1><h2 id="1-1-什么是分布式系统"><a href="#1-1-什么是分布式系统" class="headerlink" title="1.1 什么是分布式系统"></a>1.1 什么是分布式系统</h2><p>定义：</p><p>分布式系统指的是由多台计算机组成的系统，这些计算机通过网络连接起来，协同工作以实现共同的目标。在分布式系统中，各个计算机之间相互独立，同时也需要协同工作来处理大量的数据和任务。分布式系统可以包括不同类型的计算机，包括服务器、台式机、移动设备等等。</p><p>分布式系统的一个主要特点是其高度的可扩展性，可以随着需求增长而增加计算机的数量。分布式系统还具有高可靠性，因为即使其中一个计算机发生故障，系统也可以继续运行，不会因为单一点的故障而完全崩溃。分布式系统还可以提供更好的性能和更快的响应时间，因为可以将任务分配给多个计算机并行处理，而不是依靠单个计算机来处理所有任务。</p><p>分布式系统的应用非常广泛，包括云计算、大数据处理、分布式数据库、分布式存储系统、分布式搜索引擎等等。</p><h2 id="1-2-为什么需要分布式系统"><a href="#1-2-为什么需要分布式系统" class="headerlink" title="1.2 为什么需要分布式系统"></a>1.2 为什么需要分布式系统</h2><p>分布式系统是由多个独立计算机组成的网络，这些计算机通过网络互相通信和协调，共同完成某些任务或提供某些服务。分布式系统之所以重要，是因为它可以带来以下几个好处：</p><ol><li>可靠性：分布式系统可以提高系统的可靠性，因为它可以在某个节点或多个节点发生故障的情况下继续工作。</li><li>可扩展性：分布式系统可以通过增加计算机节点来扩展系统的处理能力，从而应对更大的工作负载。</li><li>高性能：分布式系统可以将任务分割成多个子任务，并在多个节点上并行处理，从而提高系统的处理速度。</li><li>负载均衡：分布式系统可以将负载分配到多个节点上，避免某个节点过度负载的情况发生，从而提高系统的稳定性和可用性。</li><li>数据共享：分布式系统可以让不同节点之间共享数据，从而使得数据更容易被访问和处理。</li></ol><p>总之，分布式系统可以提高系统的可靠性、可扩展性、高性能和负载均衡能力，使得系统更加稳定和高效。因此，在大规模应用中，分布式系统已成为一种必要的技术手段。</p><h2 id="1-3-分布式系统的示例"><a href="#1-3-分布式系统的示例" class="headerlink" title="1.3 分布式系统的示例"></a>1.3 分布式系统的示例</h2><h3 id="1-3-1-搜索引擎"><a href="#1-3-1-搜索引擎" class="headerlink" title="1.3.1 搜索引擎"></a>1.3.1 搜索引擎</h3><p>DNS是一个将IP地址和域名相互映射的分布式数据库，主要特点包括去中心化、可扩展性和健壮性。</p><p>搜索引擎背后的分布式基础设施：</p><ul><li>一个全球化、巨大的多数据中心（一个中心上万台物理机）</li><li>一个分布式文件系统（GFS）</li><li>大规模结构化数据的存储系统（Bigtable）</li><li>分布式锁服务(chubby)</li><li>并行和分布式计算的编程模式（MapReduce）</li><li>分布式数据库（Spanner）</li></ul><h3 id="1-3-2-加密货币"><a href="#1-3-2-加密货币" class="headerlink" title="1.3.2 加密货币"></a>1.3.2 加密货币</h3><p>加密货币和分布式系统密不可分。事实上，加密货币的核心技术就是基于分布式系统。</p><p>加密货币使用的是一种称为区块链的分布式账本技术。这种技术将账本数据分散存储在网络上的多个节点中，每个节点都有完整的账本副本，并通过加密算法进行验证和保护。这种分布式存储和验证方式使得区块链上的交易记录无法被篡改或删除，从而确保了加密货币的安全性和去中心化特点。</p><p>此外，分布式系统还能够实现去中心化的交易和转账，以及实现智能合约等功能。智能合约是一种自动执行的计算机程序，可以自动化完成各种事务，例如支付、转账、投票等。</p><p><a href="https://blog.csdn.net/weixin_40413961/article/details/122639770?ops_request_misc=%7B%22request_id%22:%22168554858916800213023799%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168554858916800213023799&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122639770-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6&spm=1018.2226.3001.4187">(458条消息) 区块链技术必杀技之——智能合约_区块链智能合约_jeff-y的博客-CSDN博客</a></p><p>总的来说，加密货币和分布式系统密切相关，加密货币的实现离不开分布式系统的技术支持，同时分布式系统也因为加密货币的需求而得到了广泛的应用和发展。</p><p>加密货币中的区块链技术使用了Merkle Tree来实现快速验证交易的有效性。</p><p>Merkle Tree是一种树状结构，它将数据分成小块并对这些块进行哈希运算。每个哈希值代表了它所对应数据块的内容。然后再将这些哈希值进行哈希，得到新的哈希值，称为父节点。父节点也可以再和其他父节点一起哈希，形成新的父节点，最终形成根节点。这个过程就像一棵树一样，因此被称为Merkle Tree。</p><p>在加密货币的交易验证中，Merkle Tree被用来快速验证某个交易是否属于某个区块。每个区块中的所有交易数据被组织成Merkle Tree结构，根节点的哈希值被包含在区块头中。当其他节点需要验证某个交易是否属于该区块时，只需要验证该交易的哈希值与Merkle Tree中的对应哈希值是否匹配，如果匹配，则该交易有效，否则无效。</p><p>通过Merkle Tree的结构，交易数据可以被高效地组织和验证，从而提高了加密货币系统的安全性和效率。</p><h2 id="1-4-分布式系统的挑战"><a href="#1-4-分布式系统的挑战" class="headerlink" title="1.4 分布式系统的挑战"></a>1.4 分布式系统的挑战</h2><p>网络延迟问题，部分失效问题，时钟问题</p><h3 id="1-4-1-网络延迟问题"><a href="#1-4-1-网络延迟问题" class="headerlink" title="1.4.1 网络延迟问题"></a>1.4.1 网络延迟问题</h3><p>分布式系统中的网络延迟是一个常见的问题，特别是在跨越不同的地理位置和数据中心时。网络延迟指的是从一个节点发送消息到另一个节点所需的时间。这个时间可以受到多种因素的影响，包括网络拓扑、带宽、传输协议和网络拥塞等。</p><p>为了降低网络延迟，可以采取以下措施：</p><ol><li>网络拓扑优化：设计一个合理的网络拓扑，使得节点之间的距离尽可能短，减少网络传输所需的时间。</li><li>协议选择优化：选择合适的协议，例如使用TCP&#x2F;IP协议时可以采用TCP快速打开（TCP Fast Open）协议来减少握手时间，或使用UDP协议来减少传输延迟。</li><li>数据压缩优化：对需要传输的数据进行压缩，可以减少数据传输量，从而减少网络传输所需的时间。</li><li>缓存优化：使用缓存技术可以减少对数据的重复访问，从而减少网络传输所需的时间。</li><li>负载均衡优化：使用负载均衡技术可以将请求分散到多个节点上，减少单个节点的负载，从而减少网络传输所需的时间。</li></ol><p>综上所述，网络延迟是分布式系统中的一个重要问题，需要采取多种优化措施来降低延迟，提高系统的性能和可靠性。</p><h3 id="1-4-2-部分失效问题"><a href="#1-4-2-部分失效问题" class="headerlink" title="1.4.2 部分失效问题"></a>1.4.2 部分失效问题</h3><p>分布式系统中的部分失效问题是指在分布式系统中的某些节点或者服务发生故障或失效，而系统的其他部分仍然正常运行。这种情况下，分布式系统需要采取措施来保证系统的可用性和稳定性。</p><p>以下是分布式系统中解决部分失效问题的一些常见方法：</p><ol><li>冗余备份：通过在分布式系统中增加冗余节点或服务来保证系统的可用性。当某些节点或服务失效时，冗余节点或服务可以接管其工作，从而保证系统的正常运行。</li><li>负载均衡：将请求分散到多个节点上，可以减轻单个节点的负担，从而减少故障的发生概率。负载均衡也可以将请求转发到最近的可用节点上，提高系统的性能和可用性。</li><li>异常检测和恢复：当某些节点或服务发生故障时，需要及时检测并采取恰当的措施进行恢复。这可以通过使用异常检测和恢复机制来实现，例如使用心跳检测机制来检测节点或服务是否存活。</li><li>限流和熔断：当某些节点或服务的负载过高时，可以采用限流和熔断机制来保护系统免受过度负载的影响。限流机制可以控制流量的速率，熔断机制可以暂时关闭某些节点或服务，以防止它们的故障影响整个系统的正常运行。</li><li>事务处理和回滚：当某些节点或服务发生故障时，可能会导致分布式事务失败。在这种情况下，需要采取事务处理和回滚机制来恢复故障，保证数据的一致性和可靠性。</li></ol><p>综上所述，分布式系统中的部分失效问题是一个常见的挑战，需要采取多种技术和机制来保证系统的可用性和稳定性。</p><h3 id="1-4-3-时钟问题"><a href="#1-4-3-时钟问题" class="headerlink" title="1.4.3 时钟问题"></a>1.4.3 时钟问题</h3><p>分布式系统中的时钟问题是指由于系统中的节点位于不同的地理位置，所以节点的时钟存在偏差和不同步的问题。时钟偏差和不同步会导致分布式系统中的数据同步、事务处理和协议执行等方面出现问题，从而影响系统的正确性和可靠性。</p><p>以下是分布式系统中解决时钟问题的一些常见方法：</p><ol><li>物理时钟同步：物理时钟同步是通过使用网络时间协议（NTP）或其他时钟同步协议来保证系统中的节点时钟保持同步。这可以减少节点之间的时钟偏差，从而提高系统的可靠性和正确性。</li><li>逻辑时钟：逻辑时钟是一种基于事件顺序的时钟，可以用于跨越不同节点的事件顺序标记。例如，Lamport时钟和向量时钟可以记录事件的发生顺序，并通过比较时间戳来确定事件的先后关系。</li><li>时钟漂移和修正：由于硬件时钟存在漂移，因此需要定期对时钟进行修正。例如，可以使用时间同步协议来校正时钟漂移，或者在节点之间进行时钟校准，从而减少时钟漂移的影响。</li><li>时钟容忍度：时钟容忍度是指在分布式系统中接受的时钟误差范围。节点之间的时钟误差超出容忍度范围时，系统会采取相应的措施来避免时钟问题对系统产生不良影响。</li></ol><p>综上所述，时钟问题是分布式系统中的一个重要挑战，需要采取多种技术和机制来解决。物理时钟同步、逻辑时钟、时钟漂移和修正以及时钟容忍度等技术和机制可以用来解决时钟问题，提高系统的可靠性和正确性。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 深入理解分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++刷题</title>
      <link href="/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p>[(459条消息) 【C语言】程序运行过程：预处理&#x2F;编译&#x2F;汇编&#x2F;链接_预处理编译汇编链接_慕雪华年的博客-CSDN博客](<a href="https://blog.csdn.net/muxuen/article/details/123227200?ops_request_misc=%7B%22request_id%22:%22168596052316800182799736%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168596052316800182799736&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123227200-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E9%A2%84%E5%A4%84%E7%90%86">https://blog.csdn.net/muxuen/article/details/123227200?ops_request_misc=%7B%22request%5Fid%22%3A%22168596052316800182799736%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168596052316800182799736&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123227200-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=预处理</a> 编译 汇编 链接&amp;spm&#x3D;1018.2226.3001.4187)</p><p><a href="https://blog.csdn.net/weixin_54338498/article/details/126953046?ops_request_misc=%7B%22request_id%22:%22168175034116800197040062%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168175034116800197040062&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-126953046-null-null.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&utm_term=%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95&spm=1018.2226.3001.4187">(443条消息) 保研机试——1基础算法（排序、哈希、模拟（日期、图形、查找、进制、字符串）、递归与分治、贪心）_Yuezero_的博客-CSDN博客</a></p><p>[(425条消息) 数据结构保研面试题整理（自用）_保研数据结构常温问题_乌鸡摸鱼的博客-CSDN博客](<a href="https://blog.csdn.net/m0_52571748/article/details/120505195?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">https://blog.csdn.net/m0_52571748/article/details/120505195?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=数据结构</a> 保研&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-120505195.142^v73^pc_search_v2,201^v4^add_ask,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><p><a href="https://blog.csdn.net/qq_53524653/article/details/121522229?ops_request_misc=%7B%22request_id%22:%22168740926216782425172942%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168740926216782425172942&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121522229-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187">(463条消息) 插入排序–折半插入排序（来一来，看一看，走过路过，不要错过）_老 胡的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/385907273">P问题、NP问题、NPC问题、NP-hard问题详解 - 知乎 (zhihu.com)</a></p><p>[保研机试整理 - 知乎 (zhihu.com)</p><p>什么时候才考虑用二分答案的技巧？<br>正向求出答案不好入手，求解答案远远没有验证答案简单。</p><p>已知前序后序算中序有多少种：</p><p>[<a href="https://blog.csdn.net/qq_37437983/article/details/79613947">(441条消息) 二叉树遍历（已知前序和后序遍历，求中序遍历的可能的序列数）_已知二叉树的前序遍历和后序遍历_我要出家当道士的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/40915131"></a></p><p><a href="https://blog.csdn.net/yizhiniu_xuyw/article/details/109596961?ops_request_misc=%7B%22request_id%22:%22168707250016800213049573%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168707250016800213049573&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-109596961-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%A0%86%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1018.2226.3001.4187">(462条消息) 堆排序的时间复杂度分析_一只牛_007的博客-CSDN博客</a></p><p>建立索引树：[(462条消息) 2020北航计算机夏令营机试题目个人理解_北航夏令营 机试_四处碰壁嘤嘤怪的博客-CSDN博客](<a href="https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request_id%22:%22168715279416800185829257%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168715279416800185829257&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%8C%97%E8%88%AA%E5%A4%8F%E4%BB%A4%E8%90%A5">https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request%5Fid%22%3A%22168715279416800185829257%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168715279416800185829257&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=北航夏令营</a> 机试&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>scanf后，用getchar()吃掉回车</p><p>表示最大 INT_MAX(climits)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//malloc</span></span><br><span class="line"><span class="type">int</span> *nums;</span><br><span class="line">nums=(*<span class="type">int</span>)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//long long int 别用cin cout</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>scanf还会返回成功输入的变量的个数,因此可判定EOF</p><p>Floyd判圈法很吊</p><p>1.lower_bound(v.begin(), v.end(), key)-v.begin()返回有序序列中大于等于key的第一个值的位置<br>2.upper_bound(v.begin(), v.end(), key)-v.begin()返回有序序列中大于key的第一个值的位置<br>3.lower_bound(v.begin(), v.end(), key, greater<int>())-v.begin()返回有序序列中小于等于key的第一个值的位置<br>4.upper_bound(v.begin(), v.end(), key, greater<int>())-v.begin()返回有序序列中小于key的第一个值的位置<br>5.上述四个函数，若无满足条件的值，则返回v.size() </p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br></pre></td></tr></table></figure><h2 id="一些常用的库"><a href="#一些常用的库" class="headerlink" title="一些常用的库"></a>一些常用的库</h2><ol><li>algorithm</li><li>vector</li><li>map</li><li>queue</li><li>iostream</li><li>string</li><li>bits&#x2F;stdc++.h（带上就对了）</li><li>cmath(sqrt之类的)</li><li>climits（INT_MAX INT_MIN）</li></ol><p><strong>STL内置find()复杂度</strong>：<br><code>algorithm的find</code> 复杂度是<code>O(n)</code>，对vector，string等 顺序查询。<br><code>map::find</code> 和 <code>set::find</code> 复杂度是<code>O(logn)</code>，因为map和set底层都是红黑树。</p><hr><h3 id="vector"><a href="#vector" class="headerlink" title="vector:"></a><strong>vector:</strong></h3><p>下面是一些常用的vector方法：</p><ol><li><p><code>push_back</code>：在vector的末尾添加一个元素。</p></li><li><p><code>pop_back</code>：删除vector末尾的一个元素。</p></li><li><p><code>size</code>：返回vector中元素的个数。</p></li><li><p><code>clear</code>：删除vector中所有的元素。</p></li><li><p><code>empty</code>：判断vector是否为空。</p></li><li><p><code>at</code>：返回vector中指定位置的元素。</p></li><li><p><code>front</code>：返回第一个元素。</p></li><li><p><code>back</code>：返回最后一个元素。</p></li><li><p><code>erase</code>：删除vector中指定位置的元素。</p></li><li><p><code>insert</code>：在vector中指定位置插入一个元素或多个元素。</p></li><li><p><code>resize</code>：改变vector的大小。</p></li><li><p><code>reserve</code>：为vector预留一定的空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li><li><p><code>swap</code>：交换两个vector中的元素。</p></li><li><p><code>begin</code>：返回指向vector第一个元素的迭代器。</p></li><li><p><code>end</code>：返回指向vector最后一个元素之后的迭代器。 这些方法能够满足大部分情况下的需求，可以根据具体的使用场景选择合适的方法进行操作。</p></li></ol><p>要取迭代器的值，直接*指针取值</p><p>对于向量(vector)，它是一种支持随机访问的容器，因此<strong>可以直接通过下标访问向量中的元素</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 使用auto关键字定义迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector不能直接使用sort函数进行排序，需要传入一个迭代器指定排序的范围。修改代码如下：</p><p>sort(v.begin(),v.end(),com);</p><hr><h3 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h3><p>以下是C++中map类的常用方法：</p><ol><li><p>insert(make_pair&lt;key, value&gt;)：向map中插入一个键值对。</p></li><li><p>erase(key)：删除map中指定键的元素。</p></li><li><p>clear()：清空map中所有元素。</p></li><li><p>size()：返回map中元素的个数。</p></li><li><p>empty()：返回map是否为空。</p></li><li><p>find(key)：查找map中是否存在指定键的元素，如果存在则返回指向该元素的迭代器，否则返回end()迭代器。</p><p>常常和end联合起来用判断找到没。(<strong>这个适合动态查找，底层红黑树实现</strong>)</p></li><li><p>count(key)：返回指定键在map中出现的次数，如果不存在则返回0或1。</p></li><li><p>begin()：返回指向map第一个元素的迭代器。</p></li><li><p>end()：返回指向map最后一个元素后面的位置的迭代器。</p></li><li><p>operator[]：通过键访问map中的元素，如果键不存在，则自动插入一个新的键值对并返回对应的值。</p></li><li><p>lower_bound(key)：返回第一个大于或等于指定键的元素的迭代器。</p></li><li><p>upper_bound(key)：返回第一个大于指定键的元素的迭代器。</p></li><li><p>equal_range(key)：返回一个pair对象，其中包含lower_bound和upper_bound返回的迭代器。</p></li><li><p>swap(map2)：交换当前map和map2的元素。 C++中的map类是一种关联式容器，用于存储键值对，其中每个键都唯一，并且按照一定的顺序排列。map的底层实现通常是红黑树，因此查找、插入和删除操作的时间复杂度为O(log n)，其中n是map中元素的个数。map类提供了丰富的方法，可以方便地进行键值对的操作，例如插入、删除、查找、排序等。同时，由于map使用键值对来存储数据，因此可以将map看作是一种特殊的数组，其下标为键，对应的值为数组元素。因此，可以通过下标来访问和修改map中的元素。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;&#123;<span class="string">&quot;apple&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 使用auto关键字定义迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a><strong>stack</strong></h3><p>C++ 中的 stack 库提供了以下常用的方法：</p><ul><li>push(elem)：将元素 elem 压入栈顶。</li><li>pop()：弹出栈顶元素。</li><li>top()：返回栈顶元素，但不弹出。</li><li>empty()：判断栈是否为空。</li><li>size()：返回栈中元素的个数。 除此之外，stack 还支持以下操作：</li><li>emplace(args…)：构造一个新元素并将其压入栈顶。</li><li>swap(stack)：交换两个 stack 的元素。</li><li>operator&#x3D;&#x3D;、operator!&#x3D;、operator&lt;、operator&lt;&#x3D;、operator&gt;、operator&gt;&#x3D;：比较两个 stack 是否相等、不相等、小于、小于等于、大于、大于等于。 具体用法可以参考下面的示例代码</li></ul><p>stack元素可以是任何类型。</p><hr><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a><strong>queue</strong></h3><p>C++中的queue是一种容器适配器，用于实现“先进先出”（FIFO）的数据结构。queue基于deque或list进行实现，提供了一些方法来操作队列，包括入队、出队、获取队首元素、获取队列大小等。以下是queue的常用方法：</p><ol><li>push(element)：将一个元素加入队列的尾部。</li><li>pop()：将队列头部的元素弹出，但没有返回值。</li><li>front()：返回队列头部的元素。</li><li>top():返回队列头部元素（和front一样）</li><li>back()：返回队列尾部的元素。</li><li>empty()：判断队列是否为空。</li><li>size()：返回队列中元素的个数。 使用queue需要包含头文件，可以通过以下方式创建一个queue对象：</li></ol><p>对于队列(queue)，由于它是一种先进先出(FIFO)的数据结构，因此只能通过front()和back()函数来访问队列的头部和尾部元素，<strong>而不能直接通过下标访问</strong>。如果要使用下标访问队列元素，需要先将队列转换为数组或向量。 </p><hr><h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a><strong>priority_queue</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;string&gt; b;</span><br></pre></td></tr></table></figure><p>对于优先队列，复杂结构类型要重载运算符<a href="https://blog.csdn.net/qq_27278957/article/details/85269245?ops_request_misc=%7B%22request_id%22:%22168033538216800213097640%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168033538216800213097640&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-85269245-null-null.142%5Ev80%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=c++%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1018.2226.3001.4187">(436条消息) C++ 运算符重载_c 重载运算符_高祥xiang的博客-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="type">int</span> real;</span><br><span class="line"><span class="type">int</span> imag;</span><br><span class="line">......</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Complex c)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> real*real+imag*imag&lt;c.real*c.real+c.imag*c.imag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面这个const是必须要有的</p><hr><h3 id="string"><a href="#string" class="headerlink" title="string"></a><strong>string</strong></h3><p>C++中的string类是一个封装了字符串操作的类，提供了一系列方法来处理和操作字符串。以下是常用的string类方法：</p><ol><li><p>length()：返回字符串的长度。</p></li><li><p>size()：返回字符串的长度。</p></li><li><p>clear()：清空字符串。</p></li><li><p>empty()：判断字符串是否为空。</p></li><li><p>assign(str)：将字符串的值设置为str。</p></li><li><p>assign(str, pos, len)：将字符串的值设置为str中从pos位置开始的长度为len的子串。</p></li><li><p>append(str)：在字符串的末尾添加str。</p></li><li><p>append(str, pos, len)：在字符串的末尾添加str中从pos位置开始的长度为len的子串。</p></li><li><p>push_back(ch)：在字符串的末尾添加一个字符。</p></li><li><p>insert(pos, str)：在字符串的pos位置插入str。</p></li><li><p>erase(pos, len)：删除从pos位置开始长度为len的子串。</p><p>erase(n):删除indexn后面的字符</p></li><li><p>replace(pos, len, str)：替换从pos位置开始长度为len的子串为str。</p></li><li><p><strong>substr(pos, len)：返回从pos位置开始长度为len的子串。</strong></p></li><li><p><strong>find(str)：查找str在字符串中第一次出现的位置，返回该位置的索引值。</strong>(找不到就是-1)</p></li><li><p>rfind(str)：查找str在字符串中最后一次出现的位置，返回该位置的索引值。</p></li><li><p>compare(str)：比较字符串和str的大小，返回0（相等）、1（大于）或-1（小于）。 除了以上列举的方法，string类还支持重载运算符，例如+（字符串拼接）、+&#x3D;（字符串拼接赋值）、&#x3D;&#x3D;（字符串相等判断）、[]（访问字符串中指定位置的字符）等。string类的使用非常方便，可以像使用普通变量一样对字符串进行赋值、拼接、查找、替换等操作。例如：</p></li></ol><p>注意string s，其s[i]类型为char，char强制类型转换可以这样转换</p><p>string(1,s[i])，1表示char长度</p><p>s[i]可以直接比较</p><p>输入str1,如果str1为空则退出</p><p><img src="C:\Users\11505\AppData\Roaming\Typora\typora-user-images\image-20230313213418581.png" alt="image-20230313213418581"></p><p>scanf不会读回车，如果下一行是gets会直接读取缓冲区中的回车，所有会用一个getchar()在中间把缓冲区中的回车抵消掉</p><p>stoi(str) 将其转换为整数，注意，如果是”04”,直接变成4</p><p>string::npos用于判断结尾（其实找不到直接-1也行）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find函数返回 jk 在 s 中的下标位置</span></span><br><span class="line">position = s.<span class="built_in">find</span>(<span class="string">&quot;jk&quot;</span>);</span><br><span class="line"><span class="comment">// 如果没找到，返回一个特别的标志</span></span><br><span class="line"><span class="comment">// c++中用npos表示，我这里npos取值是4294967295</span></span><br><span class="line"><span class="keyword">if</span>(position != s.npos)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;position: &quot;</span> &lt;&lt; position &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Not found the flag&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果输入的字符串有空格，那么用如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin,str)</span><br></pre></td></tr></table></figure><p>可以直接通过下标修改字符</p><p>删除字符串内重复字符:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;aadfgggh&quot;</span>;</span><br><span class="line"><span class="comment">//去重复</span></span><br><span class="line"><span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="built_in">unique</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>()),str.<span class="built_in">end</span>());  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除字符串内某个指定字符:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;aadfgggh&quot;</span>;</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>(),<span class="string">&#x27;a&#x27;</span>),str.<span class="built_in">end</span>()); <span class="comment">//在容器中, 删除[begin,end)之间的所有值等于&#x27;a&#x27;的值.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line">string::<span class="built_in">erase</span>(begin,end)：删除[begin,end)之间的所有值c</span><br></pre></td></tr></table></figure><p>在Find the Smallest Number中，我发现string的超出index一位的位置依然可以访问，但是没有数</p><hr><h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a><strong>algorithm</strong></h3><p>C++标准库中的algorithm库提供了许多常用的算法，这些算法可以用于处理容器中的数据，例如排序、查找、遍历等。以下是algorithm库中常用的方法：</p><ol><li>sort(first, last, func)：对[first, last)区间内的元素进行升&#x2F;降序排序（取决于func返回）。</li><li>reverse(first, last)：对[first, last)区间内的元素进行翻转。</li><li>find(first, last, val)：在[first, last)区间内查找值为val的元素，返回该元素的迭代器。如果没有找到，返回last。</li><li>find_if(first, last, pred)：在[first, last)区间内查找满足条件pred的第一个元素，返回该元素的迭代器。如果没有找到，返回last。</li><li>count(first, last, val)：统计[first, last)区间内值为val的元素个数。</li><li>count_if(first, last, pred)：统计[first, last)区间内满足条件pred的元素个数。</li><li>accumulate(first, last, init)：对[first, last)区间内的元素进行累加，初始值为init。</li><li>max_element(first, last)：返回[first, last)区间内的最大元素的迭代器。</li><li>min_element(first, last)：返回[first, last)区间内的最小元素的迭代器。</li><li>unique(first, last)：对[first, last)区间内的元素去重，返回去重后的末尾迭代器。</li><li>remove(first, last, val)：删除[first, last)区间内值为val的元素，返回删除后的末尾迭代器。</li><li>remove_if(first, last, pred)：删除[first, last)区间内满足条件pred的元素，返回删除后的末尾迭代器。</li><li>for_each(first, last, func)：对[first, last)区间内的元素执行操作func。</li><li>transform(first1, last1, first2, result, op)：将[first1, last1)区间内的元素和[first2, …)区间内的元素进行op操作，并将结果存储到[result, …)区间内。</li></ol><h3 id="climits"><a href="#climits" class="headerlink" title="climits"></a>climits</h3><p><climits>中定义的常量主要有以下几种：</p><ol><li>整数类型的最大值和最小值：INT_MAX、INT_MIN、LONG_MAX、LONG_MIN、SHRT_MAX、SHRT_MIN等等。</li><li>字符类型的最大值和最小值：CHAR_MAX、CHAR_MIN、SCHAR_MAX、SCHAR_MIN、UCHAR_MAX等等。</li><li>位数相关的常量：CHAR_BIT、INT_BIT、LONG_BIT等等。</li><li>其他常量：MB_LEN_MAX表示一个多字节字符的最大长度，FLT_MAX、FLT_MIN、DBL_MAX、DBL_MIN等等表示浮点类型的最大值和最小值。</li></ol><h2 id="设置输出精度"><a href="#设置输出精度" class="headerlink" title="设置输出精度"></a>设置输出精度</h2><p>设置输出精度为1位小数</p><p>cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; ans &lt;&lt; endl</p><h2 id="设置输出位数"><a href="#设置输出位数" class="headerlink" title="设置输出位数"></a>设置输出位数</h2><p>printf(“%02d”,&amp;)</p><p>前面补零，两位，不够两位就补零</p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p><a href="https://zhuanlan.zhihu.com/p/83334559">KMP 算法详解 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/v_JULY_v/article/details/7041827?ops_request_misc=%7B%22request_id%22:%22167957843316800227474381%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167957843316800227474381&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-7041827-null-null.142%5Ev76%5Epc_new_rank,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=KMP&spm=1018.2226.3001.4187">(427条消息) 从头到尾彻底理解KMP（2014年8月22日版）_kmp算法难吗是什么级别_v_JULY_v的博客-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(<span class="type">char</span>* p,<span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k]) </span><br><span class="line">&#123;</span><br><span class="line">++k;</span><br><span class="line">++j;</span><br><span class="line">next[j] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kmp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    </span></span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    </span></span><br><span class="line"><span class="comment">//next[j]即为j所对应的next值      </span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == pLen)</span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="最大连续子序列"><a href="#最大连续子序列" class="headerlink" title="最大连续子序列"></a>最大连续子序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> nums[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;N)&#123;</span><br><span class="line"><span class="keyword">if</span> (N==EOF)<span class="keyword">break</span>;</span><br><span class="line"><span class="type">int</span> maxnum=INT_MIN;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">cin&gt;&gt;nums[i];</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (N==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">dp[i]=<span class="built_in">max</span>(nums[i],dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">maxnum=<span class="built_in">max</span>(dp[i],maxnum);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最大子矩阵"><a href="#最大子矩阵" class="headerlink" title="最大子矩阵"></a>最大子矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> matrix[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> support[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hangmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> maxnum;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=<span class="built_in">max</span>(arr[i],dp[i<span class="number">-1</span>]+arr[i]);</span><br><span class="line">maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">allmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> maxnum;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">1</span>)&#123;</span><br><span class="line">arr[k]=support[j][k];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">arr[k]=support[j][k]-support[i<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">maxnum=<span class="built_in">max</span>(<span class="built_in">hangmax</span>(n),maxnum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">cin&gt;&gt;matrix[i][j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">1</span>)support[i][j]=matrix[i][j];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">support[i][j]=matrix[i][j]+support[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxnum;</span><br><span class="line">maxnum=<span class="built_in">allmax</span>(n);</span><br><span class="line">cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长递增-减序列"><a href="#最长递增-减序列" class="headerlink" title="最长递增&#x2F;减序列"></a>最长递增&#x2F;减序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> daodan[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> maxnum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (daodan[i]&lt;=daodan[j])</span><br><span class="line">dp[i]=<span class="built_in">max</span>(<span class="number">1</span>,dp[j]+<span class="number">1</span>);</span><br><span class="line">maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;daodan[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxnum;</span><br><span class="line">maxnum=<span class="built_in">countmax</span>(n);</span><br><span class="line">cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大上升子序列和（O-N-2-）"><a href="#最大上升子序列和（O-N-2-）" class="headerlink" title="最大上升子序列和（O(N^2)）"></a>最大上升子序列和（O(N^2)）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> nums[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> maxsum;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i]&gt;nums[j])</span><br><span class="line">dp[i]=<span class="built_in">max</span>(nums[i],dp[j]+nums[i]);</span><br><span class="line">maxsum=<span class="built_in">max</span>(maxsum,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxsum;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;nums[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">maxsum=<span class="built_in">countmax</span>(n);</span><br><span class="line">cout&lt;&lt;maxsum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h3><p>1<br>7<br>3<br>5<br>9<br>4<br>8<br>3</p><p><a href="https://blog.csdn.net/lxt_Lucia/article/details/81209962?ops_request_misc=%7B%22request_id%22:%22168639963816800225544693%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168639963816800225544693&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81209962-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=LCS&spm=1018.2226.3001.4187">(461条消息) 最长公共子序列 (LCS) 详解+例题模板（全）_lxt_Lucia的博客-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s1;</span><br><span class="line">string s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(string s1,string s2)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> length1=s1.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> length2=s2.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> dp[length1][length2];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;length1;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;length2;j++)&#123;</span><br><span class="line">dp[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxnum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;length1;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;length2;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (s1[i]==s2[j])&#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">dp[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">dp[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">maxnum=<span class="built_in">max</span>(maxnum,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;s1&gt;&gt;s2)&#123;</span><br><span class="line"><span class="type">int</span> maxnum=<span class="built_in">countmax</span>(s1,s2);</span><br><span class="line">cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LIS（Nlogn）"><a href="#LIS（Nlogn）" class="headerlink" title="LIS（Nlogn）"></a>LIS（Nlogn）</h3><p><a href="https://blog.csdn.net/lxt_Lucia/article/details/81206439?ops_request_misc=%7B%22request_id%22:%22168766303316800185860492%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168766303316800185860492&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81206439-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97&spm=1018.2226.3001.4187">(465条消息) 最长上升子序列 (LIS) 详解+例题模板 (全)_lxt_Lucia的博客-CSDN博客</a></p><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">d</span>&#123;</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> C,N;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;C&gt;&gt;N)&#123;</span><br><span class="line"><span class="keyword">if</span> (C==<span class="number">0</span>&amp;&amp;N==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="type">int</span> dp[C+<span class="number">1</span>];</span><br><span class="line">d deal[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=C;i++)&#123;</span><br><span class="line">dp[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">cin&gt;&gt;price&gt;&gt;score;</span><br><span class="line">deal[i].price=price;</span><br><span class="line">deal[i].score=score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=C;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span> (j&gt;=deal[i].price)&#123;</span><br><span class="line">dp[j]=<span class="built_in">max</span>(dp[j-deal[i].price]+deal[i].score,dp[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[C]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个背包的变种</p><p><a href="https://blog.csdn.net/weixin_41994332/article/details/115829716?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-115829716-blog-109011034.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-115829716-blog-109011034.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=1">(465条消息) 复旦大学2021年计算机学院机试题解_复旦oj_PyKt的博客-CSDN博客</a></p><p>这里是直接顺序的</p><h2 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS BFS"></a>DFS BFS</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> hight)</span>  <span class="comment">//合并函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>[hight - low + <span class="number">1</span>];  <span class="comment">//用 new 申请一个辅助函数</span></span><br><span class="line"><span class="type">int</span> i = low, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;    <span class="comment">// k为 b 数组的小标</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= hight)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">&#123;</span><br><span class="line">b[k++] = a[i++];  <span class="comment">//按从小到大存放在 b 数组里面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">b[k++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)  <span class="comment">// j 序列结束，将剩余的 i 序列补充在 b 数组中 </span></span><br><span class="line">&#123;</span><br><span class="line">b[k++] = a[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= hight)<span class="comment">// i 序列结束，将剩余的 j 序列补充在 b 数组中 </span></span><br><span class="line">&#123;</span><br><span class="line">b[k++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">k = <span class="number">0</span>;  <span class="comment">//从小标为 0 开始传送</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= hight; i++)  <span class="comment">//将 b 数组的值传递给数组 a</span></span><br><span class="line">&#123;</span><br><span class="line">a[i] = b[k++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]b;     <span class="comment">// 辅助数组用完后，将其的空间进行释放（销毁）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> hight)</span> <span class="comment">//归并排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; hight)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (low + hight) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">mergesort</span>(a, low, mid);          <span class="comment">//对 a[low,mid]进行排序</span></span><br><span class="line"><span class="built_in">mergesort</span>(a, mid + <span class="number">1</span>, hight);    <span class="comment">//对 a[mid+1,hight]进行排序</span></span><br><span class="line"><span class="built_in">merge</span>(a, low, mid, hight);       <span class="comment">//进行合并操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, a[<span class="number">100</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入数列中的元素个数 n 为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请依次输入数列中的元素：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mergesort</span>(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;归并排序结果&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> m=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quickpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="comment">//与运算，可判断奇偶，详细见注释</span></span><br><span class="line">sum=sum*a%m;<span class="comment">//取模运算</span></span><br><span class="line">a=a*a%m;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;<span class="comment">//位运算，右移，相当于除以2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="模拟问题"><a href="#模拟问题" class="headerlink" title="模拟问题"></a>模拟问题</h2><p>就是找规律，还行</p><h2 id="日期问题"><a href="#日期问题" class="headerlink" title="日期问题"></a>日期问题</h2><p>要预处理</p><h2 id="最大公因数-最小公倍数"><a href="#最大公因数-最小公倍数" class="headerlink" title="最大公因数&#x2F;最小公倍数"></a>最大公因数&#x2F;最小公倍数</h2><p>最小公倍数&#x3D;a*b&#x2F;c</p><p>c为最大公因数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大公因数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">biggest</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b!=<span class="number">0</span>?<span class="built_in">biggest</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最小公倍数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">smallest</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> big=<span class="built_in">biggest</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> a*b/big;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;n)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">2</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> sushu[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sushu[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (sushu[i]==<span class="literal">false</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=i;j*i&lt;=n;j++)&#123; <span class="comment">//j直接从i开始，提高效率</span></span><br><span class="line"><span class="keyword">if</span> (j*i&lt;n)&#123;</span><br><span class="line">sushu[j*i]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (sushu[i])&#123;</span><br><span class="line"><span class="keyword">if</span> (i%<span class="number">10</span>==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个数n，其质因数最多只有一个大于其平方根！</p><h2 id="矩阵乘法（构造函数）"><a href="#矩阵乘法（构造函数）" class="headerlink" title="矩阵乘法（构造函数）"></a>矩阵乘法（构造函数）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line"><span class="type">int</span> matrix[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> row;</span><br><span class="line"><span class="type">int</span> col;</span><br><span class="line"><span class="built_in">Matrix</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">row</span>(a),<span class="built_in">col</span>(b)&#123;&#125;<span class="comment">//注意构造函数的写法</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Matrix <span class="title">Multiply</span><span class="params">(Matrix a,Matrix b)</span></span>&#123;</span><br><span class="line">Matrix ans=<span class="built_in">Matrix</span>(a.row,b.col);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.row;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;b.col;j++)&#123;</span><br><span class="line"><span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;a.col;k++)&#123;</span><br><span class="line">temp+=a.matrix[i][k]*b.matrix[k][j];</span><br><span class="line">&#125;</span><br><span class="line">ans.matrix[i][j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMatrix</span><span class="params">(Matrix m)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> row=m.row;</span><br><span class="line"><span class="type">int</span> col=m.col;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (j!=<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;m.matrix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Matrix a=<span class="built_in">Matrix</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Matrix b=<span class="built_in">Matrix</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">cin&gt;&gt;a.matrix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">cin&gt;&gt;b.matrix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Matrix c=<span class="built_in">Multiply</span>(a,b);</span><br><span class="line"><span class="built_in">printMatrix</span>(c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><a href="https://so.csdn.net/so/search?spm=1000.2115.3001.4498&q=prim%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91&t=&u=">prim算法求最小生成树- CSDN搜索</a></p><p>kruscal</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(edge c)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> weight&gt;c.weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">edge</span>(<span class="type">int</span> q,<span class="type">int</span> w,<span class="type">int</span> e):<span class="built_in">a</span>(q),<span class="built_in">b</span>(w),<span class="built_in">weight</span>(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;edge,vector&lt;edge&gt;,greater&lt;edge&gt;&gt;edges;</span><br><span class="line"><span class="type">int</span> graph[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (graph[x]==<span class="number">-1</span>)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">temp=<span class="built_in">find</span>(graph[x]);</span><br><span class="line">graph[x]=temp;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;n)&#123;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="type">int</span> a,b,weight;</span><br><span class="line"><span class="type">int</span> num=n*(n<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">memset</span>(graph,<span class="number">-1</span>,<span class="built_in">sizeof</span>(graph));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">graph[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (num--)&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">edge edge1=<span class="built_in">edge</span>(a,b,weight);</span><br><span class="line">edges.<span class="built_in">push</span>(edge1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!edges.<span class="built_in">empty</span>()&amp;&amp;count&lt;n<span class="number">-1</span>)&#123;</span><br><span class="line">edge temp=edges.<span class="built_in">top</span>();</span><br><span class="line">edges.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> a=<span class="built_in">find</span>(temp.a);</span><br><span class="line"><span class="type">int</span> b=<span class="built_in">find</span>(temp.b);</span><br><span class="line"><span class="type">int</span> weight=temp.weight;</span><br><span class="line"><span class="keyword">if</span> (a!=b)&#123;</span><br><span class="line">graph[a]=b;</span><br><span class="line">count++;</span><br><span class="line">sum+=weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="弗洛伊德"><a href="#弗洛伊德" class="headerlink" title="弗洛伊德"></a>弗洛伊德</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;k ++) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++) &#123; </span><br><span class="line"> <span class="keyword">if</span> (ans[i][k] == 无穷 || ans[k][j] == 无穷) <span class="keyword">continue</span>; </span><br><span class="line"> <span class="keyword">if</span> (ans[i][j] == 无穷 || ans[i][k] + ans[k][j] &lt; ans[i][j]) </span><br><span class="line"> ans[i][j] = ans[i][k] + ans[k][j]; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h2 id="迪杰斯特拉"><a href="#迪杰斯特拉" class="headerlink" title="迪杰斯特拉"></a>迪杰斯特拉</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123; <span class="comment">//初始化</span></span><br><span class="line"> Dis[i] = <span class="number">-1</span>; <span class="comment">//所有距离为-1，即不可达</span></span><br><span class="line"> mark[i] = <span class="literal">false</span>; <span class="comment">//所有结点不属于集合K</span></span><br><span class="line"> &#125; </span><br><span class="line"> Dis[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//得到最近的点为结点1,长度为0</span></span><br><span class="line"> mark[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//将结点1加入集合K</span></span><br><span class="line"> <span class="type">int</span> newP = <span class="number">1</span>; <span class="comment">//集合K中新加入的点为结点1 </span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i ++) &#123; <span class="comment">//循环n-1次,按照最短路径递增的顺序确定其他n-1个点的最短路径长度</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; edge[newP].<span class="built_in">size</span>();j ++) &#123; <span class="comment">//遍历与该新加入集合</span></span><br><span class="line">K中的结点直接相邻的边</span><br><span class="line"> <span class="type">int</span> t = edge[newP][j].next; <span class="comment">//该边的另一个结点</span></span><br><span class="line"> <span class="type">int</span> c = edge[newP][j].c; <span class="comment">//该边的长度</span></span><br><span class="line"> <span class="keyword">if</span> (mark[t] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">//若另一个结点也属于集合K,则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[t] == - <span class="number">1</span> || Dis[t] &gt; Dis[newP] + c) <span class="comment">//若该结点尚不可</span></span><br><span class="line">达,或者该结点从新加入的结点经过一条边到达时比以往距离更短</span><br><span class="line"> Dis[t] = Dis[newP] + c; <span class="comment">//更新其距离信息</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="type">int</span> min = <span class="number">123123123</span>; <span class="comment">//最小值初始化为一个大整数,为找最小值做准备</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++) &#123; <span class="comment">//遍历所有结点</span></span><br><span class="line"> <span class="keyword">if</span> (mark[j] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">//若其属于集合K则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[j] == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">//若该结点仍不可达则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[j] &lt; min) &#123; <span class="comment">//若该结点经由结点1至集合K中的某点在经过一条</span></span><br><span class="line">边到达时距离小于当前最小值</span><br><span class="line"> min = Dis[j]; <span class="comment">//更新其为最小值</span></span><br><span class="line"> newP = j; <span class="comment">//新加入的点暂定为该点</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉回路（hierholzer）"><a href="#欧拉回路（hierholzer）" class="headerlink" title="欧拉回路（hierholzer）"></a>欧拉回路（hierholzer）</h2><p><a href="https://blog.csdn.net/weixin_44316314/article/details/96898445?ops_request_misc=%7B%22request_id%22:%22168707940816800182775723%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168707940816800182775723&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-96898445-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E7%9A%84%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(462条消息) 欧拉回路（hierholzer算法）_逐步插入回路法_run around的博客-CSDN博客</a></p><h2 id="关键路径（AOE网）"><a href="#关键路径（AOE网）" class="headerlink" title="关键路径（AOE网）"></a>关键路径（AOE网）</h2><p>最早开始时间&#x3D;最晚开始时间</p><p>用拓扑图</p><p>最早开始时间（所有先序活动的最晚完成时间）</p><p>最晚开始时间（所有后续活动的最早开始时间减去该活动花费的时间）</p><p>注意源点的最早开始时间不一定为0，要初始化</p><p>汇点的最晚开始时间初始化为totalTime-该汇点任务的时间</p><p>非汇点的最晚开始时间为无穷</p><p>如果只是要求关键路径的长度，其实在earliest[i]初始化的时候就设置为任务的时间就行，但如果要算其他的，就还是设置为0</p><p>7 5<br>11 20 17 10 11 17 17<br>5 4<br>6 1<br>7 3<br>2 4<br>2 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yushu 1e9+7</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;zero;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;re;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line"><span class="type">int</span> to;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> in[<span class="number">100001</span>];</span><br><span class="line">vector&lt;edge&gt;edges[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> task[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> earliest[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> latest[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">in[i]=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;task[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num=m;</span><br><span class="line"><span class="type">int</span> allTime=<span class="number">0</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;input edge&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">while</span> (num--)&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">in[b]++;</span><br><span class="line">edge temp;</span><br><span class="line">temp.to=b;</span><br><span class="line">temp.weight=task[b];</span><br><span class="line">edges[a].<span class="built_in">push_back</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;input finished.&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[i]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span> (in[i]==<span class="number">0</span>)&#123;</span><br><span class="line">zero.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!zero.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> node=zero.<span class="built_in">front</span>();</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;zero:&quot;</span>&lt;&lt;node&lt;&lt;endl;</span><br><span class="line">zero.<span class="built_in">pop</span>();</span><br><span class="line">re.<span class="built_in">push_back</span>(node);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;edges[node].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> to=edges[node][i].to;</span><br><span class="line"><span class="type">int</span> weight=edges[node][i].weight;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;edge:&quot;</span>&lt;&lt;node&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;to&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;weight&lt;&lt;endl;</span><br><span class="line">earliest[to]=<span class="built_in">max</span>(earliest[to],earliest[node]+task[node]);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;to&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[to]&lt;&lt;endl;</span><br><span class="line">in[to]--;</span><br><span class="line"><span class="keyword">if</span> (in[to]==<span class="number">0</span>)&#123;</span><br><span class="line">zero.<span class="built_in">push</span>(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">allTime=<span class="built_in">max</span>(allTime,earliest[i]+task[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;reverse:&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=re.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> u=re[i];</span><br><span class="line"><span class="keyword">if</span> (edges[u].<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">latest[u]=allTime-task[u];</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;latest:[&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[u]&lt;&lt;endl;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">latest[u]=<span class="number">99999999</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;edges[u].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line"><span class="type">int</span> to=edges[u][j].to;</span><br><span class="line"><span class="type">int</span> weight=edges[u][j].weight;</span><br><span class="line">latest[u]=<span class="built_in">min</span>(latest[u],latest[to]-task[u]);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;latest:[&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[u]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[i]&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;latest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sum*=(latest[i]-earliest[i]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;allTime&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u011240016/article/details/53171808?ops_request_misc=%7B%22request_id%22:%22168784579716782425186584%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168784579716782425186584&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-53171808-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=AOE&spm=1018.2226.3001.4187">(466条消息) AOE问题总结_DrCrypto的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_44880154/article/details/114380592?ops_request_misc=&request_id=&biz_id=102&utm_term=AOE%E9%A2%98&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-114380592.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(466条消息) AOE网关键路径求解例题_关键路径例题图解_HardyDragon_CC的博客-CSDN博客</a></p><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><p><a href="https://blog.csdn.net/yc_cy1999/article/details/104580701?ops_request_misc=&request_id=&biz_id=102&utm_term=%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95%E9%A2%98%E5%8D%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104580701.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(443条消息) 2019年南京大学计算机考研复试机试真题_南大计算机专业考研机试_yc_cy1999的博客-CSDN博客</a></p><p>一个整数可以变为多少个整数相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//存所有状态</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j ++)<span class="comment">//j是容量</span></span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h2><p><a href="https://blog.csdn.net/qq12323qweeqwe/article/details/123083331?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-123083331.nonecase&spm=1018.2226.3001.4187">(462条消息) 291. 蒙德里安的梦想（状压dp）_seez的博客-CSDN博客</a></p><p>[(462条消息) <a href="https://blog.csdn.net/yl_puyu/article/details/109631735?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-109631735.nonecase&spm=1018.2226.3001.4187">状压dp] 蒙德里安的梦想(模板题+状压dp)_状压dp模板题_Ypuyu的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_27262727/article/details/105700957?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B4%AA%E5%BF%83%E9%A2%98%E7%9B%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105700957.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(462条消息) C++笔试题模版汇总(五)动态规划&#x2F;贪心_c++笔试题 考动态规划么_ai_XZP_master的博客-CSDN博客</a></p><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p>结论：把i个盘子移到另一个柱面上，需要2^i-1步</p><p><a href="https://zhuanlan.zhihu.com/p/392523306">关于汉诺塔问题 - 知乎 (zhihu.com)</a></p><h2 id="放置街灯（Placing-Lampposts-UVa-10859）-star"><a href="#放置街灯（Placing-Lampposts-UVa-10859）-star" class="headerlink" title="放置街灯（Placing Lampposts, UVa 10859）:star:"></a>放置街灯（Placing Lampposts, UVa 10859）:star:</h2><p><img src="C:\Users\11505\AppData\Roaming\Typora\typora-user-images\image-20230515221130204.png" alt="image-20230515221130204"></p><h2 id="经典贪心"><a href="#经典贪心" class="headerlink" title="经典贪心"></a>经典贪心</h2><p><a href="https://blog.csdn.net/KXL5180/article/details/82824003?ops_request_misc=%7B%22request_id%22:%22168424305316800227456811%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168424305316800227456811&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-82824003-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=UVa10382&spm=1018.2226.3001.4187">(450条消息) UVA-10382经典贪心问题，区间覆盖_uva 10382_KXL5180的博客-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//酸奶工程</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="comment">//定义long long，防止爆int</span></span><br><span class="line">ll n,s;</span><br><span class="line">ll c[<span class="number">10010</span>],y[<span class="number">10010</span>];<span class="comment">//存储费用和交互数量</span></span><br><span class="line">ll f[<span class="number">10010</span>];</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;c[i],&amp;y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            f[i]=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[i]=<span class="built_in">min</span>(c[i],f[i<span class="number">-1</span>]+s);</span><br><span class="line">        &#125;</span><br><span class="line">        sum=sum+f[i]*y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳跃问题"><a href="#跳跃问题" class="headerlink" title="跳跃问题"></a>跳跃问题</h2><p><a href="https://blog.csdn.net/weixin_41570890/article/details/110795229?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%982&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-110795229.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(462条消息) Leetcode——跳跃问题II_跳跃问题2_Purple.’’的博客-CSDN博客</a></p><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p><a href="https://blog.csdn.net/youngyangyang04/article/details/111190664?ops_request_misc=%7B%22request_id%22:%22168647702416800197016860%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168647702416800197016860&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-111190664-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C&spm=1018.2226.3001.4187">(462条消息) 「leetcode」135.分发糖果【贪心算法】详细图解_代码随想录的博客-CSDN博客</a></p><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p><a href="https://blog.csdn.net/weixin_45697774/article/details/104274713?ops_request_misc=%7B%22request_id%22:%22168667245116800197028500%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168667245116800197028500&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104274713-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E7%BA%BF%E6%AE%B5%E6%A0%91&spm=1018.2226.3001.4187">(462条消息) 线段树 从入门到进阶（超清晰，简单易懂）_线段树进阶_繁凡さん的博客-CSDN博客</a></p><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p><a href="https://blog.csdn.net/lemonxiaoxiao/article/details/108672039?ops_request_misc=%7B%22request_id%22:%22168667270816800222874127%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168667270816800222874127&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108672039-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(462条消息) 匈牙利算法详解_Amelie_xiao的博客-CSDN博客</a></p><p><strong>一个二分图中的最大匹配数等于这个图中的最小点覆盖数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> M, N;            <span class="comment">//M, N分别表示左、右侧集合的元素数量</span></span><br><span class="line"><span class="type">int</span> Map[MAXM][MAXN]; <span class="comment">//邻接矩阵存图</span></span><br><span class="line"><span class="type">int</span> p[MAXN];         <span class="comment">//记录当前右侧元素所对应的左侧元素</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN];      <span class="comment">//记录右侧元素是否已被访问过</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        <span class="keyword">if</span> (Map[i][j] &amp;&amp; !vis[j]) <span class="comment">//有边且未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[j] = <span class="literal">true</span>;                 <span class="comment">//记录状态为访问过</span></span><br><span class="line">            <span class="keyword">if</span> (p[j] == <span class="number">0</span> || <span class="built_in">match</span>(p[j])) <span class="comment">//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                p[j] = i;    <span class="comment">//当前左侧元素成为当前右侧元素的新匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回匹配成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//循环结束，仍未找到匹配，返回匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hungarian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)); <span class="comment">//重置vis数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">match</span>(i))</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>[(462条消息) 2018南京大学计算机夏令营机试第二题（回溯）_只会写臭虫的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_43175029/article/details/94670710?ops_request_misc=&request_id=&biz_id=102&utm_term=Missing">https://blog.csdn.net/weixin_43175029/article/details/94670710?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Missing</a> number  Given a positi&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-94670710.142^v88^control_2,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><p>回溯就是dfs，并且在每次dfs时记得恢复原状态；如果只需要输出一种状态，设置flag标志位</p><p>N皇后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// bool数组用来判断搜索的下一个位置是否可行</span></span><br><span class="line"><span class="comment">// col列，dg对角线，udg反对角线</span></span><br><span class="line"><span class="comment">// g[N][N]用来存路径</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// u == n 表示已经搜了n行，故输出这条路径</span></span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);   <span class="comment">// 等价于cout &lt;&lt; g[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);  <span class="comment">// 换行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 枚举u这一行，搜索合法的列</span></span><br><span class="line">    <span class="type">int</span> x = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; y ++ )</span><br><span class="line">        <span class="comment">// 剪枝(对于不满足要求的点，不再继续往下搜索)  </span></span><br><span class="line">        <span class="comment">// 这里y-x+n是左上角到右下角,y+x是左下角到右上角</span></span><br><span class="line">        <span class="keyword">if</span> (col[y] == <span class="literal">false</span> &amp;&amp; dg[y - x + n] == <span class="literal">false</span> &amp;&amp; udg[y + x] == <span class="literal">false</span>) &#123;</span><br><span class="line">            col[y] = dg[y - x + n] = udg[y + x] = <span class="literal">true</span>;</span><br><span class="line">            g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">            g[x][y] = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">// 恢复现场</span></span><br><span class="line">            col[y] = dg[y - x + n] = udg[y + x] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="建立索引树"><a href="#建立索引树" class="headerlink" title="建立索引树"></a>建立索引树</h2><p>[(462条消息) 2020北航计算机夏令营机试题目个人理解_北航夏令营 机试_四处碰壁嘤嘤怪的博客-CSDN博客](<a href="https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request_id%22:%22168715279416800185829257%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168715279416800185829257&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%8C%97%E8%88%AA%E5%A4%8F%E4%BB%A4%E8%90%A5">https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request%5Fid%22%3A%22168715279416800185829257%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168715279416800185829257&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=北航夏令营</a> 机试&amp;spm&#x3D;1018.2226.3001.4187)</p><p>注意 建树不一定要指针，数组也可</p><p>4 5<br>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分布式系统（二）分布式系统模型</title>
      <link href="/2024/06/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/06/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系统模型"><a href="#分布式系统模型" class="headerlink" title="分布式系统模型"></a>分布式系统模型</h1><h2 id="2-1-两将军问题"><a href="#2-1-两将军问题" class="headerlink" title="2.1 两将军问题"></a>2.1 两将军问题</h2><p>“两将军问题”是一个经典的分布式系统问题，旨在研究在存在故障节点的情况下如何协调两个进程之间的通信。</p><p>问题场景是两个将军分别率领一支军队进攻敌方城市。两个将军之间必须达成一致，以确定进攻时间和策略。但是，将军们分别位于两个不同的营地，只能通过信使进行通信。此外，有可能存在恶劣的天气或其它因素干扰通信，或者其中一个将军的信使被敌人抓住并修改了消息。</p><p>该问题的关键是如何确保将军之间的通信可靠，并避免消息的丢失和篡改。经典的解决方案是使用拜占庭将军问题中的拜占庭容错算法，该算法可以容忍部分节点的故障和恶意攻击。</p><p>具体实现上，将军们需要达成共识，以决定进攻时间和策略。首先，每个将军向所有其他将军发送一个决策信息，并等待回复。如果将军收到的回复都是一致的，他就可以确定其他将军的决策，并做出相应的行动。如果将军收到的回复不一致，他会将这些信息再次发送给所有其他将军，直到收到一致的回复。</p><p>在该问题中，每个将军需要知道有多少其他将军参与协调，并且需要容忍其他将军的可能失败和恶意行为。这需要设计合适的算法和协议来保证将军之间的协作和共识。</p><p>总之，“两将军问题”是一个经典的分布式系统问题，它探讨了如何在分布式系统中实现可靠通信和共识协作的问题。拜占庭容错算法提供了一种解决方案，可以容忍部分节点的故障和恶意攻击，从而确保将军之间的通信可靠性和一致性。</p><p><strong>TCP三次握手与其的关系</strong></p><p>TCP三次握手是一种建立TCP连接的过程，包括客户端发送SYN报文，服务器回复SYN+ACK报文，最后客户端回复ACK报文，建立连接。</p><p>在分布式系统中，TCP三次握手是实现可靠通信的重要手段。它确保了客户端和服务器之间的连接在建立时具有可靠性和稳定性。通过三次握手，客户端和服务器可以确保对方已经准备好进行通信，同时也可以在连接建立之前进行一些必要的信息交换和验证，如协商连接参数和检查连接的有效性等。</p><p>在分布式系统中，TCP三次握手也可以用于解决“两将军问题”，确保两个进程之间的通信可靠和一致。类似于TCP三次握手，两个进程可以通过发送和确认消息来建立连接，并在建立连接之前进行必要的验证和信息交换，以确保连接的可靠性和有效性。</p><p>总之，TCP三次握手是分布式系统中实现可靠通信的重要手段，它可以确保连接的可靠性和有效性，同时也可以应用于解决其他类似的分布式系统问题，如“两将军问题”。</p><h2 id="2-2-拜占庭将军问题"><a href="#2-2-拜占庭将军问题" class="headerlink" title="2.2 拜占庭将军问题"></a>2.2 拜占庭将军问题</h2><p>拜占庭将军问题（Byzantine Generals Problem）是分布式系统中的一个经典问题，涉及到在存在故障或恶意行为的情况下，如何进行分布式决策。</p><p>问题场景是，在拜占庭帝国，几个将军率领各自的部队围攻敌人。他们必须就进攻或撤退达成一致的决策，但是将军之间只能通过消息传递进行通信。然而，有可能存在一些叛变的将军，他们会传递虚假信息，导致其他将军做出错误的决策。</p><p>在这种情况下，如何确保将军们可以就正确的进攻或撤退做出决策，即使有些将军叛变或发生故障。</p><p>拜占庭将军问题的解决方案是拜占庭容错算法（Byzantine Fault Tolerance Algorithm）。该算法可以容忍部分节点的故障和恶意攻击，从而确保分布式系统在存在故障或恶意行为的情况下仍然能够正确地工作。</p><p>具体实现上，拜占庭容错算法需要将每个将军看作一个节点，将节点之间的通信看作消息传递。每个将军必须向其他将军发送自己的决策信息，并根据接收到的消息来做出最终的决策。</p><p>在算法中，每个将军必须决定一个信任阈值（trust threshold），即可以容忍多少个叛变节点。如果叛变节点的数量超过信任阈值，则将军不再相信这些节点传递的信息。每个将军都需要向其他将军发送自己的决策信息，并在接收到足够数量的信息后，根据这些信息来做出最终的决策。</p><p>拜占庭容错算法提供了一种解决分布式系统中存在故障或恶意行为的问题的方法，可以保证在一定程度上容忍节点的故障和恶意攻击，从而确保系统的可靠性和正确性。</p><h2 id="2-3-系统模型"><a href="#2-3-系统模型" class="headerlink" title="2.3 系统模型"></a>2.3 系统模型</h2><h3 id="2-3-1-网络链路模型"><a href="#2-3-1-网络链路模型" class="headerlink" title="2.3.1 网络链路模型"></a>2.3.1 网络链路模型</h3><p>可靠链路、公平损失链路和任意链路是三种不同类型的链路模型，它们分别描述了网络链路的不同特性。</p><ol><li>可靠链路：指传输层提供的数据传输服务是可靠的，即数据包不会丢失、重复、乱序等，而且保证数据传输的正确性。这种链路通常用于需要可靠传输的应用，例如文件传输、电子邮件等。</li><li>公平损失链路：指传输层提供的数据传输服务是不可靠的，即数据包可能会丢失、重复、乱序等，但是丢失的概率是公平的，即每个数据包有相同的丢失概率。这种链路通常用于需要低延迟和高吞吐量的应用，例如视频流和音频流。</li><li>任意链路：指传输层提供的数据传输服务是不可靠的，数据包可能会丢失、重复、乱序等，并且丢失的概率也是不确定的。这种链路通常用于互联网等大规模、不可控的网络环境中。</li></ol><p>在实际应用中，不同的链路模型适用于不同的应用场景。例如，可靠链路适用于需要可靠传输的应用，公平损失链路适用于需要低延迟和高吞吐量的应用，任意链路则适用于大规模、不可控的网络环境。</p><h3 id="2-3-2-节点故障类型"><a href="#2-3-2-节点故障类型" class="headerlink" title="2.3.2 节点故障类型"></a>2.3.2 节点故障类型</h3><p>在分布式系统中，节点故障类型主要有以下几种：</p><ol><li>宕机故障：指节点因为硬件故障、软件故障等原因而停止工作，无法处理请求和发送响应。</li><li>网络故障：指节点与网络中的其他节点失去了连接，无法正常通信。</li><li>时钟偏差故障：指节点的本地时钟与其他节点的时钟存在偏差，导致节点无法准确判断事件的先后顺序。</li><li>节点软件故障：指节点运行的软件出现了错误，导致节点无法正常处理请求和发送响应。</li><li>节点配置故障：指节点的配置文件或者参数设置出现错误，导致节点无法正常工作。</li></ol><p>以上节点故障类型都可能对分布式系统的正常运行造成影响，因此在设计和实现分布式系统时需要考虑如何处理这些故障，提高系统的容错性和可靠性。常用的方法包括备份、冗余、检查点和恢复等。</p><p>崩溃停止、崩溃恢复和拜占庭故障是分布式系统中常见的故障类型和处理方法。</p><ol><li>崩溃停止：指节点因为硬件故障、软件故障等原因而停止工作，无法处理请求和发送响应。在这种情况下，通常的做法是通过备份或者冗余机制来保证系统的可用性。</li><li>崩溃恢复：指节点在崩溃之后能够恢复正常工作。在分布式系统中，崩溃恢复通常通过检查点和恢复机制实现。检查点是指在节点正常工作的过程中定期保存系统状态的快照，当节点崩溃之后，可以通过恢复最近一次的检查点来恢复系统状态。</li><li>拜占庭故障：指节点在分布式系统中出现不可预测的错误或者故障，例如节点发送错误的消息、故意不发送消息、篡改消息等。这种故障在分布式系统中比较常见，因此需要采取特殊的处理方式。在拜占庭故障中，通常使用多数投票算法或者拜占庭容错算法来解决。多数投票算法是指节点之间通过投票来决定最终的结果，只有得到多数节点的认可才被认为是有效的。拜占庭容错算法则是一种更加复杂的算法，可以在少数节点出现故障或者恶意行为的情况下仍然保证系统的正确性。</li></ol><p>在实际应用中，分布式系统需要根据不同的故障类型和处理方式来设计和实现，提高系统的容错性和可靠性。</p><h3 id="2-3-3-按时间划分模型"><a href="#2-3-3-按时间划分模型" class="headerlink" title="2.3.3 按时间划分模型"></a>2.3.3 按时间划分模型</h3><p>同步模型、异步模型和部分同步模型是分布式系统中常见的通信模型。</p><ol><li>同步模型：指进程之间的通信是基于同步的，即发送方发送消息后需要等待接收方确认收到消息后才能继续执行。这种模型具有简单、可靠、易于实现的优点，但同时也存在效率低、容易死锁等问题。</li><li>异步模型：指进程之间的通信是基于异步的，即发送方发送消息后不需要等待接收方确认，可以直接继续执行。这种模型具有效率高、并行度高等优点，但同时也存在可靠性低、容易产生乱序等问题。</li><li>部分同步模型：指进程之间的通信既包括同步模型的特点，又包括异步模型的特点。具体来说，部分同步模型中既存在同步消息，也存在异步消息。这种模型可以在保证可靠性的同时，又能充分发挥系统的并行性能，因此在分布式系统中得到广泛应用。</li></ol><p>在实际应用中，需要根据具体的场景来选择不同的通信模型。例如，在需要保证数据一致性和可靠性的场景中，可以选择同步模型或者部分同步模型；而在需要高效并行处理的场景中，可以选择异步模型或者部分同步模型。</p><h2 id="2-4-消息语义传递"><a href="#2-4-消息语义传递" class="headerlink" title="2.4 消息语义传递"></a>2.4 消息语义传递</h2><p>消息语义传递指的是在分布式系统中，如何确保消息的正确传递和语义的一致性。在分布式系统中，消息的传递是通过网络进行的，网络通信可能会受到各种因素的干扰和影响，例如网络延迟、丢包、重复等问题。因此，在消息的传递过程中需要保证消息的正确性和语义的一致性。</p><p>在实际应用中，通常使用一些技术来保证消息的正确性和语义的一致性，例如：</p><ol><li>消息确认机制：发送方在发送消息后，需要等待接收方的确认消息，以确保消息被正确地接收。如果发送方在一定时间内没有收到确认消息，就会重新发送消息，以保证消息的可靠传递。</li><li>消息重复检测：接收方在接收到消息后，会对消息进行唯一性检测，以避免重复处理消息，从而保证消息语义的一致性。</li><li>事务机制：在涉及到多个操作的场景中，可以使用事务机制来保证操作的原子性、一致性和持久性。例如，数据库中的事务机制可以保证一组数据库操作要么全部执行成功，要么全部执行失败，从而确保数据的一致性和可靠性。</li><li>消息序列化和反序列化：在消息的传递过程中，需要将消息转换成网络传输格式进行传输。因此，需要对消息进行序列化和反序列化，以保证消息的正确性和可靠性。</li></ol><p>综上所述，消息语义传递是分布式系统中非常重要的一环，需要采取各种技术手段来确保消息的正确性和语义的一致性，从而保证分布式系统的稳定运行。</p><p>幂等性指的是在进行多次相同操作时，最终的结果与只执行一次操作时的结果是一致的。在分布式系统中，由于网络通信等因素的影响，可能会导致消息被重复传递，因此，需要考虑如何保证消息的幂等性。</p><p>具体来说，消息幂等性通常可以通过以下几种方式来实现：</p><ol><li>去重：对于已经处理过的消息，可以进行去重操作，避免重复处理相同的消息。</li><li>乐观锁：使用乐观锁机制可以避免多次修改同一资源导致的数据不一致问题。</li><li>版本号：在对资源进行修改时，可以使用版本号来确保修改的原子性和一致性。</li><li>业务逻辑实现：在实现业务逻辑时，可以通过设计合理的业务逻辑来确保多次执行相同操作时的结果是一致的。</li></ol><p>综上所述，消息语义和幂等性在分布式系统中都是非常重要的概念。消息语义保证了消息的正确性和语义的一致性，而幂等性则保证了操作的原子性和一致性，从而确保分布式系统的稳定运行。 </p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 深入理解分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
