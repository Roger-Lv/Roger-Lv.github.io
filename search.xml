<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java刷题</title>
      <link href="/2024/06/24/Java%20algo/"/>
      <url>/2024/06/24/Java%20algo/</url>
      
        <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p><a href="https://blog.csdn.net/leader_song/article/details/132094080?ops_request_misc=%7B%22request_id%22:%22171151104816800211548110%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171151104816800211548110&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-132094080-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%872023&spm=1018.2226.3001.4187">2024年 Java 面试八股文（20w字）_java八股文2023-CSDN博客</a></p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>[Spring中的IOC和AOP是什么意思？-CSDN博客](<a href="https://blog.csdn.net/weixin_45704311/article/details/124295453?ops_request_misc=%7B%22request_id%22:%22171152017116777224421689%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171152017116777224421689&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-124295453-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=IOC">https://blog.csdn.net/weixin_45704311/article/details/124295453?ops_request_misc=%7B%22request%5Fid%22%3A%22171152017116777224421689%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171152017116777224421689&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-124295453-null-null.142^v100^pc_search_result_base2&amp;utm_term=IOC</a> AOP&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p><a href="https://blog.csdn.net/crazymakercircle/article/details/125059491?ops_request_misc=%7B%22request_id%22:%22171164453116800225568300%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171164453116800225568300&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125059491-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=sentinel&spm=1018.2226.3001.4187">sentinel （史上最全）-CSDN博客</a></p><h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p><a href="https://flydean.blog.csdn.net/article/details/113803536?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-113803536-blog-133955312.235%5Ev43%5Epc_blog_bottom_relevance_base7&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-113803536-blog-133955312.235%5Ev43%5Epc_blog_bottom_relevance_base7&utm_relevant_index=2">gradle中的build script详解_gradle buildscript-CSDN博客</a></p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>[JAVA内存分配原理解析–栈、堆、常量池_堆,栈,常量池详解-CSDN博客](<a href="https://blog.csdn.net/gb702250823/article/details/92801716?ops_request_misc=%7B%22request_id%22:%22171151029816800225558425%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171151029816800225558425&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-92801716-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=java">https://blog.csdn.net/gb702250823/article/details/92801716?ops_request_misc=%7B%22request%5Fid%22%3A%22171151029816800225558425%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171151029816800225558425&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-92801716-null-null.142^v100^pc_search_result_base2&amp;utm_term=java</a> 常量池 栈 堆&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><p><a href="https://blog.csdn.net/CodePlayMe/article/details/130724568?ops_request_misc=%7B%22request_id%22:%22170261719316777224420083%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170261719316777224420083&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-130724568-null-null.142%5Ev96%5Epc_search_result_base2&utm_term=java%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1018.2226.3001.4187">java刷题前常用的数据结构及方法_java刷题常用方法-CSDN博客</a></p><h3 id="int-转Integer"><a href="#int-转Integer" class="headerlink" title="int 转Integer"></a>int 转Integer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(num);</span><br></pre></td></tr></table></figure><h3 id="int到string数据类型的转换"><a href="#int到string数据类型的转换" class="headerlink" title="int到string数据类型的转换"></a><strong>int到string数据类型的转换</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">Integer.toString(num);</span><br></pre></td></tr></table></figure><p>或者<strong>String.valueOf(num);</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="comment">// 引号带上数据</span></span><br><span class="line">    <span class="type">int</span> num=<span class="number">100</span>;</span><br><span class="line">    String a=<span class="string">&quot;&quot;</span>+num;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">   <span class="comment">// 直接类型转换</span></span><br><span class="line">    Integer num2=<span class="number">100</span>;</span><br><span class="line">    String b=Integer.toString(num2);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串定义</span></span><br><span class="line">    String c=String.valueOf(num2);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String到int类型的转换"><a href="#String到int类型的转换" class="headerlink" title="String到int类型的转换"></a><strong>String到int类型的转换</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line">    <span class="comment">// parseInt</span></span><br><span class="line">    <span class="comment">// 加上static的方法，方法属于类，需要使用类名进行调用，没有加上static的，方法属于对象，可以new一个对象再调用</span></span><br><span class="line">    <span class="type">int</span> e=Integer.parseInt(s);</span><br><span class="line">    System.out.println(e);</span><br></pre></td></tr></table></figure><h3 id="ArrayList动态转换为Array数组"><a href="#ArrayList动态转换为Array数组" class="headerlink" title="ArrayList动态转换为Array数组"></a>ArrayList动态转换为Array数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String [] array=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[size]);</span><br></pre></td></tr></table></figure><p>除此之外，<strong>ArrayList</strong>还有以下的常用的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void add(int index, E element) 将指定元素插入此列表中的指定位置。</span><br><span class="line">boolean add(E e)将指定的元素追加到此列表的末尾。</span><br><span class="line">boolean contains(Object o)如果此列表包含指定的元素，则返回 true 。</span><br><span class="line">E get(int index) 返回此列表中指定位置的元素。</span><br><span class="line">int indexOf(Object o) 返回此列表中第一次出现的指定元素的索引，如果此列表不包含该元素，则返回-1。</span><br><span class="line">boolean isEmpty() 如果此列表不包含任何元素，则返回 true 。</span><br><span class="line">int lastIndexOf(Object o)返回此列表中指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-1。</span><br><span class="line">E remove(int index) 删除此列表中指定位置的元素。</span><br><span class="line">boolean remove(Object o)从该列表中删除指定元素的第一个匹配项（如果存在）</span><br><span class="line">E set(int index, E element) 用指定的元素替换此列表中指定位置的元素。</span><br><span class="line">int size() 返回此列表中的元素数。</span><br></pre></td></tr></table></figure><h3 id="Array数组转为ArrayList"><a href="#Array数组转为ArrayList" class="headerlink" title="Array数组转为ArrayList"></a>Array数组转为ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;list= Arrays.asList(array)</span><br></pre></td></tr></table></figure><h3 id="Arrays的常用方法"><a href="#Arrays的常用方法" class="headerlink" title="Arrays的常用方法"></a>Arrays的常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建数组</span></span><br><span class="line"><span class="type">int</span> nums[]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//获取长度</span></span><br><span class="line">nums.length;</span><br><span class="line"></span><br><span class="line">Arrays.toString(nums)</span><br><span class="line">Arrays.sort(nums)<span class="comment">//升序</span></span><br><span class="line">Arrays.fill(nums)<span class="comment">//初始化数组的时候会用到（比如全部给-1）</span></span><br><span class="line">Arrays.equal(nums)</span><br><span class="line">Arrays.copyof(nums)</span><br><span class="line">Arrays.compare(nums)</span><br><span class="line">Arrays.binarySearch(nums)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ArrayList的常用用法"><a href="#ArrayList的常用用法" class="headerlink" title="ArrayList的常用用法"></a>ArrayList的常用用法</h3><p>Array：只可存储基本数据类型和对象。被设置为<strong>固定大小</strong>。所包含的方法没有ArrayList多<br>ArrayList：只能<strong>存储对象</strong>。是一个<strong>可变数组</strong>，大小可自动调整。有很多操作方法：<a href="https://so.csdn.net/so/search?q=addAll&spm=1001.2101.3001.7020">addAll</a>、removeAll、iteration等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        sites.remove(<span class="number">3</span>); <span class="comment">// 删除第四个元素</span></span><br><span class="line"><span class="comment">//计算大小</span></span><br><span class="line">sites.size();</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">Collections.sort(sites);</span><br><span class="line"><span class="comment">//是否包含</span></span><br><span class="line">sites.contains();</span><br><span class="line"><span class="comment">//addAll()</span></span><br><span class="line">这个方法括号中类型是list，拼接</span><br><span class="line">    </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> 将指定元素插入此列表中的指定位置。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>将指定的元素追加到此列表的末尾。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>如果此列表包含指定的元素，则返回 <span class="literal">true</span> 。</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> 返回此列表中指定位置的元素。</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> 返回此列表中第一次出现的指定元素的索引，如果此列表不包含该元素，则返回-<span class="number">1</span>。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> 如果此列表不包含任何元素，则返回 <span class="literal">true</span> 。</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>返回此列表中指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-<span class="number">1</span>。</span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> 删除此列表中指定位置的元素。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>从该列表中删除指定元素的第一个匹配项（如果存在）</span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> 用指定的元素替换此列表中指定位置的元素。</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> 返回此列表中的元素数。</span><br></pre></td></tr></table></figure><h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a><strong>Collections类</strong></h3><p>对list进行反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.reverse(list)</span><br></pre></td></tr></table></figure><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String获取长度是.length()（要加括号）</p><p><a href="https://blog.csdn.net/weixin_62756510/article/details/124698100?ops_request_misc=%7B%22request_id%22:%22171013865416777224481954%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171013865416777224481954&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124698100-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=stringbuilder&spm=1018.2226.3001.4187">String、StringBuilder类超详细笔记_stringbuilder可以用equalsignorecase-CSDN博客</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">重要：<span class="type">char</span> charAt​(<span class="type">int</span> index) 返回指定索引处的 <span class="type">char</span>值。</span><br><span class="line"><span class="type">int</span> indexOf​(<span class="type">int</span> ch) 返回指定字符第一次出现的字符串中的索引。</span><br><span class="line">- <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> ，当且仅当， length()是 <span class="number">0</span> 返回 <span class="literal">true</span></span><br><span class="line"><span class="type">int</span> lastIndexOf​(<span class="type">int</span> ch) 返回指定字符最后一次出现的字符串中的索引。</span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> 返回此字符串的长度。</span><br><span class="line">String replace​(CharSequence target, CharSequence replacement) 将此字符串中与文字目标序列匹配的每个子字符串替换为指定的文字替换序列。</span><br><span class="line">String replaceAll​(String regex, String replacement) 将给定替换的给定 regular expression匹配的此字符串的每个子字符串替换。</span><br><span class="line">String[] split​(String regex) 将此字符串拆分为给定 regular expression的匹配 项 。</span><br><span class="line"><span class="type">boolean</span> startsWith​(String prefix) 测试此字符串是否以指定的前缀开头。</span><br><span class="line">String substring​(<span class="type">int</span> beginIndex) 返回一个字符串，该字符串是此字符串的子字符串。</span><br><span class="line"><span class="type">char</span>[] toCharArray() 将此字符串转换为新的字符数组。</span><br><span class="line">String <span class="title function_">toLowerCase</span><span class="params">()</span> 使用默认语言环境的规则将此 String所有字符转换为小写。</span><br><span class="line">String <span class="title function_">toUpperCase</span><span class="params">()</span> 使用默认语言环境的规则将此 String所有字符转换为大写。</span><br><span class="line">比较大小的话</span><br><span class="line">    String c= <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">c.compareTo(b);</span><br><span class="line">或者</span><br><span class="line">    c.equals(b);</span><br></pre></td></tr></table></figure><h3 id="字符类Chracter"><a href="#字符类Chracter" class="headerlink" title="字符类Chracter"></a>字符类Chracter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Character.compare(<span class="type">char</span> x, <span class="type">char</span> y) 以数字方式比较两个 <span class="type">char</span>值。</span><br><span class="line">Character.equals(Object obj) 将此对象与指定的对象进行比较。</span><br><span class="line">Character.isDigit(<span class="type">char</span> ch) 确定指定的字符是否为数字。</span><br><span class="line">Character.isLetter(<span class="type">char</span> ch) 确定指定的字符是否为字母。</span><br><span class="line">Character.isLowerCase(<span class="type">char</span> ch) 确定指定的字符是否为小写字符。</span><br><span class="line">Character.isUpperCase(<span class="type">char</span> ch) 确定指定的字符是否为大写字符。</span><br><span class="line">Character.toString(<span class="type">char</span> c) 返回表示指定的 <span class="type">char</span>的 String对象。</span><br><span class="line">Character.valueOf(<span class="type">char</span> c) 返回表示指定的 <span class="type">char</span>值的 Character实例。</span><br><span class="line">Character.toLowerCase(<span class="string">&quot;A&quot;</span>); 转为小写</span><br><span class="line">Character.toUpperCase(<span class="string">&quot;a&quot;</span>); 转为大写</span><br><span class="line"><span class="comment">//char数组转String</span></span><br><span class="line"><span class="type">char</span>[] data = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data);</span><br><span class="line">System.out.println(str);  <span class="comment">//输出abc</span></span><br></pre></td></tr></table></figure><h3 id="字符串构造器StringBuilder"><a href="#字符串构造器StringBuilder" class="headerlink" title="字符串构造器StringBuilder"></a>字符串构造器StringBuilder</h3><p><a href="https://blog.csdn.net/qq_46634307/article/details/126283200?ops_request_misc=%7B%22request_id%22:%22171014028016800192229813%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=171014028016800192229813&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-126283200-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=stringbuilder%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%AD%97%E7%AC%A6&spm=1018.2226.3001.4187">Java-修改 String 指定位置的字符最全方法总结（StringBuilder 和 StringBuffer 的使用以及区别）_string替换指定位置字符-CSDN博客</a></p><p><a href="https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-89966303-blog-124698100.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-89966303-blog-124698100.235%5Ev43%5Epc_blog_bottom_relevance_base1&utm_relevant_index=1">String、StringBuffer与StringBuilder之间区别_string stringbuffer stringbuilder区别-CSDN博客</a></p><p>可变字符串，StringBuilder对象的内容可以修改。</p><ol><li><p>StringBuilder类的常用方法</p><ol><li><p>append()方法<br>使用append()方法可实现字符串的拼接操作，返回拼接后的StringBuilder对象。</p></li><li><p>reverse()方法<br>使用reverse()方法可实现StringBuilder字符串的反转操作。</p></li><li><p>delete(int start, int end)方法<br>删除字符串中指定索引范围为 [start,end) 的所有内容。</p><p>Java中大多数范围均为左闭右开区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">sb.delete(<span class="number">5</span>,<span class="number">8</span>);  <span class="comment">//删除索引范围为[5,8)内的所有内容，即从w开始删除到l之前</span></span><br><span class="line">System.out.println(sb);  <span class="comment">//输出hellold</span></span><br></pre></td></tr></table></figure></li><li><p>insert(int start, 任意数据类型)方法<br>在索引start处开始插入任意数据类型的内容。插入内容的起始索引是start。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">sb1.insert(<span class="number">2</span>,<span class="number">77</span>);</span><br><span class="line">System.out.println(sb1);  <span class="comment">//输出he77llo</span></span><br><span class="line">sb1.insert(<span class="number">3</span>,<span class="string">&quot;ooo&quot;</span>);</span><br><span class="line">System.out.println(sb1);  <span class="comment">//输出he7ooo7llo</span></span><br></pre></td></tr></table></figure></li><li><p>setCharAt(index,character)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.setCharAt(j,Character.toUpperCase(sb.charAt(j)));</span><br></pre></td></tr></table></figure></li></ol></li><li><p>StringBuilder与String的相互转换<br> 1）String转为StringBuilder<br> ① 构造方法StringBuilder(String str)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>② 字符串拼接方法append(String str)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><p>2）StringBuilder转为String<br>通过StringBuilder对象调用toString()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">String、StringBuilder、StringBuffer的区别</span><br><span class="line">String为不可变字符串类，StringBuilder、StringBuffer为可变字符串类。</span><br><span class="line">StringBuilder类性能较高，但存在线程安全问题; StringBuffer类线程安全，但性能较差。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="双链表LinkedList"><a href="#双链表LinkedList" class="headerlink" title="双链表LinkedList"></a>双链表LinkedList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> <span class="comment">// 判断链表中是否存在元素o 复杂度O(N)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span></span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span> <span class="comment">//删除，返回的是删除的元素</span></span><br><span class="line">E getFirst/Last()</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">( E e)</span></span><br><span class="line">Collections.reverse(link); <span class="comment">// 翻转链表</span></span><br></pre></td></tr></table></figure><h3 id="哈希表Hashmap"><a href="#哈希表Hashmap" class="headerlink" title="哈希表Hashmap"></a>哈希表Hashmap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>如果这个映射包含指定键映射，则返回<span class="literal">true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> 如果此映射将一个或多个键映射到指定值，则返回 <span class="literal">true</span> 。</span><br><span class="line">V <span class="title function_">get</span><span class="params">(Object key)</span> 返回指定键映射到的值，如果此映射不包含键的映射，则返回 <span class="literal">null</span> 。</span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span> 将指定的值与此映射中的指定键相关联。</span><br><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span> 从此映射中删除指定键的映射（如果存在）。</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> 返回此映射中键 - 值映射的数量。</span><br><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> 返回此映射中包含的值的Collection视图。</span><br><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> 返回此映射中包含的键的Set视图。</span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> 返回指定键映射到的值，如果此映射不包含键的映射，则返回 defaultValue 。这个方法继承自Map接口</span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> 如果key存在则什么都不做，否则put()，并且返回当前值</span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射的Set视图。</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 初始化哈希表 */</span></span><br><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加操作 */</span></span><br><span class="line"><span class="comment">// 在哈希表中添加键值对 (key, value)</span></span><br><span class="line">map.put(<span class="number">12836</span>, <span class="string">&quot;小哈&quot;</span>);   </span><br><span class="line">map.put(<span class="number">15937</span>, <span class="string">&quot;小啰&quot;</span>);   </span><br><span class="line">map.put(<span class="number">16750</span>, <span class="string">&quot;小算&quot;</span>);   </span><br><span class="line">map.put(<span class="number">13276</span>, <span class="string">&quot;小法&quot;</span>);</span><br><span class="line">map.put(<span class="number">10583</span>, <span class="string">&quot;小鸭&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询操作 */</span></span><br><span class="line"><span class="comment">// 向哈希表中输入键 key ，得到值 value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> map.get(<span class="number">15937</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除操作 */</span></span><br><span class="line"><span class="comment">// 在哈希表中删除键值对 (key, value)</span></span><br><span class="line">map.remove(<span class="number">10583</span>);</span><br></pre></td></tr></table></figure><h3 id="哈希集合HashSet"><a href="#哈希集合HashSet" class="headerlink" title="哈希集合HashSet"></a>哈希集合HashSet</h3><p>[【Java 基础篇】Java Set 详解-CSDN博客](<a href="https://blog.csdn.net/qq_21484461/article/details/131383848?ops_request_misc=%7B%22request_id%22:%22171015290416800180682690%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171015290416800180682690&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131383848-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=Java">https://blog.csdn.net/qq_21484461/article/details/131383848?ops_request_misc=%7B%22request%5Fid%22%3A%22171015290416800180682690%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171015290416800180682690&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131383848-null-null.142^v99^pc_search_result_base2&amp;utm_term=Java</a> set&amp;spm&#x3D;1018.2226.3001.4187)</p><p>不能保证集合迭代的顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> 如果指定的元素尚不存在，则将其添加到此集合中。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> 如果存在，则从该集合中移除指定的元素。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> 如果此set包含指定的元素，则返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h3><p>栈，后进先出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化栈 */</span></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入栈 */</span></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出栈 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> stack.isEmpty();</span><br></pre></td></tr></table></figure><h3 id="队列Queue、双端队列Deque（都可用LinkedList来实例化，因为二者都是接口）"><a href="#队列Queue、双端队列Deque（都可用LinkedList来实例化，因为二者都是接口）" class="headerlink" title="队列Queue、双端队列Deque（都可用LinkedList来实例化，因为二者都是接口）"></a>队列Queue、双端队列Deque（都可用LinkedList来实例化，因为二者都是接口）</h3><p>队列，先进先出，Queue和Deque都是接口，而LinkedList类继承了这两个队列，<strong>可以是用LinkedList来实例化Queue或者Deque</strong>，可以作为单向队列或者双向队列来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Queue</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> 将指定元素插入此列表中的指定位置。</span><br><span class="line">E <span class="title function_">element</span><span class="params">()</span> 检索但不删除此列表的头部（第一个元素）。</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> 返回此列表中指定位置的元素。</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> 返回此列表中第一次出现的指定元素的索引，如果此列表不包含该元素，则返回-<span class="number">1</span>。</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> 返回此列表中指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-<span class="number">1</span>。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> 将指定的元素添加为此列表的尾部（最后一个元素）。</span><br><span class="line">E <span class="title function_">peek</span><span class="params">()</span> 检索但不删除此列表的头部（第一个元素）</span><br><span class="line">E <span class="title function_">poll</span><span class="params">()</span> 检索并删除此列表的头部（第一个元素）。</span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> 用指定的元素替换此列表中指定位置的元素。</span><br><span class="line"><span class="comment">/* 翻转队列 */</span></span><br><span class="line">Collections.reverse(queue) </span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> queue.isEmpty();</span><br></pre></td></tr></table></figure><p>双端队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化双向队列 */</span></span><br><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">deque.offerLast(<span class="number">2</span>);   <span class="comment">// 添加至队尾</span></span><br><span class="line">deque.offerLast(<span class="number">5</span>);</span><br><span class="line">deque.offerLast(<span class="number">4</span>);</span><br><span class="line">deque.offerFirst(<span class="number">3</span>);  <span class="comment">// 添加至队首</span></span><br><span class="line">deque.offerFirst(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peekFirst</span> <span class="operator">=</span> deque.peekFirst();  <span class="comment">// 队首元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peekLast</span> <span class="operator">=</span> deque.peekLast();    <span class="comment">// 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">popFirst</span> <span class="operator">=</span> deque.pollFirst();  <span class="comment">// 队首元素出队</span></span><br><span class="line"><span class="type">int</span> <span class="variable">popLast</span> <span class="operator">=</span> deque.pollLast();    <span class="comment">// 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> deque.isEmpty();</span><br></pre></td></tr></table></figure><p>…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList可以作为堆栈使用，并且在类中实现了对应的方法</span><br><span class="line">E <span class="title function_">pop</span><span class="params">()</span> 弹出此列表所代表的堆栈中的元素。</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> 将元素推送到此列表所表示的堆栈上。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优先队列-作为堆来用"><a href="#优先队列-作为堆来用" class="headerlink" title="优先队列(作为堆来用)"></a>优先队列(作为堆来用)</h3><p>默认小顶堆，但如果是数据结构就还是要重写comparator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//读</span></span><br><span class="line">minHeap.peek();</span><br><span class="line">minHeap.poll();(会弹出)</span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line">minHeap.add();</span><br><span class="line">minHeap.offer();</span><br><span class="line"><span class="comment">//优先队列自然排序示例</span></span><br><span class="line">Queue&lt;Integer&gt; integerPriorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">7</span>);<span class="comment">//容量为7</span></span><br><span class="line"><span class="comment">//优先队列使用示例</span></span><br><span class="line">Queue&lt;Customer&gt; customerPriorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(idComparator);</span><br><span class="line"><span class="comment">//匿名Comparator实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Customer&gt; idComparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Customer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Customer c1, Customer c2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (c1.getId() - c2.getId());<span class="comment">//这是小顶堆，反着写就是大顶堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化堆 */</span></span><br><span class="line"><span class="comment">// 初始化小顶堆</span></span><br><span class="line">Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 初始化大顶堆（使用 lambda 表达式修改 Comparator 即可）</span></span><br><span class="line">Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入堆 */</span></span><br><span class="line">maxHeap.offer(<span class="number">1</span>);</span><br><span class="line">maxHeap.offer(<span class="number">3</span>);</span><br><span class="line">maxHeap.offer(<span class="number">2</span>);</span><br><span class="line">maxHeap.offer(<span class="number">5</span>);</span><br><span class="line">maxHeap.offer(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取堆顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> maxHeap.peek(); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 堆顶元素出堆 */</span></span><br><span class="line"><span class="comment">// 出堆元素会形成一个从大到小的序列</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 5</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 4</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 3</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 2</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取堆大小 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> maxHeap.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断堆是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> maxHeap.isEmpty();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入列表并建堆 */</span></span><br><span class="line">minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>邻接矩阵</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于邻接矩阵实现的无向图类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjMat</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; vertices; <span class="comment">// 顶点列表，元素代表“顶点值”，索引代表“顶点索引”</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; adjMat; <span class="comment">// 邻接矩阵，行列索引对应“顶点索引”</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphAdjMat</span><span class="params">(<span class="type">int</span>[] vertices, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertices = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.adjMat = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vertices) &#123;</span><br><span class="line">            addVertex(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加边</span></span><br><span class="line">        <span class="comment">// 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">            addEdge(e[<span class="number">0</span>], e[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取顶点数量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertices.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加顶点 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addVertex</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> size();</span><br><span class="line">        <span class="comment">// 向顶点列表中添加新顶点的值</span></span><br><span class="line">        vertices.add(val);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中添加一行</span></span><br><span class="line">        List&lt;Integer&gt; newRow = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            newRow.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        adjMat.add(newRow);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中添加一列</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; row : adjMat) &#123;</span><br><span class="line">            row.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除顶点 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeVertex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="comment">// 在顶点列表中移除索引 index 的顶点</span></span><br><span class="line">        vertices.remove(index);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中删除索引 index 的行</span></span><br><span class="line">        adjMat.remove(index);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中删除索引 index 的列</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; row : adjMat) &#123;</span><br><span class="line">            row.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加边 */</span></span><br><span class="line">    <span class="comment">// 参数 i, j 对应 vertices 元素索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引越界与相等处理</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= size() || j &gt;= size() || i == j)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="comment">// 在无向图中，邻接矩阵关于主对角线对称，即满足 (i, j) == (j, i)</span></span><br><span class="line">        adjMat.get(i).set(j, <span class="number">1</span>);</span><br><span class="line">        adjMat.get(j).set(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除边 */</span></span><br><span class="line">    <span class="comment">// 参数 i, j 对应 vertices 元素索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引越界与相等处理</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= size() || j &gt;= size() || i == j)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        adjMat.get(i).set(j, <span class="number">0</span>);</span><br><span class="line">        adjMat.get(j).set(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印邻接矩阵 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;顶点列表 = &quot;</span>);</span><br><span class="line">        System.out.println(vertices);</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接矩阵 =&quot;</span>);</span><br><span class="line">        PrintUtil.printMatrix(adjMat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邻接表的BFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 广度优先遍历 */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line">List&lt;Vertex&gt; <span class="title function_">graphBFS</span><span class="params">(GraphAdjList graph, Vertex startVet)</span> &#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    List&lt;Vertex&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    Set&lt;Vertex&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    visited.add(startVet);</span><br><span class="line">    <span class="comment">// 队列用于实现 BFS</span></span><br><span class="line">    Queue&lt;Vertex&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    que.offer(startVet);</span><br><span class="line">    <span class="comment">// 以顶点 vet 为起点，循环直至访问完所有顶点</span></span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">vet</span> <span class="operator">=</span> que.poll(); <span class="comment">// 队首顶点出队</span></span><br><span class="line">        res.add(vet);            <span class="comment">// 记录访问顶点</span></span><br><span class="line">        <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">        <span class="keyword">for</span> (Vertex adjVet : graph.adjList.get(vet)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(adjVet))</span><br><span class="line">                <span class="keyword">continue</span>;        <span class="comment">// 跳过已被访问的顶点</span></span><br><span class="line">            que.offer(adjVet);   <span class="comment">// 只入队未访问的顶点</span></span><br><span class="line">            visited.add(adjVet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回顶点遍历序列</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邻接表的DFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 深度优先遍历辅助函数 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(GraphAdjList graph, Set&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet)</span> &#123;</span><br><span class="line">    res.add(vet);     <span class="comment">// 记录访问顶点</span></span><br><span class="line">    visited.add(vet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex adjVet : graph.adjList.get(vet)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(adjVet))</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过已被访问的顶点</span></span><br><span class="line">        <span class="comment">// 递归访问邻接顶点</span></span><br><span class="line">        dfs(graph, visited, res, adjVet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 深度优先遍历 */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line">List&lt;Vertex&gt; <span class="title function_">graphDFS</span><span class="params">(GraphAdjList graph, Vertex startVet)</span> &#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    List&lt;Vertex&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    Set&lt;Vertex&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    dfs(graph, visited, res, startVet);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="构建树（前序-中序）"><a href="#构建树（前序-中序）" class="headerlink" title="构建树（前序+中序）"></a>构建树（前序+中序）</h4><p><a href="https://www.hello-algo.com/chapter_divide_and_conquer/build_binary_tree_problem/#3">12.3  构建树问题 - Hello 算法 (hello-algo.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构建二叉树：分治 */</span></span><br><span class="line">TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] preorder, Map&lt;Integer, Integer&gt; inorderMap, <span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 子树区间为空时终止</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 初始化根节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[i]);</span><br><span class="line">    <span class="comment">// 查询 m ，从而划分左右子树</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> inorderMap.get(preorder[i]);</span><br><span class="line">    <span class="comment">// 子问题：构建左子树</span></span><br><span class="line">    root.left = dfs(preorder, inorderMap, i + <span class="number">1</span>, l, m - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 子问题：构建右子树</span></span><br><span class="line">    root.right = dfs(preorder, inorderMap, i + <span class="number">1</span> + m - l, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//构建右子树稍微复杂一些。首先，需要确定右子树的根节点在前序遍历中的位置。由于左子树的根节点之后的所有元素都属于右子树，所以右子树的根节点在前序遍历中的位置是 i + 1 + (m - l)。这里的 m - l 表示左子树的大小，即左子树有多少个节点。</span></span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构建二叉树 */</span></span><br><span class="line">TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化哈希表，存储 inorder 元素到索引的映射</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; inorderMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        inorderMap.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> dfs(preorder, inorderMap, <span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回溯问题"><a href="#回溯问题" class="headerlink" title="回溯问题"></a>回溯问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(State state, List&lt;Choice&gt; choices, List&lt;State&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否为解</span></span><br><span class="line">    <span class="keyword">if</span> (isSolution(state)) &#123;</span><br><span class="line">        <span class="comment">// 记录解</span></span><br><span class="line">        recordSolution(state, res);</span><br><span class="line">        <span class="comment">// 不再继续搜索</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (Choice choice : choices) &#123;</span><br><span class="line">        <span class="comment">// 剪枝：判断选择是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (isValid(state, choice)) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            makeChoice(state, choice);</span><br><span class="line">            backtrack(state, choices, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            undoChoice(state, choice);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：全排列 I */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span>[] choices, <span class="type">boolean</span>[] selected, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 当状态长度等于元素数量时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (state.size() == choices.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; choices.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">choice</span> <span class="operator">=</span> choices[i];</span><br><span class="line">        <span class="comment">// 剪枝：不允许重复选择元素</span></span><br><span class="line">        <span class="keyword">if</span> (!selected[i]) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            selected[i] = <span class="literal">true</span>;</span><br><span class="line">            state.add(choice);</span><br><span class="line">            <span class="comment">// 进行下一轮选择</span></span><br><span class="line">            backtrack(state, choices, selected, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            selected[i] = <span class="literal">false</span>;</span><br><span class="line">            state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全排列 I */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permutationsI</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    backtrack(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(), nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length], res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子集和问题"><a href="#子集和问题" class="headerlink" title="子集和问题"></a>子集和问题</h4><p>类似于全排列问题，我们可以把子集的生成过程想象成一系列选择的结果，并在选择过程中实时更新“元素和”，当元素和等于 <code>target</code> 时，就将子集记录至结果列表。</p><p>而与全排列问题不同的是，<strong>本题集合中的元素可以被无限次选取</strong>，因此无须借助 <code>selected</code> 布尔列表来记录元素是否已被选择。我们可以对全排列代码进行小幅修改，初步得到解题代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：子集和 I */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span> target, <span class="type">int</span> total, <span class="type">int</span>[] choices, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (total == target) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; choices.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝：若子集和超过 target ，则跳过该选择</span></span><br><span class="line">        <span class="keyword">if</span> (total + choices[i] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新元素和 total</span></span><br><span class="line">        state.add(choices[i]);</span><br><span class="line">        <span class="comment">// 进行下一轮选择</span></span><br><span class="line">        backtrack(state, target, total + choices[i], choices, res);</span><br><span class="line">        <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">        state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解子集和 I（包含重复子集） */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumINaive</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 状态（子集）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子集和</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 结果列表（子集列表）</span></span><br><span class="line">    backtrack(state, target, total, nums, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样的问题是，其在进行选取的时候，会造成重复，解决办法是先排序</p><ul><li>在开启搜索前，先将数组 <code>nums</code> 排序。在遍历所有选择时，<strong>当子集和超过 <code>target</code> 时直接结束循环</strong>，因为后边的元素更大，其子集和一定超过 <code>target</code> 。</li><li>省去元素和变量 <code>total</code> ，<strong>通过在 <code>target</code> 上执行减法来统计元素和</strong>，当 <code>target</code> 等于 0 时记录解。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：子集和 I */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span> target, <span class="type">int</span>[] choices, <span class="type">int</span> start, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="comment">// 剪枝二：从 start 开始遍历，避免生成重复子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; choices.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝一：若子集和超过 target ，则直接结束循环</span></span><br><span class="line">        <span class="comment">// 这是因为数组已排序，后边元素更大，子集和一定超过 target</span></span><br><span class="line">        <span class="keyword">if</span> (target - choices[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新 target, start</span></span><br><span class="line">        state.add(choices[i]);</span><br><span class="line">        <span class="comment">// 进行下一轮选择</span></span><br><span class="line">        backtrack(state, target - choices[i], choices, i, res);</span><br><span class="line">        <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">        state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解子集和 I */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumI</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 状态（子集）</span></span><br><span class="line">    Arrays.sort(nums); <span class="comment">// 对 nums 进行排序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 遍历起始点</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 结果列表（子集列表）</span></span><br><span class="line">    backtrack(state, target, nums, start, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="N皇后问题（经典）"><a href="#N皇后问题（经典）" class="headerlink" title="N皇后问题（经典）"></a>N皇后问题（经典）</h4><p><a href="https://www.hello-algo.com/chapter_backtracking/n_queens_problem/#3">13.4  N 皇后问题 - Hello 算法 (hello-algo.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：n 皇后 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> n, List&lt;List&lt;String&gt;&gt; state, List&lt;List&lt;List&lt;String&gt;&gt;&gt; res,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span>[] cols, <span class="type">boolean</span>[] diags1, <span class="type">boolean</span>[] diags2)</span> &#123;</span><br><span class="line">    <span class="comment">// 当放置完所有行时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; copyState = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; sRow : state) &#123;</span><br><span class="line">            copyState.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(sRow));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(copyState);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">// 计算该格子对应的主对角线和次对角线</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">diag1</span> <span class="operator">=</span> row - col + n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diag2</span> <span class="operator">=</span> row + col;</span><br><span class="line">        <span class="comment">// 剪枝：不允许该格子所在列、主对角线、次对角线上存在皇后</span></span><br><span class="line">        <span class="keyword">if</span> (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) &#123;</span><br><span class="line">            <span class="comment">// 尝试：将皇后放置在该格子</span></span><br><span class="line">            state.get(row).set(col, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 放置下一行</span></span><br><span class="line">            backtrack(row + <span class="number">1</span>, n, state, res, cols, diags1, diags2);</span><br><span class="line">            <span class="comment">// 回退：将该格子恢复为空位</span></span><br><span class="line">            state.get(row).set(col, <span class="string">&quot;#&quot;</span>);</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解 n 皇后 */</span></span><br><span class="line">List&lt;List&lt;List&lt;String&gt;&gt;&gt; <span class="title function_">nQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化 n*n 大小的棋盘，其中 &#x27;Q&#x27; 代表皇后，&#x27;#&#x27; 代表空位</span></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        List&lt;String&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            row.add(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        state.add(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span>[] cols = <span class="keyword">new</span> <span class="title class_">boolean</span>[n]; <span class="comment">// 记录列是否有皇后</span></span><br><span class="line">    <span class="type">boolean</span>[] diags1 = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>]; <span class="comment">// 记录主对角线上是否有皇后</span></span><br><span class="line">    <span class="type">boolean</span>[] diags2 = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>]; <span class="comment">// 记录次对角线上是否有皇后</span></span><br><span class="line">    List&lt;List&lt;List&lt;String&gt;&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    backtrack(<span class="number">0</span>, n, state, res, cols, diags1, diags2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记忆化搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] mem)</span> &#123;</span><br><span class="line">    <span class="comment">// 已知 dp[1] 和 dp[2] ，返回之</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || i == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">// 若存在记录 dp[i] ，则直接返回之</span></span><br><span class="line">    <span class="keyword">if</span> (mem[i] != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> mem[i];</span><br><span class="line">    <span class="comment">// dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> dfs(i - <span class="number">1</span>, mem) + dfs(i - <span class="number">2</span>, mem);</span><br><span class="line">    <span class="comment">// 记录 dp[i]</span></span><br><span class="line">    mem[i] = count;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 爬楼梯：记忆化搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">climbingStairsDFSMem</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// mem[i] 记录爬到第 i 阶的方案总数，-1 代表无记录</span></span><br><span class="line">    <span class="type">int</span>[] mem = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(mem, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dfs(n, mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>暴力搜索 O(2^n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：暴力搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">knapsackDFS</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> i, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 若已选完所有物品或背包无剩余容量，则返回价值 0</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若超过背包容量，则只能选择不放入背包</span></span><br><span class="line">    <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">        <span class="keyword">return</span> knapsackDFS(wgt, val, i - <span class="number">1</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算不放入和放入物品 i 的最大价值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> knapsackDFS(wgt, val, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yes</span> <span class="operator">=</span> knapsackDFS(wgt, val, i - <span class="number">1</span>, c - wgt[i - <span class="number">1</span>]) + val[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 返回两种方案中价值更大的那一个</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(no, yes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间优化加动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：空间优化后的动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">knapsackDPComp</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cap + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 倒序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> cap; c &gt;= <span class="number">1</span>; c--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &lt;= c) &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[c] = Math.max(dp[c], dp[c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><p>空间优化加动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 完全背包：空间优化后的动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unboundedKnapsackDPComp</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cap + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">                <span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">                dp[c] = dp[c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[c] = Math.max(dp[c], dp[c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="零钱兑换问题2"><a href="#零钱兑换问题2" class="headerlink" title="零钱兑换问题2"></a>零钱兑换问题2</h4><p>凑硬币</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换 II：动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">coinChangeIIDP</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][amt + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) &#123;</span><br><span class="line">                <span class="comment">// 若超过目标金额，则不选硬币 i</span></span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选硬币 i 这两种方案之和</span></span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a] + dp[i][a - coins[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加空间优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换 II：空间优化后的动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">coinChangeIIDPComp</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amt + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) &#123;</span><br><span class="line">                <span class="comment">// 若超过目标金额，则不选硬币 i</span></span><br><span class="line">                dp[a] = dp[a];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选硬币 i 这两种方案之和</span></span><br><span class="line">                dp[a] = dp[a] + dp[a - coins[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h4><p><a href="https://www.hello-algo.com/chapter_dynamic_programming/edit_distance_problem/#1">14.6  编辑距离问题 - Hello 算法 (hello-algo.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> datastructure.dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Levenshtein</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">distance</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> a.length();</span><br><span class="line">         <span class="type">int</span> <span class="variable">length2</span> <span class="operator">=</span> b.length();</span><br><span class="line">         <span class="type">int</span> dp[][] = <span class="keyword">new</span> <span class="title class_">int</span>[length1+<span class="number">1</span>][length2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=length1;i++)&#123;</span><br><span class="line">             dp[i][<span class="number">0</span>]=i;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=length2;j++)&#123;</span><br><span class="line">             dp[<span class="number">0</span>][j]=j;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ;i&lt;=length1;i++)&#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=length2;j++)&#123;</span><br><span class="line">                 <span class="keyword">if</span> (a.charAt(i-<span class="number">1</span>)==b.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;kitten&quot;</span>;</span><br><span class="line">          <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;sitting&quot;</span>;</span><br><span class="line">          <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> distance(s1,s2);</span><br><span class="line">          System.out.println(ans);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>一般情况下，贪心算法的适用情况分以下两种。</p><ol><li><strong>可以保证找到最优解</strong>：贪心算法在这种情况下往往是最优选择，因为它往往比回溯、动态规划更高效。</li><li><strong>可以找到近似最优解</strong>：贪心算法在这种情况下也是可用的。对于很多复杂问题来说，寻找全局最优解非常困难，能以较高效率找到次优解也是非常不错的。</li></ol><p>贪心问题的解决流程大体可分为以下三步。</p><ol><li><strong>问题分析</strong>：梳理与理解问题特性，包括状态定义、优化目标和约束条件等。这一步在回溯和动态规划中都有涉及。</li><li><strong>确定贪心策略</strong>：确定如何在每一步中做出贪心选择。这个策略能够在每一步减小问题的规模，并最终解决整个问题。</li><li><strong>正确性证明</strong>：通常需要证明问题具有贪心选择性质和最优子结构。这个步骤可能需要用到数学证明，例如归纳法或反证法等。</li></ol><h4 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumGas</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumCost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sumCost += cost[i];</span><br><span class="line">            sumGas += gas[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sumCost &gt; sumGas)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hasPassed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; hasPassed &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == n)</span><br><span class="line">                    j = <span class="number">0</span>;</span><br><span class="line">                rest += gas[j];</span><br><span class="line">                <span class="keyword">if</span> (rest &gt;= cost[j]) &#123;</span><br><span class="line">                    rest -= cost[j];</span><br><span class="line">                    hasPassed++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasPassed == n)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCP-03-机器人大冒险"><a href="#LCP-03-机器人大冒险" class="headerlink" title="LCP 03. 机器人大冒险"></a><a href="https://leetcode.cn/problems/programmable-robot/">LCP 03. 机器人大冒险</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">robot</span><span class="params">(String cmd, <span class="type">int</span>[][] obstacles, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cmd.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sx</span> <span class="operator">=</span> <span class="number">0</span>, sy = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录走完一轮后机器人的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cmd.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;U&#x27;</span>) ++ sy;</span><br><span class="line">            <span class="keyword">else</span> ++ sx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先计算能否到达终点 不考虑障碍物</span></span><br><span class="line">        <span class="comment">// 若不能直接返回false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">canFinish</span> <span class="operator">=</span> canReach(cmd, x, y, sx, sy);</span><br><span class="line">        <span class="keyword">if</span> (!canFinish) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 判断在终点前会不会遇到障碍物 </span></span><br><span class="line">        <span class="comment">// 若遇到则返回false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] o : obstacles) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o[<span class="number">0</span>] &gt; x || o[<span class="number">1</span>] &gt; y)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (canReach(cmd, o[<span class="number">0</span>], o[<span class="number">1</span>], sx, sy)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断能否从坐标(x, y)到达(tx, ty)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canReach</span><span class="params">(String cmd, <span class="type">int</span> tx, <span class="type">int</span> ty, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// round记录走到目标点至少要走多少轮</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">round</span> <span class="operator">=</span> Math.min(tx/x, ty/y);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> round*x, ny = round*y;</span><br><span class="line">        <span class="keyword">if</span> (nx == tx &amp;&amp; ny == ty) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cmd.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cmd.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;U&#x27;</span>) ++ ny;</span><br><span class="line">            <span class="keyword">else</span> ++ nx;</span><br><span class="line">            <span class="keyword">if</span> (nx &gt; tx || ny &gt; ty) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (nx == tx &amp;&amp; ny == ty) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4&amp;SRV6</title>
      <link href="/2024/06/24/B-EP2/"/>
      <url>/2024/06/24/B-EP2/</url>
      
        <content type="html"><![CDATA[<h1 id="B-EP2"><a href="#B-EP2" class="headerlink" title="B-EP2"></a>B-EP2</h1><p>背景：互联网变得臃肿，网络管理员迫切需要一种快速高效的<strong>网络遥测方案</strong>，能够利用采集到的实时准确的网络状态信息来快速检测和定位常见网络故障，然后需要一个有效的<strong>网络控制和管理（NC&amp;M）方案</strong>，以实现只能及时决策以在网络路径上<strong>梳理和路由流量</strong>，以同时实现<strong>高效的利用和高质量的服务（QoS</strong>）。</p><ul><li>采集网络信息，定位故障</li><li>有效的网络控制和管理方案</li></ul><p><a href="https://blog.csdn.net/hjxzb/article/details/91141685?ops_request_misc=%7B%22request_id%22:%22168753985816782427413509%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168753985816782427413509&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-91141685-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=P4&spm=1018.2226.3001.4187">(465条消息) P4学习笔记（一）初识P4_p4接口是干嘛的_程序员学编程的博客-CSDN博客</a></p><ol><li><p>基于P4的主动遥测</p><ul><li><p>探针代替数据分组进行遥测，降低了遥测开销（因为数组分组比如INT即带内网络遥测<a href="https://blog.csdn.net/weixin_47104688/article/details/123229563?ops_request_misc=%7B%22request_id%22:%22168606788516800222871187%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168606788516800222871187&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-123229563-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=INT%E5%B8%A6%E5%86%85&spm=1018.2226.3001.4187">(460条消息) 带内网络遥测INT–In-band Network Telemetry_袁冬至的博客-CSDN博客</a></p><p><img src="https://img-blog.csdnimg.cn/41f24f5aae434d68bf9eca75786137da.png" alt="在这里插入图片描述"></p><p><a href="https://www.sdnlab.com/23822.html">https://www.sdnlab.com/23822.html</a></p><p><a href="https://blog.csdn.net/changqing1234/article/details/103669835?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-103669835-blog-123229563.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-103669835-blog-123229563.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=1">(465条消息) Telemetry 技术概述_LeocenaY的博客-CSDN博客</a></p><p>，在转发数据分组时能够在数据在网络结构流动的过程中，通过在路径中间节点插入元数据，监控系统可以通过这些元数据进行收集网络状态，但这样载荷比就大)，INT之类的带内网络遥测也存在一些局限性，难以获取全局网络试图。这样就加入了探针进行主动遥测，提高数据分组的有效载荷比。</p><p><a href="https://www.sdnlab.com/23822.html">一文读懂带内网络遥测技术 | SDNLAB | 专注网络创新技术</a></p></li></ul></li><li><p>基于段路由（基于IPV6的一向技术）</p><p><img src="C:\Users\11505\AppData\Roaming\Typora\typora-user-images\image-20230607005803362.png" alt="image-20230607005803362"></p><p><a href="https://blog.csdn.net/m0_49864110/article/details/123591943?ops_request_misc=%7B%22request_id%22:%22168606977016800225513092%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168606977016800225513092&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123591943-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=SRV6&spm=1018.2226.3001.4187">(460条消息) 广域网技术——SRv6 SID讲解_静下心来敲木鱼的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/Ether_Dzh/article/details/119847548?ops_request_misc=%7B%22request_id%22:%22168754187716800227440687%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168754187716800227440687&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-119847548-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=SRV6&spm=1018.2226.3001.4187">(465条消息) 1.2、SRv6(Segment Routing Over IPv6) 介绍_srv6技术是什么_Ether_Dzh的博客-CSDN博客</a></p><p><img src="https://img-blog.csdnimg.cn/559f3e9343e344db9882548b9a095e9e.png" alt="在这里插入图片描述"></p><ul><li>改变SR标签和排列顺序指定探测路径</li><li>探针加入SR标签栈获取全面的网络视图，环形探测路径，单个探测点具备探针发送端和接收端功能，减少多个探测点之间同步协调探针等复杂操作。</li><li>减少遥测冗余，探针分组中加入遥测指示域，指定需要采集的遥测数据</li><li>将可编程设备的内部状态的状态信息嵌入到探针中，通过可编程设备的定制化能力自定义数据分组处理逻辑来是实现。</li></ul></li></ol><p>SDN控制面：可编程环境</p><p>可集中控制网络：SDN域由集中统一的控制单元实施管理</p><p>转发和控制分离</p><p>P4：</p><ul><li><p>可以对网络设备芯片逻辑进行编程</p></li><li><p>可重配置性：支持转发逻辑代码经过编译部署到具体平台上之后动态修改报文</p></li><li><p>不绑定某个具体的网络协议</p></li><li><p>平台无关性：独立于特定的底层运行平台来编写数据报文处理逻辑</p></li><li><p>需要特定交换机的支持</p></li><li><p>数据采集与感知：</p><ol><li>通过ONOS（一体化的网络操作系统）的Restful北向接口查询得到的ONOS特有数据库内的全局网络信息（但忽略细节）<a href="https://blog.csdn.net/weixin_34384681/article/details/91849632?ops_request_misc=%7B%22request_id%22:%22168606907716800227458444%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168606907716800227458444&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-6-91849632-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=ONOS&spm=1018.2226.3001.4187">(460条消息) ONOS预热篇之ONOS简介_weixin_34384681的博客-CSDN博客</a></li><li>数据层交换机中的数据流，插入探针，数据采集服务链，提取各个包的特征进行统计</li><li>基于段路由机制，进行INT主动遥测（INT本身是有局限性的，探测路径需要提前指定，而借助段路由机制进行主动网络遥测，降低成本提高了灵活性），流量包中插入探针，快速获取探测包路径上的第一手数据平面遥测数据</li></ol></li><li><p>这里的智能分析与决策采用深度学习相关的东西</p></li><li><p>可编程动态管控（P4）：仅管理数据平面如何处理数据包，定义控制平面与数据平面通信的接口，但不描述控制平面功能</p></li><li><p>传统交换机和P4交换机</p><p>在传统交换机中，制造商定义了数据平面的功能，控制平面通过一些管理表（如路由表）中的条目以及处理控制数据包（如路由协议数据包）或异步事件（如链路状态更改或学习通知）来控制数据平面。</p><p>P4可编程交换机与传统交换机的区别主要体现在两个方面：</p><ul><li>数据平面功能不是预先固定的，而是由 P4 程序定义的。数据平面在初始化时配置为实现 P4 程序描述的功能（由红色长箭头显示），并且没有现有网络协议的内置知识。</li><li>控制平面使用与固定功能设备中相同的通道与数据平面进行通信，但数据平面中的表集合和其他对象不再是固定的，因为它们由 P4 程序定义。P4 编译器生成控制平面用于与数据平面通信的 API。</li></ul></li><li><p>控制平面（SDN控制器）如何与P4的设备进行通信？</p><ul><li><p>P4Runtime（基于gRPC框架）</p></li><li><p>OpenFlow协议中，控制器和设备是由控制器开放端口，设备才能连接上控制器；而P4Runtime是设备上开始gRPC,控制器连接设备，因此，在支持P4的设备上也会有一个代理的Agent去处理控制器来的连接</p></li></ul></li></ul><p>鉴于基于P4的被动网络遥测可扩展性不足的缺点，首先要保证的就是主动遥测的探测路径在运行时是灵活可控的，我们采用段路由机制来灵活控制探针的探测路径（这里的路径生成采用了<a href="https://blog.csdn.net/KCDCY/article/details/124732427?ops_request_misc=%7B%22request_id%22:%22168606887816800222897225%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168606887816800222897225&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124732427-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%AC%A7%E6%8B%89%E9%80%9A%E8%B7%AF%E7%AE%97%E6%B3%95">Hierholzer <em>算法</em>，欧拉回路</a>）。段路由机制简单易用，不需要额外的协议支持，通过组合一系列简单的网络操作指令就可以完全控制数据分组的转发路径。在降低了网络成本的同时也提高了灵活性。最后段路由能够支持增量部署，降低了部署难度，可行性好。该系统下可以灵活定义遥测路径，按需探测可能或已经出现问题的路径，快速定位故障位置。同时，可以在探针格式中加入探测遥测数据类型的字段来支持按需获取遥测数据。同时要保证能够采集到网络设备内部的状态信息等细粒度准确的遥测数据，我们可以通过修改可编程设备的数据平面处理逻辑来区分正常数据分组和探针数据分组，对于正常数据分组直接正常转发，而对于探针数据分组匹配其中的路径转发标签以及遥测指令字段，将实时的网络状态信息封装在探针数据分组中。</p>]]></content>
      
      
      <categories>
          
          <category> SDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN </tag>
            
            <tag> P4 </tag>
            
            <tag> SRV6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研复习准备</title>
      <link href="/2024/06/24/%E4%BF%9D%E7%A0%94/"/>
      <url>/2024/06/24/%E4%BF%9D%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h1><p><a href="https://blog.csdn.net/zqm_0015/article/details/109236372">(453条消息) 2021年计算机保研面试题_一个主机将两个端口接到网络上是否会提升吞吐量_Challow的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/Baoyan_cs/article/details/124314177">(453条消息) 吐血整理，20个计算机保研常见问题及回答模板_计算机专业20个面试常见问题_Baoyan_cs的博客-CSDN博客</a></p><p>[(453条消息) 2021计算机保研经历(清软, 北深, 浙大, 南大, 中科大, 北航, 哈深, 南开, 华科, 武大, 中大)_inicho的博客-CSDN博客](<a href="https://blog.csdn.net/qq_43280818/article/details/123450451?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">https://blog.csdn.net/qq_43280818/article/details/123450451?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=计算机网络</a> 保研&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-9-123450451.142^v87^insert_down28,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><p>[(453条消息) 计算机网络保研面试题整理（自用）_乌鸡摸鱼的博客-CSDN博客](<a href="https://blog.csdn.net/m0_52571748/article/details/119513761?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">https://blog.csdn.net/m0_52571748/article/details/119513761?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=计算机网络</a> 保研&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-1-119513761.142^v87^insert_down28,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><p>[(453条消息) 计算机专业保研面试复习笔记——计算机网络_计算机保研复习_欧二lord的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_43117620/article/details/109198194?ops_request_misc=%7B%22request_id%22:%22168433738716800227438825%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168433738716800227438825&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-109198194-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">https://blog.csdn.net/weixin_43117620/article/details/109198194?ops_request_misc=%7B%22request%5Fid%22%3A%22168433738716800227438825%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168433738716800227438825&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-109198194-null-null.142^v87^insert_down28,239^v2^insert_chatgpt&amp;utm_term=计算机网络</a> 保研&amp;spm&#x3D;1018.2226.3001.4187)</p><p><a href="https://blog.csdn.net/weixin_46893257/article/details/116306838?ops_request_misc=%7B%22request_id%22:%22168470925916800215052847%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168470925916800215052847&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-116306838-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=IPv6%E6%B5%81%E6%A0%87%E7%AD%BE&spm=1018.2226.3001.4187">(454条消息) IPV6基本报头_ipv6报头_yibasuo18176的博客-CSDN博客</a></p><p>[(454条消息) BGP、IBGP、EBGP、IGP、EGP_bgp和egp的区别_zhaomax的博客-CSDN博客](<a href="https://blog.csdn.net/zhaomax/article/details/52399403?ops_request_misc=&request_id=&biz_id=102&utm_term=IGP">https://blog.csdn.net/zhaomax/article/details/52399403?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=IGP</a> BGP&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-4-52399403.142^v87^insert_down28,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><a href="https://blog.csdn.net/m0_52571748/article/details/119512934">(453条消息) 计算机操作系统保研面试题整理（自用）_乌鸡摸鱼csdn_乌鸡摸鱼的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/love521314123/article/details/119682266">(453条消息) 操作系统笔记（含王道计算机考研——操作系统课件）_操作系统考研笔记_一只不吃老鼠的猫的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/lishanleilixin/article/details/89709194">(454条消息) OS之存储管理 — 磁盘调度算法_os 对磁盘操作 写优先_如是说如是的博客-CSDN博客</a></p><h2 id="计组"><a href="#计组" class="headerlink" title="计组"></a>计组</h2><p><a href="https://blog.csdn.net/m0_52571748/article/details/119530739?ops_request_misc=%7B%22request_id%22:%22168433894316800197057897%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168433894316800197057897&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-119530739-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BF%9D%E7%A0%94&spm=1018.2226.3001.4187">(453条消息) 计算机组成原理保研面试题整理（自用）_计算机组成原理面试题_乌鸡摸鱼的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/love521314123/article/details/122825247#comments_26524593">(453条消息) 王道计算机考研——计算机组成原理笔记_王道计算机组成原理_一只不吃老鼠的猫的博客-CSDN博客</a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="https://blog.csdn.net/weixin_43790779/article/details/120934734?ops_request_misc=%7B%22request_id%22:%22168433902416800226547104%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168433902416800226547104&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120934734-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BF%9D%E7%A0%94&spm=1018.2226.3001.4187">(453条消息) 保研面试复习之数据结构篇_数据结构保研复习_abtgu的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_40113925/article/details/100938378?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-100938378-blog-120934734.235%5Ev36%5Epc_relevant_anti_vip&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-100938378-blog-120934734.235%5Ev36%5Epc_relevant_anti_vip&utm_relevant_index=3">(453条消息) 数据结构基础概念知识点_保研&#x2F;考研&#x2F;面试复习_顺序哈希分块折半_Raising_的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/whz_zb/article/details/7425152?ops_request_misc=%7B%22request_id%22:%22168465798116800182114693%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168465798116800182114693&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-7425152-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%83%9C%E8%80%85%E6%A0%91%E5%92%8C%E8%B4%A5%E8%80%85%E6%A0%91&spm=1018.2226.3001.4187">(454条消息) 胜者树与败者树_胜者树和败者树_whz_zb的博客-CSDN博客</a></p><p>[(454条消息) 详解全局变量，全局变量与静态变量的区别_静态变量和全局变量_舒泱的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_43222324/article/details/106989714?ops_request_misc=%7B%22request_id%22:%22168474123716800226594104%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168474123716800226594104&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-106989714-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">https://blog.csdn.net/weixin_43222324/article/details/106989714?ops_request_misc=%7B%22request%5Fid%22%3A%22168474123716800226594104%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168474123716800226594104&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-106989714-null-null.142^v87^insert_down28,239^v2^insert_chatgpt&amp;utm_term=全局变量</a> 静态变量&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><p><a href="https://uestc.feishu.cn/file/boxcnT7mKncOLwyhbDjSGrCPhed">概率论.pdf - 成电飞书云文档 (feishu.cn)</a></p><h2 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h2><p><a href="https://uestc.feishu.cn/file/QdMtbKWaDofazmxMw6EcHqFyndc">高等数学知识点最全汇总.pdf - 成电飞书云文档 (feishu.cn)</a></p><p><a href="https://blog.csdn.net/crj0926/article/details/101761433?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%E5%92%8C%E5%8F%98%E6%8D%A2%E5%8C%BA%E5%88%AB&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-101761433.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(454条消息) 傅里叶级数和傅里叶变换简介和推导_傅里叶级数和傅里叶变换的区别和联系_HKDER的博客-CSDN博客</a></p><h2 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h2><p><a href="https://uestc.feishu.cn/file/PjBcbDESvoKrngxSYHScvkCInJd">离散数学.docx - 成电飞书云文档 (feishu.cn)</a></p><h2 id="线代"><a href="#线代" class="headerlink" title="线代"></a>线代</h2><p><a href="https://uestc.feishu.cn/file/HzV3b1Wxno1LFaxF6G9c1VKunzg">线代.pdf - 成电飞书云文档 (feishu.cn)</a></p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><a href="https://uestc.feishu.cn/file/boxcn0xg2vSIlKrccY2Y32c7Hye">数据库.pdf - 成电飞书云文档 (feishu.cn)</a></p><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><h2 id="JAVA-C"><a href="#JAVA-C" class="headerlink" title="JAVA&amp;C++"></a>JAVA&amp;C++</h2><p>[(454条消息) java—垃圾回收算法(GC)_会飞的猪zhu的博客-CSDN博客](<a href="https://blog.csdn.net/m0_58196614/article/details/126426266?ops_request_misc=&request_id=&biz_id=102&utm_term=Java">https://blog.csdn.net/m0_58196614/article/details/126426266?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Java</a> 的垃圾回收算法&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-126426266.142^v87^insert_down28,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="经验贴"><a href="#经验贴" class="headerlink" title="经验贴"></a>经验贴</h2><p><a href="https://zhuanlan.zhihu.com/p/415169966">2021年计算机保研经验帖 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/569448591">2022南大cs夏令营笔试面试准备 - 知乎 (zhihu.com)</a></p><p><a href="https://www.rstk.cn/news/624725.html?action=onClick">https://www.rstk.cn/news/624725.html?action=onClick</a></p><p><a href="https://zhuanlan.zhihu.com/p/377444777">2021年半跨CS保研经历（已上岸pku） - 知乎 (zhihu.com)</a></p><h2 id="机试真题"><a href="#机试真题" class="headerlink" title="机试真题"></a>机试真题</h2><p><a href="https://github.com/Muyiyunzi/BUAA-CS-Codes">Muyiyunzi&#x2F;BUAA-CS-Codes: 北京航空航天大学计算机学院研究生考试复试上机部分往年试题及解答 (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研经验贴</title>
      <link href="/2024/06/24/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
      <url>/2024/06/24/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="保研经验贴"><a href="#保研经验贴" class="headerlink" title="保研经验贴"></a>保研经验贴</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天被两三个25届的同学问到保研的事 尘封许久的记忆再次打开 再次汇总了之前收到的所有信息和仅存的记忆 给一点模板上的参考<br>注:是疫情解封后第一次线下 故之前很多经验贴没有参考性</p><p>bg: 985本SE</p><p>rank: 3&#x2F;181 3.99&#x2F;4.00</p><p>论文: 无</p><p>竞赛: 双国三 双省一 一省三 n校奖</p><p>奖学金: 两年国奖</p><p>方向: 分布式系统&#x2F;存储 偏架构和系统设计方向</p><p>实习: 某自驾公司地图存储系统&#x2F;字节抖音电商开发岗</p><p>由于夏令营已经上岸 故没有参加后续预推免</p><p>入营:</p><p>夏令营:</p><p>①北大计算机 直博（放弃且意愿不强 真不想读博）</p><p>②北大软微 硕士（计算机学院组➕老师 最终去向）</p><p>③中国科学院计算所 硕士</p><p>④上海交通大学电院 硕士</p><p>⑤南京大学计算机学院 硕士</p><p>⑥北京航空航天大学计算机学院 硕士（放弃）</p><p>⑦中国人民大学信院 硕士</p><p>⑧西安交通大学计算机学院 硕士</p><p>被拒:</p><p>①复旦大学计算机学院（只要第一我也没办法）</p><p>参加:</p><p>由于在实习真抽不开时间去其他地方参营</p><p>①北大软微</p><p>②北航计算机</p><p>③南大计算机（参加了部分 获得软件所的通过了但后面不是很想去参加了…跟北大有冲突也是个重要原因）<br>优营</p><p>①北大软微</p><p>②北航计算机</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>数学方面:</p><p>①概率论②线性代数③微积分④离散数学</p><p>这部分需要从头到尾过一遍 相关概念、联系一定要熟，各部分重点其实网上总结🉐十分详细了 一定好好准备！</p><p>英语方面:</p><p>①各种日常口语➕部分计算机相关专业的词汇 不需要特别详细 但我建议提早一个月进入状态</p><p>专业知识:</p><p>①数据结构②计算机网络③操作系统④计组⑤编译原理⑥机试！！！（别说其他语言了 现在学c++还来得及 STL弄熟➕王道机试指南➕力扣➕到处搜集真题 爆！！！）</p><p>四五很少考 南大计算机的笔试特别喜欢考编译原理——题简直又多又长又难 数据结构重中之重 机试一定好好准备！！！</p><h2 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h2><p>南大计算机（流程繁琐）</p><p>①最开始我记得是软件所有个面试，线上的，会问一些离散数学（平面图 哈密顿图等等）和一些数据结构的题 差不多十五分钟（这一部分是提前了差不多两个月进行的）</p><p>②后续在临近夏令营的时候还有一轮线上笔试 巨难（如果没学过编译原理就寄了）</p><p>③后续就是去线下啦 但遗憾没去看看美丽的仙林校区😭</p><p>北航计算机（特色大模拟➕不报销车费路费 甚至不包吃）</p><p>①第一天就是两道机试 总共两小时 第一道大模拟真的搞的头大（好在还是写对了） 第二道真是完全一点不会（不是常规的算法题） 这一轮🉐至少做对一个才能进入下一轮</p><p>②第二天面试 数学➕英语➕各种专业问题 甚至还问了我前端➕后端➕java和c++ python语言特性使用场景（好在哥们也是实习面试了几十轮还是信手拈来的）</p><p>老师全程压力面，不能怂！</p><p>然后优营发的很快，我记得是7月2号就发了，也是我第一个优营</p><p>北大软微</p><p>软微从22年开始比较特殊，首先据说要退学费，其次夏令营的师资和实验室可以是计算机学院&#x2F;智能学院的，加上还是硕士简直不要太香好吧</p><p>①第一天闲聊吹水 我就记得紫燕百味鸡外卖还挺好吃</p><p>②先来三道算法题！（30min 我们组跟系统方向强相关三道分别是mid mid hard难度的 可以写伪代码）其实我第三道有点问题但由于太自信甚至后续面试当场给出来数学证明让老师也疑惑住了</p><p>③面试: 自我介绍➕各种问题的提问 甚至问到我一些关于实习用到的juiceFS和一些底层的概念&#x2F;分布式共识&#x2F;运维&#x2F;缓存等，还问到代码量（必然是多多），以及数学上面的证明➕算法题复盘➕一些其他的问题，其实都还好，虽然没全准备过但意外达的非常好（最终拟录取看复试分数排名竟然差不多前1％）</p><p>优营隔了几天就发了 </p><h2 id="一些被问到的问题"><a href="#一些被问到的问题" class="headerlink" title="一些被问到的问题"></a>一些被问到的问题</h2><ol><li><p>论文是必须的吗？</p><p>有最好，如果搞ai必须有相关实习&#x2F;科研经历，如果走system路线有实习或者经历都行</p></li><li><p>四六级真的重要吗？</p><p>我觉得一般重要 不要太低就行</p></li><li><p>给计算机专业课重要程度排个序</p><p>数据结构＞计算机网络&#x3D;操作系统＞计组＞编译原理</p></li><li><p>事先套磁了吗？</p><p>五月份套了一个，但强com。我建议现在3月份就可以开始套了，越早越好！</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 经验贴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 清北复交 </tag>
            
            <tag> bar </tag>
            
            <tag> 专硕 </tag>
            
            <tag> 学硕 </tag>
            
            <tag> 直博 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研夏令营他人经验总结</title>
      <link href="/2024/06/24/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%BA%90/"/>
      <url>/2024/06/24/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="保研夏令营"><a href="#保研夏令营" class="headerlink" title="保研夏令营"></a><strong>保研夏令营</strong></h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h2><ul><li>CSP，最好300+？（<strong>对于北航有效</strong>）</li><li>报名一般5月开始，联系老师建议4月</li></ul><h2 id="入营"><a href="#入营" class="headerlink" title="入营"></a><strong>入营</strong></h2><ul><li>主要看<strong>成绩</strong>，<strong>高质量科研</strong>成果加分，实习经历、获奖<strong>无用</strong>，入营后成绩影响不大（rank1可加<strong>印象分</strong>）——郑博文</li><li>清北上交学硕rank1都不一定进得去</li><li>都留给本校学生了</li><li>复旦卡rank1</li><li>南大比较海rank5&#x2F;6好像就行</li><li>中科大有点歧视非计科出身，软院入营看运气</li><li>自动化所要rank1&#x2F;2</li><li>计算所联系老师</li><li>清深热门专业也比较难入</li><li>其他方向还好</li><li>北大整个都是联系老师流的</li><li>浙大夏令营没有学硕，就不说了</li><li>清华也没学硕，直博也不给offer</li><li>人大高瓴要rank1&#x2F;2        ——郑博文</li></ul><h2 id="机试"><a href="#机试" class="headerlink" title="机试"></a><strong>机试</strong></h2><ul><li>非常不推荐力扣（不需要自己设计数据结构、不需要自己处理输入输出），不推荐其他语言</li><li>语言：<strong>C++</strong>        平台：<strong>洛谷、AcWing</strong>        ——郑博文</li><li>狠抓，因为很多学校都因为这个初筛，人工智能机试卷中卷，尽量现在就连起来  leetcode（主要看思想） pat要相对难一点，重点！！！要看输入输出；在保研成绩稳的情况下，准备机试（我摔了很多次的地方一定要在强调很多遍） 数据结构——刘欣宇</li><li>计算所机试vipl实验室如果用c++的话  不能调用stl库  考的也就是用c实现了  其他的都是可以调用库的——刘欣宇</li><li>有一本王道机试指南  你可以找找电子版  里面题很经典 前面的比较简单  尽量早点过  后面图论也比较容易考，算法里面很爱考贪心  动态规划，你也可以看看时间函数  我遇到过两次机试  是考时间的  题目大概是  上班打卡，下班也要打卡，打卡方式有很多种，但是都是同一个人的，这个人会进出公司，看谁累计上班时间长 ——刘欣宇</li></ul><h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a><strong>笔试</strong></h2><ul><li>看是计算机学院还是ai学院，数据结构比较重视，其他三门专业课主要看知识点，数据结构刷了一本王道        ——郑博文</li><li>大多数学校没有笔试，南大、计算所有，南大难，考底层，计算所  有单独的数学考试（他还考了少量的微积分  极少极少）——刘欣宇</li></ul><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><ul><li>408和数学也要复习 面试会问你，408里面 数据结构》计网》操作系统  计组</li><li>先看数据结构  数学（线代很爱问正定矩阵  概率论很爱问大数定律和中心极限定理） 然后在看计网 os ，计组基本上没问——刘欣宇</li></ul><h2 id="科研"><a href="#科研" class="headerlink" title="科研"></a><strong>科研</strong></h2><ul><li>最好找个<strong>外校</strong>的实验室，<strong>计院</strong>的也行，本校实验室不算实习，但可以让老师帮挂公司</li><li>一定要<strong>高质量</strong>科研成果        ——郑博文</li></ul><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><ul><li>突然想起来  心态也很重要  有可能夏令营啥也没拿到  或者只有一个  但是别慌 预推免还有  预推免先都报上  如只要能面试  就有很大概率候补到  不要全都选很好的专业  很容易落得一场空  坚信  只要我面试了 肯定会有候补到的时候；今年浙软  南大计算机  北航计算机 国防科大都快被鸽穿了 ——刘欣宇</li></ul><h2 id="一些文章链接"><a href="#一些文章链接" class="headerlink" title="一些文章链接"></a>一些文章链接</h2><p><a href="https://blog.csdn.net/mengwuyaaa/article/details/82918032?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-82918032-blog-125315403.pc_relevant_vip_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-82918032-blog-125315403.pc_relevant_vip_default&utm_relevant_index=2">https://blog.csdn.net/mengwuyaaa/article/details/82918032?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-82918032-blog-125315403.pc_relevant_vip_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-82918032-blog-125315403.pc_relevant_vip_default&amp;utm_relevant_index=2</a></p><h1 id="经验贴的一些阅读"><a href="#经验贴的一些阅读" class="headerlink" title="经验贴的一些阅读"></a>经验贴的一些阅读</h1><h2 id="人品"><a href="#人品" class="headerlink" title="人品"></a>人品</h2><p>导师人品最重要，千万不要去坑导直博，即使是清北的。</p><p>可以先去导师评价网找找，目前可用的有 <a href="https://link.zhihu.com/?target=https://www.yankong.org/">研控</a> 、<a href="https://link.zhihu.com/?target=https://www.daoshipingjia.xyz/">硕博导师评价网</a>，另外我这里还有导师评价网后台数据库 excel（包含全国各大院校 1 万条导师评价信息），以及上交电院导师评价，不方便发，需要的话可以私戳。</p><p>然后就是在百度、谷歌上搜，还可以去问组内 &#x2F; 隔壁组学长学姐。如何联系学长学姐？<strong>一种方法是找本校保研到该校或在绿群找到保研到该校的学长学姐，请他介绍介绍；另一种方法是通过导师的论文，推测出学长学姐的名字，然后在论文网站里找邮箱发邮件问。注意要兼听则明</strong></p><h2 id="专业课怎么复习"><a href="#专业课怎么复习" class="headerlink" title="专业课怎么复习"></a>专业课怎么复习</h2><p>如果时间不是很充裕，不要全面撒网，每门课要复习的也就一二十个常见问题，找找保研 &#x2F; 考研面试重点问题来看看就行。</p><p>要复习的课有：</p><ul><li>数学：线性代数、概率论、高数</li><li>计算机：数据结构、计组、操作系统、计网、算法、数据库、软件工程、编译原理、编程语言</li><li>人工智能：机器学习、深度学习</li></ul><p>注意这些课不必完全复习，挑几门和研究方向相关的看看重点就行，比如对于 AI 方向，最重要的是数学、数据结构、人工智能。</p><h2 id="没有科研经历咋办"><a href="#没有科研经历咋办" class="headerlink" title="没有科研经历咋办"></a>没有科研经历咋办</h2><p>和老师方向一致的科研经历非常重要，即使没有产出论文，也是巨大的加分项，这就像去找工作，实习经历是巨大的加分项一样。</p><p>如果你现在是大三下学期开学之前的话，可以去联系本校老师进实验室做科研。如果已经很晚了，如六月份了，可以去找一些论文，复现或者读懂代码，掌握好细节，包装成一个项目，耗时半个月左右，前提是不能被问穿，得答得上来。</p><p>一段科研经历，老师更关注你做了什么，而不是这个科研做的结果。要讲好一个项目，需要讲好 motivation（为什么做）、method（做了什么）、result（做得咋样）、contribution（你做了啥），其中最重要的是 contribution 和 motivation。不要说得太直白，尽量学术化一点。（可以参考顶会论文的 Introduction，看看怎样讲好一个故事）。老师也非常喜欢问你的科研项目里面用到的东西的底层原理，而这些东西你可能就是在 PyTorch 里面调了个库，需要注意一下。</p><p>如果有论文，论文的内容、细节一定要清楚，还有 EI 会议之类的水文不建议写在简历，如果被问穿了，可能是减分项</p><h2 id="要准备哪些文书"><a href="#要准备哪些文书" class="headerlink" title="要准备哪些文书"></a>要准备哪些文书</h2><p>文书材料的模板后续我会整理发出来。</p><ul><li>简历：推荐 <a href="https://link.zhihu.com/?target=https://www.wondercv.com/">超级简历WonderCV</a> ，内容写保研要素中比较重要的就行，包括：联系方式、学校、专业、成绩、排名、获奖、项目、数学、编程、英语、读博意向等，自己的劣势部分不要往上面写。</li><li>个人陈述：准备 1000 字、2000 字的，就是简历的扩充，重点是讲做过的项目，研究规划等。</li><li>推荐信：准备 2 封教授推荐信即可，这东西没人看，注意复旦、北航等学校需正教授推荐信，清华、复旦等学校要求老师本人在线填写或用本人的邮箱发送推荐信。</li><li>套磁信：既要简洁了当，直言主题，又不能不客套。edu邮箱比较正式，gmail有邮件追踪插件mailtrack。</li><li>PPT：相当于把简历讲出来，大部分的篇幅应该讲项目，和学习无关的不要讲太多。</li><li>各种证明材料：成绩单、排名证明、获奖证书、身份证、学生证、英语证明，都扫描成pdf。</li></ul><h2 id="一些有用的网站"><a href="#一些有用的网站" class="headerlink" title="一些有用的网站"></a>一些有用的网站</h2><ul><li>邮件追踪：Gmail 有个插件 mailtrack，可以看到你发的邮件什么时候被老师打开了，打开了几次。</li><li>查老师学术水平：<a href="https://link.zhihu.com/?target=https://scholar.google.com/">Google Scholar</a>、<a href="https://link.zhihu.com/?target=https://dblp.org/">dblp</a>、<a href="https://link.zhihu.com/?target=https://www.aminer.cn/">AMiner</a>、<a href="https://link.zhihu.com/?target=https://csrankings.org/%23/index?all&cn">CSRankings</a>、<a href="https://link.zhihu.com/?target=https://www.semanticscholar.org/">Semantic Scholar</a></li><li>查国家自然科学基金：<a href="https://link.zhihu.com/?target=https://www.ceshigo.com/Nsfc/fund">测试狗基金查询</a>、<a href="https://link.zhihu.com/?target=https://grants.nsfc.gov.cn/egrantindex/funcindex/prjsearch-list">基金委查询系统</a></li><li>导师评价网：<a href="https://link.zhihu.com/?target=https://www.yankong.org/">研控</a> 、<a href="https://link.zhihu.com/?target=https://www.daoshipingjia.xyz/">硕博导师评价网</a></li><li>机试刷题平台：<a href="https://link.zhihu.com/?target=https://www.acwing.com/">AcWing</a></li><li>夏令营 &#x2F; 预推免开营信息：<a href="https://link.zhihu.com/?target=http://pc.baoyanwang.com.cn/">保研信息网</a></li><li>中科院计算所各实验室介绍：<a href="https://link.zhihu.com/?target=http://cskaoyan.com/thread-237791-1-2.html">中科院计算所实验室情况简要介绍-王道论坛</a></li></ul><h1 id="清北华五院系分析"><a href="#清北华五院系分析" class="headerlink" title="清北华五院系分析"></a>清北华五院系分析</h1><h2 id="1-清华大学"><a href="#1-清华大学" class="headerlink" title="1 清华大学"></a>1 清华大学</h2><p>清华的 offer 基本在预推免发，夏令营发 offer 的只有叉院、深研院。除了软件、深研院外，外校基本只能拿直博。夏令营各院系自己组织，可以报多个，但有些院系没有夏令营。预推免是学校系统上报，最多报两个。</p><ul><li>计算机系（贵系）：国内计算机 top1，需要尽早联系导师。开夏令营，但不发 offer，通过机试的，预推免免试。机试很难，3 道编程题，难度和 CSP 第 3-4 题差不多。</li><li>自动化系（雷系）：有做 AI 的老师，注意自动化系的硕士分三种，学硕、大数据工程（要去贵州）、校企联培（要去企业）。</li><li>叉院：国内 bar 最高的学院，至少要 985 rk1 + 在投顶会 &#x2F; ACM，6 月初就开营。</li><li>软件学院：没有夏令营，基本上是专硕，强com，主要看机试成绩，机试难度中等。</li><li>网研院：相当于贵系网安专业，难度比贵系低。</li><li>深研院：有计算机技术、人工智能、大数据、TBSI 四个方向，TBSI 是学硕，其他都是专硕，计算机技术机试很难，人工智能最卷，TBSI 要求六级 500+。</li><li>高等研究院：有 msra 校企联培博士，导师郭百宁，但是好像没啥人知道，可以早点联系捡漏。</li></ul><h2 id="2-北京大学"><a href="#2-北京大学" class="headerlink" title="2 北京大学"></a>2 北京大学</h2><p>北大的 offer 大多是夏令营发出去，预推免相当于补录了，可以报多个院系。</p><ul><li><p>计算机学院：超弱 com，完全取决于老师要不要你，夏令营无机试，面试走过场，需要尽早联系导师，去进组实习，bar 比贵系低，985 前 5% 就可以试试。夏令营之后，软件所一般鸽的比较多，还有外校基本只能拿直博。</p></li><li><p>智能学院：原信科智能所，和计算机学院的情况差不多。</p></li><li><p>软微：基本全是专硕，纯就业向，强com，入营主要看排名，不过据说从今年开始，也要做科研了。</p></li><li><p>深研院：基本全是学硕，弱com，不过坑导较多。</p></li><li><p>软微：</p><ul><li><p>不得不说北京真的是大城市，这是我第一次来北京，真的感受到了首都的魅力。</p><p>   复试分为两个部分：手撕算法题 + 面试</p><pre><code>  手撕算法题部分，当天面试的所有人都在一起写题，一共有三道题，选其中一道题手撕代码就可以了，难度大概是 easy 到 medium 之间吧，手撕快排也有，大模拟也有。  面试部分，首先你要给每位老师发你的简历，老师看到我是湖大的，就要我英文描述一下湖大的风景，其实我早有准备，当时背的是介绍长沙，我就活用了。然后老师让我抽一道基础题，我抽到了数据库系统，其实很不巧我就数据库没怎么复习，但是还是凭自己的记忆说了一通，然后老师还问了数据库系统和数据库管理系统的区别，我记得他说的是 DBS 和 DBMS 的区别，当时我秒懂，DBMS 我会啊，所以我又说了一通。  接着老师会拿出刚刚手撕的算法题问你觉得怎么样，写得对不对，你要尽可能展现出你的算法功底就好了，比方说一个很简单的求平方和，没有给你数据范围时，其实是一个大数乘法 + 大数加法。然后老师开始问我项目了，大概问了我的代码量和实现难点。</code></pre></li><li></li></ul></li></ul><h2 id="3-中科院"><a href="#3-中科院" class="headerlink" title="3 中科院"></a>3 中科院</h2><p>中科院各所差别极大，所内各组也差别极大，所谓“强组清北，弱组211”。中科院的师生比很高，一般硕导一年 0-1 个硕士名额，博导一年1硕1博，中科院可以报任意多个所（多准备几个邮箱多注册几个号就行）。计算机相关的研究所有：</p><p>表格 还在加载中，请等待加载完成后再尝试复制</p><p>各所基本是夏令营就招完学生，预推免相当于补录，另外，国科大计算机学院、人工智能学院也招生（比两所容易一些），导师基本是两所的。最后再说一下，虽然两所的实力要略强于华五，如果你以后从事专业相关的事情（如：学术届、企业技术岗），可以来两所；但如果以后从事非专业相关的事情（如：考公），更建议去华五。</p><ul><li>计算所：体系结构方向亚洲第一，AI 方向实力也很强，超弱com，你甚至没入营都可以拿 offer，有霸面机制，即如果你没有入营，老师也可以邀请你来面试，和入营的没区别。计算所是分组来考核的，所里不管，牛组竞争非常激烈（如寒武纪、龙芯、vipl等）。体系结构和 AI 的大牛很多，就不细说了。还有要注意很多组要求博士延毕一年。</li><li>自动化所：体量很大，光模式识别国重就 100 多位老师，AI 方向特别 CV 很强，模式识别国重有很多 AI 大牛。强 com，bar 985 前 5，以“未来的邀约”闻名于保研圈。</li><li>软件所：有计算机科学国重（软件与理论方向），另外中文信息实验室的孙l、韩xp老师也比较强（NLP 方向）。</li><li>信工所：有网安国重，有个 CV 组也很强（操xc组），不过，操老师去年跳槽到中山当院长了。</li><li>神仙院：深圳先进技术研究院，下面的数字所有个 MM Lab 很强，和港中大那个 MM Lab 、商汤、上海浦江实验室关系密切，负责人是乔y老师（3万引），另外组里董c老师也是大牛。</li></ul><h2 id="4-上海交通大学"><a href="#4-上海交通大学" class="headerlink" title="4 上海交通大学"></a>4 上海交通大学</h2><p>招生主要在夏令营，预推免招的少。注意上交电院博士毕业是出了名的难，据说基本 6 年起步。密西根是单独报名，其他院系在学校系统上报名，只能报一个。</p><ul><li>计算机系、网安：上交计算机系像贵系那样，各方向都有，都比较强。硕士非常难，2021 年非华五只录了 4 个，有机试。直博入营容易，没有机试，关键是要找到导师接收（直博没有导师接收，拿了优营也没用）。上交牛导很多，AI 方向有几个年轻老师特别火，如卢cw、张wn、张qs、严jc 等。</li><li>软件学院：国内最强的软件学院，以 ipads实验室（分布式系统方向）闻名，机试听说是开发软件，比较硬核。</li><li>网安学院：比计算机系要容易。</li><li>密西根学院：想去上交，密西根最容易，不过学费贵，导师一般。</li></ul><h2 id="5-浙江大学"><a href="#5-浙江大学" class="headerlink" title="5 浙江大学"></a>5 浙江大学</h2><p>浙大的计算机图形学国内第一，计算机学院体量也非常大。浙大只能报一个学院。</p><ul><li>计算机学院：夏令营只有直博，要去做一个多月的项目，内容由报名老师指定，8月下旬，每个博导可以推荐 1 名学生（院士 2 名），进入学院答辩环节（走过场）。浙大大量名额（含所有硕士名额）在预推免，不过要跟浙大本校竞争。CAD&amp;CG 国重里面有很多 CG、CV 大牛。</li><li>软件学院：在宁波，纯就业向，夏令营入营点击就送，千人海王营，考核要做项目，优营容易拿，但没什么用，还是要参加预推免，预推免有机试。</li><li>工程师学院：夏令营、预推免都有，比计算机学院容易。</li><li>国际联合学院：在嘉兴市海宁市（县级市），不太了解，招计算机专业的学生。</li></ul><h2 id="6-复旦大学"><a href="#6-复旦大学" class="headerlink" title="6 复旦大学"></a>6 复旦大学</h2><p>复旦的计算机是 B+，但是人工智能方向很强，学校 title 好，魔都位置好。复旦只能报一个学院。</p><ul><li>计算机学院：发放 offer 夏令营：预推免 &#x3D; 1 : 2，夏令营的 bar 巨高，985 一个专业只能入一个。有机试但不算分。NLP 组（黄邱张）很强，CV 方向姜yg组、薛xy组也比较强。</li><li>大数据学院：发统计学或金融学位证，难度不比计算机学院低，对数学要求高。</li><li>工研院：难度比计算机学院低。</li><li>类脑智能研究院：有部分老师做 AI 和生物交叉。</li></ul><h2 id="7-南京大学"><a href="#7-南京大学" class="headerlink" title="7 南京大学"></a>7 南京大学</h2><p>南大三个学院都可以报，但只能入一个，海王营，入营后有线上笔试，考408等专业课，没有机试，南大是超强 com。</p><ul><li>计算机系：软件所非常强，软件所在学院夏令营前有自己办的夏令营，另外 MCG 组的王lm老师是南大 CV 最强的老师，NLP 组黄sj老师也比较强。</li><li>人工智能学院：lamda（周zh组）非常强，主要是做机器学习、数据挖掘的， lamda 在学院夏令营前也有自己办的夏令营，lamda 一共两轮面试，第一轮学长面，第二轮报考老师面。注意拿了 lamda offer 后，还需要人工智能学院优营才能录取，南大的 com 非常强。</li><li>软件学院：比 CS、AI 容易一些，纯就业型。</li></ul><h2 id="8-中国科学技术大学"><a href="#8-中国科学技术大学" class="headerlink" title="8 中国科学技术大学"></a>8 中国科学技术大学</h2><p>中科大没有直博，全是硕士，系统里可以报三个志愿，只能入一个，基本上只有一志愿有用，中科大是弱 com。还有入营中科大后会收到入营大礼包！！！</p><ul><li>计算机学院：入营歧视软件专业，我校计算机前5%可入，软件只能入1%，没有预推免。AI方向做数据挖掘的多，几乎没有做CV的（都在自动化系、电子系）。BDAA（陈eh组）很强，陈eh老师是杰青，组里还有刘q、连df两位优青，人好学术好。网络方向李xy（ACM &#x2F; IEEE fellow）组很牛，组里张yy老师也是IEEE fellow，做智能感知的。另外计算机学院还有网红教授张l（逃）</li><li>自动化系（10系）：自动化系和电子系虽然同属信息学院，但招生是分开的，必须导师推荐才能入营，预推免有少量名额。CV 方向的张tz，查zj老师很强，都是优青+万引。</li><li>电子系（6系）：虽然叫电子系，其实很多老师是做人工智能的，大牛很多。何xn组（巨牛，30岁，2.2万引）非常强，何老师组里两位小老板也很强，王x（7k引）、冯fl（4k引），都是30岁出头。电子系AI方向还有吴f（院士候选人）、李hq、张yd等杰青，周wg、刘d、谢ht、王j等优青，实力非常强。</li><li>大数据学院：就是计算机、自动化、电子的老师，一般科大本校喜欢拿大数据学院名额，所以外校入营难，没有预推免。</li><li>网安学院：何xn的两个小老板都挂在网安学院，这里甚至还能找到潘建伟。</li><li>软件学院：一共就几个保研招生名额，主要招考研。</li><li>苏州研究院：比本部简单一些，值得一提的是，中科院计算所奇迹组的周sh老师（IEEE fellow，万引，医学影像大牛）全职来中科大，在这里招生物医学工程专业的学生（医学 CV 方向）。</li><li>先研院：比本部简单一些。</li><li>科学岛：中科院合肥物质研究院，发中科大毕业证，入营点击就送，最容易上岸华五的地方。</li></ul><h2 id="9-中国人民大学"><a href="#9-中国人民大学" class="headerlink" title="9 中国人民大学"></a>9 中国人民大学</h2><p>人大在中关村，位置好，学术强的老师大多在高瓴，强 com。人大信息和高瓴可以都报，也可以都入营，</p><ul><li>信息学院（王老吉）：夏令营 4 月 20 号左右就开放报名了，然后愣是 6 月 29 才发入营名单，官网通告栏一直是王老吉奖学金获奖公示，绿群群友们天天去刷学院官网都等不到入营名单，故称为王老吉学院。王老吉招生人数少，之前入营也少，bar 很高（学硕卡 985 rk2 左右），但今年是海王营了。王老吉数据库方向比较强，无预推免。</li><li>高瓴人工智能学院（加多宝）：王老吉的 hxd 当然是加多宝了。高瓴的老师基本都是做 AI 的（偏信息检索、数据挖掘），没有什么比较差的，下限很高，都做学术。高瓴只有学硕和直博，都在夏令营招生，没有预推免，鸽子比较多，一般入营即 offer，学硕 bar 挺高，可能 985 2% 左右，直博低一些。文jr、徐j等老师都是 msra 过来的，IR 大牛，严r老师是北大王选所过来的，NLP 大牛，还有几个姚班毕业的 AP 也很强。高瓴最大的劣势就是人大这个 title 不够好了吧。</li></ul><h2 id="10-其他学校的部分AI牛组"><a href="#10-其他学校的部分AI牛组" class="headerlink" title="10 其他学校的部分AI牛组"></a>10 其他学校的部分AI牛组</h2><p>我保研过程中了解到的其他学校的一些 AI 牛组（还有很多没列上来）：</p><p>南开大学程mm组（CV）、哈工大SCIR实验室（刘t组，NLP）、北航VR国重（CV）、厦门大学mac实验室（纪rr组，CV）、东南大学palm实验室（耿x组）、中山大学郑ws组（CV）、华科白x组（OCR）、上科大虞jy组（CV）、西湖大学李zq组（原自动化所大牛）、西湖大学张y组（NLP）。</p>]]></content>
      
      
      <categories>
          
          <category> 经验贴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 夏令营 </tag>
            
            <tag> 清北 </tag>
            
            <tag> 华五 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于动态规划/性价比/背包问题的思考</title>
      <link href="/2024/06/24/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%E6%80%A7%E4%BB%B7%E6%AF%94%E9%97%AE%E9%A2%98%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2024/06/24/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%E6%80%A7%E4%BB%B7%E6%AF%94%E9%97%AE%E9%A2%98%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="关于动态规划-性价比-背包问题的思考"><a href="#关于动态规划-性价比-背包问题的思考" class="headerlink" title="关于动态规划&#x2F;性价比&#x2F;背包问题的思考"></a>关于动态规划&#x2F;性价比&#x2F;背包问题的思考</h1><p>01背包本质上就可以用空间换时间，动规本质上也是那空间换时间，本身也就是一个贪心算法，所以<br>01背包&lt;–&gt;贪心&lt;–&gt;动态规划</p><p>如果说是0-1背包问题，需要逆序更新，原因是东西只有一个，不能影响之前的部分</p><p>如果是东西有无数个，则直接顺序更新</p><p>如果东西是牛奶之类的，有性价比，并且可以买非整数数量的，可以退化为贪心来做，结构体：数量，价格，性价比，sort一下就完事儿了。</p><p>讲究序列（排列问题），先遍历背包，不要求序列（组合问题），先遍历物品</p><p>滚动数组</p><p>另外，0-1背包要求倒序，若要求组合而非排列，即为先物品，再背包，且倒顺序，滚动数组添加</p><p>而且，如果是算有多少种，直接加就行,dp[0]&#x3D;1，其他为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[j]+=dp[j-nums[i]]</span><br><span class="line">    <span class="comment">//这里怎么去理解呢，会导致重复吗？</span></span><br><span class="line">    <span class="comment">//不会重复</span></span><br></pre></td></tr></table></figure><p>如果是要算最多&#x2F;最少，还要min和max比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j]=<span class="built_in">max</span>(dp[j],dp[j-nums[i]]+value[i])</span><br></pre></td></tr></table></figure><p>[(425条消息) 背包问题（背包九讲）_你好世界wxx的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_42638946/article/details/114028588?ops_request_misc=%7B%22request_id%22:%22167933155516800186567314%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=167933155516800186567314&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-6-114028588-null-null.142%5Ev74%5Epc_new_rank,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">https://blog.csdn.net/weixin_42638946/article/details/114028588?ops_request_misc=%7B%22request%5Fid%22%3A%22167933155516800186567314%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=167933155516800186567314&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-6-114028588-null-null.142^v74^pc_new_rank,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=01背包问题</a> 凑整&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by WXX on 2021/2/24 14:36</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j--) <span class="comment">//倒叙</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by WXX on 2021/2/24 15:21</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; j++)<span class="comment">//顺序</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by WXX on 2021/2/24 16:07</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  <span class="comment">// 先循环物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)  <span class="comment">// 再循环容量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++)  <span class="comment">// 最后循环决策</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++刷题</title>
      <link href="/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p>[(459条消息) 【C语言】程序运行过程：预处理&#x2F;编译&#x2F;汇编&#x2F;链接_预处理编译汇编链接_慕雪华年的博客-CSDN博客](<a href="https://blog.csdn.net/muxuen/article/details/123227200?ops_request_misc=%7B%22request_id%22:%22168596052316800182799736%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168596052316800182799736&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123227200-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E9%A2%84%E5%A4%84%E7%90%86">https://blog.csdn.net/muxuen/article/details/123227200?ops_request_misc=%7B%22request%5Fid%22%3A%22168596052316800182799736%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168596052316800182799736&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123227200-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=预处理</a> 编译 汇编 链接&amp;spm&#x3D;1018.2226.3001.4187)</p><p><a href="https://blog.csdn.net/weixin_54338498/article/details/126953046?ops_request_misc=%7B%22request_id%22:%22168175034116800197040062%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168175034116800197040062&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-126953046-null-null.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&utm_term=%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95&spm=1018.2226.3001.4187">(443条消息) 保研机试——1基础算法（排序、哈希、模拟（日期、图形、查找、进制、字符串）、递归与分治、贪心）_Yuezero_的博客-CSDN博客</a></p><p>[(425条消息) 数据结构保研面试题整理（自用）_保研数据结构常温问题_乌鸡摸鱼的博客-CSDN博客](<a href="https://blog.csdn.net/m0_52571748/article/details/120505195?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">https://blog.csdn.net/m0_52571748/article/details/120505195?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=数据结构</a> 保研&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-120505195.142^v73^pc_search_v2,201^v4^add_ask,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><p><a href="https://blog.csdn.net/qq_53524653/article/details/121522229?ops_request_misc=%7B%22request_id%22:%22168740926216782425172942%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168740926216782425172942&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121522229-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187">(463条消息) 插入排序–折半插入排序（来一来，看一看，走过路过，不要错过）_老 胡的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/385907273">P问题、NP问题、NPC问题、NP-hard问题详解 - 知乎 (zhihu.com)</a></p><p>[保研机试整理 - 知乎 (zhihu.com)</p><p>什么时候才考虑用二分答案的技巧？<br>正向求出答案不好入手，求解答案远远没有验证答案简单。</p><p>已知前序后序算中序有多少种：</p><p>[<a href="https://blog.csdn.net/qq_37437983/article/details/79613947">(441条消息) 二叉树遍历（已知前序和后序遍历，求中序遍历的可能的序列数）_已知二叉树的前序遍历和后序遍历_我要出家当道士的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/40915131"></a></p><p><a href="https://blog.csdn.net/yizhiniu_xuyw/article/details/109596961?ops_request_misc=%7B%22request_id%22:%22168707250016800213049573%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168707250016800213049573&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-109596961-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%A0%86%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1018.2226.3001.4187">(462条消息) 堆排序的时间复杂度分析_一只牛_007的博客-CSDN博客</a></p><p>建立索引树：[(462条消息) 2020北航计算机夏令营机试题目个人理解_北航夏令营 机试_四处碰壁嘤嘤怪的博客-CSDN博客](<a href="https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request_id%22:%22168715279416800185829257%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168715279416800185829257&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%8C%97%E8%88%AA%E5%A4%8F%E4%BB%A4%E8%90%A5">https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request%5Fid%22%3A%22168715279416800185829257%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168715279416800185829257&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=北航夏令营</a> 机试&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>scanf后，用getchar()吃掉回车</p><p>表示最大 INT_MAX(climits)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//malloc</span></span><br><span class="line"><span class="type">int</span> *nums;</span><br><span class="line">nums=(*<span class="type">int</span>)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//long long int 别用cin cout</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>scanf还会返回成功输入的变量的个数,因此可判定EOF</p><p>Floyd判圈法很吊</p><p>1.lower_bound(v.begin(), v.end(), key)-v.begin()返回有序序列中大于等于key的第一个值的位置<br>2.upper_bound(v.begin(), v.end(), key)-v.begin()返回有序序列中大于key的第一个值的位置<br>3.lower_bound(v.begin(), v.end(), key, greater<int>())-v.begin()返回有序序列中小于等于key的第一个值的位置<br>4.upper_bound(v.begin(), v.end(), key, greater<int>())-v.begin()返回有序序列中小于key的第一个值的位置<br>5.上述四个函数，若无满足条件的值，则返回v.size() </p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br></pre></td></tr></table></figure><h2 id="一些常用的库"><a href="#一些常用的库" class="headerlink" title="一些常用的库"></a>一些常用的库</h2><ol><li>algorithm</li><li>vector</li><li>map</li><li>queue</li><li>iostream</li><li>string</li><li>bits&#x2F;stdc++.h（带上就对了）</li><li>cmath(sqrt之类的)</li><li>climits（INT_MAX INT_MIN）</li></ol><p><strong>STL内置find()复杂度</strong>：<br><code>algorithm的find</code> 复杂度是<code>O(n)</code>，对vector，string等 顺序查询。<br><code>map::find</code> 和 <code>set::find</code> 复杂度是<code>O(logn)</code>，因为map和set底层都是红黑树。</p><hr><h3 id="vector"><a href="#vector" class="headerlink" title="vector:"></a><strong>vector:</strong></h3><p>下面是一些常用的vector方法：</p><ol><li><p><code>push_back</code>：在vector的末尾添加一个元素。</p></li><li><p><code>pop_back</code>：删除vector末尾的一个元素。</p></li><li><p><code>size</code>：返回vector中元素的个数。</p></li><li><p><code>clear</code>：删除vector中所有的元素。</p></li><li><p><code>empty</code>：判断vector是否为空。</p></li><li><p><code>at</code>：返回vector中指定位置的元素。</p></li><li><p><code>front</code>：返回第一个元素。</p></li><li><p><code>back</code>：返回最后一个元素。</p></li><li><p><code>erase</code>：删除vector中指定位置的元素。</p></li><li><p><code>insert</code>：在vector中指定位置插入一个元素或多个元素。</p></li><li><p><code>resize</code>：改变vector的大小。</p></li><li><p><code>reserve</code>：为vector预留一定的空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li><li><p><code>swap</code>：交换两个vector中的元素。</p></li><li><p><code>begin</code>：返回指向vector第一个元素的迭代器。</p></li><li><p><code>end</code>：返回指向vector最后一个元素之后的迭代器。 这些方法能够满足大部分情况下的需求，可以根据具体的使用场景选择合适的方法进行操作。</p></li></ol><p>要取迭代器的值，直接*指针取值</p><p>对于向量(vector)，它是一种支持随机访问的容器，因此<strong>可以直接通过下标访问向量中的元素</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 使用auto关键字定义迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector不能直接使用sort函数进行排序，需要传入一个迭代器指定排序的范围。修改代码如下：</p><p>sort(v.begin(),v.end(),com);</p><hr><h3 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h3><p>以下是C++中map类的常用方法：</p><ol><li><p>insert(make_pair&lt;key, value&gt;)：向map中插入一个键值对。</p></li><li><p>erase(key)：删除map中指定键的元素。</p></li><li><p>clear()：清空map中所有元素。</p></li><li><p>size()：返回map中元素的个数。</p></li><li><p>empty()：返回map是否为空。</p></li><li><p>find(key)：查找map中是否存在指定键的元素，如果存在则返回指向该元素的迭代器，否则返回end()迭代器。</p><p>常常和end联合起来用判断找到没。(<strong>这个适合动态查找，底层红黑树实现</strong>)</p></li><li><p>count(key)：返回指定键在map中出现的次数，如果不存在则返回0或1。</p></li><li><p>begin()：返回指向map第一个元素的迭代器。</p></li><li><p>end()：返回指向map最后一个元素后面的位置的迭代器。</p></li><li><p>operator[]：通过键访问map中的元素，如果键不存在，则自动插入一个新的键值对并返回对应的值。</p></li><li><p>lower_bound(key)：返回第一个大于或等于指定键的元素的迭代器。</p></li><li><p>upper_bound(key)：返回第一个大于指定键的元素的迭代器。</p></li><li><p>equal_range(key)：返回一个pair对象，其中包含lower_bound和upper_bound返回的迭代器。</p></li><li><p>swap(map2)：交换当前map和map2的元素。 C++中的map类是一种关联式容器，用于存储键值对，其中每个键都唯一，并且按照一定的顺序排列。map的底层实现通常是红黑树，因此查找、插入和删除操作的时间复杂度为O(log n)，其中n是map中元素的个数。map类提供了丰富的方法，可以方便地进行键值对的操作，例如插入、删除、查找、排序等。同时，由于map使用键值对来存储数据，因此可以将map看作是一种特殊的数组，其下标为键，对应的值为数组元素。因此，可以通过下标来访问和修改map中的元素。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;&#123;<span class="string">&quot;apple&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 使用auto关键字定义迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a><strong>stack</strong></h3><p>C++ 中的 stack 库提供了以下常用的方法：</p><ul><li>push(elem)：将元素 elem 压入栈顶。</li><li>pop()：弹出栈顶元素。</li><li>top()：返回栈顶元素，但不弹出。</li><li>empty()：判断栈是否为空。</li><li>size()：返回栈中元素的个数。 除此之外，stack 还支持以下操作：</li><li>emplace(args…)：构造一个新元素并将其压入栈顶。</li><li>swap(stack)：交换两个 stack 的元素。</li><li>operator&#x3D;&#x3D;、operator!&#x3D;、operator&lt;、operator&lt;&#x3D;、operator&gt;、operator&gt;&#x3D;：比较两个 stack 是否相等、不相等、小于、小于等于、大于、大于等于。 具体用法可以参考下面的示例代码</li></ul><p>stack元素可以是任何类型。</p><hr><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a><strong>queue</strong></h3><p>C++中的queue是一种容器适配器，用于实现“先进先出”（FIFO）的数据结构。queue基于deque或list进行实现，提供了一些方法来操作队列，包括入队、出队、获取队首元素、获取队列大小等。以下是queue的常用方法：</p><ol><li>push(element)：将一个元素加入队列的尾部。</li><li>pop()：将队列头部的元素弹出，但没有返回值。</li><li>front()：返回队列头部的元素。</li><li>top():返回队列头部元素（和front一样）</li><li>back()：返回队列尾部的元素。</li><li>empty()：判断队列是否为空。</li><li>size()：返回队列中元素的个数。 使用queue需要包含头文件，可以通过以下方式创建一个queue对象：</li></ol><p>对于队列(queue)，由于它是一种先进先出(FIFO)的数据结构，因此只能通过front()和back()函数来访问队列的头部和尾部元素，<strong>而不能直接通过下标访问</strong>。如果要使用下标访问队列元素，需要先将队列转换为数组或向量。 </p><hr><h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a><strong>priority_queue</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;string&gt; b;</span><br></pre></td></tr></table></figure><p>对于优先队列，复杂结构类型要重载运算符<a href="https://blog.csdn.net/qq_27278957/article/details/85269245?ops_request_misc=%7B%22request_id%22:%22168033538216800213097640%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168033538216800213097640&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-85269245-null-null.142%5Ev80%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=c++%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1018.2226.3001.4187">(436条消息) C++ 运算符重载_c 重载运算符_高祥xiang的博客-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="type">int</span> real;</span><br><span class="line"><span class="type">int</span> imag;</span><br><span class="line">......</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Complex c)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> real*real+imag*imag&lt;c.real*c.real+c.imag*c.imag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面这个const是必须要有的</p><hr><h3 id="string"><a href="#string" class="headerlink" title="string"></a><strong>string</strong></h3><p>C++中的string类是一个封装了字符串操作的类，提供了一系列方法来处理和操作字符串。以下是常用的string类方法：</p><ol><li><p>length()：返回字符串的长度。</p></li><li><p>size()：返回字符串的长度。</p></li><li><p>clear()：清空字符串。</p></li><li><p>empty()：判断字符串是否为空。</p></li><li><p>assign(str)：将字符串的值设置为str。</p></li><li><p>assign(str, pos, len)：将字符串的值设置为str中从pos位置开始的长度为len的子串。</p></li><li><p>append(str)：在字符串的末尾添加str。</p></li><li><p>append(str, pos, len)：在字符串的末尾添加str中从pos位置开始的长度为len的子串。</p></li><li><p>push_back(ch)：在字符串的末尾添加一个字符。</p></li><li><p>insert(pos, str)：在字符串的pos位置插入str。</p></li><li><p>erase(pos, len)：删除从pos位置开始长度为len的子串。</p><p>erase(n):删除indexn后面的字符</p></li><li><p>replace(pos, len, str)：替换从pos位置开始长度为len的子串为str。</p></li><li><p><strong>substr(pos, len)：返回从pos位置开始长度为len的子串。</strong></p></li><li><p><strong>find(str)：查找str在字符串中第一次出现的位置，返回该位置的索引值。</strong>(找不到就是-1)</p></li><li><p>rfind(str)：查找str在字符串中最后一次出现的位置，返回该位置的索引值。</p></li><li><p>compare(str)：比较字符串和str的大小，返回0（相等）、1（大于）或-1（小于）。 除了以上列举的方法，string类还支持重载运算符，例如+（字符串拼接）、+&#x3D;（字符串拼接赋值）、&#x3D;&#x3D;（字符串相等判断）、[]（访问字符串中指定位置的字符）等。string类的使用非常方便，可以像使用普通变量一样对字符串进行赋值、拼接、查找、替换等操作。例如：</p></li></ol><p>注意string s，其s[i]类型为char，char强制类型转换可以这样转换</p><p>string(1,s[i])，1表示char长度</p><p>s[i]可以直接比较</p><p>输入str1,如果str1为空则退出</p><p><img src="C:\Users\11505\AppData\Roaming\Typora\typora-user-images\image-20230313213418581.png" alt="image-20230313213418581"></p><p>scanf不会读回车，如果下一行是gets会直接读取缓冲区中的回车，所有会用一个getchar()在中间把缓冲区中的回车抵消掉</p><p>stoi(str) 将其转换为整数，注意，如果是”04”,直接变成4</p><p>string::npos用于判断结尾（其实找不到直接-1也行）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find函数返回 jk 在 s 中的下标位置</span></span><br><span class="line">position = s.<span class="built_in">find</span>(<span class="string">&quot;jk&quot;</span>);</span><br><span class="line"><span class="comment">// 如果没找到，返回一个特别的标志</span></span><br><span class="line"><span class="comment">// c++中用npos表示，我这里npos取值是4294967295</span></span><br><span class="line"><span class="keyword">if</span>(position != s.npos)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;position: &quot;</span> &lt;&lt; position &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Not found the flag&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果输入的字符串有空格，那么用如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin,str)</span><br></pre></td></tr></table></figure><p>可以直接通过下标修改字符</p><p>删除字符串内重复字符:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;aadfgggh&quot;</span>;</span><br><span class="line"><span class="comment">//去重复</span></span><br><span class="line"><span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="built_in">unique</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>()),str.<span class="built_in">end</span>());  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除字符串内某个指定字符:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;aadfgggh&quot;</span>;</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>(),<span class="string">&#x27;a&#x27;</span>),str.<span class="built_in">end</span>()); <span class="comment">//在容器中, 删除[begin,end)之间的所有值等于&#x27;a&#x27;的值.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line">string::<span class="built_in">erase</span>(begin,end)：删除[begin,end)之间的所有值c</span><br></pre></td></tr></table></figure><p>在Find the Smallest Number中，我发现string的超出index一位的位置依然可以访问，但是没有数</p><hr><h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a><strong>algorithm</strong></h3><p>C++标准库中的algorithm库提供了许多常用的算法，这些算法可以用于处理容器中的数据，例如排序、查找、遍历等。以下是algorithm库中常用的方法：</p><ol><li>sort(first, last, func)：对[first, last)区间内的元素进行升&#x2F;降序排序（取决于func返回）。</li><li>reverse(first, last)：对[first, last)区间内的元素进行翻转。</li><li>find(first, last, val)：在[first, last)区间内查找值为val的元素，返回该元素的迭代器。如果没有找到，返回last。</li><li>find_if(first, last, pred)：在[first, last)区间内查找满足条件pred的第一个元素，返回该元素的迭代器。如果没有找到，返回last。</li><li>count(first, last, val)：统计[first, last)区间内值为val的元素个数。</li><li>count_if(first, last, pred)：统计[first, last)区间内满足条件pred的元素个数。</li><li>accumulate(first, last, init)：对[first, last)区间内的元素进行累加，初始值为init。</li><li>max_element(first, last)：返回[first, last)区间内的最大元素的迭代器。</li><li>min_element(first, last)：返回[first, last)区间内的最小元素的迭代器。</li><li>unique(first, last)：对[first, last)区间内的元素去重，返回去重后的末尾迭代器。</li><li>remove(first, last, val)：删除[first, last)区间内值为val的元素，返回删除后的末尾迭代器。</li><li>remove_if(first, last, pred)：删除[first, last)区间内满足条件pred的元素，返回删除后的末尾迭代器。</li><li>for_each(first, last, func)：对[first, last)区间内的元素执行操作func。</li><li>transform(first1, last1, first2, result, op)：将[first1, last1)区间内的元素和[first2, …)区间内的元素进行op操作，并将结果存储到[result, …)区间内。</li></ol><h3 id="climits"><a href="#climits" class="headerlink" title="climits"></a>climits</h3><p><climits>中定义的常量主要有以下几种：</p><ol><li>整数类型的最大值和最小值：INT_MAX、INT_MIN、LONG_MAX、LONG_MIN、SHRT_MAX、SHRT_MIN等等。</li><li>字符类型的最大值和最小值：CHAR_MAX、CHAR_MIN、SCHAR_MAX、SCHAR_MIN、UCHAR_MAX等等。</li><li>位数相关的常量：CHAR_BIT、INT_BIT、LONG_BIT等等。</li><li>其他常量：MB_LEN_MAX表示一个多字节字符的最大长度，FLT_MAX、FLT_MIN、DBL_MAX、DBL_MIN等等表示浮点类型的最大值和最小值。</li></ol><h2 id="设置输出精度"><a href="#设置输出精度" class="headerlink" title="设置输出精度"></a>设置输出精度</h2><p>设置输出精度为1位小数</p><p>cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; ans &lt;&lt; endl</p><h2 id="设置输出位数"><a href="#设置输出位数" class="headerlink" title="设置输出位数"></a>设置输出位数</h2><p>printf(“%02d”,&amp;)</p><p>前面补零，两位，不够两位就补零</p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p><a href="https://zhuanlan.zhihu.com/p/83334559">KMP 算法详解 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/v_JULY_v/article/details/7041827?ops_request_misc=%7B%22request_id%22:%22167957843316800227474381%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167957843316800227474381&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-7041827-null-null.142%5Ev76%5Epc_new_rank,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=KMP&spm=1018.2226.3001.4187">(427条消息) 从头到尾彻底理解KMP（2014年8月22日版）_kmp算法难吗是什么级别_v_JULY_v的博客-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(<span class="type">char</span>* p,<span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k]) </span><br><span class="line">&#123;</span><br><span class="line">++k;</span><br><span class="line">++j;</span><br><span class="line">next[j] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kmp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    </span></span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    </span></span><br><span class="line"><span class="comment">//next[j]即为j所对应的next值      </span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == pLen)</span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="最大连续子序列"><a href="#最大连续子序列" class="headerlink" title="最大连续子序列"></a>最大连续子序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> nums[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;N)&#123;</span><br><span class="line"><span class="keyword">if</span> (N==EOF)<span class="keyword">break</span>;</span><br><span class="line"><span class="type">int</span> maxnum=INT_MIN;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">cin&gt;&gt;nums[i];</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (N==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">dp[i]=<span class="built_in">max</span>(nums[i],dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">maxnum=<span class="built_in">max</span>(dp[i],maxnum);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最大子矩阵"><a href="#最大子矩阵" class="headerlink" title="最大子矩阵"></a>最大子矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> matrix[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> support[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hangmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> maxnum;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=<span class="built_in">max</span>(arr[i],dp[i<span class="number">-1</span>]+arr[i]);</span><br><span class="line">maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">allmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> maxnum;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">1</span>)&#123;</span><br><span class="line">arr[k]=support[j][k];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">arr[k]=support[j][k]-support[i<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">maxnum=<span class="built_in">max</span>(<span class="built_in">hangmax</span>(n),maxnum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">cin&gt;&gt;matrix[i][j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">1</span>)support[i][j]=matrix[i][j];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">support[i][j]=matrix[i][j]+support[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxnum;</span><br><span class="line">maxnum=<span class="built_in">allmax</span>(n);</span><br><span class="line">cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长递增-减序列"><a href="#最长递增-减序列" class="headerlink" title="最长递增&#x2F;减序列"></a>最长递增&#x2F;减序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> daodan[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> maxnum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (daodan[i]&lt;=daodan[j])</span><br><span class="line">dp[i]=<span class="built_in">max</span>(<span class="number">1</span>,dp[j]+<span class="number">1</span>);</span><br><span class="line">maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;daodan[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxnum;</span><br><span class="line">maxnum=<span class="built_in">countmax</span>(n);</span><br><span class="line">cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大上升子序列和（O-N-2-）"><a href="#最大上升子序列和（O-N-2-）" class="headerlink" title="最大上升子序列和（O(N^2)）"></a>最大上升子序列和（O(N^2)）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> nums[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> maxsum;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i]&gt;nums[j])</span><br><span class="line">dp[i]=<span class="built_in">max</span>(nums[i],dp[j]+nums[i]);</span><br><span class="line">maxsum=<span class="built_in">max</span>(maxsum,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxsum;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;nums[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">maxsum=<span class="built_in">countmax</span>(n);</span><br><span class="line">cout&lt;&lt;maxsum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h3><p>1<br>7<br>3<br>5<br>9<br>4<br>8<br>3</p><p><a href="https://blog.csdn.net/lxt_Lucia/article/details/81209962?ops_request_misc=%7B%22request_id%22:%22168639963816800225544693%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168639963816800225544693&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81209962-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=LCS&spm=1018.2226.3001.4187">(461条消息) 最长公共子序列 (LCS) 详解+例题模板（全）_lxt_Lucia的博客-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s1;</span><br><span class="line">string s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(string s1,string s2)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> length1=s1.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> length2=s2.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> dp[length1][length2];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;length1;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;length2;j++)&#123;</span><br><span class="line">dp[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxnum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;length1;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;length2;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (s1[i]==s2[j])&#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">dp[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">dp[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">maxnum=<span class="built_in">max</span>(maxnum,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;s1&gt;&gt;s2)&#123;</span><br><span class="line"><span class="type">int</span> maxnum=<span class="built_in">countmax</span>(s1,s2);</span><br><span class="line">cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LIS（Nlogn）"><a href="#LIS（Nlogn）" class="headerlink" title="LIS（Nlogn）"></a>LIS（Nlogn）</h3><p><a href="https://blog.csdn.net/lxt_Lucia/article/details/81206439?ops_request_misc=%7B%22request_id%22:%22168766303316800185860492%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168766303316800185860492&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81206439-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97&spm=1018.2226.3001.4187">(465条消息) 最长上升子序列 (LIS) 详解+例题模板 (全)_lxt_Lucia的博客-CSDN博客</a></p><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">d</span>&#123;</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> C,N;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;C&gt;&gt;N)&#123;</span><br><span class="line"><span class="keyword">if</span> (C==<span class="number">0</span>&amp;&amp;N==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="type">int</span> dp[C+<span class="number">1</span>];</span><br><span class="line">d deal[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=C;i++)&#123;</span><br><span class="line">dp[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">cin&gt;&gt;price&gt;&gt;score;</span><br><span class="line">deal[i].price=price;</span><br><span class="line">deal[i].score=score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=C;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span> (j&gt;=deal[i].price)&#123;</span><br><span class="line">dp[j]=<span class="built_in">max</span>(dp[j-deal[i].price]+deal[i].score,dp[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[C]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个背包的变种</p><p><a href="https://blog.csdn.net/weixin_41994332/article/details/115829716?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-115829716-blog-109011034.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-115829716-blog-109011034.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=1">(465条消息) 复旦大学2021年计算机学院机试题解_复旦oj_PyKt的博客-CSDN博客</a></p><p>这里是直接顺序的</p><h2 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS BFS"></a>DFS BFS</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> hight)</span>  <span class="comment">//合并函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>[hight - low + <span class="number">1</span>];  <span class="comment">//用 new 申请一个辅助函数</span></span><br><span class="line"><span class="type">int</span> i = low, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;    <span class="comment">// k为 b 数组的小标</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= hight)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">&#123;</span><br><span class="line">b[k++] = a[i++];  <span class="comment">//按从小到大存放在 b 数组里面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">b[k++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)  <span class="comment">// j 序列结束，将剩余的 i 序列补充在 b 数组中 </span></span><br><span class="line">&#123;</span><br><span class="line">b[k++] = a[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= hight)<span class="comment">// i 序列结束，将剩余的 j 序列补充在 b 数组中 </span></span><br><span class="line">&#123;</span><br><span class="line">b[k++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">k = <span class="number">0</span>;  <span class="comment">//从小标为 0 开始传送</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= hight; i++)  <span class="comment">//将 b 数组的值传递给数组 a</span></span><br><span class="line">&#123;</span><br><span class="line">a[i] = b[k++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]b;     <span class="comment">// 辅助数组用完后，将其的空间进行释放（销毁）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> hight)</span> <span class="comment">//归并排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; hight)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (low + hight) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">mergesort</span>(a, low, mid);          <span class="comment">//对 a[low,mid]进行排序</span></span><br><span class="line"><span class="built_in">mergesort</span>(a, mid + <span class="number">1</span>, hight);    <span class="comment">//对 a[mid+1,hight]进行排序</span></span><br><span class="line"><span class="built_in">merge</span>(a, low, mid, hight);       <span class="comment">//进行合并操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, a[<span class="number">100</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入数列中的元素个数 n 为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请依次输入数列中的元素：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mergesort</span>(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;归并排序结果&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> m=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quickpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="comment">//与运算，可判断奇偶，详细见注释</span></span><br><span class="line">sum=sum*a%m;<span class="comment">//取模运算</span></span><br><span class="line">a=a*a%m;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;<span class="comment">//位运算，右移，相当于除以2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="模拟问题"><a href="#模拟问题" class="headerlink" title="模拟问题"></a>模拟问题</h2><p>就是找规律，还行</p><h2 id="日期问题"><a href="#日期问题" class="headerlink" title="日期问题"></a>日期问题</h2><p>要预处理</p><h2 id="最大公因数-最小公倍数"><a href="#最大公因数-最小公倍数" class="headerlink" title="最大公因数&#x2F;最小公倍数"></a>最大公因数&#x2F;最小公倍数</h2><p>最小公倍数&#x3D;a*b&#x2F;c</p><p>c为最大公因数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大公因数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">biggest</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b!=<span class="number">0</span>?<span class="built_in">biggest</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最小公倍数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">smallest</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> big=<span class="built_in">biggest</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> a*b/big;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;n)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">2</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> sushu[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sushu[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (sushu[i]==<span class="literal">false</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=i;j*i&lt;=n;j++)&#123; <span class="comment">//j直接从i开始，提高效率</span></span><br><span class="line"><span class="keyword">if</span> (j*i&lt;n)&#123;</span><br><span class="line">sushu[j*i]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (sushu[i])&#123;</span><br><span class="line"><span class="keyword">if</span> (i%<span class="number">10</span>==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个数n，其质因数最多只有一个大于其平方根！</p><h2 id="矩阵乘法（构造函数）"><a href="#矩阵乘法（构造函数）" class="headerlink" title="矩阵乘法（构造函数）"></a>矩阵乘法（构造函数）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line"><span class="type">int</span> matrix[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> row;</span><br><span class="line"><span class="type">int</span> col;</span><br><span class="line"><span class="built_in">Matrix</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">row</span>(a),<span class="built_in">col</span>(b)&#123;&#125;<span class="comment">//注意构造函数的写法</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Matrix <span class="title">Multiply</span><span class="params">(Matrix a,Matrix b)</span></span>&#123;</span><br><span class="line">Matrix ans=<span class="built_in">Matrix</span>(a.row,b.col);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.row;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;b.col;j++)&#123;</span><br><span class="line"><span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;a.col;k++)&#123;</span><br><span class="line">temp+=a.matrix[i][k]*b.matrix[k][j];</span><br><span class="line">&#125;</span><br><span class="line">ans.matrix[i][j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMatrix</span><span class="params">(Matrix m)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> row=m.row;</span><br><span class="line"><span class="type">int</span> col=m.col;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (j!=<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;m.matrix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Matrix a=<span class="built_in">Matrix</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Matrix b=<span class="built_in">Matrix</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">cin&gt;&gt;a.matrix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">cin&gt;&gt;b.matrix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Matrix c=<span class="built_in">Multiply</span>(a,b);</span><br><span class="line"><span class="built_in">printMatrix</span>(c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><a href="https://so.csdn.net/so/search?spm=1000.2115.3001.4498&q=prim%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91&t=&u=">prim算法求最小生成树- CSDN搜索</a></p><p>kruscal</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(edge c)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> weight&gt;c.weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">edge</span>(<span class="type">int</span> q,<span class="type">int</span> w,<span class="type">int</span> e):<span class="built_in">a</span>(q),<span class="built_in">b</span>(w),<span class="built_in">weight</span>(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;edge,vector&lt;edge&gt;,greater&lt;edge&gt;&gt;edges;</span><br><span class="line"><span class="type">int</span> graph[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (graph[x]==<span class="number">-1</span>)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">temp=<span class="built_in">find</span>(graph[x]);</span><br><span class="line">graph[x]=temp;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;n)&#123;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="type">int</span> a,b,weight;</span><br><span class="line"><span class="type">int</span> num=n*(n<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">memset</span>(graph,<span class="number">-1</span>,<span class="built_in">sizeof</span>(graph));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">graph[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (num--)&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">edge edge1=<span class="built_in">edge</span>(a,b,weight);</span><br><span class="line">edges.<span class="built_in">push</span>(edge1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!edges.<span class="built_in">empty</span>()&amp;&amp;count&lt;n<span class="number">-1</span>)&#123;</span><br><span class="line">edge temp=edges.<span class="built_in">top</span>();</span><br><span class="line">edges.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> a=<span class="built_in">find</span>(temp.a);</span><br><span class="line"><span class="type">int</span> b=<span class="built_in">find</span>(temp.b);</span><br><span class="line"><span class="type">int</span> weight=temp.weight;</span><br><span class="line"><span class="keyword">if</span> (a!=b)&#123;</span><br><span class="line">graph[a]=b;</span><br><span class="line">count++;</span><br><span class="line">sum+=weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="弗洛伊德"><a href="#弗洛伊德" class="headerlink" title="弗洛伊德"></a>弗洛伊德</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;k ++) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++) &#123; </span><br><span class="line"> <span class="keyword">if</span> (ans[i][k] == 无穷 || ans[k][j] == 无穷) <span class="keyword">continue</span>; </span><br><span class="line"> <span class="keyword">if</span> (ans[i][j] == 无穷 || ans[i][k] + ans[k][j] &lt; ans[i][j]) </span><br><span class="line"> ans[i][j] = ans[i][k] + ans[k][j]; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h2 id="迪杰斯特拉"><a href="#迪杰斯特拉" class="headerlink" title="迪杰斯特拉"></a>迪杰斯特拉</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123; <span class="comment">//初始化</span></span><br><span class="line"> Dis[i] = <span class="number">-1</span>; <span class="comment">//所有距离为-1，即不可达</span></span><br><span class="line"> mark[i] = <span class="literal">false</span>; <span class="comment">//所有结点不属于集合K</span></span><br><span class="line"> &#125; </span><br><span class="line"> Dis[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//得到最近的点为结点1,长度为0</span></span><br><span class="line"> mark[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//将结点1加入集合K</span></span><br><span class="line"> <span class="type">int</span> newP = <span class="number">1</span>; <span class="comment">//集合K中新加入的点为结点1 </span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i ++) &#123; <span class="comment">//循环n-1次,按照最短路径递增的顺序确定其他n-1个点的最短路径长度</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; edge[newP].<span class="built_in">size</span>();j ++) &#123; <span class="comment">//遍历与该新加入集合</span></span><br><span class="line">K中的结点直接相邻的边</span><br><span class="line"> <span class="type">int</span> t = edge[newP][j].next; <span class="comment">//该边的另一个结点</span></span><br><span class="line"> <span class="type">int</span> c = edge[newP][j].c; <span class="comment">//该边的长度</span></span><br><span class="line"> <span class="keyword">if</span> (mark[t] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">//若另一个结点也属于集合K,则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[t] == - <span class="number">1</span> || Dis[t] &gt; Dis[newP] + c) <span class="comment">//若该结点尚不可</span></span><br><span class="line">达,或者该结点从新加入的结点经过一条边到达时比以往距离更短</span><br><span class="line"> Dis[t] = Dis[newP] + c; <span class="comment">//更新其距离信息</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="type">int</span> min = <span class="number">123123123</span>; <span class="comment">//最小值初始化为一个大整数,为找最小值做准备</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++) &#123; <span class="comment">//遍历所有结点</span></span><br><span class="line"> <span class="keyword">if</span> (mark[j] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">//若其属于集合K则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[j] == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">//若该结点仍不可达则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[j] &lt; min) &#123; <span class="comment">//若该结点经由结点1至集合K中的某点在经过一条</span></span><br><span class="line">边到达时距离小于当前最小值</span><br><span class="line"> min = Dis[j]; <span class="comment">//更新其为最小值</span></span><br><span class="line"> newP = j; <span class="comment">//新加入的点暂定为该点</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉回路（hierholzer）"><a href="#欧拉回路（hierholzer）" class="headerlink" title="欧拉回路（hierholzer）"></a>欧拉回路（hierholzer）</h2><p><a href="https://blog.csdn.net/weixin_44316314/article/details/96898445?ops_request_misc=%7B%22request_id%22:%22168707940816800182775723%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168707940816800182775723&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-96898445-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E7%9A%84%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(462条消息) 欧拉回路（hierholzer算法）_逐步插入回路法_run around的博客-CSDN博客</a></p><h2 id="关键路径（AOE网）"><a href="#关键路径（AOE网）" class="headerlink" title="关键路径（AOE网）"></a>关键路径（AOE网）</h2><p>最早开始时间&#x3D;最晚开始时间</p><p>用拓扑图</p><p>最早开始时间（所有先序活动的最晚完成时间）</p><p>最晚开始时间（所有后续活动的最早开始时间减去该活动花费的时间）</p><p>注意源点的最早开始时间不一定为0，要初始化</p><p>汇点的最晚开始时间初始化为totalTime-该汇点任务的时间</p><p>非汇点的最晚开始时间为无穷</p><p>如果只是要求关键路径的长度，其实在earliest[i]初始化的时候就设置为任务的时间就行，但如果要算其他的，就还是设置为0</p><p>7 5<br>11 20 17 10 11 17 17<br>5 4<br>6 1<br>7 3<br>2 4<br>2 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yushu 1e9+7</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;zero;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;re;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line"><span class="type">int</span> to;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> in[<span class="number">100001</span>];</span><br><span class="line">vector&lt;edge&gt;edges[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> task[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> earliest[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> latest[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">in[i]=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;task[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num=m;</span><br><span class="line"><span class="type">int</span> allTime=<span class="number">0</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;input edge&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">while</span> (num--)&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">in[b]++;</span><br><span class="line">edge temp;</span><br><span class="line">temp.to=b;</span><br><span class="line">temp.weight=task[b];</span><br><span class="line">edges[a].<span class="built_in">push_back</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;input finished.&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[i]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span> (in[i]==<span class="number">0</span>)&#123;</span><br><span class="line">zero.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!zero.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> node=zero.<span class="built_in">front</span>();</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;zero:&quot;</span>&lt;&lt;node&lt;&lt;endl;</span><br><span class="line">zero.<span class="built_in">pop</span>();</span><br><span class="line">re.<span class="built_in">push_back</span>(node);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;edges[node].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> to=edges[node][i].to;</span><br><span class="line"><span class="type">int</span> weight=edges[node][i].weight;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;edge:&quot;</span>&lt;&lt;node&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;to&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;weight&lt;&lt;endl;</span><br><span class="line">earliest[to]=<span class="built_in">max</span>(earliest[to],earliest[node]+task[node]);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;to&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[to]&lt;&lt;endl;</span><br><span class="line">in[to]--;</span><br><span class="line"><span class="keyword">if</span> (in[to]==<span class="number">0</span>)&#123;</span><br><span class="line">zero.<span class="built_in">push</span>(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">allTime=<span class="built_in">max</span>(allTime,earliest[i]+task[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;reverse:&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=re.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> u=re[i];</span><br><span class="line"><span class="keyword">if</span> (edges[u].<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">latest[u]=allTime-task[u];</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;latest:[&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[u]&lt;&lt;endl;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">latest[u]=<span class="number">99999999</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;edges[u].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line"><span class="type">int</span> to=edges[u][j].to;</span><br><span class="line"><span class="type">int</span> weight=edges[u][j].weight;</span><br><span class="line">latest[u]=<span class="built_in">min</span>(latest[u],latest[to]-task[u]);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;latest:[&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[u]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[i]&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;latest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sum*=(latest[i]-earliest[i]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;allTime&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u011240016/article/details/53171808?ops_request_misc=%7B%22request_id%22:%22168784579716782425186584%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168784579716782425186584&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-53171808-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=AOE&spm=1018.2226.3001.4187">(466条消息) AOE问题总结_DrCrypto的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_44880154/article/details/114380592?ops_request_misc=&request_id=&biz_id=102&utm_term=AOE%E9%A2%98&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-114380592.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(466条消息) AOE网关键路径求解例题_关键路径例题图解_HardyDragon_CC的博客-CSDN博客</a></p><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><p><a href="https://blog.csdn.net/yc_cy1999/article/details/104580701?ops_request_misc=&request_id=&biz_id=102&utm_term=%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95%E9%A2%98%E5%8D%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104580701.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(443条消息) 2019年南京大学计算机考研复试机试真题_南大计算机专业考研机试_yc_cy1999的博客-CSDN博客</a></p><p>一个整数可以变为多少个整数相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//存所有状态</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j ++)<span class="comment">//j是容量</span></span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h2><p><a href="https://blog.csdn.net/qq12323qweeqwe/article/details/123083331?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-123083331.nonecase&spm=1018.2226.3001.4187">(462条消息) 291. 蒙德里安的梦想（状压dp）_seez的博客-CSDN博客</a></p><p>[(462条消息) <a href="https://blog.csdn.net/yl_puyu/article/details/109631735?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-109631735.nonecase&spm=1018.2226.3001.4187">状压dp] 蒙德里安的梦想(模板题+状压dp)_状压dp模板题_Ypuyu的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_27262727/article/details/105700957?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B4%AA%E5%BF%83%E9%A2%98%E7%9B%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105700957.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(462条消息) C++笔试题模版汇总(五)动态规划&#x2F;贪心_c++笔试题 考动态规划么_ai_XZP_master的博客-CSDN博客</a></p><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p>结论：把i个盘子移到另一个柱面上，需要2^i-1步</p><p><a href="https://zhuanlan.zhihu.com/p/392523306">关于汉诺塔问题 - 知乎 (zhihu.com)</a></p><h2 id="放置街灯（Placing-Lampposts-UVa-10859）-star"><a href="#放置街灯（Placing-Lampposts-UVa-10859）-star" class="headerlink" title="放置街灯（Placing Lampposts, UVa 10859）:star:"></a>放置街灯（Placing Lampposts, UVa 10859）:star:</h2><p><img src="C:\Users\11505\AppData\Roaming\Typora\typora-user-images\image-20230515221130204.png" alt="image-20230515221130204"></p><h2 id="经典贪心"><a href="#经典贪心" class="headerlink" title="经典贪心"></a>经典贪心</h2><p><a href="https://blog.csdn.net/KXL5180/article/details/82824003?ops_request_misc=%7B%22request_id%22:%22168424305316800227456811%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168424305316800227456811&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-82824003-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=UVa10382&spm=1018.2226.3001.4187">(450条消息) UVA-10382经典贪心问题，区间覆盖_uva 10382_KXL5180的博客-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//酸奶工程</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="comment">//定义long long，防止爆int</span></span><br><span class="line">ll n,s;</span><br><span class="line">ll c[<span class="number">10010</span>],y[<span class="number">10010</span>];<span class="comment">//存储费用和交互数量</span></span><br><span class="line">ll f[<span class="number">10010</span>];</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;c[i],&amp;y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            f[i]=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[i]=<span class="built_in">min</span>(c[i],f[i<span class="number">-1</span>]+s);</span><br><span class="line">        &#125;</span><br><span class="line">        sum=sum+f[i]*y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳跃问题"><a href="#跳跃问题" class="headerlink" title="跳跃问题"></a>跳跃问题</h2><p><a href="https://blog.csdn.net/weixin_41570890/article/details/110795229?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%982&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-110795229.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(462条消息) Leetcode——跳跃问题II_跳跃问题2_Purple.’’的博客-CSDN博客</a></p><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p><a href="https://blog.csdn.net/youngyangyang04/article/details/111190664?ops_request_misc=%7B%22request_id%22:%22168647702416800197016860%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168647702416800197016860&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-111190664-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C&spm=1018.2226.3001.4187">(462条消息) 「leetcode」135.分发糖果【贪心算法】详细图解_代码随想录的博客-CSDN博客</a></p><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p><a href="https://blog.csdn.net/weixin_45697774/article/details/104274713?ops_request_misc=%7B%22request_id%22:%22168667245116800197028500%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168667245116800197028500&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104274713-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E7%BA%BF%E6%AE%B5%E6%A0%91&spm=1018.2226.3001.4187">(462条消息) 线段树 从入门到进阶（超清晰，简单易懂）_线段树进阶_繁凡さん的博客-CSDN博客</a></p><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p><a href="https://blog.csdn.net/lemonxiaoxiao/article/details/108672039?ops_request_misc=%7B%22request_id%22:%22168667270816800222874127%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168667270816800222874127&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108672039-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(462条消息) 匈牙利算法详解_Amelie_xiao的博客-CSDN博客</a></p><p><strong>一个二分图中的最大匹配数等于这个图中的最小点覆盖数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> M, N;            <span class="comment">//M, N分别表示左、右侧集合的元素数量</span></span><br><span class="line"><span class="type">int</span> Map[MAXM][MAXN]; <span class="comment">//邻接矩阵存图</span></span><br><span class="line"><span class="type">int</span> p[MAXN];         <span class="comment">//记录当前右侧元素所对应的左侧元素</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN];      <span class="comment">//记录右侧元素是否已被访问过</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        <span class="keyword">if</span> (Map[i][j] &amp;&amp; !vis[j]) <span class="comment">//有边且未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[j] = <span class="literal">true</span>;                 <span class="comment">//记录状态为访问过</span></span><br><span class="line">            <span class="keyword">if</span> (p[j] == <span class="number">0</span> || <span class="built_in">match</span>(p[j])) <span class="comment">//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                p[j] = i;    <span class="comment">//当前左侧元素成为当前右侧元素的新匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回匹配成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//循环结束，仍未找到匹配，返回匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hungarian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)); <span class="comment">//重置vis数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">match</span>(i))</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>[(462条消息) 2018南京大学计算机夏令营机试第二题（回溯）_只会写臭虫的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_43175029/article/details/94670710?ops_request_misc=&request_id=&biz_id=102&utm_term=Missing">https://blog.csdn.net/weixin_43175029/article/details/94670710?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Missing</a> number  Given a positi&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-94670710.142^v88^control_2,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><p>回溯就是dfs，并且在每次dfs时记得恢复原状态；如果只需要输出一种状态，设置flag标志位</p><p>N皇后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// bool数组用来判断搜索的下一个位置是否可行</span></span><br><span class="line"><span class="comment">// col列，dg对角线，udg反对角线</span></span><br><span class="line"><span class="comment">// g[N][N]用来存路径</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// u == n 表示已经搜了n行，故输出这条路径</span></span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);   <span class="comment">// 等价于cout &lt;&lt; g[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);  <span class="comment">// 换行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 枚举u这一行，搜索合法的列</span></span><br><span class="line">    <span class="type">int</span> x = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; y ++ )</span><br><span class="line">        <span class="comment">// 剪枝(对于不满足要求的点，不再继续往下搜索)  </span></span><br><span class="line">        <span class="comment">// 这里y-x+n是左上角到右下角,y+x是左下角到右上角</span></span><br><span class="line">        <span class="keyword">if</span> (col[y] == <span class="literal">false</span> &amp;&amp; dg[y - x + n] == <span class="literal">false</span> &amp;&amp; udg[y + x] == <span class="literal">false</span>) &#123;</span><br><span class="line">            col[y] = dg[y - x + n] = udg[y + x] = <span class="literal">true</span>;</span><br><span class="line">            g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">            g[x][y] = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">// 恢复现场</span></span><br><span class="line">            col[y] = dg[y - x + n] = udg[y + x] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="建立索引树"><a href="#建立索引树" class="headerlink" title="建立索引树"></a>建立索引树</h2><p>[(462条消息) 2020北航计算机夏令营机试题目个人理解_北航夏令营 机试_四处碰壁嘤嘤怪的博客-CSDN博客](<a href="https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request_id%22:%22168715279416800185829257%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168715279416800185829257&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%8C%97%E8%88%AA%E5%A4%8F%E4%BB%A4%E8%90%A5">https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request%5Fid%22%3A%22168715279416800185829257%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168715279416800185829257&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=北航夏令营</a> 机试&amp;spm&#x3D;1018.2226.3001.4187)</p><p>注意 建树不一定要指针，数组也可</p><p>4 5<br>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
