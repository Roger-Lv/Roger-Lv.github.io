<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Windows11下安装WSL</title>
      <link href="/2024/07/19/Windows11%E4%B8%8B%E5%AE%89%E8%A3%85WSL/"/>
      <url>/2024/07/19/Windows11%E4%B8%8B%E5%AE%89%E8%A3%85WSL/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows11下安装WSL"><a href="#Windows11下安装WSL" class="headerlink" title="Windows11下安装WSL"></a>Windows11下安装WSL</h1><h2 id="一、WSL是什么？"><a href="#一、WSL是什么？" class="headerlink" title="一、WSL是什么？"></a>一、WSL是什么？</h2><p>开发人员可以在 Windows 计算机上同时访问 Windows 和 Linux 的强大功能。 通过适用于 Linux 的 Windows 子系统 (WSL)，开发人员可以安装 Linux 发行版（例如 Ubuntu、OpenSUSE、Kali、Debian、Arch Linux 等），并直接在 Windows 上使用 Linux 应用程序、实用程序和 Bash 命令行工具，不用进行任何修改，也无需承担传统虚拟机或双启动设置的费用。</p><h2 id="二、安装步骤"><a href="#二、安装步骤" class="headerlink" title="二、安装步骤"></a>二、安装步骤</h2><ol><li><p>确保电脑虚拟化开启</p><ol><li><p>控制面板-&gt;程序-&gt;启用或关闭 windows 功能，开启 Windows 虚拟化和 Linux 子系统（WSL2)以及Hyper-V。由于在Windows11中并没有Hyper-V，需要进行手动配置</p><p><img src="https://s2.loli.net/2024/07/19/A3LuWHaFGxiN1Xp.png" alt="image-20240719174041320.png"></p></li><li><p>配置Hyper-V</p><p>家庭版windows11没有Hyper-V，需要配置Hyper-V。打开vs code创建Hyper-7.cmd，复制以下内容并保存后执行。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pushd</span> &quot;%~dp0&quot;</span><br><span class="line"><span class="built_in">dir</span> /b <span class="variable">%SystemRoot%</span>\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class="line"><span class="keyword">for</span> /f <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;<span class="built_in">findstr</span> /i . hyper-v.txt <span class="number">2</span>^&gt;<span class="built_in">nul</span>&#x27;) <span class="keyword">do</span> dism /online /norestart /add-package:&quot;<span class="variable">%SystemRoot%</span>\servicing\Packages\<span class="variable">%%i</span>&quot;</span><br><span class="line"><span class="built_in">del</span> hyper-v.txt</span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL</span><br></pre></td></tr></table></figure></li></ol></li><li><p>系统安装<br>win11 使用 WSL2 安装 linux 子系统 ubuntu 出现错误：无法解析服务器的名称或地址。原本显示报错：ConnectionError: Couldn’t reach <a href="https://raw.githubusercontent.com/huggingfac">https://raw.githubusercontent.com/huggingfac</a><br>无法访问。</p><p>解决方法：</p><ol><li><p>修改 本地 host 文件。<br>记事本打开 C:\Windows\System32\drivers\etc\hosts 文件，添加如下解析地址（4个中有一个好用就添加它）</p><p>在<a href="https://www.ipaddress.com这个网站中的查询框中输入：raw.githubusercontent.com">https://www.ipaddress.com这个网站中的查询框中输入：raw.githubusercontent.com</a><br>在里面找到相应的的ipv4地址，这四个地址随便选一个即可（好用的）：</p><blockquote><p>185.199.108.133 raw.githubusercontent.com<br>185.199.109.133 raw.githubusercontent.com<br>185.199.110.133 raw.githubusercontent.com<br>185.199.111.133 raw.githubusercontent.com</p></blockquote></li></ol></li><li><p>在CMD中刷新 DNS 解析缓存<br>ipconfig &#x2F;flushdns</p></li><li><p>再次运行查看或安装命令<br>查看可安装的 WSL</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -o</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/19/L9XK5m1WUuCFagJ.png" alt="image-20240719174714709.png"></p></li><li><p>列出已安装版本</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/19/EMauckZm7XIsgbH.png" alt="image-20240719174508599.png"></p></li><li><p>wsl –install -d(安装):</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --install -d Ubuntu-<span class="number">22</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure></li><li><p>wsl -d (运行)：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -d Ubuntu-<span class="number">22</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/19/Qc8HYLlKUgT4Noy.png" alt="image-20240719174849821.png"></p></li><li><p>修改到D盘</p><p>由于默认是到C盘，现修改到C盘。</p><ol><li><p>关闭子系统</p><p>关闭界面&#x2F;输入如下命令关闭子系统。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown Ubuntu-<span class="number">22</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure></li><li><p>导出子系统</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --export Ubuntu-<span class="number">22</span>.<span class="number">04</span> D:/WSL/Ubuntu22.<span class="number">04</span>.tar</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/19/sxLkiu6fzeMSnt8.png" alt="image-20240719175252993.png"></p></li><li><p>注销原子系统</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister Ubuntu-<span class="number">22</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/19/VeGrK5x89pNmEUC.png" alt="image-20240719175312011.png"></p><p><img src="https://s2.loli.net/2024/07/19/ay8BjvmsLEM6zbO.png" alt="image-20240719175322005.png"></p></li><li><p>从D盘导入</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --import Ubuntu-<span class="number">22</span>.<span class="number">04</span> D:/WSL/Ubuntu-<span class="number">22</span>.<span class="number">04</span>.tar</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/19/vVk7RUDGqZlPOC5.png" alt="image-20240719175344296.png"></p><p><img src="https://s2.loli.net/2024/07/19/Nylr6I5Esx3kUch.png" alt="image-20240719175359321.png"></p></li><li><p>再次运行导入好的系统</p><p><img src="https://s2.loli.net/2024/07/19/Tx1PuMZdCLiYVEf.png" alt="image-20240719175427475.png"></p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> WSL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状压DP算法</title>
      <link href="/2024/07/18/2024-06-24-%E7%8A%B6%E5%8E%8BDP%E7%AE%97%E6%B3%95/"/>
      <url>/2024/07/18/2024-06-24-%E7%8A%B6%E5%8E%8BDP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h1><h2 id="使用状压DP的原因"><a href="#使用状压DP的原因" class="headerlink" title="使用状压DP的原因"></a>使用状压DP的原因</h2><p>我们知道状态压缩，顾名思义，就是需要考虑的状态非常多，我们如果用平常的思想去表示状态，那是非常不现实的，在时间和空间上都不允许，我们使用某种方法，以最小的代价表示某种状态。 那么，这通常是用进制来表示状态的，而选择几进制则根据要求使用的对象的点的状态有几种。一般来说，只有0和1，我们则是用二进制来表示，当然也有其他进制的题，在例题中会列举，需要我们灵活变通，主要谈二进制。</p><p>那么如何用二进制表示状态呢？我们发现，二进制上是按位分的，那么我们每一位可以看成一个点，而点上的取值则为该点的状态或者选择。例如00001001这个状态则表示第一个点和第四个点状态为1，其余的点状态为0。所以按照这种思想，能抽象的表示出一个很复杂的状态，实现了时间和空间的优化。</p><h2 id="状压DP的适用条件"><a href="#状压DP的适用条件" class="headerlink" title="状压DP的适用条件"></a>状压DP的适用条件</h2><p><strong>状态压缩其实是有适用环境的：</strong></p><ol><li>状态需要有一定的状态单元。 即一个状态应该是保存一个集合，其中的元素值对应着0或1，例如我们常见的棋盘，我们可以用0或1来表示棋子的放置状态。而整个集合即是一个01串，即二进制数，我们通常用十进制表示。那么我们再进行状态转移或者判断的时候，需要先将十进制转化为二进制，再将二进制转化为十进制。</li><li>题目中限制的集合大小不会超过20。 这是最显著的特征，为什么呢？我们知道如果用二进制表示状态，那么集合大小为20的二进制状态有2^{20} - 1已经达到1e7的数量级了。</li><li>具有动态规划的特性。 对于动态规划，一般都是要求最优化某个值，具有最优子结构的性质。同时也需要满足状态转移的特性，而不是前一个状态毫无关系的。</li></ol><p>适用环境总结：</p><ol><li>二进制</li><li>集合&#x2F;状态大小受限（比如不会大于int类型能表示的最大数）</li><li>满足动态规划特性</li></ol><h2 id="状压DP的板子"><a href="#状压DP的板子" class="headerlink" title="状压DP的板子"></a>状压DP的板子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> maxn = <span class="number">1</span> &lt;&lt; n;<span class="comment">//总状态数。</span></span><br><span class="line"><span class="comment">//枚举已有的集合数。按照状态转移的顺序，一般从小编号到大编号。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)&#123;</span><br><span class="line">    <span class="comment">//枚举当前集合中的状态。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxn; ++ j)&#123;</span><br><span class="line">        <span class="comment">//判断当前集合是否处于合法状态，通常我们需用一个数组提前处理好。如g数组;</span></span><br><span class="line">        <span class="keyword">if</span>(当前状态是否合格)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; maxn; ++ k)&#123;</span><br><span class="line">                <span class="comment">//枚举上一个集合的状态。</span></span><br><span class="line">                <span class="keyword">if</span>(上一个集合的状态是否合格 + 上一个集合的状态和当前状态的集合是否产生了冲突)&#123;</span><br><span class="line">                    列写状态转移方程。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="USACO06NOV-Corn-Fields-G"><a href="#USACO06NOV-Corn-Fields-G" class="headerlink" title=" USACO06NOV Corn Fields G"></a><a href="https://www.luogu.com.cn/problem/P1879"> USACO06NOV Corn Fields G</a></h3><p>农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。</p><p>遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。</p><p>John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）</p><p>输入格式</p><p>第一行：两个整数M和N，用空格隔开。</p><p>第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。</p><p>输出格式</p><p>一个整数，即牧场分配总方案数除以100,000,000的余数。</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 1 1</span><br><span class="line">0 1 0</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><p>思路：</p><p>我们先作出规定，定义n代表的是行，m代表的是列。那么牧场大小就是n × m。我们看到数据范围,n , m都特别小，同时所求为方案数，这很符合状压DP的适用条件。那么对于每一行，我们就可以看成一个未知集合，而集合的大小自然就是列m。对于每一个单元，其取值范围为0 , 1，而1代表放置奶牛，0代表不放置奶牛，所以我们自然可以用二进制表示，那么状态总数就是( 1 &lt; &lt; m ) − 1。 </p><ol><li>对于每一个状态，我们需要判断是否合格，而其中明确不能选择两块相邻的土地，在集合内，即相邻位不能全为1，所以我们可以预处理<strong>g数组</strong>，处理方式即为:g[i] &#x3D; !(i &amp; (i &lt;&lt; 1))（这里的i的取值从0到所有的状态）；</li><li>同样，我们还应该知晓土地的状况，因为毕竟只有土地肥沃才可以放置奶牛，则我们可以通过一个st数组判断，集合与集合之间，我们也需要考虑相邻位不能全为1，所以在枚举上一个集合的状态也需要严格判断。</li><li>对于状态定义，我们可以用f [ i ] [ j ]表示第i行且状态为j的方案数。</li><li>对于状态转移，假设上一行状态为k，则状态转移方程为：f [ i ] [ j ] + &#x3D; f [ i − 1 ] [ k ]</li></ol><p>答案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span> + <span class="number">5</span>,M = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;<span class="comment">//n行m列的土地。</span></span><br><span class="line"><span class="type">int</span> a[N][M],st[N];<span class="comment">//a代表土地，st代表每一行的土地状况。</span></span><br><span class="line"><span class="type">bool</span> g[<span class="number">1</span> &lt;&lt; N];<span class="comment">//g得到所有状态中的合法状态。</span></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">1</span> &lt;&lt; N];<span class="comment">//f[i][j]表示的则是第i行且状态为j的方案数，是由上一行转移过来的，所以我们定义上一行的状态为k。</span></span><br><span class="line"><span class="comment">//则状态转移方程为f[i][j] += f[i - 1][k];//其中j和k必须满足条件。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到每一行的土地状况。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)&#123;</span><br><span class="line">            st[i] = (st[i] &lt;&lt; <span class="number">1</span>) + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到所有状态中的合法状态。</span></span><br><span class="line">    <span class="type">int</span> maxn = <span class="number">1</span> &lt;&lt; m;<span class="comment">//总状态。</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//初始化，这种也算一种。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++ i)&#123;</span><br><span class="line">        g[i] = !( i &amp; (i &lt;&lt; <span class="number">1</span>));<span class="comment">//由于不能相邻，所以我们左移判断是否符合条件。 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="comment">//枚举每一行。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxn; ++ j)&#123;</span><br><span class="line">            <span class="comment">//枚举每一行的状态，判断此状态是否符合条件。1.不能相邻。2.是全部状态的子集。</span></span><br><span class="line">            <span class="keyword">if</span>(g[j] &amp;&amp; (j &amp; st[i]) == j)&#123;</span><br><span class="line">                <span class="comment">//如果符合条件。则我们去判断上一行是否符合。</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; maxn; ++ k)&#123;</span><br><span class="line">                    <span class="comment">//枚举上一行状态。注意，这里我们无需判断上一行状态是否存在，因为不存在即为0.</span></span><br><span class="line">                    <span class="comment">//只需要判断j和k是否存在相邻草地。</span></span><br><span class="line">                    <span class="keyword">if</span>(!(j &amp; k))&#123;</span><br><span class="line">                        f[i][j] = (f[i][j] + f[i - <span class="number">1</span>][k]) % P;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxn; ++ j)&#123;</span><br><span class="line">        ans = (ans + f[n][j]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="糖果"><a href="#糖果" class="headerlink" title="糖果"></a>糖果</h3><p>【问题描述】<br>糖果店的老板一共有 M 种口味的糖果出售。为了方便描述，我们将M种口味编号1~M。<br>小明希望能品尝到所有口味的糖果。遗憾的是老板并不单独出售糖果，而是K颗一包整包出售。<br>幸好糖果包装上注明了其中K颗糖果的口味，所以小明可以在买之前就知道每包内的糖果口味。<br>给定N包糖果，请你计算小明最少买几包，就可以品尝到所有口味的糖果<br>【输入格式】<br>第一行包含三个整数 N、M 和 K。<br>接下来 N 行每行 K个整数 T1,T2,….Tκ，代表一包糖果的口味。<br>【输出格式】<br>一个整数表示答案。如果小明无法品尝所有口味，输出-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> n=sc.nextInt();</span><br><span class="line">    <span class="type">int</span> m=sc.nextInt();</span><br><span class="line">    <span class="type">int</span> k=sc.nextInt();</span><br><span class="line">    <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[n][k];</span><br><span class="line">    <span class="type">int</span>[] sta = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>&lt;&lt;k];</span><br><span class="line">    Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">// 动规数组只有dp[0]为0，其余全部初始化-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=k; j++)&#123;</span><br><span class="line">            a[i][j] = sc.nextInt(); <span class="comment">// 读取数据</span></span><br><span class="line">            <span class="comment">/* 此处用sta[i]做了k次或赋值，解释如下。 */</span></span><br><span class="line">            <span class="comment">/* 对于数据a[i][j]，意味第i个包裹中的第j块糖果的种类 */</span></span><br><span class="line">            <span class="comment">/* 比如a[i][j]是第4类糖果，那么1&lt;&lt;(a[i][j]-1)的值为二进制的1000，也就是第四类糖果被选中。 */</span></span><br><span class="line">            <span class="comment">/* 当sta[i]做了k次或赋值后，sta[i]的二进制上会有若干个1，表示第i个包裹中有哪些类别的糖果。 */</span></span><br><span class="line">            sta[i] |= <span class="number">1</span> &lt;&lt; (a[i][j] - <span class="number">1</span>);           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 这里说明一下dp数组的含义 */</span></span><br><span class="line">        <span class="comment">/* dp[l] = k，表示要想获得l的二进制表示的所有糖果种类，至少要选取k个包裹。 */</span></span><br><span class="line">        <span class="comment">/* 由于我们刚刚初始化sta数组，那么这里表示的含义就是对于每一个包裹，要想获得这个包裹里的所有糖果种类，需要1个包裹。 */</span></span><br><span class="line">        dp[sta[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 接下来就是动规得出答案了 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123; <span class="comment">// 依次考虑每一个包裹，获取包裹后会对dp有什么影响</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;(<span class="number">1</span>&lt;&lt;m); j++) &#123; <span class="comment">// 在考虑包裹i时，对所有已经存在的状态j都做分析，看包裹i是否对状态j有所影响</span></span><br><span class="line">            <span class="keyword">if</span> (dp[j] == -<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// 状态j不存在，考虑下一个</span></span><br><span class="line">            <span class="comment">/* 分两种情况 */</span></span><br><span class="line">            <span class="comment">/* 状态j存在，但拿到包裹i后，状态j|sta[i]不存在，更新之 */</span></span><br><span class="line">            <span class="comment">/* 状态j存在，拿到包裹i后的状态也存在，但在状态j下拿到包裹i，比之前的代价更小，更新之 */</span></span><br><span class="line">            <span class="keyword">if</span> (dp[j | sta[i]] == -<span class="number">1</span> || dp[j] + <span class="number">1</span> &lt; dp[j|sta[i]]) &#123;</span><br><span class="line">                dp[j | sta[i]] = dp[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(dp[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>]); <span class="comment">// 最后输出的是要拿到所有糖果种类需要的最少包裹数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust中的错误处理</title>
      <link href="/2024/07/18/2024-07-18-Rust%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/2024/07/18/2024-07-18-Rust%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Rust中的错误处理"><a href="#Rust中的错误处理" class="headerlink" title="Rust中的错误处理"></a>Rust中的错误处理</h1><p>如果你使用过其他编程语言，那么就会知道Rust中的错误处理是完全不同的方法。像Java,JS,Python等你常常会使用<code>throw</code>处理异常，以及<code>return</code>成功的值。但在Rust中，你会返回给调用者一个<code>Result</code></p><p><code>Result&lt;T, E&gt;</code>是一个拥有两个值的枚举类型，其中<code>Ok(T)</code>用来返回成功值，<code>Err(E)</code>用来返回错误值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回错误而不是抛出错误,这是一种编程习惯的转变。所以如果你是Rust的初学者，可能刚开始学习起来觉得很麻烦，因为这需要你用去思考在不同的场景，应该使用什么样的方法去处理错误。</p><p>在这篇博客中会有错误处理的一些范式，以及它们在Rust中是如何体现的：</p><ul><li>忽略错误</li><li>直接结束程序</li><li>使用默认值处理</li><li>传递错误</li><li>传递多个错误</li><li>模式匹配Boxed错误</li><li>使用库 or 应用</li><li>创建自定义错误</li><li>传递自定义错误</li><li>模式匹配自定义错误</li></ul><h2 id="忽略错误-unwrap"><a href="#忽略错误-unwrap" class="headerlink" title="忽略错误(unwrap())"></a><strong>忽略错误</strong>(unwrap())</h2><p>（如果出现错误会触发panic，让该线程退出）</p><p>最简单的处理方法就是直接忽略这个错误，这听起来是不太好的想法，但是可以在以下情况使用：</p><ul><li>刚刚开始编写代码，不想浪费太多时间在错误处理上。</li><li>坚定确信当前的情况下，错误一定不会发生。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;./Cargo.toml&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使知道文件会存在，但是编译器也无法知道。因此，使用<code>unwrap()</code>关键字让编译器信任，并返回其中的值。如果<code>read_to_string()</code>函数返回一个<code>Ok()</code>，unwrap将获取<code>Ok()</code>的内容并将其分配给content变量。如果它返回一个错误，那么程序会陷入<code>panic</code>这回让当前程序线程退出。</p><blockquote><p>需要注意的是在许多Rust示例代码中使用<code>unwrap</code>来跳过错误处理，但是这样做主要是为了方便，不应该在实际开发中使用。</p></blockquote><h2 id="结束程序-expect"><a href="#结束程序-expect" class="headerlink" title="结束程序(expect())"></a><strong>结束程序</strong>(expect())</h2><p>有些错误无法处理或从中恢复。在这些情况下，最好直接终止程序。 让使用与上面相同的例子——正在读取一个文件，肯定会看到它。想象一下，对于这个程序来说，这个文件绝对重要，没有它就无法正常工作。如果由于某种原因，该文件不存在，那么最好应该直接终止该程序。</p><p>可以像之前一样使用<code>unwrap</code>或者使用<code>expect</code>，它和<code>unwrap</code>差不多，唯一不同的是添加了额外的错误信息。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;./Cargo.toml&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Can&#x27;t read Cargo.toml&quot;</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解关于：<code>panic!</code></p><h2 id="使用默认值-unwrap-or"><a href="#使用默认值-unwrap-or" class="headerlink" title="使用默认值(unwrap_or())"></a><strong>使用默认值</strong>(unwrap_or())</h2><p>在某些情况下，可以通过返回默认值来处理错误。</p><p>例如正在编写一个服务器，它监听的端口可以使用环境变量进行配置。如果没有设置环境变量，则访问该值将导致错误。但可以通过返回默认值来轻松处理这个问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">port</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;PORT&quot;</span>).<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;3000&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，使用在这里，使用了一种称为<code>unwrap_or</code>的<code>unwrap</code>变体，它允许提供默认值。</p><p>了解关于： <code>unwrap_or_else</code>, <code>unwrap_or_default</code></p><h2 id="传递错误给调用者"><a href="#传递错误给调用者" class="headerlink" title="传递错误给调用者"></a><strong>传递错误给调用者</strong></h2><p>当没有足够的context来处理错误时，可以将错误冒泡（向上传播）到调用者函数。下面是一个精心设计的示例，它使用Web服务获取当前年份：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">match</span> <span class="title function_ invoke__">get_current_date</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(date) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;We&#x27;ve time travelled to &#123;&#125;!!&quot;</span>, date),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;Oh noes, we don&#x27;t know which era we&#x27;re in! :( \n  &#123;&#125;&quot;</span>, e),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_current_date</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, reqwest::Error&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">url</span> = <span class="string">&quot;https://postman-echo.com/time/object&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">result</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(url);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">response</span> = <span class="keyword">match</span> result &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(res) =&gt; res,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">body</span> = response.json::&lt;HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">json</span> = <span class="keyword">match</span> body &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(json) =&gt; json,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">date</span> = json[<span class="string">&quot;years&quot;</span>].<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(date)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块在<code>get_current_date</code>中有两个函数调用(get和json)会返回Result值。因为get_current_date并没有返回错误时要做什么的上下文，所以使用模式匹配将错误传回main.</p><p>有时候在使用模式匹配去处理，多个嵌套的错误处理可能会让代码看起来非常混乱，所以可以引入<code>?</code>来重写上述代码.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">match</span> <span class="title function_ invoke__">get_current_date</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(date) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;We&#x27;ve time travelled to &#123;&#125;!!&quot;</span>, date),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;Oh noes, we don&#x27;t know which era we&#x27;re in! :( \n  &#123;&#125;&quot;</span>, e),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_current_date</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, reqwest::Error&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">url</span> = <span class="string">&quot;https://postman-echo.com/time/object&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">res</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(url)?.json::&lt;HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;&gt;()?;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">date</span> = res[<span class="string">&quot;years&quot;</span>].<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(date)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来简洁明了。其中<code>?</code>操作符类似于<code>unwrap</code>但是在遇到Error时并不会产生<code>panic</code>，而是会将错误返回给调用者函数。需要记住的一件事情是只有在函数返回<code>Option</code>和<code>Result</code>类型时才能使用<code>?</code>操作符。</p><p><a href="https://blog.csdn.net/qq_45983373/article/details/133816439">Rust语言中Option和Result两种类型的使用_rust option result-CSDN博客</a></p><p><strong>注意Option和Result：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中Option更多用于一个返回值不确定是否存在的情况下（可以理解为其他语言中的NULL）。</p><p>而Result更多用于会出现错误进行捕捉的场景。</p><p>所以会看到很多函数后面的返回值(可以return，也可以直接None&#x2F;Some&#x2F;Ok&#x2F;Err)是这样的，给出各自的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Option处理可能存在或不存在的值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_element_index</span>(arr: &amp;[<span class="type">i32</span>], target: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">usize</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, &amp;value) <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> value == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Result处理可能的错误情况</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Cannot divide by zero&quot;</span>) <span class="comment">//这里会返回Result中的Err，内容是这个字符串字面量</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(a / b) <span class="comment">//这里会返回Result中的Ok，内容就是实际除法得到的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里 &amp;&#x27;static str 表示错误信息是一个指向程序生命周期为整个程序的字符串字面量的引用。使用 &amp;&#x27;static str 而不是 String 可以避免在堆上分配内存，从而提高效率。</span></span><br><span class="line"><span class="comment">&amp;&#x27;static str 表示一个指向字符串字面量的引用，其生命周期是 &#x27;static。这意味着这个字符串字面量在程序的整个生命周期内都是有效的。</span></span><br><span class="line"><span class="comment">为什么使用 &#x27;static 生命周期？</span></span><br><span class="line"><span class="comment">避免动态内存分配：字符串字面量存储在程序的只读数据段中，使用 &#x27;static 生命周期可以避免在堆上为错误消息分配额外的内存。这在处理大量错误时尤其重要，因为它可以减少内存消耗。</span></span><br><span class="line"><span class="comment">简化错误处理：使用静态字符串可以简化错误处理逻辑，因为编译器可以保证这些字符串在整个程序生命周期内都是有效的，无需担心生命周期问题。*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用Option</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span> = <span class="title function_ invoke__">find_element_index</span>(&amp;numbers, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">match</span> index &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Element found at index: &#123;&#125;&quot;</span>, i),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Element not found&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Result</span></span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">divide</span>(<span class="number">10</span>, <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(result) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Result of division: &#123;&#125;&quot;</span>, result),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, error),</span><br><span class="line">    &#125;</span><br><span class="line"><span class="title function_ invoke__">divide</span>(<span class="number">10</span>,<span class="number">2</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="title function_ invoke__">divide</span>(<span class="number">10</span>,<span class="number">2</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;defined by yourself&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传递多个错误给调用者"><a href="#传递多个错误给调用者" class="headerlink" title="传递多个错误给调用者"></a><strong>传递多个错误给调用者</strong></h2><p>在之前的例子中，<code>get</code>和<code>json</code>函数返回了一个<code>reqwest::Error</code>错误。但是如果已经有了一个在调用其他的函数时返回的错误类型，那么应该怎么处理呢？</p><p>让通过返回格式化的日期而不是年份来扩展上一个示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="keyword">use</span> chrono::NaiveDate;</span><br><span class="line">  <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">get_current_date</span>() &#123;</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(date) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;We&#x27;ve time travelled to &#123;&#125;!!&quot;</span>, date),</span><br><span class="line">      <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;Oh noes, we don&#x27;t know which era we&#x27;re in! :( \n  &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">get_current_date</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, reqwest::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = <span class="string">&quot;https://postman-echo.com/time/object&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(url)?.json::&lt;HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;&gt;()?;</span><br><span class="line">-   <span class="keyword">let</span> <span class="variable">date</span> = res[<span class="string">&quot;years&quot;</span>].<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">+   <span class="keyword">let</span> <span class="variable">formatted_date</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, res[<span class="string">&quot;years&quot;</span>], res[<span class="string">&quot;months&quot;</span>] + <span class="number">1</span>, res[<span class="string">&quot;date&quot;</span>]);</span><br><span class="line">+   <span class="keyword">let</span> <span class="variable">parsed_date</span> = NaiveDate::<span class="title function_ invoke__">parse_from_str</span>(formatted_date.<span class="title function_ invoke__">as_str</span>(), <span class="string">&quot;%Y-%m-%d&quot;</span>)?;</span><br><span class="line">+   <span class="keyword">let</span> <span class="variable">date</span> = parsed_date.format(<span class="string">&quot;%Y %B %d&quot;</span>).<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(date)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上述的代码是不能编译的，由于parse_from_str返回了一个<code>chrono::format::ParseError</code>错误而不是<code>reqwest::Error</code></p><p>可以使用<code>Box</code>关键字来解决这个问题</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">use</span> chrono::NaiveDate;</span><br><span class="line">  <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">get_current_date</span>() &#123;</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(date) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;We&#x27;ve time travelled to &#123;&#125;!!&quot;</span>, date),</span><br><span class="line">      <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;Oh noes, we don&#x27;t know which era we&#x27;re in! :( \n  &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">- <span class="keyword">fn</span> <span class="title function_">get_current_date</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, reqwest::Error&gt; &#123;</span><br><span class="line">+ <span class="keyword">fn</span> <span class="title function_">get_current_date</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = <span class="string">&quot;https://postman-echo.com/time/object&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(url)?.json::&lt;HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;&gt;()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">formatted_date</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, res[<span class="string">&quot;years&quot;</span>], res[<span class="string">&quot;months&quot;</span>] + <span class="number">1</span>, res[<span class="string">&quot;date&quot;</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parsed_date</span> = NaiveDate::<span class="title function_ invoke__">parse_from_str</span>(formatted_date.<span class="title function_ invoke__">as_str</span>(), <span class="string">&quot;%Y-%m-%d&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">date</span> = parsed_date.format(<span class="string">&quot;%Y %B %d&quot;</span>).<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(date)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当想要发返回多个不同的错误时，返回一个特征对象 <code>Box&lt;dyn std::error::Error&gt;</code>是一种便利的处理方法。</p><p>了解更多关于： <code>anyhow</code>, <code>eyre</code></p><h2 id="模式匹配Boxed错误"><a href="#模式匹配Boxed错误" class="headerlink" title="模式匹配Boxed错误"></a><strong>模式匹配Boxed错误</strong></h2><p>目前为止，只在main中打印错误，而不是真正地去处理它们。如果想处理和恢复Box错误，需要“downcast”它们：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">use</span> chrono::NaiveDate;</span><br><span class="line">  <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">get_current_date</span>() &#123;</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(date) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;We&#x27;ve time travelled to &#123;&#125;!!&quot;</span>, date),</span><br><span class="line">-     <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;Oh noes, we don&#x27;t know which era we&#x27;re in! :( \n  &#123;&#125;&quot;</span>, e),</span><br><span class="line">+     <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">+       <span class="built_in">eprintln!</span>(<span class="string">&quot;Oh noes, we don&#x27;t know which era we&#x27;re in! :(&quot;</span>);</span><br><span class="line">+       <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(err) = e.downcast_ref::&lt;reqwest::Error&gt;() &#123;</span><br><span class="line">+         <span class="built_in">eprintln!</span>(<span class="string">&quot;Request Error: &#123;&#125;&quot;</span>, err)</span><br><span class="line">+       &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(err) = e.downcast_ref::&lt;chrono::format::ParseError&gt;() &#123;</span><br><span class="line">+         <span class="built_in">eprintln!</span>(<span class="string">&quot;Parse Error: &#123;&#125;&quot;</span>, err)</span><br><span class="line">+       &#125;</span><br><span class="line">+     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">get_current_date</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = <span class="string">&quot;https://postman-echo.com/time/object&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(url)?.json::&lt;HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;&gt;()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">formatted_date</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, res[<span class="string">&quot;years&quot;</span>], res[<span class="string">&quot;months&quot;</span>] + <span class="number">1</span>, res[<span class="string">&quot;date&quot;</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parsed_date</span> = NaiveDate::<span class="title function_ invoke__">parse_from_str</span>(formatted_date.<span class="title function_ invoke__">as_str</span>(), <span class="string">&quot;%Y-%m-%d&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">date</span> = parsed_date.format(<span class="string">&quot;%Y %B %d&quot;</span>).<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(date)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，必须知道get_current_date的实现细节（其中包含的不同错误），才能够在main中对其进行downcast。</p><p>了解更多关于: <code>downcast</code>, <code>downcast_mut</code></p><h2 id="库-vs-应用"><a href="#库-vs-应用" class="headerlink" title="库 vs 应用"></a><strong>库 vs 应用</strong></h2><p>如前面所述，使用Box带来的问题是：如果想要处理底层错误，必须了解函数的实现细节。当以<code>Box&lt; dyn std::error::Error&gt;</code>形式返回某个内容时，具体的类型信息将会丢失。为了以不同方式处理不同的错误，需要将它们向下转换为某个具体类型，这种转换可能会在运行时失败。</p><p>然而，脱离上下文，谈论好坏并不是很有用。一个很好的经验法则是思考当前正在编写的代码是一个“Application”还是“Library”：</p><h3 id="Application应用"><a href="#Application应用" class="headerlink" title="Application应用"></a><strong>Application应用</strong></h3><ul><li>您正在编写的代码将由最终用户使用。</li><li>大多数由应用程序代码生成的错误不会被处理，而是记录或报告给用户。</li><li>可以使用box错误。</li></ul><h3 id="Library库"><a href="#Library库" class="headerlink" title="Library库"></a><strong>Library库</strong></h3><ul><li>您正在编写的代码将被其他代码使用。一个“库”可以是开源crate，内部library等。</li><li>错误是库的API的一部分，因此库的使用者知道应该期望并从中恢复哪些错误。</li><li>库中的错误通常由用户处理，因此它们需要结构化且易于执行<a href="%5Bhttps://doc.rust-lang.org/1.30.0/book/2018-edition/ch06-02-match.html#matches-are-exhaustive%5D(https://link.zhihu.com/?target=https://doc.rust-lang.org/1.30.0/book/2018-edition/ch06-02-match.html#matches-are-exhaustive)">exhaustive match</a></li><li>如果您返回Box错误，那么库的使用者需要知道由代码、依赖项等创建的错误类型！</li><li>可以返回自定义错误，而不是Box错误。</li></ul><h2 id="创建自定义错误"><a href="#创建自定义错误" class="headerlink" title="创建自定义错误"></a><strong>创建自定义错误</strong></h2><p>对于library代码，可以将所有错误转换为自定义的错误类型，并返回它，而不是使用特征对象<code>box</code>。在的例子中，目前由两个错误<code>reqwest::Error</code>和<code>chrono::format::ParseError</code>。可以将它们分别转换为<code>MyCustomError::HttpError</code>和<code>MyCustomError::ParseError</code></p><p>首先要创建一个enum来装的两个错误变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">MyCustomError</span> &#123;</span><br><span class="line">  HttpError,</span><br><span class="line">  ParseError,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Error</code>trait规定实现必须<code>Debug</code>和<code>Display</code> traits:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">MyCustomError</span> &#123;</span><br><span class="line">  HttpError,</span><br><span class="line">  ParseError,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::error::Error <span class="keyword">for</span> <span class="title class_">MyCustomError</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">MyCustomError</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      MyCustomError::HttpError =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;HTTP Error&quot;</span>),</span><br><span class="line">      MyCustomError::ParseError =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;Parse Error&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样创建的自定义错误类型，这是一个非常简单的例子，但是没有包含太多关于错误的信息。但这应该足以作为创建更复杂、更现实的自定义错误的起点。下面是一些常见开发中的自定义错误处理的例子:<a href="https://link.zhihu.com/?target=https://github.com/BurntSushi/ripgrep/blob/12.1.1/crates/regex/src/error.rs">ripgrep</a>, <a href="https://link.zhihu.com/?target=https://github.com/seanmonstar/reqwest/blob/v0.10.7/src/error.rs">reqwest</a>, <a href="https://link.zhihu.com/?target=https://github.com/BurntSushi/rust-csv/blob/master/src/error.rs">csv</a> and <a href="https://link.zhihu.com/?target=https://github.com/serde-rs/json/blob/master/src/error.rs">serde_json</a></p><p>还有: <code>thiserror</code>, <code>snafu</code></p><h2 id="传递自定义错误"><a href="#传递自定义错误" class="headerlink" title="传递自定义错误"></a><strong>传递自定义错误</strong></h2><p>看看使用自定义错误类型后对于之前程序的修改</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// main.rs</span></span><br><span class="line"></span><br><span class="line">+ <span class="keyword">mod</span> error;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">use</span> chrono::NaiveDate;</span><br><span class="line">+ <span class="keyword">use</span> error::MyCustomError;</span><br><span class="line">  <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// skipped, will get back later</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">- <span class="keyword">fn</span> <span class="title function_">get_current_date</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">+ <span class="keyword">fn</span> <span class="title function_">get_current_date</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, MyCustomError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = <span class="string">&quot;https://postman-echo.com/time/object&quot;</span>;</span><br><span class="line">-   <span class="keyword">let</span> <span class="variable">res</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(url)?.json::&lt;HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;&gt;()?;</span><br><span class="line">+   <span class="keyword">let</span> <span class="variable">res</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(url)</span><br><span class="line">+     .<span class="title function_ invoke__">map_err</span>(|_| MyCustomError::HttpError)?</span><br><span class="line">+     .json::&lt;HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;&gt;()</span><br><span class="line">+     .<span class="title function_ invoke__">map_err</span>(|_| MyCustomError::HttpError)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">formatted_date</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, res[<span class="string">&quot;years&quot;</span>], res[<span class="string">&quot;months&quot;</span>] + <span class="number">1</span>, res[<span class="string">&quot;date&quot;</span>]);</span><br><span class="line">-   <span class="keyword">let</span> <span class="variable">parsed_date</span> = NaiveDate::<span class="title function_ invoke__">parse_from_str</span>(formatted_date.<span class="title function_ invoke__">as_str</span>(), <span class="string">&quot;%Y-%m-%d&quot;</span>)?;</span><br><span class="line">+   <span class="keyword">let</span> <span class="variable">parsed_date</span> = NaiveDate::<span class="title function_ invoke__">parse_from_str</span>(formatted_date.<span class="title function_ invoke__">as_str</span>(), <span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">+     .<span class="title function_ invoke__">map_err</span>(|_| MyCustomError::ParseError)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">date</span> = parsed_date.format(<span class="string">&quot;%Y %B %d&quot;</span>).<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(date)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意到使用了<code>map_err</code>将一个错误类型转换为另外的错误类型.</p><p>但是可以看到太多的verbose作为结果，的函数充斥着太多<code>map_err</code>调用。可以实现<code>From</code> trait，这样就会完成自动错误类型转换。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// error.rs</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[derive(Debug)]</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">MyCustomError</span> &#123;</span><br><span class="line">    HttpError,</span><br><span class="line">    ParseError,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">impl</span> <span class="title class_">std</span>::error::Error <span class="keyword">for</span> <span class="title class_">MyCustomError</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">MyCustomError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">      <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        MyCustomError::HttpError =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;HTTP Error&quot;</span>),</span><br><span class="line">        MyCustomError::ParseError =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;Parse Error&quot;</span>),</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">+ <span class="keyword">impl</span> <span class="title class_">From</span>&lt;reqwest::Error&gt; <span class="keyword">for</span> <span class="title class_">MyCustomError</span> &#123;</span><br><span class="line">+   <span class="keyword">fn</span> <span class="title function_">from</span>(_: reqwest::Error) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">+     MyCustomError::HttpError</span><br><span class="line">+   &#125;</span><br><span class="line">+ &#125;</span><br><span class="line"></span><br><span class="line">+ <span class="keyword">impl</span> <span class="title class_">From</span>&lt;chrono::format::ParseError&gt; <span class="keyword">for</span> <span class="title class_">MyCustomError</span> &#123;</span><br><span class="line">+   <span class="keyword">fn</span> <span class="title function_">from</span>(_: chrono::format::ParseError) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">+     MyCustomError::ParseError</span><br><span class="line">+   &#125;</span><br><span class="line">+ &#125;</span><br><span class="line"> <span class="comment">// main.rs</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mod</span> error;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">use</span> chrono::NaiveDate;</span><br><span class="line">  <span class="keyword">use</span> error::MyCustomError;</span><br><span class="line">  <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// skipped, will get back later</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">get_current_date</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, MyCustomError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = <span class="string">&quot;https://postman-echo.com/time/object&quot;</span>;</span><br><span class="line">-   <span class="keyword">let</span> <span class="variable">res</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(url)</span><br><span class="line">-     .<span class="title function_ invoke__">map_err</span>(|_| MyCustomError::HttpError)?</span><br><span class="line">-     .json::&lt;HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;&gt;()</span><br><span class="line">-     .<span class="title function_ invoke__">map_err</span>(|_| MyCustomError::HttpError)?;</span><br><span class="line">+   <span class="keyword">let</span> <span class="variable">res</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(url)?.json::&lt;HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;&gt;()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">formatted_date</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, res[<span class="string">&quot;years&quot;</span>], res[<span class="string">&quot;months&quot;</span>] + <span class="number">1</span>, res[<span class="string">&quot;date&quot;</span>]);</span><br><span class="line">-   <span class="keyword">let</span> <span class="variable">parsed_date</span> = NaiveDate::<span class="title function_ invoke__">parse_from_str</span>(formatted_date.<span class="title function_ invoke__">as_str</span>(), <span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">-     .<span class="title function_ invoke__">map_err</span>(|_| MyCustomError::ParseError)?;</span><br><span class="line">+   <span class="keyword">let</span> <span class="variable">parsed_date</span> = NaiveDate::<span class="title function_ invoke__">parse_from_str</span>(formatted_date.<span class="title function_ invoke__">as_str</span>(), <span class="string">&quot;%Y-%m-%d&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">date</span> = parsed_date.format(<span class="string">&quot;%Y %B %d&quot;</span>).<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(date)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在移除<code>map_err</code>后代码变得更加整洁了。</p><p>然而,<code>From</code>trait并不是一种能减少使用<code>map_err</code>的魔法。在上面的例子中，将类型转换从<code>get_current_data</code>函数内部移动到<code>From&lt;X&gt; for MyCustomError</code>实现.那么如果一个错误没有在<code>MyCustomError</code>出现过，就不能使用From trait，从而只能使用<code>map_err</code></p><h2 id="模式匹配自定义错误"><a href="#模式匹配自定义错误" class="headerlink" title="模式匹配自定义错误"></a><strong>模式匹配自定义错误</strong></h2><p>一直忽略了main的变动，现在要看看如何去处理自定义错误类型的模式匹配问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// main.rs</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mod</span> error;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">use</span> chrono::NaiveDate;</span><br><span class="line">  <span class="keyword">use</span> error::MyCustomError;</span><br><span class="line">  <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">get_current_date</span>() &#123;</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(date) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;We&#x27;ve time travelled to &#123;&#125;!!&quot;</span>, date),</span><br><span class="line">      <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Oh noes, we don&#x27;t know which era we&#x27;re in! :(&quot;</span>);</span><br><span class="line">-       <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(err) = e.downcast_ref::&lt;reqwest::Error&gt;() &#123;</span><br><span class="line">-         <span class="built_in">eprintln!</span>(<span class="string">&quot;Request Error: &#123;&#125;&quot;</span>, err)</span><br><span class="line">-       &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(err) = e.downcast_ref::&lt;chrono::format::ParseError&gt;() &#123;</span><br><span class="line">-         <span class="built_in">eprintln!</span>(<span class="string">&quot;Parse Error: &#123;&#125;&quot;</span>, err)</span><br><span class="line">-       &#125;</span><br><span class="line">+       <span class="keyword">match</span> e &#123;</span><br><span class="line">+         MyCustomError::HttpError =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;Request Error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">+         MyCustomError::ParseError =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;Parse Error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">+       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">get_current_date</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, MyCustomError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = <span class="string">&quot;https://postman-echo.com/time/object&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(url)?.json::&lt;HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt;&gt;()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">formatted_date</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, res[<span class="string">&quot;years&quot;</span>], res[<span class="string">&quot;months&quot;</span>] + <span class="number">1</span>, res[<span class="string">&quot;date&quot;</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parsed_date</span> = NaiveDate::<span class="title function_ invoke__">parse_from_str</span>(formatted_date.<span class="title function_ invoke__">as_str</span>(), <span class="string">&quot;%Y-%m-%d&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">date</span> = parsed_date.format(<span class="string">&quot;%Y %B %d&quot;</span>).<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(date)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>请注意，与Boxed错误不同，实际上可以直接匹配MyCustomError enum中的变量。<a href="https://zhuanlan.zhihu.com/p/492292655"></a></p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust构建自己的第一个项目</title>
      <link href="/2024/07/17/2024-07-17-Rust%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/"/>
      <url>/2024/07/17/2024-07-17-Rust%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Rust构建自己的第一个项目"><a href="#Rust构建自己的第一个项目" class="headerlink" title="Rust构建自己的第一个项目"></a>Rust构建自己的第一个项目</h1><p>几个核心命令：</p><p>cargo new xxx：用于新建项目</p><p>cargo build：用于在Cargo.toml中添加dependencies进行依赖的下载和编译</p><p>cargo run：用于运行</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>在目录下输入下列指令，例如要构建一个叫做hello-rust的项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello-rust</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/17/EBDu3SwHjL1neC7.png" alt="image-20240717224533358.png"></p><p><code>Cargo</code> 已经帮我们创建好默认项目了，还创建了个git的本地仓库，还有一些配置文件， <code>src/main.rs</code> 为编写应用代码的地方。</p><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>使用cargo run命令运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/17/mNL3feJjDEgQwSM.png" alt="image-20240717224940931.png"></p><p>可以看到会经历一个编译的过程后，打印出Hello,world！信息</p><h2 id="编写Hello-Rust"><a href="#编写Hello-Rust" class="headerlink" title="编写Hello-Rust"></a>编写Hello-Rust</h2><p>Cargo.toml文件是一个管理项目配置的文件，包括项目依赖等相关配置</p><p>添加配置在dependencies中：</p><p><img src="https://s2.loli.net/2024/07/17/f3v2g9nkEeCP1Bw.png" alt="image-20240717225346375.png"></p><p>在命令行中运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/17/q5HyoCIZ3QMJfiS.png" alt="image-20240717225528135.png"></p><p>可以看到除了我们自定义添加的ferris-say版本的依赖，还会自动添加好依赖的依赖</p><p>接下来就在 <code>src/main.rs</code> 中写入以下内容:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> ferris_says::say; <span class="comment">// from the previous step</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;stdout, BufWriter&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stdout</span> = <span class="title function_ invoke__">stdout</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello fellow Rustaceans!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">width</span> = message.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">writer</span> = BufWriter::<span class="title function_ invoke__">new</span>(stdout.<span class="title function_ invoke__">lock</span>());</span><br><span class="line">    <span class="title function_ invoke__">say</span>(message.<span class="title function_ invoke__">as_bytes</span>(), width, &amp;<span class="keyword">mut</span> writer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再执行</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/17/t3oD9w8rgWaKBeu.png" alt="image-20240717230124205.png"></p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java八股</title>
      <link href="/2024/07/10/2024-06-24-Java%E5%85%AB%E8%82%A1/"/>
      <url>/2024/07/10/2024-06-24-Java%E5%85%AB%E8%82%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Java八股"><a href="#Java八股" class="headerlink" title="Java八股"></a>Java八股</h1><p><a href="https://blog.csdn.net/leader_song/article/details/132094080?ops_request_misc=%7B%22request_id%22:%22171151104816800211548110%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171151104816800211548110&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-132094080-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%872023&spm=1018.2226.3001.4187">2024年 Java 面试八股文（20w字）_java八股文2023-CSDN博客</a></p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p><a href="https://blog.csdn.net/qq_62124267/article/details/135418799?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-135418799-blog-124295453.235%5Ev43%5Epc_blog_bottom_relevance_base7&spm=1001.2101.3001.4242.1&utm_relevant_index=1">面试被问了几百遍的 IOC 和 AOP ，一篇文章带你搞清楚！！！_ioc和aop的原理面试-CSDN博客</a></p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p><a href="https://blog.csdn.net/crazymakercircle/article/details/125059491?ops_request_misc=%7B%22request_id%22:%22171164453116800225568300%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171164453116800225568300&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125059491-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=sentinel&spm=1018.2226.3001.4187">sentinel （史上最全）-CSDN博客</a></p><h2 id="Gradle-Maven"><a href="#Gradle-Maven" class="headerlink" title="Gradle&amp;Maven"></a>Gradle&amp;Maven</h2><p><a href="https://flydean.blog.csdn.net/article/details/113803536?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-113803536-blog-133955312.235%5Ev43%5Epc_blog_bottom_relevance_base7&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-113803536-blog-133955312.235%5Ev43%5Epc_blog_bottom_relevance_base7&utm_relevant_index=2">gradle中的build script详解_gradle buildscript-CSDN博客</a></p><p>[Gradle和Maven的区别-CSDN博客](<a href="https://blog.csdn.net/weixin_45626288/article/details/131973787?ops_request_misc=%7B%22request_id%22:%22172024305816800185819613%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024305816800185819613&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-131973787-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=gradle">https://blog.csdn.net/weixin_45626288/article/details/131973787?ops_request_misc=%7B%22request%5Fid%22%3A%22172024305816800185819613%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=172024305816800185819613&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-131973787-null-null.142^v100^pc_search_result_base8&amp;utm_term=gradle</a> maven&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="线程池和锁"><a href="#线程池和锁" class="headerlink" title="线程池和锁"></a>线程池和锁</h2><p><a href="https://blog.csdn.net/qq_54070103/article/details/124108541?ops_request_misc=%7B%22request_id%22:%22172024328716800184129598%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024328716800184129598&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124108541-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E9%94%81&spm=1018.2226.3001.4187">面试+基础—–详细解读多线程（线程池、锁、死锁…）_多线程井发、死锁问题、线程池原理等-CSDN博客</a></p><p><a href="https://blog.csdn.net/u013541140/article/details/95225769?ops_request_misc=%7B%22request_id%22:%22172024532116800211519152%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024532116800211519152&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-95225769-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=%E7%BA%BF%E7%A8%8B%E6%B1%A0&spm=1018.2226.3001.4187">Java 多线程：彻底搞懂线程池_java线程池-CSDN博客</a></p><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p><a href="https://blog.csdn.net/qq_35190492/article/details/113174359?ops_request_misc=%7B%22request_id%22:%22172024555916800184190893%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024555916800184190893&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-113174359-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=netty&spm=1018.2226.3001.4187">【硬核】肝了一月的Netty知识点-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_33384191/article/details/129187707?ops_request_misc=%7B%22request_id%22:%22172024555916800184190893%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024555916800184190893&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129187707-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=netty&spm=1018.2226.3001.4187">超详细Netty入门，看这篇就够了！_netty框架-CSDN博客</a></p><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p><a href="https://blog.csdn.net/qq_41317495/article/details/108553894?ops_request_misc=%7B%22request_id%22:%22172024618916800185817050%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024618916800185817050&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108553894-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=JUnit&spm=1018.2226.3001.4187">JUnit详解-CSDN博客</a></p><h2 id="Pytest"><a href="#Pytest" class="headerlink" title="Pytest"></a>Pytest</h2><p><a href="https://blog.csdn.net/lovedingd/article/details/98952868?ops_request_misc=%7B%22request_id%22:%22172024619416800226527972%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024619416800226527972&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-98952868-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=pytest&spm=1018.2226.3001.4187">Python测试框架之pytest详解_pytest框架详解-CSDN博客</a></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><a href="https://blog.csdn.net/m0_61503020/article/details/125456520?ops_request_misc=%7B%22request_id%22:%22172024335816800225519741%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024335816800225519741&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125456520-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=docker&spm=1018.2226.3001.4187">docker入门，这一篇就够了。-CSDN博客</a></p><blockquote><p>docker run [可选参数] image 命令 #启动容器（无镜像会先下载镜像）<br>#参数说明<br>–name &#x3D; “Name”   容器名字<br>-c   后面跟待完成的命令<br>-d   以后台方式运行并且返回ID，启动守护进程式容器<br>-i   使用交互方式运行容器，通常与t同时使用<br>-t   为容器重新分配一个伪输入终端。也即启动交互式容器<br>-p   指定容器端口    -p 容器端口:物理机端口  映射端口<br>-P   随机指定端口<br>-v   给容器挂载存储卷</p></blockquote><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>[JAVA内存分配原理解析–栈、堆、常量池_堆,栈,常量池详解-CSDN博客](<a href="https://blog.csdn.net/gb702250823/article/details/92801716?ops_request_misc=%7B%22request_id%22:%22171151029816800225558425%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171151029816800225558425&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-92801716-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=java">https://blog.csdn.net/gb702250823/article/details/92801716?ops_request_misc=%7B%22request%5Fid%22%3A%22171151029816800225558425%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171151029816800225558425&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-92801716-null-null.142^v100^pc_search_result_base2&amp;utm_term=java</a> 常量池 栈 堆&amp;spm&#x3D;1018.2226.3001.4187)</p><p><a href="https://blog.csdn.net/LJWfbj666/article/details/139120947?ops_request_misc=&request_id=&biz_id=102&utm_term=java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-139120947.142%5Ev100%5Epc_search_result_base8&spm=1018.2226.3001.4187">java的垃圾回收(GC)详解_java gc-CSDN博客</a></p><p><a href="https://blog.csdn.net/ZHHX666/article/details/124484199?ops_request_misc=%7B%22request_id%22:%22172025262616800182710898%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172025262616800182710898&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124484199-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8&spm=1018.2226.3001.4187">Java - 类加载器_java类加载器-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端微服务-programmer-club项目的设计与实现</title>
      <link href="/2024/07/10/2024-07-10-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/07/10/2024-07-10-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="程序员社区项目"><a href="#程序员社区项目" class="headerlink" title="程序员社区项目"></a>程序员社区项目</h1><p><img src="https://s2.loli.net/2024/07/10/zbYgoZyvmxdwP3n.png" alt="image-20240710162449654.png"></p><h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>前后端分离，后端负责所有的设计、接口的定义，后端先行，前端协同，通过接口文档，采用apifox的文档进行对接。</p><p>敏捷开发，版本上线迭代，需求分析-&gt;功能设计-&gt;详细设计-&gt;编码实现。</p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>后端：IDEA</p><p>前端：VSCode</p><p>项目管理：git</p><p>包依赖管理：Maven3.6.0</p><p>数据库：Mysql5.7</p><p>框架：Springboot 2.4.2</p><p>数据库图形化：Navicat</p><p>接口管理工具：APIPost7</p><p>Redis桌面工具：RedisDesktop</p><p>表建模：PDManager</p><p>原型设计：axure8</p><p>原型组件库: antdesign</p><p>代码生成器：easycode（idea的plugin市场）</p><p>一些插件：mybatis，easycode</p><p>node.js</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="传统项目"><a href="#传统项目" class="headerlink" title="传统项目"></a>传统项目</h3><p><img src="https://s2.loli.net/2024/07/10/IkmcCyEaiVK8jvT.png" alt="image-20240710175347652.png"></p><h3 id="现有的架构"><a href="#现有的架构" class="headerlink" title="现有的架构"></a>现有的架构</h3><p><a href="https://blog.csdn.net/qq_49619863/article/details/127836283?ops_request_misc=%7B%22request_id%22:%22172060612716800222827668%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172060612716800222827668&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127836283-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=ddd%E6%9E%B6%E6%9E%84&spm=1018.2226.3001.4187">DDD架构-CSDN博客</a></p><p>ddd 架构</p><p><img src="https://s2.loli.net/2024/07/10/6L8j9VMkRHxWOga.png" alt="cbc3530efc1e41d6b6a94455d804d3d3[1].png"></p><p>例子：</p><ol><li><strong>电子商务领域</strong>：<ul><li>实体：用户、产品、订单、支付记录。</li><li>聚合：购物车、订单详情。</li><li>领域服务：订单处理、库存管理、用户认证。</li></ul></li><li><strong>交通物流领域</strong>：<ul><li>实体：司机、车辆、货物、运输任务。</li><li>聚合：运输订单、车队管理。</li><li>领域服务：路径规划、货物追踪、调度优化。</li></ul></li></ol><p><img src="https://s2.loli.net/2024/07/10/eTX5pdGHV3OrFIB.png" alt="image-20240710175452746.png"></p><ol><li><strong>API（对外接口层）</strong>：这一层负责定义对外提供的服务接口，通常用于与客户端或其他服务进行交互。</li><li><strong>Controller</strong>：在传统的MVC架构中，控制器用于处理用户的请求。在这里，它用于接收API层的请求，并将请求转换为应用层可以理解的格式。</li><li><strong>DTO（Data Transfer Object）</strong>：数据传输对象，用于在不同层之间传输数据，特别是从Controller层到Application层。</li><li><strong>BO（Business Object）</strong>：业务对象，代表领域层中的业务实体，是领域逻辑的载体。</li><li><strong>Application层（应用层）</strong>：这一层包含应用服务，它们协调领域对象来完成业务逻辑。它还包含一些业务逻辑的转换逻辑，如DTO到BO的转换。</li><li><strong>Interceptor</strong>：拦截器，用于在请求处理过程中进行一些前置或后置处理，例如日志记录、权限验证等。</li><li><strong>Application-MQ（消费者）&#x2F; Application-Job</strong>：这指的是应用层中处理消息队列消息的组件，或者定时任务的处理。</li><li><strong>Domain层（领域层）</strong>：这是DDD中的核心层，包含业务逻辑和领域模型。领域层专注于业务规则和业务实体。</li><li><strong>Service</strong>：领域服务，执行领域逻辑但不自然属于任何实体或值对象的操作。</li><li><strong>Entity&#x2F;PO（Persistent Object）</strong>：持久化对象，通常与数据库存储相关，代表数据库中的记录。</li><li><strong>Mapper</strong>：数据访问对象，用于将领域对象映射到数据库表。</li><li><strong>Infra层（基础设施层）</strong>：提供技术实现，如数据库访问、消息传递、外部服务调用等。</li><li><strong>RPC</strong>：远程过程调用，用于服务之间的通信。</li><li><strong>MG（生产者）</strong>：指的是消息生成者，负责生成并发送消息到消息队列。</li><li><strong>Starter（启动层）</strong>：指的是服务启动时需要自动执行的代码或配置。</li><li><strong>Aggressive（聚合层）</strong>：聚合层，将多个领域对象聚合成一个更大的业务实体。</li><li><strong>Config</strong>：配置层，用于存储和访问配置信息。</li><li><strong>Dict（字典）</strong>：指的是数据字典，用于存储一些固定的数据或映射关系。</li><li><strong>Common（公共层）</strong>：包含整个应用中多个地方会用到的通用代码或工具。</li><li><strong>Enums</strong>：枚举，用于定义一组命名的常量。</li><li><strong>Utils</strong>：工具类，提供一些通用的辅助功能。</li></ol><p>req-&gt;dto-&gt;do-&gt;bo-&gt;entity-&gt;po</p><p><img src="https://s2.loli.net/2024/07/10/vcwy8WMZKz7pNSe.jpg" alt="UBWaSonlxTkZyGs[1].jpg"></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="https://s2.loli.net/2024/07/17/YwcR1HeWvrqD72s.png" alt="image-20240717163452115.png"></p><h4 id="后端项目目录（backend）"><a href="#后端项目目录（backend）" class="headerlink" title="后端项目目录（backend）"></a>后端项目目录（backend）</h4><ul><li><strong>asyncTool</strong>: 包含异步处理工具或库，用于处理异步任务。</li><li><strong>doc</strong>: 存放项目文档，如API文档、技术规范等。</li><li><strong>jc-club-auth</strong>: 认证服务，负责用户认证和授权。</li><li><strong>jc-club-circle</strong>: 可能与社区圈子或用户组相关功能。</li><li><strong>jc-club-common-starter</strong>: 通用启动器或工具类，提供项目通用功能。</li><li><strong>jc-club-gateway</strong>: 网关服务，负责请求路由、负载均衡等。</li><li><strong>jc-club-gen</strong>: 代码生成工具，可能用于快速生成项目代码。</li><li><strong>jc-club-interview</strong>: 面试相关功能，可能包含面试题库或模拟面试。</li><li><strong>jc-club-oss</strong>: 对象存储服务，用于管理文件存储。</li><li><strong>jc-club-practice</strong>: 实践项目或示例代码。</li><li><strong>jc-club-subject</strong>: 主题或课程相关功能，可能用于教育或培训。</li><li><strong>jc-club-wx</strong>: 微信相关功能，可能包含微信公众号接口或小程序支持。</li></ul><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p><img src="https://s2.loli.net/2024/07/10/SRyfeJV49ksGvNl.png" alt="image-20240710163626898.png"></p><h2 id="服务器中间件"><a href="#服务器中间件" class="headerlink" title="服务器中间件"></a>服务器中间件</h2><p>服务器采用的京东云 centos</p><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y </span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">docker version </span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="Docker安装mysql"><a href="#Docker安装mysql" class="headerlink" title="Docker安装mysql"></a>Docker安装mysql</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7 </span><br><span class="line">docker images </span><br><span class="line">mkdir -p /home/service/mysql/data </span><br><span class="line">mkdir -p /home/service/mysql/conf</span><br><span class="line">cd /home/service/mysql/conf</span><br><span class="line">touch my.cnf</span><br></pre></td></tr></table></figure><p>将以下内容粘入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">character-set-server=utf8</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">default-time_zone = &#x27;+8:00&#x27;</span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql -v /home/service/mysql/logs:/logs -v /home/service/mysql/data:/mysql_data -e MYSQL_ROOT_PASSWORD=Wing1Q2W#E -d mysql:5.7</span><br><span class="line">docker exec -it mysql bash </span><br><span class="line">mysql -uroot -p </span><br><span class="line"></span><br><span class="line">CREATE USER &#x27;admin&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;Wing1Q2W#E&#x27;;</span><br><span class="line">GRANT ALL ON *.* TO &#x27;admin&#x27;@&#x27;%&#x27;; </span><br><span class="line">flush privileges; </span><br></pre></td></tr></table></figure><p>docker ps 查看启动状态。</p><p>navicat直接连接即可，云服务器需要开启防火墙。</p><h3 id="Maven配置国内源"><a href="#Maven配置国内源" class="headerlink" title="Maven配置国内源"></a>Maven配置国内源</h3><p>maven一定要放到Jenkins的数据挂载目录内，这样容器才能读到。参考开发工具选型里面的maaven包。</p><p>在maven的conf的setting的mirrors里面进行配置，配置后，Jenkins下载包会非常的快。</p><mirror>    <id>alimaven</id>    <name>aliyun maven</name>    <url>http://maven.aliyun.com/nexus/content/groups/public/</url>    <mirrorOf>central</mirrorOf></mirror><h3 id="Docker安装Jenkins"><a href="#Docker安装Jenkins" class="headerlink" title="Docker安装Jenkins"></a>Docker安装Jenkins</h3><p>机器上要有 jdk，服务器可以执行如下命令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y java-1.8.0-openjdk.x86_64</span><br></pre></td></tr></table></figure><p>jenkins开始</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker search jenkins</span><br><span class="line">docker pull jenkins/jenkins:2.414.2</span><br><span class="line">docker run -d -u root -p 8080:8080 -p 50000:50000 -v /var/jenkins_home:/var/jenkins_home -v /etc/localtime:/etc/localtime --name jenkins jenkins/jenkins:2.414.2</span><br><span class="line">docker start jenkins</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/10/M5EsQGFc1BZRXKO.png" alt="image-20240710183915242.png"></p><p>这样就是启动成功了。然后通过8080端口进行访问。访问的过程会很慢等待一下。服务器内存最好大点，内存小的容易启动不起来。</p><p>通过log来看一下密码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs 67166b666c76</span><br></pre></td></tr></table></figure><p><img src="C:\Users\11505\AppData\Roaming\Typora\typora-user-images\image-20240710184049696.png" alt="image-20240710184049696"></p><p>访问之后，输入上面的密码。</p><p>点击继续后，选择 按照推荐安装插件。然后继续等待。</p><p><img src="https://s2.loli.net/2024/07/10/c47Sz8MmHEie1q9.png" alt="image-20240710184132391.png"></p><p>界面如下：</p><p><img src="https://s2.loli.net/2024/07/10/Xth1ImGUkQxvTeN.png" alt="image-20240710184237761.png"></p><p><strong>新建任务</strong></p><p>上面输入任务名称，下面选择构建自由风格</p><p><img src="https://s2.loli.net/2024/07/10/3I4O7YSW8Xm9Cag.png" alt="image-20240710184414482.png"></p><p>选择源码管理，配置maven，注意：maven一定要放到Jenkins的数据挂载目录内，这样容器才能读到。</p><p><img src="https://s2.loli.net/2024/07/10/pXRAlrL3iSWkdMQ.png" alt="image-20240710184525082.png"></p><p><strong>配置ssh服务器</strong></p><p><img src="https://s2.loli.net/2024/07/10/Af3ZOncUWhbgRmy.png" alt="image-20240710184610325.png"></p><p><img src="https://s2.loli.net/2024/07/10/AdwqUtZPVxmolQb.png" alt="image-20240710184703520.png"></p><p>设置密码即可。</p><p><strong>配置ssh分发</strong></p><p><img src="https://s2.loli.net/2024/07/10/9vxsIKnEQPHNF7k.png" alt="image-20240710184752937.png"></p><p><strong>配置shell脚本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cp /var/jenkins_home/workspace/programmer-club-subject/programmer-club-subject/programmer-club-starter/target/programmer-club-starter.jar /var/jenkins_home/jar/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">APP_NAME=programmer-club-starter.jar</span><br><span class="line">LOG_NAME=programmer-club-starter.log</span><br><span class="line"></span><br><span class="line">pid=`ps -ef | grep $APP_NAME | grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">function is_exist()&#123;</span><br><span class="line">pid=`ps -ef | grep $APP_NAME | grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">if [ -z $&#123;pid&#125; ]; then</span><br><span class="line">String=&quot;notExist&quot;</span><br><span class="line">echo $String</span><br><span class="line">else</span><br><span class="line">String=&quot;exist&quot;</span><br><span class="line">echo $String</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str=$(is_exist)</span><br><span class="line">if [ $&#123;str&#125; = &quot;exist&quot; ]; then</span><br><span class="line">echo &quot; 检测到已经启动的程序，pid 是 $&#123;pid&#125; &quot;</span><br><span class="line">kill -9 $pid</span><br><span class="line">else</span><br><span class="line">echo &quot; 程序没有启动了 &quot;</span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is not running&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">str=$(is_exist)</span><br><span class="line">if [ $&#123;str&#125; = &quot;exist&quot; ]; then</span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; 已经启动了. pid=$&#123;pid&#125; .&quot;</span><br><span class="line">else</span><br><span class="line">source /etc/profile</span><br><span class="line">BUILD_ID=dontKillMe</span><br><span class="line">nohup java -Xms300m -Xmx300m -jar /var/jenkins_home/jar/$APP_NAME   &gt;$LOG_NAME 2&gt;&amp;1 &amp;</span><br><span class="line">echo &quot;程序已重新启动...&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="yum安装JDK"><a href="#yum安装JDK" class="headerlink" title="yum安装JDK"></a>yum安装JDK</h3><p>yum install -y java-1.8.0-openjdk.x86_64</p><h3 id="Docker安装minio，搭建自己的oss服务器"><a href="#Docker安装minio，搭建自己的oss服务器" class="headerlink" title="Docker安装minio，搭建自己的oss服务器"></a>Docker安装minio，搭建自己的oss服务器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search minio</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/10/iAn9flaIqCROozt.png" alt="image-20240710185255132.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker pull minio/minio</span><br><span class="line"></span><br><span class="line">docker run -p 9000:9000 -p 9090:9090 \</span><br><span class="line"> --name minio \</span><br><span class="line"> -d --restart=always \</span><br><span class="line"> -e &quot;MINIO_ACCESS_KEY=minioadmin&quot; \</span><br><span class="line"> -e &quot;MINIO_SECRET_KEY=minioadmin&quot; \</span><br><span class="line"> -v /mydata/minio/data:/data \</span><br><span class="line"> minio/minio server \</span><br><span class="line"> /data --console-address &quot;:9090&quot; -address &quot;:9000&quot;</span><br></pre></td></tr></table></figure><p>启动后，访问机器ip+9090，进入minio的界面，输入用户名或密码后可以访问。</p><p><img src="https://s2.loli.net/2024/07/10/g5FPeCrX4x1AbWd.png" alt="image-20240710185416658.png"></p><h3 id="Docker安装miniomc突破7天限制"><a href="#Docker安装miniomc突破7天限制" class="headerlink" title="Docker安装miniomc突破7天限制"></a>Docker安装miniomc突破7天限制</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker pull minio/mc</span><br><span class="line"></span><br><span class="line">docker run -it --entrypoint=/bin/sh minio/mc</span><br><span class="line"></span><br><span class="line">mc config host add &lt;ALIAS&gt; &lt;YOUR-S3-ENDPOINT&gt; &lt;YOUR-ACCESS-KEY&gt; &lt;YOUR-SECRET-KEY&gt; [--api API-SIGNATURE]</span><br><span class="line"></span><br><span class="line">mc config host add minio http://xxx.xx.xx.xxx:9000 GrVCPXySKgGoJiGgXmtv 0xlqSI9GXvnBOtp0GwUj5OshKNBk9JgwoexotbVV</span><br><span class="line"></span><br><span class="line">mc ls minio</span><br><span class="line"></span><br><span class="line">mc anonymous</span><br><span class="line"></span><br><span class="line">mc anonymous set download minio/jichi</span><br></pre></td></tr></table></figure><h3 id="Docker查看运行容器启动命令"><a href="#Docker查看运行容器启动命令" class="headerlink" title="Docker查看运行容器启动命令"></a>Docker查看运行容器启动命令</h3><p>安装一个小工具 get_command_4_run_container</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull cucker/get_command_4_run_container</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以nacos为例子</span></span><br><span class="line">docker run --rm -v /var/run/docker.sock:/var/run/docker.sock cucker/get_command_4_run_container nacos</span><br></pre></td></tr></table></figure><p>看到如下的启动命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \ </span><br><span class="line">--name nacos \ </span><br><span class="line">--privileged \ </span><br><span class="line">--cgroupns host \ </span><br><span class="line">--env JVM_XMX=256m \ </span><br><span class="line">--env MODE=standalone \ </span><br><span class="line">--env JVM_XMS=256m \ </span><br><span class="line">-p 8848:8848/tcp \ </span><br><span class="line">-p 9848:9848/tcp \ </span><br><span class="line">--restart=always \ </span><br><span class="line">-w /home/nacos \ </span><br><span class="line">nacos/nacos-server</span><br></pre></td></tr></table></figure><h3 id="Docker安装nacos"><a href="#Docker安装nacos" class="headerlink" title="Docker安装nacos"></a>Docker安装nacos</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search nacos</span><br><span class="line">docker pull nacos/nacos-server</span><br></pre></td></tr></table></figure><p>镜像拉完之后，启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name nacos \</span><br><span class="line">  --privileged  \</span><br><span class="line">  --cgroupns host \</span><br><span class="line">  --env JVM_XMX=256m \</span><br><span class="line"> --env MODE=standalone \</span><br><span class="line">  --env JVM_XMS=256m \</span><br><span class="line">  -p 8848:8848/tcp \</span><br><span class="line">  -p 9848:9848/tcp \</span><br><span class="line">  --restart=always \</span><br><span class="line">  -w /home/nacos \</span><br><span class="line">  nacos/nacos-server</span><br></pre></td></tr></table></figure><p>云服务器不要忘记打开防火墙端口。</p><p>访问 ip 地址+8848 &#x2F;nacos 即可进入控制台</p><p><img src="https://s2.loli.net/2024/07/17/omQFLlRk7htf5bB.png" alt="image-20240717151037534.png"></p><p>nacos 的文档：<a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">https://nacos.io/zh-cn/docs/what-is-nacos.html</a></p><p>nacos 的架构原理：<a href="https://developer.aliyun.com/ebook/36?spm=a2c6h.20345107.ebook-index.18.152c2984fsi5ST">https://developer.aliyun.com/ebook/36?spm=a2c6h.20345107.ebook-index.18.152c2984fsi5ST</a></p><h3 id="Docker安装Redis"><a href="#Docker安装Redis" class="headerlink" title="Docker安装Redis"></a>Docker安装Redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search redis</span><br><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><p>拉下镜像之后，点击下面地址选择自己需要的 redis 版本的配置文件</p><p><a href="https://redis.io/docs/management/config/">https://redis.io/docs/management/config/</a></p><p><img src="https://s2.loli.net/2024/07/17/QifoExYAU6VzSnt.png" alt="image-20240717151249025.png"></p><p>提前在服务器建立 &#x2F;data&#x2F;redis 文件夹，touch 文件redis.conf，也可以上面的直接复制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动命令</span><br><span class="line">docker run -p 6379:6379 --name redis -v /data/redis/redis.conf:/etc/redis/redis.conf  -v /data/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure><p>-p 6379:6379:把容器内的6379端口映射到宿主机6379端口 </p><p>-v &#x2F;data&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf：把宿主机配置好的redis.conf放到容器内的这个位置中 </p><p>-v &#x2F;data&#x2F;redis&#x2F;data:&#x2F;data：把redis持久化的数据在宿主机内显示，做数据备份</p><p>redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf：这个是关键配置，让redis不是无配置启动，而是按照这个redis.conf的配置启动 </p><p>–appendonly yes：redis启动后数据持久化</p><p><strong>IDEA连接redis可以直接下载 plugin 的 redis 插件</strong></p><h3 id="Docker安装es"><a href="#Docker安装es" class="headerlink" title="Docker安装es"></a>Docker安装es</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">docker search elasticsearch</span><br><span class="line"></span><br><span class="line">docker pull elasticsearch:7.3.1</span><br><span class="line"></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot;  -e ES_JAVA_OPTS=&quot;-Xms1024m -Xmx1024m&quot; 3d3aa92f641f</span><br></pre></td></tr></table></figure><p>启动成功之后，访问<a href="http://xxx.xx.xx.xxx:9200/">http://xxx.xx.xx.xxx:9200/</a></p><p><img src="https://s2.loli.net/2024/07/17/g9zDn8wIMPYakiS.png" alt="image-20240717151757675.png"></p><p>看到这个就证明成功了！</p><p>插件：es-head</p><h3 id="docker安装xxl-job"><a href="#docker安装xxl-job" class="headerlink" title="docker安装xxl-job"></a>docker安装xxl-job</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker search xxl-job</span><br><span class="line">docker pull xuxueli/xxl-job-admin:2.4.0</span><br><span class="line"></span><br><span class="line">docker run  -d \</span><br><span class="line">        -p 8088:8088\</span><br><span class="line">        -v /tool/xxl-job/logs:/data/applogs \</span><br><span class="line">        -v /tool/xxl-job/application.properties:/xxl-job/xxl-job-admin/src/main/resources/application.properties \</span><br><span class="line">        -e PARAMS=&quot;--server.port=8088\</span><br><span class="line">        --spring.datasource.url=jdbc:mysql://xxx.xx.xx.xxx:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai \</span><br><span class="line">        --spring.datasource.username=root \</span><br><span class="line">        --spring.datasource.password=Wing1Q2W#E&quot; \</span><br><span class="line">        --name xxl-job-admin  \</span><br><span class="line">xuxueli/xxl-job-admin:2.4.0</span><br></pre></td></tr></table></figure><h3 id="rocketmq安装"><a href="#rocketmq安装" class="headerlink" title="rocketmq安装"></a>rocketmq安装</h3><p>官网地址：<a href="https://rocketmq.apache.org/">https://rocketmq.apache.org/</a></p><p>安装包上传到 linux 的&#x2F;soft 文件夹，没有此文件夹，先创建，不过在 es 的时候已经创建过了。</p><p><img src="https://s2.loli.net/2024/07/17/eEKGOkDYhwJUHxT.png" alt="image-20240717152141331.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum install unzip  可以解压zip包的依赖</span><br><span class="line">unzip rocketmq-all-4.8.0-bin-release.zip</span><br><span class="line">cd rocketmq-all-4.8.0-bin-release</span><br><span class="line">cd bin</span><br><span class="line">vim runserver.sh</span><br><span class="line">将其中的xmx，xms等进行修改256m，弄小一点，让服务器用</span><br><span class="line">vim runbroker.sh</span><br><span class="line">同理修改其中的xmx，xms等进行修改256m，弄小一点，让服务器用</span><br><span class="line">nohup sh mqnamesrv &amp;</span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure><p>启动broker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export NAMESRV_ADDR=localhost:9876</span><br><span class="line">nohup sh mqbroker -n localhost:9876 &amp;</span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure><p>发送消息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br><span class="line">sh tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure><p>如果发送消息报错，建立文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/store</span><br><span class="line">mkdir commitlog </span><br><span class="line">cd commitlog</span><br><span class="line">mkdir consumequeue</span><br></pre></td></tr></table></figure><p>关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqshutdown broker</span><br><span class="line">sh bin/mqshutdown namesrv</span><br></pre></td></tr></table></figure><p><strong>安装控制台</strong></p><p><img src="https://s2.loli.net/2024/07/17/QmgKi1q86yeVaR3.png" alt="image-20240717152526211.png"></p><p>更改端口和配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -Xms300m -Xmx300m -jar rocketmq-console.jar &gt; console.log &amp;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/17/QvTwp6AJcBnLKjV.png" alt="image-20240717152632964.png"></p><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><h4 id="数据库表建模JSON"><a href="#数据库表建模JSON" class="headerlink" title="数据库表建模JSON"></a>数据库表建模JSON</h4><p><strong>刷题模块</strong></p><p><img src="https://s2.loli.net/2024/07/17/AE9ZyjdKSlap1tb.png" alt="image-20240717154028356.png"></p><p><strong>SQL</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `subject_radio`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `subject_radio`</span><br><span class="line">(</span><br><span class="line">    `id`             <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    `subject_id`     <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;题目id&#x27;</span>,</span><br><span class="line">    `option_type`    tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;a,b,c,d&#x27;</span>,</span><br><span class="line">    `option_content` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;选项内容&#x27;</span>,</span><br><span class="line">    `is_correct`     tinyint(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否正确&#x27;</span>,</span><br><span class="line">    `created_by`     <span class="type">varchar</span>(<span class="number">32</span>)  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">    `created_time`   datetime     <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `update_by`      <span class="type">varchar</span>(<span class="number">32</span>)  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改人&#x27;</span>,</span><br><span class="line">    `update_time`    datetime     <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">    `is_deleted`     <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;单选题信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `subject_multiple`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `subject_multiple`</span><br><span class="line">(</span><br><span class="line">    `id`             <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    `subject_id`     <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;题目id&#x27;</span>,</span><br><span class="line">    `option_type`    <span class="type">bigint</span>(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;选项类型&#x27;</span>,</span><br><span class="line">    `option_content` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;选项内容&#x27;</span>,</span><br><span class="line">    `is_correct`     tinyint(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否正确&#x27;</span>,</span><br><span class="line">    `created_by`     <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">    `created_time`   datetime    <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `update_by`      <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新人&#x27;</span>,</span><br><span class="line">    `update_time`    datetime    <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    `is_deleted`     <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;多选题信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `subject_mapping`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `subject_mapping`</span><br><span class="line">(</span><br><span class="line">    `id`           <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    `subject_id`   <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;题目id&#x27;</span>,</span><br><span class="line">    `category_id`  <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类id&#x27;</span>,</span><br><span class="line">    `label_id`     <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;标签id&#x27;</span>,</span><br><span class="line">    `created_by`   <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">    `created_time` datetime    <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `update_by`    <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改人&#x27;</span>,</span><br><span class="line">    `update_time`  datetime    <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">    `is_deleted`   <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">536</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;题目分类关系表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `subject_liked`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `subject_liked`</span><br><span class="line">(</span><br><span class="line">    `id`           <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    `subject_id`   <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;题目id&#x27;</span>,</span><br><span class="line">    `like_user_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8mb4_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;点赞人id&#x27;</span>,</span><br><span class="line">    `status`       <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;点赞状态 1点赞 0不点赞&#x27;</span>,</span><br><span class="line">    `created_by`   <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">    `created_time` datetime                        <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `update_by`    <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改人&#x27;</span>,</span><br><span class="line">    `update_time`  datetime                        <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">    `is_deleted`   <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `uniq_like` (`subject_id`,`like_user_id`) <span class="keyword">USING</span> BTREE COMMENT <span class="string">&#x27;点赞唯一索引&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_bin COMMENT<span class="operator">=</span><span class="string">&#x27;题目点赞表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `subject_label`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `subject_label`</span><br><span class="line">(</span><br><span class="line">    `id`           <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    `label_name`   <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;标签分类&#x27;</span>,</span><br><span class="line">    `sort_num`     <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;排序&#x27;</span>,</span><br><span class="line">    `category_id`  <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `created_by`   <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">    `created_time` datetime    <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `update_by`    <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新人&#x27;</span>,</span><br><span class="line">    `update_time`  datetime    <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    `is_deleted`   <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">64</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;题目标签表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `subject_judge`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `subject_judge`</span><br><span class="line">(</span><br><span class="line">    `id`           <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    `subject_id`   <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;题目id&#x27;</span>,</span><br><span class="line">    `is_correct`   tinyint(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否正确&#x27;</span>,</span><br><span class="line">    `created_by`   <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">    `created_time` datetime    <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `update_by`    <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新人&#x27;</span>,</span><br><span class="line">    `update_time`  datetime    <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    `is_deleted`   <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;判断题&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `subject_info`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `subject_info`</span><br><span class="line">(</span><br><span class="line">    `id`                <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    `subject_name`      <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;题目名称&#x27;</span>,</span><br><span class="line">    `subject_difficult` tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;题目难度&#x27;</span>,</span><br><span class="line">    `settle_name`       <span class="type">varchar</span>(<span class="number">32</span>)  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;出题人名&#x27;</span>,</span><br><span class="line">    `subject_type`      tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;题目类型 1单选 2多选 3判断 4简答&#x27;</span>,</span><br><span class="line">    `subject_score`     tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;题目分数&#x27;</span>,</span><br><span class="line">    `subject_parse`     <span class="type">varchar</span>(<span class="number">512</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;题目解析&#x27;</span>,</span><br><span class="line">    `created_by`        <span class="type">varchar</span>(<span class="number">32</span>)  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">    `created_time`      datetime     <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `update_by`         <span class="type">varchar</span>(<span class="number">32</span>)  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改人&#x27;</span>,</span><br><span class="line">    `update_time`       datetime     <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">    `is_deleted`        <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">327</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;题目信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `subject_category`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `subject_category`</span><br><span class="line">(</span><br><span class="line">    `id`            <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    `category_name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类名称&#x27;</span>,</span><br><span class="line">    `category_type` tinyint(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类类型&#x27;</span>,</span><br><span class="line">    `image_url`     <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;图标连接&#x27;</span>,</span><br><span class="line">    `parent_id`     <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;父级id&#x27;</span>,</span><br><span class="line">    `created_by`    <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">    `created_time`  datetime    <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `update_by`     <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新人&#x27;</span>,</span><br><span class="line">    `update_time`   datetime    <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    `is_deleted`    tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否删除 0: 未删除 1: 已删除&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">12</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;题目分类&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `subject_brief`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `subject_brief`</span><br><span class="line">(</span><br><span class="line">    `id`             <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    `subject_id`     <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;题目id&#x27;</span>,</span><br><span class="line">    `subject_answer` text COMMENT <span class="string">&#x27;题目答案&#x27;</span>,</span><br><span class="line">    `created_by`     <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">    `created_time`   datetime    <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `update_by`      <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新人&#x27;</span>,</span><br><span class="line">    `update_time`    datetime    <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    `is_deleted`     <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">280</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;简答题&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="刷题模块数据模型"><a href="#刷题模块数据模型" class="headerlink" title="刷题模块数据模型"></a>刷题模块数据模型</h4><p><img src="https://s2.loli.net/2024/07/17/V8iKD6RWFCJHUab.png" alt="image-20240717162213876.png"></p><p><img src="https://s2.loli.net/2024/07/17/9I7ol1eVBZm3NvA.png" alt="image-20240717154416885.png"><br><img src="https://s2.loli.net/2024/07/17/nbR4qgoGCBw93ik.png" alt="image-20240717154425945.png"><br><img src="https://s2.loli.net/2024/07/17/iYCKuszXPJmLG5t.png" alt="image-20240717154441135.png"><br><img src="https://s2.loli.net/2024/07/17/cuG26enxkZCDtps.png" alt="image-20240717162527674.png"><br><img src="https://s2.loli.net/2024/07/17/KZSErI4H5tVxn2k.png" alt="image-20240717162448319.png"><br><img src="https://s2.loli.net/2024/07/17/V2PGpheKlCJ1Dfw.png" alt="image-20240717154448206.png"><br><img src="https://s2.loli.net/2024/07/17/b85pTjQCnKoW2VB.png" alt="image-20240717154500698.png"></p><p><strong>鉴权模块</strong></p><h3 id="刷题模块"><a href="#刷题模块" class="headerlink" title="刷题模块"></a>刷题模块</h3><p><img src="https://s2.loli.net/2024/07/17/wl4dD9uVb1gnAtB.png" alt="image-20240717163944712.png"></p><p>starter类是用于放置整个项目的启动类的</p><h4 id="产品功能模块"><a href="#产品功能模块" class="headerlink" title="产品功能模块"></a>产品功能模块</h4><p><img src="https://s2.loli.net/2024/07/10/weDZpG3xrbvXtnV.png" alt="image-20240710164145589.png"></p><h4 id="研发功能模块拆分"><a href="#研发功能模块拆分" class="headerlink" title="研发功能模块拆分"></a>研发功能模块拆分</h4><p><img src="https://s2.loli.net/2024/07/10/xjnVqWl3YUD97AB.png" alt="image-20240710164949102.png"></p><h4 id="原型设计"><a href="#原型设计" class="headerlink" title="原型设计"></a>原型设计</h4><p>axrue+antdesign的组件库</p><h5 id="刷题首页"><a href="#刷题首页" class="headerlink" title="刷题首页"></a>刷题首页</h5><p><img src="https://s2.loli.net/2024/07/10/mLyW9JI56dVsefR.png" alt="image-20240710165032544.png"></p><h5 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h5><p><img src="https://s2.loli.net/2024/07/10/s5GYPwTHDFv6pe3.png" alt="image-20240710165319312.png"></p><h4 id="分类模块"><a href="#分类模块" class="headerlink" title="分类模块"></a>分类模块</h4><p><img src="https://s2.loli.net/2024/07/10/OQNz3dAREaLeyTm.png" alt="image-20240710174638222.png"></p><p>分类的概念是面试题的大类。其中我们有两种概念，一种是岗位分类，例如后端，前端，测试。一种是岗位下细分的分类，比如后端下细分，框架，并发，集合等等。</p><h5 id="新增分类"><a href="#新增分类" class="headerlink" title="新增分类"></a>新增分类</h5><p>正常的业务逻辑，保证新增后，可以正常的插入数据库即可。</p><h5 id="修改分类"><a href="#修改分类" class="headerlink" title="修改分类"></a>修改分类</h5><p>crud</p><h5 id="删除分类"><a href="#删除分类" class="headerlink" title="删除分类"></a>删除分类</h5><p>crud</p><h5 id="首页的分类"><a href="#首页的分类" class="headerlink" title="首页的分类"></a>首页的分类</h5><p>可以扩展做成做成缓存，不易变的数据，直接从redis查缓存。</p><p>缓存预热这种，启动项目之后，扔进去。</p><p>目前做成串行化的，二期可以优化，由前端先查询岗位大类，然后再根据大类查询小类。</p><h4 id="标签详细设计"><a href="#标签详细设计" class="headerlink" title="标签详细设计"></a>标签详细设计</h4><p>标签的概念是分类下的细分。标签是通用性的，独立的个体，与标签不进行强耦合，和题目相关。标签和分类是公用的，多个分类可以对应同一个标签。</p><p>涉及的代码提交记录。</p><h5 id="新增标签"><a href="#新增标签" class="headerlink" title="新增标签"></a>新增标签</h5><p>crud 直接看代码</p><h5 id="修改标签"><a href="#修改标签" class="headerlink" title="修改标签"></a>修改标签</h5><p>crud</p><h5 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h5><p>crud</p><h5 id="标签查询"><a href="#标签查询" class="headerlink" title="标签查询"></a>标签查询</h5><p>根据分类去查询标签，要通过题目信息的关联表来进行查询。详细看代码</p><p>以上功能涉及到 subject_label 表</p><p><img src="https://s2.loli.net/2024/07/10/omhFSeL9tyZRjVJ.png" alt="7yCAHGEJegnk5NF[1].png"></p><h4 id="题目模块"><a href="#题目模块" class="headerlink" title="题目模块"></a>题目模块</h4><p><img src="https://s2.loli.net/2024/07/10/MLmSYUluqyNp1sz.png" alt="image-20240710174839950.png"></p><p>题目分为单选，多选，判断，简单，四种数据类型，在设计数据的时候，拆分成了题目的主表和其他对应的表来做。</p><h5 id="新增题目"><a href="#新增题目" class="headerlink" title="新增题目"></a>新增题目</h5><p>注意：采取工厂+策略的模式去做扩展，现在有四种题型，未来无论加多少种，都可以不用动主流程。</p><p>后期会结合es 做题目的查重。为搜索做准备。</p><h5 id="修改题目"><a href="#修改题目" class="headerlink" title="修改题目"></a>修改题目</h5><p>crud</p><h5 id="删除题目"><a href="#删除题目" class="headerlink" title="删除题目"></a>删除题目</h5><p>要注意删除主表的同时，也把其他的细分的数据表进行同步的处理。</p><h5 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h5><p>难度不大，就是个简单的分页的查询，分类、标签，难度这些其实都是入参的场景。</p><p>查标签，难度啊，出题人啊，等等，这些就直接查，不做join。</p><h5 id="题目的详情"><a href="#题目的详情" class="headerlink" title="题目的详情"></a>题目的详情</h5><p>也做一下工厂+策略吧</p><p>此功能涉及如下数据表</p><p><img src="https://s2.loli.net/2024/07/10/x2aCvEXZFSIl6N7.png" alt="image-20240710171403151.png"></p><h3 id="OSS模块"><a href="#OSS模块" class="headerlink" title="OSS模块"></a>OSS模块</h3><h4 id="OSS模块设计"><a href="#OSS模块设计" class="headerlink" title="OSS模块设计"></a>OSS模块设计</h4><p><img src="https://s2.loli.net/2024/07/17/DutXl68xcz4QmRr.png" alt="image-20240717153600388.png"></p><p>注意：考虑 oss 的扩展性和切换性。</p><p>目前对接的 minio，要考虑，如果作为公共的 oss 服务，如何切换到其他的阿里云 oss 或者对接京东云的 oss。作为基础的 oss 服务，切换等等动作，不应该要求业务方进行改造，以及对切换有感知。</p><p><img src="https://s2.loli.net/2024/07/17/Ag6VbxBDoSRjn4O.png" alt="image-20240717153706800.png"></p><h4 id="OSS模块配合nacos实现动态切换"><a href="#OSS模块配合nacos实现动态切换" class="headerlink" title="OSS模块配合nacos实现动态切换"></a>OSS模块配合nacos实现动态切换</h4><p>nacos 作为配置中心，可以实现动态配置，适用于比如动态数据源切换，动态切换 oss。</p><h5 id="集成naocs动态配置"><a href="#集成naocs动态配置" class="headerlink" title="集成naocs动态配置"></a>集成naocs动态配置</h5><p>配置</p><ol><li>jc-club-oss&#x2F;pom.xml</li><li>jc-club-oss&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;jingdianjichi&#x2F;oss&#x2F;controller&#x2F;FileController.java</li><li>jc-club-oss&#x2F;src&#x2F;main&#x2F;resources&#x2F;application.yml</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust异步编程</title>
      <link href="/2024/07/09/2024-07-09-Rust%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/07/09/2024-07-09-Rust%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Rust异步编程"><a href="#Rust异步编程" class="headerlink" title="Rust异步编程"></a>Rust异步编程</h1><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">index</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">100</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = tokio::<span class="title function_ invoke__">spawn</span>(</span><br><span class="line">        async_http_client.<span class="title function_ invoke__">get</span>(<span class="built_in">format!</span>(<span class="string">&quot;www.example.com/items/&#123;&#125;&quot;</span>, index))</span><br><span class="line">    );</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = handle.<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比较使用异步编写的示例与同步编写的相同示例 - 对于大量并发 Web 请求，异步版本比同步请求快约 60%</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust基础学习</title>
      <link href="/2024/07/08/2024-07-08-Rust%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/07/08/2024-07-08-Rust%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Rust基础学习"><a href="#Rust基础学习" class="headerlink" title="Rust基础学习"></a>Rust基础学习</h1><p><a href="https://www.rust-lang.org/learn">Learn Rust - Rust Programming Language (rust-lang.org)</a></p><p><a href="https://blog.csdn.net/weixin_47754149/article/details/125701852?ops_request_misc=%7B%22request_id%22:%22172041285316800211535314%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172041285316800211535314&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125701852-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=Rust&spm=1018.2226.3001.4187">【一起学Rust】Rust介绍与开发环境搭建_rust开发-CSDN博客</a></p><p>包管理工具：cargo</p><p>命令行：</p><blockquote><p>cargo new [name]：创建一个新的Rust项目<br>cargo build：构建项目<br>cargo run：运行项目<br>cargo test：运行测试<br>cargo doc：生成文档<br>cargo update：更新依赖项<br>cargo clean：清除构建输出<br>cargo publish：将软件包发布到crates.io上<br>cargo install [package]: 安装指定软件包<br>cargo uninstall [package]: 卸载指定软件包</p></blockquote><p><a href="https://blog.csdn.net/qq_36678837/article/details/131371856?ops_request_misc=%7B%22request_id%22:%22172041285316800211535314%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172041285316800211535314&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-131371856-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=Rust&spm=1018.2226.3001.4187">Rust 全面指南：从基础到高级，一网打尽 Rust 的编程知识_rust语言-CSDN博客</a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义变量可以使用let关键字，例如：</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">10</span>; <span class="comment">//会被自动推断为i32类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: <span class="type">i32</span> = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//上述默认为不可变变量,若要可变变量需要加入mut关键字</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">z</span>=<span class="number">30</span>;</span><br><span class="line">z=<span class="number">40</span>;</span><br><span class="line"><span class="comment">//const关键字用于代表这是一个常亮，不能与mut关键字连用</span></span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>关键字<br>Rust 语言有一组保留的 关键字（keywords），就像大部分语言一样，它们只能由语言本身使用。记住，你不能使用这些关键字作为变量或函数的名称。大部分关键字有特殊的意义，你将在 Rust 程序中使用它们完成各种任务；一些关键字目前没有相应的功能，是为将来可能添加的功能保留的。可以在附录 A 中找到关键字的列表。</p><p>目前正在使用的关键字<br>如下关键字目前有对应其描述的功能。</p><p>as - 强制类型转换，消除特定包含项的 trait 的歧义，或者对 use 语句中的项重命名<br>async - 返回一个 Future 而不是阻塞当前线程<br>await - 暂停执行直到 Future 的结果就绪<br>break - 立刻退出循环<br>const - 定义常量或不变裸指针（constant raw pointer）<br>continue - 继续进入下一次循环迭代<br>crate - 在模块路径中，代指 crate root<br>dyn - 动态分发 trait 对象<br>else - 作为 if 和 if let 控制流结构的 fallback<br>enum - 定义一个枚举<br>extern - 链接一个外部函数或变量<br>false - 布尔字面值 false<br>fn - 定义一个函数或 函数指针类型 (function pointer type)<br>for - 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期<br>if - 基于条件表达式的结果分支<br>impl - 实现自有或 trait 功能<br>in - for 循环语法的一部分<br>let - 绑定一个变量<br>loop - 无条件循环<br>match - 模式匹配<br>mod - 定义一个模块<br>move - 使闭包获取其所捕获项的所有权<br>mut - 表示引用、裸指针或模式绑定的可变性<br>pub - 表示结构体字段、impl 块或模块的公有可见性<br>ref - 通过引用绑定<br>return - 从函数中返回<br>Self - 定义或实现 trait 的类型的类型别名<br>self - 表示方法本身或当前模块<br>static - 表示全局变量或在整个程序执行期间保持其生命周期<br>struct - 定义一个结构体<br>super - 表示当前模块的父模块<br>trait - 定义一个 trait<br>true - 布尔字面值 true<br>type - 定义一个类型别名或关联类型<br>union - 定义一个 union 并且是 union 声明中唯一用到的关键字<br>unsafe - 表示不安全的代码、函数、trait 或实现<br>use - 引入外部空间的符号<br>where - 表示一个约束类型的从句<br>while - 基于一个表达式的结果判断是否进行循环</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>由大括号控制</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://s2.loli.net/2024/07/08/3jEMuSxnkrgJ8bF.png" alt="image-20240708124030796.png"></p><p>元组(tuple)和数组(array)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元组</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>=(<span class="number">100</span>,<span class="string">&#x27;余&#x27;</span>,<span class="literal">true</span>,<span class="number">10.1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元组是以<code>()</code>表示的，里面放入各个元素，且各个元素之间用<code>,</code>分隔</p><p>由于rust可以自动推导出其类型，所以这里没有手动为其标注类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元组</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>:(<span class="type">i32</span>,<span class="type">char</span>,<span class="type">bool</span>,<span class="type">f64</span>)=(<span class="number">100</span>,<span class="string">&#x27;余&#x27;</span>,<span class="literal">true</span>,<span class="number">10.1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,tup.<span class="number">0</span>,)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里是手动标注类型</p><p>还有数组也很常用，它的使用方法与元组还是有点差距的，其中最大的差别就是，数组中的所有元素的类型必须相同（而上面提到的元组各个元素类型可以不同）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,arr[<span class="number">0</span>],arr[<span class="number">1</span>],arr[<span class="number">2</span>],arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>分为String（可变）和&amp;str（不可变）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>);</span><br><span class="line"><span class="comment">//&amp;str</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello, world!&quot;</span>;</span><br><span class="line"><span class="comment">//转化</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span> = s.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">s2.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="可变数组Vec"><a href="#可变数组Vec" class="headerlink" title="可变数组Vec"></a>可变数组Vec</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(); <span class="comment">// 创建一个空向量(由于是可变的，要使用mut关键字)</span></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>); <span class="comment">// 向向量中添加元素</span></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="title function_ invoke__">pop</span>();<span class="comment">//向量中弹出元素</span></span><br><span class="line"><span class="comment">//insert,remove</span></span><br></pre></td></tr></table></figure><h3 id="Rust-HashTable-Map"><a href="#Rust-HashTable-Map" class="headerlink" title="Rust HashTable(Map)"></a>Rust HashTable(Map)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="comment">//insert</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>), <span class="number">100</span>); <span class="comment">//这里应该是将字符串字面量转化为String类</span></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Bob&quot;</span>), <span class="number">90</span>);</span><br><span class="line"><span class="comment">//get</span></span><br><span class="line">scores.<span class="title function_ invoke__">get</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"><span class="comment">//有序的map是BTreeMap，要求KEY类型是可以排序的</span></span><br></pre></td></tr></table></figure><h3 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if else</span></span><br><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="comment">// code block to execute if the condition is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// code block to execute if the condition is false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a&gt;<span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a&gt;0&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>  a==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a==0&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a&lt;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//match</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//枚举</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">        Up,</span><br><span class="line">        Down,</span><br><span class="line">        Left,</span><br><span class="line">        Right,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">direction</span> = Direction::Up;</span><br><span class="line">    <span class="keyword">match</span> direction &#123;</span><br><span class="line">        Direction::Up =&gt; <span class="built_in">println!</span>(<span class="string">&quot;You chose up&quot;</span>), <span class="comment">//在使用match语句的时候，对于每一种不同的情况进行匹配，如果匹配成功了之后，就执行这个=&gt;符号后面所对应的那些代码</span></span><br><span class="line">        Direction::Down =&gt; <span class="built_in">println!</span>(<span class="string">&quot;You chose down&quot;</span>),</span><br><span class="line">        Direction::Left =&gt; <span class="built_in">println!</span>(<span class="string">&quot;You chose left&quot;</span>),</span><br><span class="line">        Direction::Right =&gt; <span class="built_in">println!</span>(<span class="string">&quot;You chose right&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//while</span></span><br><span class="line"><span class="keyword">while</span> condition &#123;</span><br><span class="line">    <span class="comment">// code block to execute while the condition is true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">variable</span> <span class="keyword">in</span> iterable &#123;</span><br><span class="line">    <span class="comment">// code block to execute for each value in the iterable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">10</span>..<span class="number">20</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*通过语法 10..20就可以自动生成一个10到20的范围对象，</span></span><br><span class="line"><span class="comment">并将该对象中的值，依次赋值给for后面的变量名i，</span></span><br><span class="line"><span class="comment">注意范围运算符 ..生成的范围对象是左闭右开的，</span></span><br><span class="line"><span class="comment">具体来说，10..20 ，i只会等于10到19</span></span><br><span class="line"><span class="comment">但是，10..=20则是10到20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//loop</span></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">// code block to execute repeatedly until break is called</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/07/09/QTcfLK5GWydksaY.png" alt="image-20240709125242057.png"></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>一个最简单的函数长下面这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">simple</span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过关键字<code>fn</code>加一个函数名字，<code>()</code>与<code>&#123;&#125;</code>组成，除此之外什么都没有，同样，它也不能做任何事。</p><p>为了能让这个函数干一些事情，我们就需要在函数体，也就是<code>&#123;&#125;</code>中写一些代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">simple</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;代码&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但只是这样还不够，在没有任何输入的情况下，这个函数能做的事情基本就写死了：无论任何地方调用它，其结果都是一样的（调用随机数除外）。</p><p>所以我们就需要函数参数，也就是从函数外部传入的变量，可以让函数内部来使用，参数写在<code>()</code>中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">simple</span>(i:<span class="type">i32</span>,c:<span class="type">char</span>,f:<span class="type">f64</span>,b:<span class="type">bool</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,i,c,f,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带有返回值的例子</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>(a:<span class="type">i32</span>,b:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&#123; <span class="comment">//-&gt;返回值类型</span></span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>=<span class="title function_ invoke__">sum</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a+b=&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><a href="https://blog.csdn.net/weixin_44786530/article/details/136432672?ops_request_misc=&request_id=&biz_id=102&utm_term=rust%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-136432672.142%5Ev100%5Epc_search_result_base8&spm=1018.2226.3001.4187">Rust结构体讲解学习，以及impl结构体方法和结构体关联函数_rust struct impl-CSDN博客</a></p><p>Rust 里 struct 语句仅用来定义，不能声明实例，结尾不需要 ; 符号，而且每个字段定义之后用 , 分隔。</p><p>结构中也没有方法，要有方法只能用impl去实现方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span> = <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建实例</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">person</span> = Person &#123;</span><br><span class="line">    name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>),</span><br><span class="line">    age: <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//访问字段 </span></span><br><span class="line">person.name</span><br><span class="line"><span class="comment">//单元结构体:结构体可以只作为一种象征而无需任何成员：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnitStruct</span>;</span><br></pre></td></tr></table></figure><h4 id="结构体方法"><a href="#结构体方法" class="headerlink" title="结构体方法"></a>结构体方法</h4><p>方法（Method）和函数（Function）类似，只不过它是用来操作结构体实例的。</p><p>如果你学习过一些面向对象的语言，那你一定很清楚函数一般放在类定义里并在函数中用 this 表示所操作的实例。</p><p>Rust 语言不是面向对象的，从它所有权机制的创新可以看出这一点。但是面向对象的珍贵思想可以在 Rust 实现。</p><p><strong>结构体方法的第一个参数必须是 &amp;self，不需声明类型，因为 self 不是一种风格而是关键字</strong>。</p><p>在调用结构体方法的时候不需要填写 self ，这是出于对使用方便性的考虑:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算一个矩形的面积：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;; <span class="comment">//创建实例</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1&#x27;s area is &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体关联函数"><a href="#结构体关联函数" class="headerlink" title="结构体关联函数"></a>结构体关联函数</h4><p>之所以”结构体方法”不叫”结构体函数”是因为”函数”这个名字留给了这种函数：它在 impl 块中却没有 &amp;self 参数。</p><p>这种函数不依赖实例，但是使用它需要声明是在哪个 impl 块中的。</p><p>一直使用的 String::from 函数就是一个”关联函数”。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create</span>(width: <span class="type">u32</span>, height: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123; </span><br><span class="line">        Rectangle &#123; width, height &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle::<span class="title function_ invoke__">create</span>(<span class="number">30</span>, <span class="number">50</span>); <span class="comment">//调用的时候::</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, rect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口（Trait）"><a href="#接口（Trait）" class="headerlink" title="接口（Trait）"></a>接口（Trait）</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Fly</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>); <span class="comment">//这个方法接收一个self参数，表示对实现这个trait的类型的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bird</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Fly</span> <span class="keyword">for</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;I can fly!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">bird</span> = Bird&#123;&#125;;</span><br><span class="line">bird.<span class="title function_ invoke__">fly</span>();</span><br></pre></td></tr></table></figure><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>Rust的注解是以#字符开头的特殊注释，可以为代码提供更多的语义信息或者修改编译器的行为。Rust注解通常放在代码的上方，用于注释某些特定的语法结构或者代码块。下面是一些常用的Rust注解：</p><ol><li>#[derive(Debug)]：这个注解用于标记一个结构体或者枚举，让编译器自动生成Debug trait的实现。这样，在调试时，我们可以使用{:?}格式化输出结构体或者枚举的内容，方便快捷。</li><li>#[test]：这个注解用于标记一个测试函数，表示它是一个单元测试。测试框架可以通过这个注解自动识别测试函数并执行测试，方便我们编写和运行测试代码。</li><li>#[allow(unused_variables)]：这个注解用于关闭编译器的未使用变量警告。如果我们定义了一个变量但是并没有使用它，编译器会发出警告，这个注解可以帮助我们屏蔽这个警告。</li><li>#[cfg(target_os &#x3D; “windows”)]：这个注解用于根据不同的操作系统编译不同的代码。如果我们的代码需要在不同的操作系统上运行，就可以使用这个注解来指定特定的编译条件。</li><li>#[no_mangle]：这个注解用于防止Rust编译器对函数名进行重命名，保留原始名称。如果我们的代码需要和其他语言交互，就需要使用这个注解来保证函数名的一致性。</li></ol><p>总之，Rust注解可以提供额外的信息，帮助编译器和开发者更好地理解和处理代码，同时也可以修改编译器的行为，以满足特定的需求。</p><p>Rust允许开发者自定义注解（Attribute），可以通过宏定义的方式实现。自定义注解可以为代码提供更多的语义信息，也可以修改编译器的行为，方便我们编写高效、优雅的代码。</p><p>自定义注解的语法格式如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[my_attribute(arg1, arg2, ...)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">my_function</span>() &#123;</span><br><span class="line">    <span class="comment">// code here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="meta">#[my_attribute(<span class="string">&quot;hello&quot;</span>, 42)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">my_function</span>() &#123;</span><br><span class="line">    <span class="comment">// code here</span></span><br><span class="line">&#125;</span><br><span class="line">定义了一个名为my_attribute的注解，它带有两个参数：一个字符串<span class="string">&quot;hello&quot;</span>和一个整数<span class="number">42</span>。我们可以在函数内部使用这个注解，例如对函数进行标记，表示它是一个特定类型的函数。</span><br></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>Rust的模块系统是基于文件系统的组织方式。每个Rust文件都可以被视为一个模块，模块名与文件名相同。在一个模块中，可以使用<code>mod</code>关键字定义子模块，使用<code>use</code>关键字引用其他模块中的定义。</p><p>例如，假设有如下结构的文件系统：</p><blockquote><p>src&#x2F;<br>├── main.rs<br>└── my_module&#x2F;<br>    ├── mod.rs<br>    ├── sub_module.rs<br>    └── my_struct.rs</p></blockquote><p>在上述结构中，src目录是Rust项目的根目录，main.rs是项目的入口文件。my_module目录是一个模块，其下有三个文件：</p><p>mod.rs：定义了my_module模块的<strong>公共接口</strong>。</p><p>sub_module.rs：定义了my_module模块的<strong>子模块</strong>sub_module。</p><p>my_struct.rs：定义了my_module模块的一个<strong>结构体</strong>MyStruct。</p><p>在<code>mod.rs</code>中，可以使用mod关键字定义子模块，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> sub_module;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> field: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">my_function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello from my_function!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述代码中，定义了一个名为<code>MyStruct</code>的结构体，还有一个名为<code>my_function</code>的函数。同时，使用<code>mod</code>关键字定义了一个名为<code>sub_module</code>的子模块。</p><p>在<code>sub_module.rs</code>中，可以定义子模块<code>sub_module</code>中的内容，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sub_function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello from sub_function!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，定义了一个名为<code>sub_function</code>的函数。</p><p>在使用<code>my_module</code>模块中的定义时，需要使用use关键字引用它们，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::my_module::&#123;MyStruct, my_function&#125;;</span><br><span class="line"><span class="keyword">use</span> crate::my_module::sub_module::sub_function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_struct</span> = MyStruct &#123; field: <span class="number">42</span> &#125;;</span><br><span class="line">    <span class="title function_ invoke__">my_function</span>();</span><br><span class="line">    <span class="title function_ invoke__">sub_function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，使用use关键字引用了MyStruct和my_function，以及sub_function。然后，可以在main函数中使用这些定义。</p><h3 id="Rust-Cargo-toml"><a href="#Rust-Cargo-toml" class="headerlink" title="Rust Cargo.toml"></a>Rust Cargo.toml</h3><p>Rust使用 Cargo.toml 文件描述项目的元数据和依赖关系。下面是对 Cargo.toml 文件的详细讲解。</p><p>Cargo.toml 文件是一个 TOML（Tom’s Obvious, Minimal Language，即Tom的简洁明了语言）格式的文件，用于描述 Rust 项目的<strong>元数据和依赖关系</strong>。它通常位于项目的根目录下，与 src&#x2F; 目录同级。</p><p>下面是一个示例：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;myproject&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;Your Name &lt;you@example.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.7.0&quot;</span></span><br><span class="line"><span class="attr">serde</span> = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;mylib&quot;</span></span><br><span class="line"><span class="attr">path</span> = <span class="string">&quot;src/mylib.rs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[bin]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;mybin&quot;</span></span><br><span class="line"><span class="attr">path</span> = <span class="string">&quot;src/mybin.rs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[bin]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;myotherbin&quot;</span></span><br><span class="line"><span class="attr">path</span> = <span class="string">&quot;src/myotherbin.rs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="attr">default</span> = [<span class="string">&quot;myfeature1&quot;</span>]</span><br><span class="line"><span class="attr">myfeature1</span> = []</span><br><span class="line"><span class="attr">myfeature2</span> = []</span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies.mydependency]</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">features</span> = [<span class="string">&quot;myfeature1&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">members</span> = [</span><br><span class="line">    <span class="string">&quot;mylib&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mybin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;myotherbin&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>[package]</code> 表示包的元数据，包括包名、版本号、作者和 Rust 版本等信息。<code>[dependencies]</code> 表示包的依赖项，<code>[lib]</code> 表示库的配置，<code>[[bin]]</code> 表示可执行文件的配置，<code>[features]</code> 表示特性的配置，<code>[dependencies.mydependency]</code> 表示依赖的配置，<code>[workspace]</code> 表示工作空间的配置。</p><p>引入单个本地模块的方法是，在项目根目录下创建一个名为 <code>src/</code> 的文件夹，然后在该文件夹下创建 Rust 模块，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/mymodule.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">myfunction</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，在 <code>main.rs</code>（或其他程序入口文件）中引入该模块：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> mymodule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    mymodule::<span class="title function_ invoke__">myfunction</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>引入多个本地模块也是类似的。假设在 src&#x2F; 目录下还有一个名为 myothermodule.rs 的 Rust 模块，可以这样写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> mymodule;</span><br><span class="line"><span class="keyword">mod</span> myothermodule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    mymodule::<span class="title function_ invoke__">myfunction</span>();</span><br><span class="line">    myothermodule::<span class="title function_ invoke__">myotherfunction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="的用法"><a href="#的用法" class="headerlink" title="::的用法"></a>::的用法</h3><p>在<a href="https://www.baidu.com/s?word=Rust&sa=re_dqa_zy">Rust</a>中，双冒号有几种用途，主要涉及到模块、类型、枚举变体或<a href="https://www.baidu.com/s?word=trait&sa=re_dqa_zy">trait</a>实现的引用。</p><ol><li><p><strong>模块和类型的引用</strong>：<code>::</code>用于引用模块中的类型或函数。例如，<code>String::from(&quot;hello&quot;)</code>表示调用<code>String</code>类型中的<code>from</code>静态方法，用于创建一个新的字符串。</p></li><li><p><strong>枚举变体的引用</strong>：当需要引用枚举的某个变体时，也可以使用<code>::</code>。例如，如果有一个枚举<code>Color</code>，其中包含<code>Red</code>和<code>Green</code>两个变体，那么可以通过<code>Color::Red</code>和<code>Color::Green</code>来引用这些变体。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Hello</span>(<span class="type">String</span>),</span><br><span class="line">    Goodbye</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(message: Message) &#123;</span><br><span class="line">    <span class="keyword">match</span> message &#123;</span><br><span class="line">        Message::<span class="title function_ invoke__">Hello</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;&quot;</span>, s),</span><br><span class="line">        Message::Goodbye =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Goodbye!&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Trait实现的引用</strong>：在Rust中，Trait可以定义一组方法，这些方法可以由实现该Trait的类型提供具体实现。使用<code>::</code>可以明确指定某个类型实现了某个Trait的具体方法。例如，如果有一个Trait <code>Greeter</code>，并且有一个类型<code>Person</code>实现了这个Trait，那么可以通过<code>Person::greet(&amp;person)</code>来调用这个方法，尽管这通常与具体的实例无关，更常见的是使用动态调度（如<code>g.greet()</code>），但在某些情况下，如需要明确类型和方法的关系时，这种语法是有用的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greet</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Greeter</span> <span class="keyword">for</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greet</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello from Person!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">use_greeter</span>(g: &amp;<span class="keyword">dyn</span> Greeter) &#123;</span><br><span class="line">    g.<span class="title function_ invoke__">greet</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Person;</span><br><span class="line">    <span class="title function_ invoke__">use_greeter</span>(&amp;person <span class="keyword">as</span> &amp;<span class="keyword">dyn</span> Greeter); <span class="comment">// 使用 as 关键字和 &amp;dyn 来创建一个 trait 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在泛型实例化中指定类型参数</strong>：当你要创建一个泛型类型的实例并明确指定其类型参数时，可以使用 <code>::&lt;T&gt;</code>。这在你不想依赖类型推断，或者类型推断不能正确工作时特别有用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec</span> = <span class="type">Vec</span>::&lt;<span class="type">i32</span>&gt;::<span class="title function_ invoke__">new</span>(); <span class="comment">// 创建一个包含 i32 类型元素的 Vec 实例</span></span><br></pre></td></tr></table></figure></li><li><p><strong>明确指定作用域</strong>：在某些情况下，<code>::</code>也用于明确指定作用域，尤其是在处理与命名空间相关的问题时。这有助于编译器理解你的意图，避免名称冲突。</p><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_something</span>() &#123;</span><br><span class="line">    io::<span class="built_in">println!</span>(<span class="string">&quot;Hello from io!&quot;</span>); <span class="comment">// 使用 std::io 模块中的 println 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="self和Self"><a href="#self和Self" class="headerlink" title="self和Self"></a>self和Self</h3><p><strong>self</strong></p><p>self 是一个代表<strong>类型实例（或者是类型的引用或者是值）</strong>的关键字，在 Rust 的方法中使用 self 可以引用当前类型的实例或者类型本身。</p><p>具体来说，当我们定义一个方法时，使用 self 关键字作为方法的第一个参数可以让我们在调用该方法时直接访问类型实例本身</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f32</span>,</span><br><span class="line">    y: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance</span>(&amp;<span class="keyword">self</span>, other: &amp;Point) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">dx</span> = <span class="keyword">self</span>.x - other.x;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">dy</span> = <span class="keyword">self</span>.y - other.y;</span><br><span class="line">        (dx * dx + dy * dy).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Self"><a href="#Self" class="headerlink" title="Self"></a>Self</h3><p>通常在 Rust 的 trait 和 associated function 中使用 Self 来指代实现该 trait 或调用该 associated function 的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f32</span>,</span><br><span class="line">    y: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="comment">//关联函数</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">origin</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Point &#123; x: <span class="number">0.0</span>, y: <span class="number">0.0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point::<span class="title function_ invoke__">origin</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h3><p>Rust常用库<br>好的，以下是一些常用的 Rust 库及其常用方法的举例：</p><ol><li>std 库<ul><li>println!(): 打印输出信息到控制台</li><li>Vec<T>: 动态数组类型</li><li>String: 可变字符串类型</li><li>HashMap&lt;K, V&gt;: 哈希表类型</li></ul></li><li>serde 库<ul><li>serde_json::to_string(): 将 Rust 结构体序列化为 JSON 字符串</li><li>serde_json::from_str(): 将 JSON 字符串反序列化为 Rust 结构体</li><li>serde_yaml::to_string(): 将 Rust 结构体序列化为 YAML 字符串</li><li>serde_yaml::from_str(): 将 YAML 字符串反序列化为 Rust 结构体</li></ul></li><li>actix 库<ul><li>actix_web::get(): 注册一个 GET 请求处理器</li><li>actix_web::post(): 注册一个 POST 请求处理器</li><li>actix_web::web::Json<T>: 解析请求体中的 JSON 数据</li></ul></li><li>tokio 库<ul><li>tokio::net::TcpListener: 创建一个 TCP 监听器</li><li>tokio::net::TcpStream: 创建一个 TCP 连接</li><li>tokio::spawn(): 在异步任务池中启动一个新的异步任务</li></ul></li><li>reqwest 库<ul><li>reqwest::get(): 发送一个 GET 请求</li><li>reqwest::post(): 发送一个 POST 请求</li><li>reqwest::Client::new(): 创建一个 HTTP 客户端对象</li></ul></li><li>rusoto 库<ul><li>rusoto_s3::S3Client::new(): 创建一个 AWS S3 客户端对象</li><li>rusoto_ec2::Ec2Client::new(): 创建一个 AWS EC2 客户端对象</li><li>rusoto_lambda::LambdaClient::new(): 创建一个 AWS Lambda 客户端对象</li></ul></li><li>diesel 库<ul><li>diesel::prelude::*: 导入 Diesel 的预定义类型和函数</li><li>diesel::insert_into(): 插入一条新的记录</li><li>diesel::load(): 加载一组记录</li></ul></li><li>log 库<ul><li>log::info(): 记录一条信息级别的日志</li><li>log::error(): 记录一条错误级别的日志</li><li>log::warn(): 记录一条警告级别的日志</li></ul></li><li>rand 库<ul><li>rand::thread_rng(): 创建一个随机数生成器对象</li><li>rand::Rng::gen_range(): 生成一个指定范围内的随机数</li><li>rand::Rng::shuffle(): 随机打乱一个数组</li></ul></li><li>image 库<ul><li>image::open(): 打开一个图像文件</li><li>image::save(): 保存一个图像文件</li><li>image::DynamicImage::resize(): 调整图像尺寸大小</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.824 Lecture2-RPC and Threads</title>
      <link href="/2024/07/03/MIT-6.824-Lecture2-RPC-and-Threads/"/>
      <url>/2024/07/03/MIT-6.824-Lecture2-RPC-and-Threads/</url>
      
        <content type="html"><![CDATA[<h3 id="Lecture2-RPC-and-Threads"><a href="#Lecture2-RPC-and-Threads" class="headerlink" title="Lecture2-RPC and Threads"></a>Lecture2-RPC and Threads</h3><h4 id="2-1-GO语言"><a href="#2-1-GO语言" class="headerlink" title="2.1 GO语言"></a>2.1 GO语言</h4><p>❓ why we use go in this class</p><p>1️⃣ go提供类许多便捷的工具，如threads、锁以及线程间同步。此外，还有RPC包也十分重要。</p><p>2️⃣ go是type safe 以及memory safe的，其垃圾回收机制（garbage collected）十分有效</p><p>3️⃣ threads + GC 是十分具有吸引力的</p><h4 id="2-2-threads"><a href="#2-2-threads" class="headerlink" title="2.2 threads"></a>2.2 threads</h4><h5 id="2-2-1-为什么要关注多线程"><a href="#2-2-1-为什么要关注多线程" class="headerlink" title="2.2.1 为什么要关注多线程"></a>2.2.1 为什么要关注多线程</h5><p>📖 多线程是在本课程中实现并发的一个重要工具，在分布式系统中，并发十分有趣。比较常见的情况是：一个程序需要同时和多台计算机（a bunch of other computers）通信，客户端可能会同时和多台服务器通信，一台服务器可能会同时响应来自不同客户端的多条请求。假如我的程序同时有 7 件不同的事情在进行，我想要一种简单的方式实现它能同时做 7 件不同的事情，多线程就能很好的解决它。</p><p>在 Go 的文档中，它把线程称为 goroutine，goroutine 真的很像大家所说的线程。</p><h5 id="2-2-2-如何理解多线程"><a href="#2-2-2-如何理解多线程" class="headerlink" title="2.2.2 如何理解多线程"></a>2.2.2 如何理解多线程</h5><p>假设有一个程序，用一个小盒子表示地址空间，在这个地址空间里，串行执行的程序（serial program）是没有多个线程的，你只有一个线程。它在这个地址空间中执行代码，它只有一个程序计数器（PC），只有一套寄存器(register），一个栈（stack)，这些东西就能描述当前的执行状态。</p><p>在一个多线程程序中，比方说 Go 程序，你可以拥有多个线程，如果这些线程同时执行，那它们就分别有一个属于自己的程序计数器，一套寄存器和一个栈，每个线程都有自己的一套线程控制，他们可以在程序中不同的部分执行每个线程。需要注意的是，每一个独立的线程都有一个栈，这些栈都在程序中的同一个地址空间中，知道地址的话不同的线程之间是可以互相访问他们的栈的。</p><p>多线程的一个重要作用就是允许程序中不同的部分都能独立的执行不同的动作。</p><p>并发的关键是你有处理多个任务的能力，不一定要同时。</p><p>并行的关键是你有同时处理多个任务的能力。</p><p>2.2.3 使用多线程的原因</p><p><strong>I&#x2F;O Concurrency——I&#x2F;O并发</strong><br>IO并发：一个线程正在等待从磁盘上读数据，当它在等待的时候，你又想要另一个线程，可能用来做计算或是从某个磁盘的地方读取数据或是向网络发送一条消息并等待回复，所以 IO 并发是使用多线程的地方之一。</p><p>比如说，我们有一个程序，已经启动并且通过 RPC 请求网络上不同的服务器，然后同时在等待多个回复。具体做法是，需要为每个 RPC 调用创建一个线程，每个线程都会通过 RPC 发送 request 消息，然后等待。当响应回复时，这个线程将会继续执行，使用多线程可以让我们同时发起多个网络请求，所有线程都会等待回复，也不是非得在同一时间去发请求，只要它愿意，这些线程总可以做不同的事情。</p><p>不同 IO 并发活动（activity）可能会有互相重叠（overlapping）的部分，也允许一个活动正在等待，另一个活动可以继续执行</p><p><strong>Parallelism——并行化</strong><br>使用<strong>多线程的</strong>另一个重要原因是<strong>多核并行</strong>（multi-core parallelism），我们想通过线程来达到并行化的目的。并行化就是如果你有个多核机器，如果你有一个计算繁重的工作，它需要消耗许多 CPU 时钟周期（CPU cycles），这是一件不太好的事情。假设你的程序能使用机器上所有的 CPU 核，比方说它是用 Go 写的多线程程序，你启动了多个 goroutine，这些 goroutine 执行一些计算密集型的任务，比如一直在那执行一个循环，计算 pi（圆周率)的值，直到达到机器上 cpu 核的极限，你的线程将会真正的以并行的方式运行。<strong>如果你启动 2 个线程代替 1 个线程，你就能获得 2 倍的性能，就能使用 2 倍数量的 CPU 时钟周期</strong></p><p>在本次课程中，我们不会把过多的精力放在此类并行化上。所以并行化是使用多线程的第二个原因</p><p><strong>Convenience——易用性</strong><br>有时候你只是想在后台做一些事情，比如你就想周期性的去执行它，但你又不愿意在主线程插入一些检查。比如有一个 master 服务需要周期性的检查它的 worker 服务是否一直存活，因为这些 worker 之一宕机的话，就需要把工作扔到另一台机器上去执行，就像 MapReduce 那样。你可以每秒、每分钟通过发送一条“你还活着吗？”这样的消息到 worker 服务上，你能启动一个 goroutine，然后执行一个死循环，sleep 1 秒后，然后做需要周期执行的动作，然后又 sleep 1 秒。</p><p>❓ <strong>开启goroutine的开销大吗</strong></p><p>📖 这个开销是值得的，而且这种开销非常少，取决于创建的线程的多少。但是，这种方法可以节省非常多的时间</p><p>❓ <strong>不使用多线程如何追踪不同活动的状态</strong></p><p>📖 使用另一种风格——<strong>异步编程</strong>（asynchronous programing），也称为<strong>事件驱动编程</strong>（event-driven programming）。</p><p>事件驱动编程的一般结构，通常它有一个线程，同时有一个循环，这个循环等待输入或者是其它任何事件，这些事件能触发程序继续进行，事件可能是一个来自客户端的请求，可能是定时器到期。如果你在编写windows 系统程序，你电脑上的许多 windows 系统程序都是通过事件驱动的风格来编写的，它们等待的东西是像键盘击键或者是鼠标移动这样的事件。因此你可能会有一个单一的只有一个控制线程的程序，这个线程有一个循环一直等待输入，无论何时有输入进来，比如收到报文，它能够找出来是哪个客户端发送的这个报文。它有一张表格记录这个客户端到底处于什么样的活动状态。</p><p><strong>使用线程的话通常会变的更加方便</strong>，因为线程能让你更容易把把程序写的连贯有序。在事件驱动循环里，你一次只能执行一个活动，这种编程模式的问题在于它实现起来有点痛苦，另一个潜在的缺陷在于当你用这种方法获取了 IO 并发后你就没法利用 CPU 的并行化机制。</p><p>所以当你写一个负载很高的服务，你得<strong>想方设法</strong>把一台大型机器的 32 核都用上，使用一个单一循环的话，它相当的不自然，也很难获得多核的性能。另一方面，冒这样的风险编程通常换来的性能提升相比多线程来说并不会太多。</p><p>而且线程相对来说也很廉价，<strong>每个线程都有一个栈</strong>，栈通常是 1kb 或数千字节，如果你有 20 个线程，这些消耗根本不用在意。但是你若有 100 万个线程，那它就会消耗大量的内存。</p><p>另外，线程调度，它是指下一步应该选择哪个线程运行，通常有一个调度列表，上面记录了 1000 个线程，这时候切换线程执行将付出相当昂贵的代价。</p><p>所以，当你只有一个服务器的时候，你的服务器需要为 100 万个客户端提供服务，你需要为这 100 万个客户端记录一些状态，这个代价还是挺高的。如果使用事件驱动编程，花点时间的话，应该容易写一个简单的而又五脏俱全高性能的服务，就是你需要多做点工作。</p><p>[(288条消息) 解读I&#x2F;O多路复用及其技术，让你彻底了解I&#x2F;O多路复用(内含图形讲解)【建议新手收藏】_Linux情报站的博客-CSDN博客](<a href="https://blog.csdn.net/m0_50662680/article/details/111273308?ops_request_misc=%7B%22request_id%22:%22166315159916782390556461%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=166315159916782390556461&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-1-111273308-null-null.142%5Ev47%5Epc_rank_34_ctr25,201%5Ev3%5Eadd_ask&utm_term=%E5%BC%82%E6%AD%A5">https://blog.csdn.net/m0_50662680/article/details/111273308?ops_request_misc=%7B%22request%5Fid%22%3A%22166315159916782390556461%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=166315159916782390556461&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-1-111273308-null-null.142^v47^pc_rank_34_ctr25,201^v3^add_ask&amp;utm_term=异步</a> 多路复用 图解&amp;spm&#x3D;1018.2226.3001.4187)</p><p>❓ <strong>多线程(threads)和多进程(processes)的区别</strong></p><p>📖 通常，对于类 UNIX 系统的机器来说，一个进程就<strong>是一个单独运行的程序，只有一个地址空间</strong>，<strong>一大片可供进程使用的内存</strong>，在这个进程里你可能同时会有好多个线程。当你准备好一个 go 程序并运行，将会创建一个 unix 进程和一块内存区，<strong>当你的 Go 进程创建 goroutine 时，它们实际上都是在同一个进程里</strong>的。</p><p>实际上这也取决于操作系统的实现，确实有个别或一些操作系统，并不关心你的进程内部到底发生了什么事情，也不关心你使用什么语言，不关心操作系统内部的业务逻辑，在进程内部能运行多个线程就行了。</p><p>如果在你的机器上运行了不止一个进程，比如一个编辑器或是编译器，操作系统需要让它们彼此分开，<strong>你的编辑器和你的编译器都有自己的内存空间，他们之间无法看到彼此的内存，不同的进程之间不会有交集</strong>。你的编辑器可能有多个线程，你的编译器也可能有多个线程，但是他们都处于各自的世界<strong>。但是</strong>在同一个进程中，线程与线程之间可以共享内存，可以使用 channel(Go语言中的概念) 进行同步，也可以使用 mutex 等。但进程之间是没有交集的，这类软件的传统结构就是这样。</p><p>❓ <strong>当上下文切换时，是所有线程都在切换吗</strong>(when a context switch happens does it happened for all threads)</p><p>你只有一个单核机器，这意味着在同一个时刻你只能做一件事情。你打算在你的机器上运行多进程，操作系统把 CPU 时间片反复的分配给这两个程序，当硬件时钟到期时，操作系统就判断是时候把 CPU 从当前正在运行的进程剥夺，然后把 CPU 分配给另一个进程，这件事件是在进程级别上做的。</p><p>我们<strong>使用的线程</strong>最终<strong>是由是操作系统线程所提供的</strong>，当<strong>操作系统上下文切换时，就是不同的线程之间产生切换</strong>时，操作系统是知道这一切的，所以操作系统可能会清楚这儿有两个线程在这个进程中，有三个线程在那个进程，当时钟到期时操作系统会基于一些调度算法选择一个不同的线程来运行。在这个进程中的线程和另一进程中的线程可能是不同的，另外，<strong>Go 会聪明复用一个操作系统线程，在上面运行尽可能多的 goroutine 以节省开支</strong>，所以这可能需要两个阶段去调度。</p><p>首先操作系统选择一个线程去运行，然后在这个进程中，Go 会再去选择哪个 goroutine 去运行。</p><h5 id="2-2-4-sharing-memory——共享内存"><a href="#2-2-4-sharing-memory——共享内存" class="headerlink" title="2.2.4 sharing memory——共享内存"></a>2.2.4 <strong>sharing memory——共享内存</strong></h5><p>事实上写多线程程序是有些挑战的，其中一个是<strong>共享数据</strong>，关于线程模型，酷的地方在于这些<strong>线程共享地址空间</strong>，<strong>共享内存</strong>，如果某个线程在内存中创建了一个对象，在其它线程中你也能使用它。你可以创建个数组或是别的什么东西，所有不同的线程都能读写。这就存在一些临界情况，如果你持有一些你关注的状态，可能你会缓存一些数据：你的 server，你的缓存，你的内存。当其中一个线程正处理一个客户端的请求的时候，首先它会先查一下缓存中的数据，但是这个共享缓存，每个线程都能读。当线程里有新的信息时，线程可能会向缓存里写入数据进行更新。</p><p>但是事实也表明如果你不关心多线程之间共享内存的话，很容易出现bug。</p><p>问题举例<br>假设你有一个全局变量 N 在不同的线程之间共享，其中一个线程只是对 N 做自增，这可能就是造成 bug 的原因。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n=n+1</span><br></pre></td></tr></table></figure><p>在同一时刻，总有其它的线程可能也正在查看，所以这里有个很明显的问题。<strong>线程 1 正在执行</strong>，但是另一个<strong>不同的线程 2</strong> 也在执行相同的代码， N 是一个全局变量，所以这里我们说的这个 N 都是同一个 N。</p><p>实际上机器运行的并不是这样的代码，而是由编译器吐出来的机器码（machine code）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LD  X , register1</span><br><span class="line">ADD 1 , register1</span><br><span class="line">STORE register1 , X</span><br></pre></td></tr></table></figure><p>你可以假设所有的线程都在执行这行代码，他们都会执行加载 x 到寄存器，x 从 0 开始有效，这意味着，所有线程都把 0 读入寄存器，然后他们都给寄存器加 1，这样所有线程各有自的寄存器的值是 1，最后再把寄存器的值 1 重新保存到内存里，现在，这两个线程对 N 做自增后，结果都是 1，但是碰巧这样写并不正确，碰巧程序想要的结果不是 1。</p><p>❓ <strong>指令的原子性</strong></p><p>这些独立的指令是不是原子的（atomic），答案是有些是，有些不是，对于 <strong>32 位的 store 指令它极有可能是原子的</strong>，从某种意义上来说，如果有两个处理器，最终要么是其中一个处理器上的 32 位值，要么是另一个处理器上的 32 位值，而不是一个混合的值。其它尺寸大小的未必就这么简单，比如一个字节的存储这依赖于你所使用的 CPU。这依赖于处理器和更复杂的指令。</p><p>比如微处理器上的自增指令，它能直接给内存上某个地址的值加 1，未必就是原子的，尽管这些指令存在原子版本的。</p><p>所以这是一个非常经典的错误，通常我们叫他<strong>“竞争”（race）</strong>，后面我打算会多次提起。称为 race 是因为如果一个 CPU 已经开始执行这段代码，另一些线程正在结束这段代码，这就是 race，第一个处理器能够在第二个处理器开始执行 load 前执行 store，如果第一个处理器的 store(寄存器中的数据存入内存)确实是在第二个处理器 load （内存放入寄存器）之前，那么第二个处理器就能看到第一个处理器存储的值，第二个处理器将 load 值 1，然后再加 1，再把 2 存入。</p><p>解决这个问题的方式很简单，加个锁就行了，只有在持有锁的时候，这个共享数据才能被使用，Go 调用 Lock 来锁住 mutex，你能看到 mu.Lock()加在这一段使用共享数据的代码前面，然后在结束的地方调用 mu.Unlock()。无论哪个线程执行到这里，只有足够幸运的那个线程才能第一个抢到锁，然后执行所有这些代码，在结束之前，另一个线程都不能继续，你可以考虑把这些在锁中间的代码封装起来。</p><p>❓ <strong>Go是如何知道我们正在锁住哪些变量</strong></p><p>答案是 go 并不知道，在这个锁里的任何位置他们一点关联都没有。所以，这里新的东西是这个变量(mu)，它是个 mutex，在 lock 和任何变量之间他们并没有什么关联。</p><h5 id="2-2-5-Coordination——协作"><a href="#2-2-5-Coordination——协作" class="headerlink" title="2.2.5 Coordination——协作"></a><strong>2.2.5 Coordination——协作</strong></h5><p>协作与指导线程运作有关，当我们正在执行涉及到多线程情况下的加锁时，可能并不知道其它线程也在加锁，他们只是想在没有人干涉的情况下拿到数据。但也有一些情况你确实就是故意的想让不同的线程之间互相受到制约，比如你生产某些数据，但是你又和我不是同一个线程，我想在你生产完数据前一直等待，直到你完成后，我再去读取。或者是你启动了一堆线程去抓取 web 页面，然后需要等待所有线程都执行结束。</p><p>所以当我们想<strong>特意的互相等待的时候，这种情况通常就称为 coordination (协作)。</strong>Go 中有很多技术可以做到，比如 channel (通道)，channel 是一种用于发数据从这个线程到另一个线程的工具。</p><p>也有一些其它工具用于特殊的目的，比如有个东西叫 condition variables (条件变量)，还有WaitGroup。</p><h5 id="2-2-6-Deadlock——死锁"><a href="#2-2-6-Deadlock——死锁" class="headerlink" title="2.2.6 Deadlock——死锁"></a><strong>2.2.6 Deadlock——死锁</strong></h5><p>死锁Deadlock：计算机系统中多道程序并发执行时，两个或两个以上的进程由于竞争资源而造成的一种互相等待的现象（僵局），如无外力作用，这些进程将永远不能再向前推进。</p><p>四个条件同时出现，死锁将会发生</p><p>1️⃣ Mutual exclusion互斥：一次只有一个进程可以使用一个资源</p><p>2️⃣ Hold and wait占有并等待：一个进程应该占有至少一个资源，并等待另一个资源，而该资源被另一个进程所占有</p><p>3️⃣ No preemption不可抢占：一个资源只有当持有它的进程完成任务后自由的释放</p><p>4️⃣ Circular wait循环等待：等待资源的进程之间存在环</p><h5 id="2-2-7-Web爬虫"><a href="#2-2-7-Web爬虫" class="headerlink" title="2.2.7 Web爬虫"></a>2.2.7 Web爬虫</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Several solutions to the crawler exercise from the Go tutorial</span><br><span class="line">// https://tour.golang.org/concurrency/10</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Serial crawler</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">func Serial(url string, fetcher Fetcher, fetched map[string]bool) &#123;</span><br><span class="line">if fetched[url] &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fetched[url] = true</span><br><span class="line">urls, err := fetcher.Fetch(url)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">for _, u := range urls &#123;</span><br><span class="line">Serial(u, fetcher, fetched)</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Concurrent crawler with shared state and Mutex</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">type fetchState struct &#123;</span><br><span class="line">mu      sync.Mutex</span><br><span class="line">fetched map[string]bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func ConcurrentMutex(url string, fetcher Fetcher, f *fetchState) &#123;</span><br><span class="line">f.mu.Lock()</span><br><span class="line">already := f.fetched[url]</span><br><span class="line">f.fetched[url] = true</span><br><span class="line">f.mu.Unlock()</span><br><span class="line"></span><br><span class="line">if already &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">urls, err := fetcher.Fetch(url)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">var done sync.WaitGroup</span><br><span class="line">for _, u := range urls &#123;</span><br><span class="line">done.Add(1)</span><br><span class="line">    u2 := u</span><br><span class="line">go func() &#123;</span><br><span class="line">defer done.Done()</span><br><span class="line">ConcurrentMutex(u2, fetcher, f)</span><br><span class="line">&#125;()</span><br><span class="line">//go func(u string) &#123;</span><br><span class="line">//defer done.Done()</span><br><span class="line">//ConcurrentMutex(u, fetcher, f)</span><br><span class="line">//&#125;(u)</span><br><span class="line">&#125;</span><br><span class="line">done.Wait()</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func makeState() *fetchState &#123;</span><br><span class="line">f := &amp;fetchState&#123;&#125;</span><br><span class="line">f.fetched = make(map[string]bool)</span><br><span class="line">return f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Concurrent crawler with channels</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">func worker(url string, ch chan []string, fetcher Fetcher) &#123;</span><br><span class="line">urls, err := fetcher.Fetch(url)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">ch &lt;- []string&#123;&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ch &lt;- urls</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func master(ch chan []string, fetcher Fetcher) &#123;</span><br><span class="line">n := 1</span><br><span class="line">fetched := make(map[string]bool)</span><br><span class="line">for urls := range ch &#123;</span><br><span class="line">for _, u := range urls &#123;</span><br><span class="line">if fetched[u] == false &#123;</span><br><span class="line">fetched[u] = true</span><br><span class="line">n += 1</span><br><span class="line">go worker(u, ch, fetcher)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">n -= 1</span><br><span class="line">if n == 0 &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func ConcurrentChannel(url string, fetcher Fetcher) &#123;</span><br><span class="line">ch := make(chan []string)</span><br><span class="line">go func() &#123;</span><br><span class="line">ch &lt;- []string&#123;url&#125;</span><br><span class="line">&#125;()</span><br><span class="line">master(ch, fetcher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// main</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Printf(&quot;=== Serial===\n&quot;)</span><br><span class="line">Serial(&quot;http://golang.org/&quot;, fetcher, make(map[string]bool))</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;=== ConcurrentMutex ===\n&quot;)</span><br><span class="line">ConcurrentMutex(&quot;http://golang.org/&quot;, fetcher, makeState())</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;=== ConcurrentChannel ===\n&quot;)</span><br><span class="line">ConcurrentChannel(&quot;http://golang.org/&quot;, fetcher)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Fetcher</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">type Fetcher interface &#123;</span><br><span class="line">// Fetch returns a slice of URLs found on the page.</span><br><span class="line">Fetch(url string) (urls []string, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// fakeFetcher is Fetcher that returns canned results.</span><br><span class="line">type fakeFetcher map[string]*fakeResult</span><br><span class="line"></span><br><span class="line">type fakeResult struct &#123;</span><br><span class="line">body string</span><br><span class="line">urls []string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f fakeFetcher) Fetch(url string) ([]string, error) &#123;</span><br><span class="line">if res, ok := f[url]; ok &#123;</span><br><span class="line">fmt.Printf(&quot;found:   %s\n&quot;, url)</span><br><span class="line">return res.urls, nil</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;missing: %s\n&quot;, url)</span><br><span class="line">return nil, fmt.Errorf(&quot;not found: %s&quot;, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// fetcher is a populated fakeFetcher.</span><br><span class="line">var fetcher = fakeFetcher&#123;</span><br><span class="line">&quot;http://golang.org/&quot;: &amp;fakeResult&#123;</span><br><span class="line">&quot;The Go Programming Language&quot;,</span><br><span class="line">[]string&#123;</span><br><span class="line">&quot;http://golang.org/pkg/&quot;,</span><br><span class="line">&quot;http://golang.org/cmd/&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&quot;http://golang.org/pkg/&quot;: &amp;fakeResult&#123;</span><br><span class="line">&quot;Packages&quot;,</span><br><span class="line">[]string&#123;</span><br><span class="line">&quot;http://golang.org/&quot;,</span><br><span class="line">&quot;http://golang.org/cmd/&quot;,</span><br><span class="line">&quot;http://golang.org/pkg/fmt/&quot;,</span><br><span class="line">&quot;http://golang.org/pkg/os/&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&quot;http://golang.org/pkg/fmt/&quot;: &amp;fakeResult&#123;</span><br><span class="line">&quot;Package fmt&quot;,</span><br><span class="line">[]string&#123;</span><br><span class="line">&quot;http://golang.org/&quot;,</span><br><span class="line">&quot;http://golang.org/pkg/&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&quot;http://golang.org/pkg/os/&quot;: &amp;fakeResult&#123;</span><br><span class="line">&quot;Package os&quot;,</span><br><span class="line">[]string&#123;</span><br><span class="line">&quot;http://golang.org/&quot;,</span><br><span class="line">&quot;http://golang.org/pkg/&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个使用多线程的例子，有三种不同风格的方案。</p><p>爬虫就是你给它一个 URL 让它开始运行。在 web 页面里，包含有许多链接指向了其它的页面，所以 web 爬虫要做的就是把这些链接指向的页面提取出来，抓取这些页面后再检查所有这些页面里的 url，然后继续抓取这些 url 指向的页面，它应该要能够停止——比如直到 web 中所有的页面被抓取完。</p><p>另外网页构成的 graph 和 URL 存在环，稍不注意可能就会陷入永无止境的爬取。所以爬虫的工作之一就是需要<strong>记住它抓取过的页面</strong>，或是已经开始抓取的页面，对于任何正在抓取中的页面都不应该有第二次抓取。</p><p>它是一个树结构，这个树结构是一个包含了环的实际网页 graph 的子集，我们想避开环，不想抓取同一个页面 2 次，另外，实践证明抓取一个 web 页面需要花点时间，但是因为网络有较长的延迟服务器又很慢，所以你完全不会想一次只抓取一个页面。</p><p>你需要使用并行化的方式持续的增加抓取页面的数量，直到达到呑吐极限，也就是每秒你抓取的页面数量不再增加为止，也就是并发数的增加耗尽了网络带宽。所以，我们希望利用并行化的方式抓取。</p><p>最后一个挑战有时候也是最难解决的问题，当爬虫运行结束，一旦我们已经抓取了所有的页面，就需要停止爬虫。什么时候结束被证明是最难的一部分。</p><p>串行化风格<br>所以我的第一个爬虫是一个串行化的爬虫，上面这段代码是可以用的，这个串行爬虫在网页 graph 中进行深度优先搜索，它会使用一个 map 类型的变量 fetched ，它只是被当作一个 set 使用来记住它所抓取过的页面。在 18 行你给它一个 URL，如果这个 URL 已经被抓取过它就直接 return，如果没有被抓取过，首先它要把这个 URL 记下，然后开始抓取，fetcher 会真正开始抓取页面，然后提取页面中的 URL，接下来迭代所有的 URL，递归的调用它自己，对于所有的页面，它会把这些页面传递给自己。它只有一个表格，一个 fetched map，当我调用递归的抓取的时候，它又抓取了很多页面。，在抓取实例之外，需要意识到某些页面是已经抓取过的，所以我们十分依赖于在函数里传递的 fetched 对象。map 使用引用而不是拷贝，所以在底层go 把指向map对象的指针传递给每个crawl函数调用，因此这些调用共享同一个对象和内存的指针，而不是（对象）的拷贝。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func Serial(url string, fetcher Fetcher, fetched map[string]bool) &#123;</span><br><span class="line">if fetched[url] &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fetched[url] = true</span><br><span class="line">urls, err := fetcher.Fetch(url)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">for _, u := range urls &#123;</span><br><span class="line">Serial(u, fetcher, fetched)</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>并发风格——共享数据与互斥</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Concurrent crawler with shared state and Mutex</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fetchState <span class="keyword">struct</span> &#123;</span><br><span class="line">mu      sync.Mutex</span><br><span class="line">fetched <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentMutex</span><span class="params">(url <span class="type">string</span>, fetcher Fetcher, f *fetchState)</span></span> &#123;</span><br><span class="line">f.mu.Lock()</span><br><span class="line">already := f.fetched[url]</span><br><span class="line">f.fetched[url] = <span class="literal">true</span></span><br><span class="line">f.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> already &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">urls, err := fetcher.Fetch(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> done sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">done.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(u <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> done.Done()</span><br><span class="line">ConcurrentMutex(u, fetcher, f)</span><br><span class="line">&#125;(u)</span><br><span class="line">&#125;</span><br><span class="line">done.Wait()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeState</span><span class="params">()</span></span> *fetchState &#123;</span><br><span class="line">f := &amp;fetchState&#123;&#125;</span><br><span class="line">f.fetched = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码明显比Serial crawler要复杂的多，它为每个fetch创建一个thread，最大的不同之处在于它做了两件事：一是必要的统计以注意到所有爬取完成的时刻，它也会处理共享表格，这个表格记录了已爬取的URL，所以这段代码仍然有URL表格即 f.fetched，这个表格被所有的crawler线程共享，所有的crawler线程执行在函数 ConcurrentMutex 内 ，所以我们仍然有 ConcurrentMutex 的树结构来探索 web graph 的不同部分。但它们中的每一个是被放在各自的goroutine中启动，而不是作为函数调用，它们都共享一个状态表记录已爬取URL的表格，因为如果有个goroutine爬取了一个URL，我们不希望另一个goroutine意外地爬取同一个URL ，11行和14行之间加上了互斥锁，用于防止race。</p><p>当我们检查表中的URL条目之后，在20行URL被以常见的方式爬取urls, err :&#x3D; fetcher.Fetch(url)。之后另一个有趣的事情是线程的启动。在第25行 ，遍历fetch函数返回的URLsfor _, u :&#x3D; range urls。第27行，对每个URL启动一个goroutinego func(u string) 。func语法是一个闭包（closure）或一个匿名函数，func关键字声明了一个函数然后我们调用了这个函数。理解（这段代码）的方式是你把一个函数声明成一段数据 先写下func关键字，然后给出函数参数，之后写出函数体 结束，现在这是一个对象 。为了让它成为一个goroutine，我们要在func前加上go关键字，然后我们必须要调用这个函数，因为在go语法中go关键字后面接函数名以及要传递的参数。第24行的<strong>WaitGroup</strong> 是go语言定义的一个数据结构，用于帮助coordination。WaitGroup内部有一个计数器，调用WaitGroup.Add()来增加计数器，调用WaitGroup.Done()来减小计数器。第32行，Wait方法被调用，等待计数器归零，因此WaitGroup是一种用于等待若干事件结束的方式，它在很多不同场景中都有应用，这里我们应用它来等待最后一个goroutine结束，因为我们对于每个goroutine都对WaitGroup加一。</p><p>❓ 如果某个子程序(subroutine)失败导致done没被调用该怎么办</p><p>有些方式可以使function失败，goroutine死掉而整个程序不死，这对我们是个麻烦。所以实际上 正确的方式是defer done.Done()，以确保不论goroutine是怎么结束的，done都会被调用。</p><p>❓ 为什么两个不同threads对done的调用不构成race</p><p>（WaitGroup）内部有互斥锁或类似的机制，每个done的方法会在执行任何指令前先取得锁，于是同时调用WaitGroup的方法并不构成race</p><p>非常难搞清楚你是不有一个race，你可能会有一段代码看起来非常合理，但实际上有某些你未知的race 是使用共享变量导致的 ，在实践中唯一能发现race的方法是使用自动化的工具。幸运的是go给我们提供了一个很不错的race探测器，go run -race crawler.go。你应该使用它。如果你把 -race 作为命令行参数，race检测器会告诉我们race发生的准确位置。</p><p>如果你不执行任何代码，那么race探测器不会知道任何事，它将不会分析。它并不是做静态分析，race探测器不会看你的源代码，不会基于源代码作出判断，它观察一次具体的程序运行。所以如果这次具体的程序运行没有执行，race探测器不可能知道某些恰好读写共享数据的代码，这是需要小心的地方。需要设置某种测试装置以确保所有的代码都被执行。</p><p><strong>并发风格——channel</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Concurrent crawler with channels</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">func worker(url string, ch chan []string, fetcher Fetcher) &#123;</span><br><span class="line">urls, err := fetcher.Fetch(url)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">ch &lt;- []string&#123;&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ch &lt;- urls</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func master(ch chan []string, fetcher Fetcher) &#123;</span><br><span class="line">n := 1</span><br><span class="line">fetched := make(map[string]bool)</span><br><span class="line">for urls := range ch &#123;</span><br><span class="line">for _, u := range urls &#123;</span><br><span class="line">if fetched[u] == false &#123;</span><br><span class="line">fetched[u] = true</span><br><span class="line">n += 1</span><br><span class="line">go worker(u, ch, fetcher)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">n -= 1</span><br><span class="line">if n == 0 &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func ConcurrentChannel(url string, fetcher Fetcher) &#123;</span><br><span class="line">ch := make(chan []string)</span><br><span class="line">go func() &#123;</span><br><span class="line">ch &lt;- []string&#123;url&#125;</span><br><span class="line">&#125;()</span><br><span class="line">master(ch, fetcher)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种实现方式中，不需要使用锁。有一个master线程，它有一个表格，但是这个表格是master函数私有的，master函数并不像前一个版本那样创建。这个版本为每个URL创建一个goroutine，但是只由master来创建，只有唯一一个master创建这些线程 ，所以我们没有一个函数的树形结构，我们只有一个master，在16行创建了自己的私有mapfetched :&#x3D; make(map[string]bool)，记录哪些URL已经爬取，然后创建一个channel，只有一个channel 所有的worker线程都将通过这个channel沟通。</p><p>这个思路是，启动一个worker线程，每个worker线程在结束时只会通过channel发送恰好一份数据给master，这份数据包含了这个worker从网页上爬取的网页中的URL的列表。master在第17行循环中 从channel中读取数据for urls :&#x3D; range ch。如果URL还未被爬取，它将在第22行启动一个新的worker去爬取那个URL go worker(u, ch, fetcher)。</p><p>worker线程不共享任何对象，worker和master之间也不共享任何对象，所以我们不必担心锁和race。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 6.824 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.824 Lecture3-GFS</title>
      <link href="/2024/07/03/MIT-6.824-Lecture3-GFS/"/>
      <url>/2024/07/03/MIT-6.824-Lecture3-GFS/</url>
      
        <content type="html"><![CDATA[<h3 id="Lecture-3-GFS"><a href="#Lecture-3-GFS" class="headerlink" title="Lecture 3-GFS"></a>Lecture 3-GFS</h3><p>[(289条消息) 谷歌文件系统GFS理解_小炮车的博客-CSDN博客_google文件系统gfs](<a href="https://blog.csdn.net/SwjtuPC/article/details/123652626?ops_request_misc=&request_id=&biz_id=102&utm_term=GFS">https://blog.csdn.net/SwjtuPC/article/details/123652626?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=GFS</a> PRIMARY&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-123652626.142^v47^pc_rank_34_ctr25,201^v3^add_ask&amp;spm&#x3D;1018.2226.3001.4187)</p><p>这门课程的主要内容是“大型存储”，GFS是这门课里有关如何构建大型存储系统的众多案例学习的第一篇。存储是一种关键的抽象，很多系统要么是设计的简单易用的存储接口，要么是基于底层存储进而构建。在分布式系统中，可能有各种各样重要的抽象可以应用在分布式系统中，但是实际上，简单的存储接口往往非常有用且极其通用。构建分布式系统大多都是关于如何设计存储系统，或是设计其它基于大型分布式存储的系统。因此我们会更加关注如何为大型分布式存储系统设计一个优秀的接口，以及如何设计优秀的存储系统的内部结构。</p><p>感觉就是分布式存储是很多分布式的底层，因此一个优秀、简单、抽象的接口和优秀的存储内部结构就很重要了。这里一方面是说明存储的重要性，另一方面值得关注的是接口和存储内部结构，这两点都很重要。</p><h4 id="3-1-Why-HARD"><a href="#3-1-Why-HARD" class="headerlink" title="3.1 Why HARD"></a>3.1 Why HARD</h4><p>为什么分布式存储系统会如此之难，以至于你需要做大量的工作才能让它正确工作？</p><ul><li><strong>Performance –&gt; Sharding</strong></li><li><strong>Fault –&gt; Tolerance</strong></li><li><strong>Tolerance –&gt; Replication</strong></li><li><strong>Repl –&gt; In Consistency</strong></li><li><strong>Consistency –&gt; Low Performance</strong></li></ul><p>人们设计大型分布式系统或大型存储系统出发点通常是想获取巨大的性能加成，通过利用数百台计算机的资源来同时完成大量工作。因此，性能performance问题就成为了最初的诉求。 之后，很自然的想法就是将数据分割放到大量的服务器上，这样就可以并行的从多台服务器读取数据。我们将这种方式称之为分片（Sharding）。<br>如果你在成百上千台服务器进行分片，你将会看见常态的故障。数千台服务器里每天会有一台服务器宕机，甚至每个小时都可能会发生错误。因此需要自动化的方法而不是人工介入来修复错误。每天都有大量错误发生，需要自动化的容错即fault tolerance。<br>实现容错最有用的一种方法是使用复制，只需要维护2-3个数据的副本，当其中一个故障了，你就可以使用另一个。如果想要容错能力就得有复制（replication）。<br>如果有复制，那就有了两份以上的数据副本，而且很容易不一致。本来想有了多个副本，就能通过任一实现容错，现在发现副本间数据很难完全一致（严格来说，它们就不再互为副本了）。这时候向不同副本请求，获取的数据也就不一样了。因此复制又带来了不一致的问题inconsistency。<br>通过合理的设计可以避免不一致的问题，并且让数据看起来也表现的符合预期。但这样需要额外的工作，需要服务器间额外的网络交互，这样又导致性能降低。因此为了获得一致性，又需要导致性能降低。<br>实际设计系统时，这些问题都难以避免，因此就要在性能和一致性之间权衡，并为一致性的保障做出性能上的让步，否则系统就会出现异常问题。</p><h4 id="3-2-Strong-Consistency"><a href="#3-2-Strong-Consistency" class="headerlink" title="3.2 Strong Consistency"></a>3.2 Strong Consistency</h4><p><strong>对于具备强一致 strong consistency或者好的一致性 good consistency的系统，从应用程序或者客户端看起来就像是和一台服务器在通信。</strong>尽管我们会通过数百台计算机构建一个系统，但是对于一个理想的强一致模型，你看到的就像是只有一台服务器，一份数据，并且系统一次只做一件事情。可以认为完全就是单个服务器上的单线程，同一时间只处理来自客户端的一个请求。<br>举例来说：（一个强一致性系统的示例）<br>一个只支持put, get的 key-value 系统。为了让服务有可预期的行为，需要定义一条规则：<strong>一个时间只执行一条请求。这样每个请求都可以看到之前所有请求按照顺序执行生成的数据。</strong>如果我们有一些客户端，客户端C1发起写请求将X设置成1；在同一时刻，客户端C2发起写请求将X设置成2。在C1和C2的写请求都执行完毕之后，客户端C3会发送读取X的请求，并得到了一个结果。客户端C4也会发送读取X的请求，也得到了一个结果。现在的问题是，这两个客户端看到的结果是什么？</p><p>学生提问：为什么一定要一次只处理一个请求？<br>Robert教授：假设C1和C2在同一时间发起请求，之后在某个时刻，服务器会响应它们。但是无法判断两个请求处理的先后顺序，可能先处理C1后处理C2，这样最终结果是2；反之则是1。这个例子也说明，即使非常简单的系统，仍然会出现一些模糊的场景使得你不知道系统的执行过程以及输出结果。<strong>能做的只是从产生的结果来判断系统的输出是一致性还是非一致性。</strong>如果C3读X得到2，那么C4最好也是读X得到2，否则就不是强一致性了。但是这里的单系统又会带来容错能力的问题，又需要构建多副本的分布式系统，但这却又是所有问题的开始。</p><h4 id="3-3-Bad-Replication-Design"><a href="#3-3-Bad-Replication-Design" class="headerlink" title="3.3 Bad Replication Design"></a>3.3 Bad Replication Design</h4><p>假设有一个类似上面的支持put, get的 key-value 系统，但是这里启动了两个服务以便于容错。假设客户端C1和C2都想执行写请求，其中一个要写X为1，另一个写X为2；每一个请求同时发给两个服务。这时，两个服务处理C1和C2的先后顺序有可能不一致，就会导致X最终结果不一致。如果C3从S1读数据，C4从S2读数据，这两个客户端读取的数据不一样。如果挂了一个服务，那么后面读取的可能和之前读到的值不同。<br>这个问题是可以解决的，但是需要服务器之间额外的通信，同时也会提高系统的复杂度。获取强一致性会带来复杂度的提升，当然也有很多方法能够在还不错的一致性和存在小瑕疵之间平衡。</p><h4 id="3-4-GFS的设计目标"><a href="#3-4-GFS的设计目标" class="headerlink" title="3.4 GFS的设计目标"></a>3.4 GFS的设计目标</h4><p>Google有大量的数据（网页、视频、索引中间文件），需要大量的磁盘来存储这些数据，同时也需要能借助MapReduce这样的工具来快速处理这些数据，因此Google需要能够快速的并行访问这些海量数据。谷歌构建了一个大型快速的文件系统，这个文件系统的数据是全局有效的，不同应用程序都可以从中读取数据。为了提高容量，文件会被GFS分割之后存放在多个服务器上，这样一方面从多个服务器上同时读同一个文件，获得了更高的吞吐；另一方面文件分割存储还可以保存比单个磁盘还要大的文件。因为在数百台服务器上构建了存储系统，系统需要具有一定的故障修复能力。<br>GFS被设计成只在一个数据中心运行，单个GFS只存在于单个数据中心的单个机房里。理论上应该副本间跨数据中心比较好，但是这样实现起来比较困难。GFS也只是谷歌工程师内部使用。</p><p>单数据中心可能是距离带来的性能影响，需要大量额外的设计逻辑。</p><p>GFS在各个方面对大型的顺序文件读写做了定制，是为TB级别的文件而生，<strong>只支持顺序访问</strong>，不支持随机访问。某种程度上来说，它有点像批处理的风格。GFS并没有花费过多的精力来降低延迟，它的关注点在于巨大的吞吐量上，因此单次操作都涉及到MB级别的数据。存储系统有单独针对小份数据优化的系统，但GFS并不是。<br>GFS论文发表在2003年的SOSP会议上，它描述了一个真正运行在成百上千台计算机上的系统，规模远大于学术界。反映了工业界对于保障系统正常工作和节省成本的经验。论文也提出了一个当时非常异类的观点：存储系统具有弱一致性也是可以的，GFS并不保证返回正确的数据，其目标是提供更好的性能。学术论文做多是多个Master节点共同分担工作，但GFS却使用单个Master节点（Active-Standby模式，只有一个Master节点在工作）。</p><p>学生提问：如果GFS返回错误的数据，会不会影响应用程序？<br>Robert教授：如果你通过搜索引擎做搜索，20000个搜索结果中丢失了一条或者搜索结果排序是错误的，没有人会注意到这些。尽管GFS可能会返回错误的数据，但是可以在应用程序中做一些补偿。例如论文中提到，应用程序应当对数据做校验，并明确标记数据的边界，这样应用程序在GFS返回不正确数据时可以恢复。</p><p>关于这个问题，后面关于spanner等基于GFS的系统是一个很好的答案。</p><h4 id="3-5-Master-Data"><a href="#3-5-Master-Data" class="headerlink" title="3.5 Master Data"></a>3.5 Master Data</h4><p>了解系统如何容错以及一致性，就需要知道master存放的数据。</p><ul><li><strong>一个master节点，Active-Standby模式，只有一个Master节点在工作，</strong>用来管理文件和Chunk的信息</li><li>上百个客户端</li><li>大量Chunk服务器，每个上面有1-2块磁盘，用来存储实际的数据。</li></ul><p>Master节点知道每一个文件对应的所有的Chunk的ID，每个Chunk 64MB，多个Chunk共同构成了一个文件。比如一个1G的文件，先从master节点查询对应的Chunk所在服务器，之后直接从Chunk Server读取对应的数据。<br>Master节点内保存的数据内容主要是两个表单：</p><p><img src="https://s2.loli.net/2024/07/03/6Y4QmFa9nyLXcf3.png" alt="a167415c6dd14a278e25fc8cfd3501f4[1].png"></p><ul><li>文件名到Chunk ID或者Chunk Handle数组的对应，即一个文件对应了哪些ChunkID。</li><li>Chunk ID到Chunk数据的对应关系。这里的数据又包括了：<ul><li>每个Chunk存储在哪些服务器上，即Chunk服务器的列表</li><li>每个Chunk当前的版本号，通过这个递增字段，用来标识最新的版本信息，cs对应的chunk值小则认为数据是不准确的</li><li>主Chunk对应的服务器，因为对Chunk的写操作都必须在Primary Chunk 上顺序处理</li><li>主Chunk的租约过期时间，主Chunk只能在特定的租约时间内担任主Chunk</li></ul></li></ul><p>以上数据都存放在内存中，同时会有log以及checkPoint存放在磁盘上，内存中用于快速访问，磁盘中用于持久化。<br>有些数据需要存在磁盘上，而有些不用。它们分别是：</p><ul><li>Chunk Handle的数组（第一个表单）要保存在磁盘上，标记成NV（non-volatile, 非易失）表示对应的数据会写入到磁盘上。</li><li>Chunk服务器列表不用保存到磁盘上。因为Master节点重启之后可以与所有的Chunk服务器通信，并查询每个Chunk服务器存储了哪些Chunk，这里标记成V（volatile），</li><li>版本号要不要写入磁盘取决于GFS是如何工作的，我认为它需要写入磁盘</li><li>主Chunk的ID，Master节点重启之后会忘记谁是主Chunk，它只需要等待60秒租约到期，那么它知道对于这个Chunk来说没有主Chunk，这个时候，Master节点可以安全指定一个新的主Chunk，这里标记成V。</li><li>类似的，租约过期时间也不用写入磁盘，这里标记成V。</li></ul><p>如果文件写满了一个64MB Chunk，之后需要新增一个Chunk或者由于指定了新的主Chunk而导致版本号更新，Master节点需要向磁盘中的Log追加一条记录，刚刚向这个文件添加了一个新的Chunk或者刚刚修改了Chunk的版本号。这种更新都需要落盘，因为磁盘更新速度有限，进而影响master节点更新速度，所以要尽可能的少写入数据到磁盘中。<br>在磁盘中维护log而不是数据库。log数据都是向同一个地址追加，可以将最近的多个log记录一次性的写入，这样只需要等待磁盘的磁碟旋转一次。数据库本质上来说是某种B树（b-tree）或者hash table。对于B树来说，每一份数据都需要在磁盘中随机找个位置写入。<br>当Master节点故障重启，并重建它的状态，log的最开始可能是几年之前，通过在磁盘中创建一些checkpoint点，从log中的最近一个checkpoint开始恢复，再逐条执行从Checkpoint开始的log，最后恢复自己的状态。</p><h4 id="3-6-GFS读文件（Read-File"><a href="#3-6-GFS读文件（Read-File" class="headerlink" title="3.6 GFS读文件（Read File)"></a>3.6 GFS读文件（Read File)</h4><p>客户端（或者应用程序）将file name，offset，size发送给Master<br>Master根据file name以及偏移量&#x2F;64MB就可以找到Chunk Handle，之后将这个chunk对应的服务器列表发送给客户端，客户端会缓存chunk和服务器列表的对应关系<br>客户端会选择一个网络上最近的服务器（Google的数据中心中，可以从IP地址的差异判断网络位置的远近），并将Chunk Handle和偏移量发送给那个Chunk server，之后返回给客户端数据</p><blockquote><p>[!CAUTION]</p><p>1.后面基于GFS的应用可以知道，为了提高效率，而且GFS是大文件的，所以一个文件可能应用只需要读取其中的一部分数据，因为这个文件本身就被应用用来对应多条不同的数据了。<br>2.可能有点绕结合3.5的图即可</p></blockquote><p>Chunk服务器会在本地的硬盘上，将每个Chunk存储成独立的Linux文件，并通过普通的Linux文件系统管理，Chunk文件会按照Handle（也就是ID）命名。Chunk服务器需要做的就是根据文件名找到对应的Chunk文件，之后从文件中读取对应的数据段，并将数据返回给客户端。<br>学生提问：如果客户端有偏移量信息，那可以直接算出来是第几个Chunk吧？<br>Robert教授：客户端可以算出来是哪个Chunk，但是客户端不知道Chunk在哪个服务器上。为了获取服务器信息，客户端需要与Master交互。Master节点找到了Chunk对应的ID，并确定了Chunk存储在哪个服务器上。</p><p>学生提问：如果读取的数据超过了一个Chunk怎么办？<br>Robert教授：会将一个读请求拆分成多个读请求（文件对应的多个chunk）再发送到Master节点，之后再向两个不同的Chunk服务器读取数据。</p><p>学生提问：能再介绍一下读数据跨越了Chunk边界的情况吗？<br>Robert教授：GFS的库会将读请求拆分，之后再将它们合并起来。比如需要Chunk7的最后两个字节，Chunk8的头两个字节，获取到这些数据之后，会将它们放在一个buffer中，再返回给调用库的应用程序。Master节点会告诉库有关Chunk的信息，而GFS库可以根据这个信息找到应用程序想要的数据。应用程序只需要确定文件名和数据在整个文件中的偏移量，GFS库和Master节点共同协商将这些信息转换成Chunk。</p><p>学生提问：从哪个Chunk服务器读取数据重要吗？<br>Robert教授：实际上不同Chunk服务器上的数据并不一定完全相同，应用程序应该要能够容忍这种情况。如果从不同的Chunk服务器读取数据，可能会略微不同。GFS论文提到，客户端会尝试从同一个机架或者同一个交换机上的服务器读取数据。</p><h4 id="3-7-GFS写文件（Write-File）"><a href="#3-7-GFS写文件（Write-File）" class="headerlink" title="3.7 GFS写文件（Write File）"></a>3.7 GFS写文件（Write File）</h4><p>从应用程序的角度来看，写文件和读文件的接口都是调用GFS的库。对于写文件，客户端会向Master节点发送请求说：我想向这个文件名对应的文件追加数据，请告诉我文件中最后一个Chunk的位置，这里即为记录追加（Record Append）。</p><p>客户端根据文件名请求master，获取chunkID（这里肯定是最后一个，当然如果是新文件第一个chunkID也是最后一个），以及对应的服务器列表，进而能够往primary chunk写文件。</p><p>不同客户端写同一份日志文件，没有一个客户端会知道文件究竟有多长，因此也就不知道该往什么样的偏移量，或者说向哪个Chunk去追加数据。这个时候，客户端可以向Master节点查询哪个Chunk服务器保存了文件的最后一个Chunk。</p><p>这里有很多细节冲突问题，详见下文及3.8<br>并发量很高的情况下，返回了最后一个chunk，但是此时又被写满了，这个已经不是最后一个了？这个应该是首先会等client发送的所有数据到达之后开始写，这时候chunk发现没有足够空间了，会返回客户端错误<br>是不是新的chunk都是通过master指定的？应该是的，之后放在文件对应的chunk list里</p><p><strong>写Primary Chunk</strong><br>写文件必须写主副本，通过master获取chunk对应的服务器列表中的主副本信息。但有时Master不一定指定了Chunk的主副本，因此需要考虑Chunk的主副本不存在的情况。对于读文件来说，可以从任何最新的Chunk副本读取数据。<br>Master节点需要告诉客户端向哪个Chunk服务器（也就是Primary Chunk所在的服务器）去做追加操作，Master节点的部分工作就是弄清楚在追加文件时，客户端应该与哪个Chunk服务器通信。</p><p><strong>No Primary 选主的逻辑</strong></p><ol><li><p>会找出所有存有Chunk最新副本的Chunk服务器，因为某个副本可能因为宕机尚未更新数据</p></li><li><p>找出新的Chunk副本。最新的副本是指副本中保存的版本号与Master中记录的Chunk的版本号一致。Chunk副本中的版本号是由Master节点下发的，Master节点知道，对于一个特定的Chunk，哪个版本号是最新的。</p><ol><li><p>Master找到最新的副本</p></li><li><p>选一个作为Primary，其他的作为Secondary</p></li><li><p>Master会增加版本号</p></li><li><p>Master节点会向Primary和Secondary副本对应的服务器发送消息告知主备关系、最新版本号–&gt;Lease</p><p>master持久化版本号</p></li><li><p>2.b应该是master向chunk的主副本发放lease，增加版本号</p></li></ol></li></ol><p>几点说明：</p><ul><li>master通过版本号区别正常副本和数据落后的副本，同时master重启之后，依然可以通过版本号区分副本的情况。</li><li>master会给primary一个60s的租约（60s之后停止成为primary），持有租约才能够是primary，这种机制可以确保我们不会同时有两个Primary。</li></ul><blockquote><p>[!CAUTION]</p><p>这里的60s，后面可以通过和master通信获得延期，实际上3个副本中的primary是master说了算</p></blockquote><p>学生提问：为什么不将所有Chunk服务器上保存的最大版本号作为Chunk的最新版本号？<br>Robert教授：master重启之后，对于每一个chunk，汇总其各副本的版本号，但是无法确认当前最大的就是最新的，可能最新的并未启动。当Master找不到持有最新Chunk的服务器时，有两种可能：要么Master会等待，并不响应客户端的请求；要么会返回给客户端现在还不知道Chunk在哪，过会再重试吧。比如机房断电导致服务器大规模重启，这时只能等待，因为不会想使用Chunk的旧数据。</p><blockquote><ol><li>通过版本号匹配，确认最新的chunk版本，这里有两点思考，1）应该是并未保存当前的副本都有哪些节点，全靠上报，当然这里是可以简单优化的2）通过版本号确定最新的，第二个有点类似raft选主，最新的term可以成为leader</li><li>因为肯定不想使用旧数据，所以只能等待最新版本的chunk上线</li><li>一个思考：这种通过别人选主和raft副本之间自己选主的区别联系优劣？</li></ol></blockquote><p>学生提问：如果Chunk服务器上报的版本号高于Master存储的版本号会怎么样？<br>Robert教授：GFS论文说，chunk server上报了一个比Master记住的版本更高的chunk版本。Master会认为它在分配新的Primary服务器时出现了错误，并且会使用这个更高的版本号来作为Chunk的最新版本号。当Master向Primary和Secondary发送完消息之后就崩溃了，可能会出现上面这种情况。为了让Master能够处理这种情况，Master在发送完消息之后，需要将Chunk的最新版本写入到磁盘中。这里的写入或许需要等到Primary和Secondary返回确认消息之后。我（Robert教授）也不太确定Master究竟是先写本地磁盘中的版本号，然后再通知Primary和Secondary，还是反过来。但是不管怎么样，Master会更新自己的版本号，并通知Primary和Secondary说，你们现在是Primary和Secondary，并且版本号更新了。</p><p>感觉是要等chunk的副本确认版本号之后，master才能持久化更新chunkID，保障master的版本号永远不会大于chunk的，不然永远找不到最新的了。同样，这种情况才会出现chunk最新版本号更高的问题。磁盘故障什么的除外。</p><p><strong>Primary写</strong></p><ol><li>客户端根据文件名从master获取到了最后一个chunkID以及对应的ChunkServer及其中的primary</li><li>客户端发送要追加的数据</li><li>chunkServer会将数据写入临时位置，并不会直接追加到文件中，</li><li>当所有的服务器都返回确认消息说，已经有了要追加的数据，客户端会向Primary服务器发送一条消息说，你和所有的Secondary服务器都有了要追加的数据，现在我想将这个数据追加到这个文件中</li><li>Primary会查看当前文件结尾的Chunk，并确保Chunk中有足够的剩余空间，然后将客户端要追加的数据写入Chunk的末尾，同时也会将offset发送给Secondary执行追加</li><li>Secondary返回成功给primary</li><li>primary收到所有成功回复，会向客户端返回写入成功，如果有一个服务器写失败或者超时，会向客户端返回写入失败</li></ol><p>几点说明：</p><ul><li>Primary服务器或许会从大量客户端收到大量的并发请求，Primary服务器会以某种顺序，一次只执行一个请求。</li><li>对于Secondary服务器来说，可能会执行失败，比如说网络丢包，磁盘空间不足，发生故障</li><li>如果客户端从Primary得到写入失败，那么客户端应该重新发起整个追加过程，客户端首先会重新与Master交互，找到文件末尾的Chunk</li></ul><blockquote><ol><li>primary控制写入的offset</li><li>这里要求三副本都写成功才能返回给客户端成功，之后客户端可以直接就近读取</li><li>只要写失败，客户端都要重新请求master，因为失败原因多多难以预料，保险起见直接重新走流程</li></ol></blockquote><p><strong>关于master指定primary 以及版本号的问答</strong></p><ul><li><p><strong>什么时候版本号会增加？</strong></p><p>Robert教授：版本号<strong>只在Master节点认为Chunk没有Primary时才会增加</strong>。在一个正常的流程中，如果对于一个Chunk来说，已经存在了Primary，那么Master节点会记住已经有一个Primary和一些Secondary，Master不会重新选择Primary，也不会增加版本号。它只会告诉客户端说这是Primary，并不会变更版本号。</p></li><li><p>如果<strong>Master节点发现Primary挂了会怎么办</strong>？</p><p>Robert教授：Master指定了一个Primary，如果之后ping不通，并不会立即选主，因为这里可能是多种原因导致一两次不通，更主要是这样会导致同时存 在两个primary（从客户端的视角，客户端1认为A是主，后面的客户端2认为B是主），会分别处理不同的写请求，最终会导致有两个不同的数据拷贝。这被称为<strong>脑裂（split-brain），通常是由网络分区引起的，比如说Master无法与Primary通信，但是Primary又可以与客户端通信，这就是一种网络分区问题，网络故障是这类分布式存储系统中最难处理的问题之一。</strong>要避免错误的为同一个Chunk指定两个Primary的可能性。Master采取的方式是，当指定一个Primary时，为它分配一个租约，Primary只在租约内有效。Master和Primary都会知道并记住租约有多长，当租约过期了，Primary会停止响应客户端请求，它会忽略或者拒绝客户端请求。如果Master不能与Primary通信，并且想要指定一个新的Primary时，Master会等到前一个Primary的租约到期。所以master必须等到租约到期之后，这样可以确保不会出现这种脑裂情况。</p></li></ul><p>这里的租约，肯定不能用系统时间，如果用倒计时的话，是否需要考虑网络上花费的时间？比如master指定primary之后就开始计时，或者收到primary的响应之后开始，总之master和指定的primary必有先后。好像lease的话，一般会在块到期的前几秒时间就立即发送消息，进行续租。但是过期的判断是否也加上这个？加上这个是否带来延迟。</p><p><strong>关于写入的问答</strong><br>如果是对一个新的文件进行追加，那这个新的文件没有副本，会怎样？<br>Robert教授：Master节点或许会通过随机数生成器创造一个新的Chunk ID。之后Master节点会创建一条新的Chunk记录，再随机选择一个Primary和一组Secondary并告诉它们，你们将对这个空的Chunk负责，请开始工作。</p><p>写文件失败之后Primary和Secondary服务器上的状态如何恢复？<br>Robert教授：Primary会回复客户端说执行失败，部分副本还是成功将数据追加了。一个Chunk的部分副本成功完成了数据追加，而另一部分没有成功，这种状态是可接受的，没有什么需要恢复，这就是GFS的工作方式。</p><p>写文件失败之后，读Chunk数据会有什么不同？<br>Robert教授：如果写文件失败之后，一个客户端读取相同的Chunk，客户端可能可以读到追加的数据，也可能读不到，取决于客户端读的是Chunk的哪个副本。</p><p>可不可以通过版本号来判断副本是否有之前追加的数据？<br>Robert教授：所有的Secondary都有相同的版本号，版本号只会在Master指定一个新Primary时才会改变，通常只有在原Primary发生故障了，才会指定一个新的Primary。副本（参与写操作的Primary和Secondary）都有相同的版本号，你没法通过版本号来判断它们是否一样，或许它们就是不一样的（取决于数据追加成功与否）。</p><p>客户端将数据拷贝给多个副本会不会造成瓶颈？<br>Robert教授：考虑到底层网络，写入文件数据的具体传输路径可能会非常重要。当论文第一次说客户端会将数据发送给每个副本。之后论文又改变了说法，说客户端只会将数据发送给离它最近的副本，之后那个副本会将数据转发到另一个副本，以此类推形成一条链，直到所有的副本都有了数据。这样一条数据传输链可以在数据中心内减少跨交换机传输（否则，所有的数据吞吐都在客户端所在的交换机上）。</p><p>为什么立即指定一个新的Primary是坏的设计？<br>Robert教授：因为客户端会通过缓存提高效率，客户端会在短时间缓存Primary的身份信息（这样，客户端就不用每次都会向Master请求Primary信息）。即使没有缓存，也有可能刚向客户端返回之后，master就指定了新的primary。如果不采用其它机制，前一个客户端是没办法知道收到的Primary已经过时了，此时如果前一个客户端执行写文件，那么就会与后来的客户端产生两个冲突的副本。</p><p>如果写入数据失败了，不是应该先找到问题在哪再重试吗？<br>Robert教授：论文中在重试追加数据之前没有任何中间操作，因为可能是网络导致部分数据丢失。客户端重试，对于大多数错误来说可以直接解决。我们希望如果某个副本出错，master能够指定新的，剔除出错的副本，同时指定版本号和新的primary，旧的副本也永远因为版本号旧被抛弃。但是论文里只是说，客户端重试，并且期望之后能正常工作。Master节点会ping所有的Chunk服务器，如果Secondary服务器挂了，Master节点可以发现并更新Primary和Secondary的集合，之后再增加版本号。但是这些都是之后才会发生（而不是立即发生）。</p><h4 id="3-8-GFS的一致性"><a href="#3-8-GFS的一致性" class="headerlink" title="3.8 GFS的一致性"></a>3.8 GFS的一致性</h4><p>对于一个新建的文件f1，会指定一个新的chunk以及对应的三个副本。客户端向文件追加数据A，此时三个副本（一个Primary和两个Secondary），都成功的将数据追加到了Chunk，Chunk中的第一个记录是A。<br>第二个客户端向文件f1追加数据B，由于网络问题导致一个secondary副本写失败，现在我们有两个副本有数据B，另一个没有。<br>第三个客户端向文件f1追加数据C，发送给主副本之后，Primary选择了偏移量，并将偏移量告诉Secondary，将数据C写在Chunk的这个位置。<br>第二个客户端会收到写失败的回复，之后会再次请求追加数据B，此时一切正常，写入成功。<br>又一个客户端向文件f1追加数据D，最终写成功两个副本，但是这个客户端挂了，因此并不会再次进行重试，最后数据D出现在某些副本中，而其他副本则完全没有。<br><strong>在GFS的这种工作方式下，Primary返回写入失败会导致不同的副本有完全不同的数据。</strong></p><p><img src="https://s2.loli.net/2024/07/03/QavCDUPo59GTjSL.png" alt="59cb609fe1f04e7fa48e278b0d1af47e[1].png"></p><p>如果一个客户端读文件f1，读到的内容取决于读取的是Chunk的哪个副本，不同的副本，读取数据的顺序是不一样的。如果读取的是第一个副本，那么客户端可以读到A、B、C，然后是一个重复的B。如果读取的是第三个副本，那么客户端可以读到A，一个空白数据，然后是C、B。</p><p>客户端重新发起写入的请求时从哪一步开始重新执行的？<br>Robert教授：根据我从论文中读到的内容，（当写入失败，客户端重新发起写入数据请求时）客户端会从整个流程的最开始重发。客户端会再次向Master询问文件最后一个Chunk是什么，因为文件可能因为其他客户端的数据追加而发生了改变。</p><p>为什么GFS要设计成多个副本不一致？<br>Robert教授：我不明白GFS设计者为什么要这么做。GFS可以设计成多个副本是完全精确同步的。但是为了保持同步，要使用各种各样的技术。其中一条规则就是不能允许这种只更新部分服务器的不完整操作。即使客户端挂了，系统只要收到了请求，就要保障完成，primary需要确保每一个副本都得到每一条消息。</p><p>如果第一次写B失败了，C应该在B的位置吧？<br>Robert教授：实际上并没有。Primary将C添加到了Chunk的末尾，在B第一次写入的位置之后。当写C的请求发送过来时，Primary实际上可能不知道B的命运是什么。因为我们面对的是多个客户端并发提交追加数据的请求，为了获得高性能，你会希望Primary先执行追加数据B的请求，一旦获取了下一个偏移量，再通知所有的副本执行追加数据C的请求，这样所有的事情就可以并行的发生。Primary也可以判断B已经写入失败了，然后再发一轮消息让所有副本撤销数据B的写操作，但是这样更复杂也更慢。</p><p>primary不去校验其它副本有没有写成功，会指定其他副本写入的offset，这样如果自己写成功了，其他副本有失败的，也不会有影响；如果自己写失败，其它副本成功了，也时按照自己的offset写入新的。<br>这样做的目的大概是为了提高性能，但是客户端就要自己处理这种乱序的数据问题。</p><p>GFS这样设计的理由是足够的简单，但是同时也给应用程序暴露了一些奇怪的数据。这里希望为应用程序提供一个相对简单的写入接口，但应用程序需要容忍读取数据的乱序。如果应用程序不能容忍乱序，应用程序要么可以通过在文件中写入序列号，这样读取的时候能自己识别顺序，要么如果应用程序对顺序真的非常敏感那么对于特定的文件不要并发写入。例如，对于电影文件，你不会想要将数据弄乱，当你将电影写入文件时，你可以只用一个客户端连续顺序而不是并发的将数据追加到文件中。</p><p><strong>将GFS升级成强一致系统（增加了系统的复杂度，增加了系统内部组件的交互）</strong></p><ul><li><p>你可能需要让Primary来探测重复的请求，这样第二个写入数据B的请求到达时，Primary就知道，我们之前看到过这个请求，可能执行了也可能没执行成功。Primay要尝试确保B不会在文件中出现两次。首先需要的是探测重复的能力。</p><blockquote><p>这里大概是考虑到客户端或者网络什么的，会出现重复的请求，通过序列号应该就能支持。</p></blockquote></li><li><p>对于Secondary来说，如果Primay要求Secondary执行一个操作，Secondary必须要执行而不是只返回一个错误给Primary。对于一个严格一致的系统来说，是不允许Secondary忽略Primary的请求而没有任何补偿措施的。如果Secondary有一些永久性故障，例如磁盘被错误的拔出了，你需要有一种机制将Secondary从系统中移除，这样Primary可以与剩下的Secondary继续工作。但是GFS没有做到这一点，或者说至少没有做对。</p><blockquote><p>这里是否有点绝对，首先无法保障secondary一定能成功，这时primary认为大家都失败了即可。</p></blockquote></li><li><p>当Primary要求Secondary追加数据时，<strong>直到Primary确信所有的Secondary都能执行数据追加之前，Secondary必须小心不要将数据暴露给读请求。</strong>在第一个阶段，Primary向Secondary发请求，要求其执行某个操作，并等待Secondary回复说能否完成该操作，这时Secondary并不实际执行操作。在第二个阶段，如果所有Secondary都回复说可以执行该操作，这时Primary才会说，好的，所有Secondary执行刚刚你们回复可以执行的那个操作。这是现实世界中很多强一致系统的工作方式，这被称为两阶段提交（Two-phase commit）。</p><blockquote><p>这里是不能让客户端读到脏数据</p></blockquote></li><li><p>当Primary崩溃时，可能有一组操作由Primary发送给Secondary，Primary在确认所有的Secondary收到了请求之前就崩溃了。当一个Primary崩溃了，一个Secondary会接任成为新的Primary，但是这时，新Primary和剩下的Secondary会在最后几个操作有分歧，因为部分副本并没有收到前一个Primary崩溃前发出的请求。新的Primary上任时，需要显式的与Secondary进行同步，以确保操作历史的结尾是相同的。</p><blockquote><p>对于GFS，切换primary时，客户端会超时失败，之后请求master，最终得到了新的primary信息，这时不管或者primary写成功失败，它也无需考虑别人上次是成功失败，它只需要把自己最后的offset发过去，但是这样客户端读不同的副本得到的结果不一致，客户端需要自己处理这种不一致。</p><p>为了保障强一致性，新primary就需要有一个同步操作，让大家都一致。</p></blockquote></li><li><p>最后，时不时的，Secondary之间可能会有差异，或者客户端从Master节点获取的是稍微过时的Secondary。系统要么需要将所有的读请求都发送给Primary，因为只有Primary知道哪些操作实际发生了，要么对于Secondary需要一个租约系统，就像Primary一样，这样就知道Secondary在哪些时间可以合法的响应客户端。</p><blockquote><p>这里应该是客户端读的时候，如果读secondary，可能这个secondary持有的数据并不是新的（新加入的，还在catch up阶段），这时它就不应该响应客户端。</p><p>读取也是一个很有趣的事，这里可以在raft中获得更多体会。</p></blockquote></li></ul><p><strong>GFS单master的问题</strong><br>最后，让我花一分钟来介绍GFS在它生涯的前5-10年在Google的出色表现，总的来说，它取得了巨大的成功，许多许多Google的应用都使用了它，许多Google的基础架构，例如BigTable和MapReduce是构建在GFS之上，GFS在Google内部广泛被应用。它最严重的局限可能在于，它只有一个Master节点，会带来以下问题：</p><ul><li><p>Master节点必须为每个文件，每个Chunk维护表单，随着GFS的应用越来越多，这意味着涉及的文件也越来越多，最终Master会耗尽内存来存储文件表单。你可以增加内存，但是单台计算机的内存也是有上限的。</p><blockquote><p>这个大概是单master内存有限，后面可以将元数据剥离出来。</p></blockquote></li><li><p>单个Master节点要承载数千个客户端的请求，而Master节点的CPU每秒只能处理数百个请求，尤其Master还需要将部分数据写入磁盘，很快客户端数量超过了单个Master的能力。</p><blockquote><p>单节点复杂所有的选主，而且客户端要从master获取primary的信息，这里能想到的一个就是根据业务搭建一个新的集群。</p><p>思考：现实问题中在多集群和单一集群之间的利弊与权衡？即搭建多个集群固然简单，有什么弊端吗？</p></blockquote></li><li><p>应用程序发现很难处理GFS奇怪的语义（本节最开始介绍的GFS的副本数据的同步，或者可以说不同步）。</p></li><li><p>从我们读到的GFS论文中，Master节点的故障切换不是自动的，需要人工干预来处理已经永久故障的Master节点，并更换新的服务器，这可能需要几十分钟甚至更长的而时间来处理，对于某些应用程序来说，这个时间太长了。</p><blockquote><p>这个感觉时Google自己留了一手。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 6.824 </tag>
            
            <tag> GFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CoRE-learning：Learnability with Time-Sharing Computational Resource Concerns</title>
      <link href="/2024/07/01/CoRE-learning%EF%BC%9A%E5%B8%A6%E6%9C%89%E5%88%86%E6%97%B6%E8%AE%A1%E7%AE%97%E8%B5%84%E6%BA%90%E8%80%83%E8%99%91%E7%9A%84%E5%8F%AF%E5%AD%A6%E4%B9%A0%E6%80%A7%E7%90%86%E8%AE%BA/"/>
      <url>/2024/07/01/CoRE-learning%EF%BC%9A%E5%B8%A6%E6%9C%89%E5%88%86%E6%97%B6%E8%AE%A1%E7%AE%97%E8%B5%84%E6%BA%90%E8%80%83%E8%99%91%E7%9A%84%E5%8F%AF%E5%AD%A6%E4%B9%A0%E6%80%A7%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="CoRE-learning：Learnability-with-Time-Sharing-Computational-Resource-Concerns"><a href="#CoRE-learning：Learnability-with-Time-Sharing-Computational-Resource-Concerns" class="headerlink" title="CoRE-learning：Learnability with Time-Sharing Computational Resource Concerns"></a>CoRE-learning：Learnability with Time-Sharing Computational Resource Concerns</h1><p><a href="https://doi.org/10.1093/nsr/nwae204">‍https://doi.org/10.1093/nsr/nwae204‍</a></p><p>一般认为，人工智能机器学习技术应用涉及算法、数据、算力“三要素”。经典机器学习理论关注算法与数据对学习性能的影响，推导出的机器学习泛化误差界所包含的重要项通常涉及假设类复杂度和样本复杂度，两者分别与算法和数据有关，而对“三要素”中的算力缺乏考虑，尽管现实场景中算力资源的供给分配直接影响到最终学习性能。</p><p>在近期发表于《国家科学评论》（<em>National Science Review</em>, NSR）的Perspective文章中，<strong>南京大学周志华教授提出了“计算资源高效学习（CoRE-learning）”理论框架，这是第一个考虑了算力资源供给调度对机器学习性能影响的学习理论框架。</strong></p><p><strong>CoRE理论框架</strong>：</p><p><img src="https://s2.loli.net/2024/07/01/jt5ZsTLezHfRrlg.png" alt="image-20240630231211322.png"></p><p>作者定义了“机器学习吞吐率”并引入了对资源动态分配调度策略的考虑，使得算力资源的供给分配对机器学习泛化性能的影响可以被抽象地在学习理论中进行研究，不仅有助于指导设计出高效使用算力资源的算法，还可望引导“智算中心”在为机器学习模型训练提供资源服务时从“独占式”转变为“分时式”，为能源的高效利用提供一个机器学习理论视角。</p><h2 id="动机（Motivation）："><a href="#动机（Motivation）：" class="headerlink" title="动机（Motivation）："></a><strong>动机（Motivation）：</strong></h2><ul><li>传统机器学习理论通常假设有足够的甚至无限供应的计算资源来处理所有接收到的数据。然而，在实际应用中，如流学习，数据流可能是无限的，且数据量巨大，不可能及时处理所有数据。（这个问题通常不是机器学习领域考虑的问题）</li><li>现代“智能超级计算”设施通常以独占方式运行，用户被分配固定数量的资源来运行机器学习任务。这种方式可能过于乐观或悲观，导致资源分配不合理。这就有点像早期的计算机系统了。</li><li>机器学习理论应该考虑时间共享计算资源的问题，以提高用户效率和硬件效率，这一关键技术就是分时（time-sharing）。</li><li>目标：<ul><li>用户效率角度：在一定时间预算内得到理想的模型结果。</li><li>硬件效率角度：计算资源被合理地利用。</li></ul></li></ul><h2 id="工作内容（Work）："><a href="#工作内容（Work）：" class="headerlink" title="工作内容（Work）："></a><strong>工作内容（Work）：</strong></h2><p>基于motivation，提出了“计算资源高效学习”（CoRE learning）的概念，并建立了一个理论框架。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>吞吐量：每秒可以传输的数据量&#x2F;数据库中平均事务处理数量。</p></li><li><p>引入了<strong>机器学习吞吐量</strong>的概念，用于在抽象层面上理论化计算资源和调度的影响。：</p><ul><li><p><strong>数据吞吐量</strong>：表示每个时间单位内可以学习的数据百分比。</p></li><li><p><strong>线程吞吐量</strong>：线程吞吐量表示在一段时间内可以很好地学习的线程的百分比。</p><p><img src="https://s2.loli.net/2024/07/01/jt5ZsTLezHfRrlg.png" alt="image-20240630231211322.png"></p><p>图1(a)为<strong>数据吞吐量</strong>，将这个概念引入机器学习研究：</p><ul><li>数据量和计算资源预算的影响可以被涉及。</li><li>但并未考虑到从数据中学习的难度可能会发生变化的事实。</li></ul><p><strong>线程</strong>：计算设备接收到的机器学习任务。</p><ul><li>生命周期：开始时间和截止&#x2F;死亡时间（这里的截止时间是人为设置的）。</li><li>成功线程：时间跨度内能很好地学习，达到用户的要求。</li><li>失败线程：时间跨度内不能很好地学习，不能达到用户的要求。</li></ul><p><strong>线程吞吐量</strong>：由该时间段内所有线程中的成功线程百分比计算，如图1(b)线程吞吐量即为3&#x2F;5&#x3D;60%。</p><p><strong>任务束（task bundle）</strong>：相关时间段内的一组任务线程。</p><p><img src="https://s2.loli.net/2024/07/01/5PweNGyE4qjfkCM.png" alt="image-20240701122812984.png"></p><ul><li>其中<img src="https://s2.loli.net/2024/07/01/UyIxqoT6D2Oht9g.png" alt="image-20240701122851437.png">，<strong>Dk</strong>表示具有数据分布的线程，<strong>bk</strong>表示起始时间，<strong>dk</strong>是截止时间，<strong>Nt</strong>是在给定计算资源前提下在时间t时可以处理的数据量，<strong>K</strong>是任务束中的总线程数（总的任务数)，T是总的**时隙（time slots)<strong>数量。如果</strong>bi&#x3D;bj (所有i≠j)**，则所有任务线程同时到达。</li></ul></li></ul></li></ul><h4 id="Learning-algorithm"><a href="#Learning-algorithm" class="headerlink" title="Learning algorithm"></a>Learning algorithm</h4><p><strong>学习算法</strong>：<img src="https://s2.loli.net/2024/07/01/ndGhjSIHwpRcqoL.png" alt="image-20240701134403028.png"></p><p><strong>输入</strong>：<img src="https://s2.loli.net/2024/07/01/CPmvKkdSObRQUcL.png" alt="image-20240701134413069.png"></p><p><strong>输出：</strong><img src="https://s2.loli.net/2024/07/01/QoOyVGNieK7wACm.png" alt="image-20240701134435515.png"></p><ul><li><strong>sk</strong>为算法确定的切换时间。</li><li><strong>Mk</strong>为第k个线程的learned model。</li></ul><p>用<strong>At</strong>表示在时间t时存活线程的集合：</p><p><img src="https://s2.loli.net/2024/07/01/QAVty5wKrUbLFhk.png" alt="image-20240701134742442.png"></p><p><strong>学习过程</strong>如下：</p><ol><li><p>for循环:时间t&#x3D;1,…,T，the learner </p><p>do：</p><ol><li>最多收集 k,t，Nt 在 k ∈ At条件下的样本 , 其中 ηk,t为线程k在时间t的数据吞吐量。</li><li>为线程k更新模型Mk。</li><li>如果线程k完成，将sk设为t。</li></ol></li><li><p>终止循环。</p></li></ol><h5 id="Definition-1-η-κ-L-CoRE-learnability-："><a href="#Definition-1-η-κ-L-CoRE-learnability-：" class="headerlink" title="Definition 1 ((η, κ,L)-CoRE learnability)："></a>Definition 1 ((η, κ,L)-CoRE learnability)：</h5><p>现在引入CoRE learnability，其中<img src="https://s2.loli.net/2024/07/01/WzpP4XcBDfGN32h.png" alt="image-20240701140345002.png">为数据吞吐量，<img src="https://s2.loli.net/2024/07/01/pMOLFz14aCht23d.png" alt="image-20240701140353686.png">为线程吞吐量。</p><p><img src="https://s2.loli.net/2024/07/01/B7GjcYV5frlUMyd.png" alt="image-20240701141334011.png"></p><p>条件（1）涉及整个数据吞吐量，约束所有在当前时刻的alive set中的线程的总体资源配额永远不会超过最大资源预算。</p><p>条件（2）涉及线程吞吐量，要求<strong>调度策略ψ</strong>使<strong>L</strong>能够尽可能多地学习：</p><ul><li>线程的学习应在截止时间前完成，如条件（2a）所示；</li><li><strong>并且线程的学习性能</strong>应当在如条件（2b）所指示的小误差水平内。学习性能由<img src="https://s2.loli.net/2024/07/01/5uw42qnWrOFLk9V.png" alt="image-20240701142408791.png">来衡量，当算法利用时隙（bk，sk）中接收到的数据并在时间点sk之前完成学习时，<img src="https://s2.loli.net/2024/07/01/MkaOoVHAUTqbND7.png" alt="image-20240701142328147.png">根据预定的<img src="https://s2.loli.net/2024/07/01/lz65UHiZhGVtoy3.png" alt="image-20240701142450627.png">来评估学习性能是否可接受。</li></ul><p>注意，条件（1）与用户效率有关，而条件（2)与硬件效率有关；调度策略应该谨慎地平衡这两个方面。</p><p>CoRE learnability定义使用了一种<img src="https://s2.loli.net/2024/07/01/rs4HoBikXz7JLhI.png" alt="image-20240701143554651.png">类似可能近似正确的PAC学习理论。与PAC不同的是，CoRE learnability考虑了资源调度策略ψ的影响，并且对于具有（η，κ）吞吐量问题的学习算法L，仅要求可接受的<img src="https://s2.loli.net/2024/07/01/rs4HoBikXz7JLhI.png" alt="image-20240701143554651.png">。</p><p><img src="https://s2.loli.net/2024/07/01/2ax13HhNpGJzjYo.png" alt="image-20240701144633004.png"></p><h5 id="算法流程举例说明："><a href="#算法流程举例说明：" class="headerlink" title="算法流程举例说明："></a>算法流程举例说明：</h5><p>图1(c)给出了一个图示，其中任务包由<strong>K&#x3D;5</strong>个线程组成。为简单起见，假设在每个时间单位<img src="https://s2.loli.net/2024/07/01/oSXzG749Wuv2Um6.png" alt="image-20240701144649262.png">个数据单位可以处理。请注意，CoRE学习允许任务线程<img src="https://s2.loli.net/2024/07/01/OSsnXAkj5QzcGm1.png" alt="image-20240701144723031.png">的开始时间sk和截止时间dk,为任何实际值，而在此图中，我们假设它们是四舍五入的，以便更好地说明。对于<strong>给定的算法L</strong>，任务束是**(0.5,0.6,L)-CoRE learnable<strong>的，因为存在一种调度策略ψ，使得在给定</strong>数据吞吐量η&#x3D;50%**的情况下，工能够成功地学习5个线程中的3个。</p><p>如图1c所示：</p><ol><li>ψ将能够处型ηN&#x3D;32个数据单元的资源平等地在time slot处于t0-t1时分配给线程1和线程3，线程1继续接收可以处理16个数据单元的资源，直到在t3完成；剩余可以处理16个数据单元的资源在t1-t3中平均分配给线程2和线程3。</li><li>在t3-t4时，因为线程1不再需要任何资源，线程2和3每个都将分配到可以处理8个以上数据单元的资源。</li><li>线程4在t4到来，ψ对线程2感到悲观，所以把所有资源分配给线程3和线程4。</li><li>线程5在t5到来，由于线程5寿命很短，所以ψ给它分配了尽可能多的资源，直到在t7学习失败。</li><li>在t6，ψ对线程3非常乐观，因此决定暂时牺牲线程4将所有剩余的资源给线程3。</li><li>在t7，只有线程2和线程4还活着。</li><li>线程2和线程5失败的原因：线程2因为学习表现不理想，违反了条件2(b)，而线程5没有在截止时间前完成，违反了条件2(a)。</li></ol><h5 id="关于调度策略ψ："><a href="#关于调度策略ψ：" class="headerlink" title="关于调度策略ψ："></a>关于调度策略ψ：</h5><p>资源调度策略ψ能够根据对学习状态的感知和对线程学习进度的预测，<strong>自适应地分配资源</strong>。</p><p>直观地说，如果L是基于梯度计算的，那么为一个任务分配更多的计算资源意味着可以为该任务执行更多的梯度计算</p><ol><li><p><strong>资源分配的动态性</strong>：在梯度下降算法中，如果一个任务线程（thread）进入了平坦的收敛区域，即错误率在过去几轮梯度计算中没有显著下降，而另一个线程进入了斜率区域，错误率下降更快，资源调度策略ψ会根据这些信息来调整资源分配。例如，在迭代τ1时，如果线程1进入了一个平坦的收敛区域，而线程2进入了斜率区域，ψ就会减少线程1的资源并重新分配给线程2。</p></li><li><p><strong>资源调度的优化</strong>：资源调度策略ψ的目标是提高整体的吞吐量（throughput）。在图1(d)的示例中，假设两个任务线程最初被分配了相同数量的资源。通过动态调整资源分配，线程2可以在最终迭代τ3达到更好的状态b，而不是b’，而线程1则牺牲了达到a’的机会，达到了a。这导致整体吞吐量<strong>从0.0提高到0.5，即线程2根据阈值ϵ0被判定为成功</strong>。</p><p><img src="https://s2.loli.net/2024/07/01/ajmr3NCiogPnFVl.png" alt="image-20240701151825121.png"></p></li><li><p><strong>资源调度的平衡</strong>：资源调度策略需要在探索和利用之间找到平衡。在机器学习过程中，可能需要在继续分配资源给当前表现不佳的任务线程（探索）和将资源重新分配给表现更好的任务线程（利用）之间做出选择。</p></li><li><p><strong>资源调度的复杂性</strong>：机器学习中的资源调度与计算机系统和数据库中的资源调度不同。在计算机系统和数据库中，一旦任务接收到，完成该任务所需的资源量通常是已知的，而在机器学习中，这个信息是未知的，只能通过在线监视学习过程来估计。</p></li><li><p><strong>在线治理和状态估计</strong>：在线治理和状态估计需要通信和计算资源，这增加了资源调度的复杂性。CoRE学习理论自然涉及到资源调度的探索-利用平衡。</p></li><li><p><strong>CoRE学习理论的目标</strong>：CoRE学习理论的一个基本目标是通过引入调度，使机器学习的计算资源能够以时间共享的方式使用，而不是当前的难以捉摸的方式。这有助于减少资源浪费，并提高资源利用效率。</p></li><li><p><strong>CoRE学习算法的证明</strong>：一旦开发出具体的CoRE学习算法，就可以证明其CoRE可学习性。</p></li></ol><h2 id="成果（Results）："><a href="#成果（Results）：" class="headerlink" title="成果（Results）："></a><strong>成果（Results）：</strong></h2><ul><li>论文提出了CoRE学习理论，该理论考虑了计算资源的调度策略，允许机器学习任务像计算机系统和数据库的时间共享技术一样运行。</li><li>通过定义CoRE可学习性，作者提供了一种评估学习算法在有限资源下性能的方法，包括数据吞吐量和线程吞吐量的限制条件。</li></ul><h2 id="结论（Conclusion）："><a href="#结论（Conclusion）：" class="headerlink" title="结论（Conclusion）："></a><strong>结论（Conclusion）：</strong></h2><ul><li>CoRE学习理论强调了在机器学习中考虑时间共享计算资源的重要性，目标是实现计算资源的高效利用，类似于计算机系统的时间共享技术。</li><li>通过引入调度策略，CoRE学习可以更好地平衡用户效率和硬件效率，提高机器学习任务的整体吞吐量。</li><li>论文指出，CoRE学习理论为机器学习中的资源调度提供了新的研究方向，包括如何在线有效地管理和估计机器学习过程的状态和进度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 分时计算 </tag>
            
            <tag> 系统优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.824 Lecture 1-Introduction</title>
      <link href="/2024/07/01/MIT%206.824%20Lecture%201-Introduction/"/>
      <url>/2024/07/01/MIT%206.824%20Lecture%201-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="MIT-6-824-Lecture-1-Introduction"><a href="#MIT-6-824-Lecture-1-Introduction" class="headerlink" title="MIT 6.824: Lecture 1-Introduction"></a>MIT 6.824: Lecture 1-Introduction</h2><h3 id="Lecture-1-Introdunction"><a href="#Lecture-1-Introdunction" class="headerlink" title="Lecture 1-Introdunction"></a>Lecture 1-Introdunction</h3><h4 id="1-1为什么分布式："><a href="#1-1为什么分布式：" class="headerlink" title="1.1为什么分布式："></a>1.1<strong>为什么分布式：</strong></h4><ul><li>连接不同物理实体</li><li>通过隔离实现安全</li><li>通过复制实现容错</li><li>并行的cpu、mem、disk、net实现扩展</li></ul><h4 id="1-2分布式系统："><a href="#1-2分布式系统：" class="headerlink" title="1.2分布式系统："></a>1.2<strong>分布式系统：</strong></h4><p>Hadoop（ hdfs , yarn , <a href="https://so.csdn.net/so/search?q=MapReduce&spm=1001.2101.3001.7020">MapReduce</a> )<br>Spark 批处理<br>Storm ， Flink 流处理<br>Hbase K&#x2F;V分布式数据库<br>Kafka 消息队列</p><h4 id="1-3Lab"><a href="#1-3Lab" class="headerlink" title="1.3Lab:"></a>1.3<strong>Lab:</strong></h4><p>1-MapReduce</p><p>2-Raft:管理复制和剔除</p><p>3-k&#x2F;v server</p><p>4-shard k&#x2F;v service</p><h4 id="1-4-Infrastructure-Abstraction"><a href="#1-4-Infrastructure-Abstraction" class="headerlink" title="1.4 Infrastructure-Abstraction"></a>1.4 <strong>Infrastructure-Abstraction</strong></h4><ol><li>storage :star:</li><li>communications</li><li>computation-MapReduce</li></ol><h4 id="1-5-Implementation"><a href="#1-5-Implementation" class="headerlink" title="1.5 Implementation:"></a>1.5 Implementation:</h4><p>examples: RPC, Threads,Lock</p><h4 id="1-6Performance"><a href="#1-6Performance" class="headerlink" title="1.6Performance:"></a>1.6Performance:</h4><p>scalability-&gt; 2 * computers-&gt; 2 * throughput</p><h4 id="1-7-Fault-Tolerance"><a href="#1-7-Fault-Tolerance" class="headerlink" title="1.7 Fault Tolerance:"></a>1.7 Fault Tolerance:</h4><p><strong>Availability</strong></p><p><strong>Recoverability</strong></p><p>tools:</p><p>NV storage</p><p>Replication</p><p><strong>Consistency</strong></p><p>put(k,v)</p><p>get(k)-&gt;v</p><p>strong?weak?</p><h4 id="1-8MapReduce"><a href="#1-8MapReduce" class="headerlink" title="1.8MapReduce"></a>1.8<strong>MapReduce</strong></h4><p>Map Function &amp; <a href="https://so.csdn.net/so/search?q=Reduce&spm=1001.2101.3001.7020">Reduce</a> Function<br>写好mapreduce程序，无需关心具体分布式实现<br>WordCount例子</p><p>INPUT1-&gt;MAP a,1 b,1</p><p>INPUT2-&gt;MAP   b,1</p><p>INPUT3-&gt;MAP    a,1         c,1</p><p>get intermediate output</p><p>Then Reduces(分治思想)</p><p><strong>Map(k,v):</strong></p><p>split v into words</p><p>for each word </p><p>emit(w,”1)</p><p><strong>Reduce(k,v):</strong></p><p>emit(len(v))</p><p><strong>简述：</strong></p><p>map&#x2F;shuffle&#x2F;reduce</p><p>master给workers分配任务，输入被分成M份（M个map task，M比worker多），每份有3个备份；对每份输入调用Map()，产出(k2,v2)的中间结果，在本地Hash成R份，传递给R个Reduce()，每个Reduce task写一个结果文件</p><p><strong>隐藏的细节：</strong></p><p>跟踪task的完成情况、数据移动、错误恢复</p><p><strong>好的负载均衡：</strong></p><p>tasks比workers多，workers完成task后master继续给它分配</p><p><strong>容错：</strong></p><p>某个服务器在运行MR任务时崩溃，只需重新运行相应的Map和Reduce而不用整个任务重新运行；</p><p>这依赖Map和Reduce是纯函数，即：</p><p>不保存状态、</p><p>不读写额外的文件、</p><p>没有task间隐藏的通信</p><p>崩溃恢复：</p><p>Map worker崩溃：</p><p>重新给包含该输入的副本的worker分配该task（可能一些Reduce worker已经读取了该Map的部分输入，不要紧，Map是纯函数）；</p><p>如果该Map的中间结果都已被读取，则不用重新运行</p><p>Reduce worker崩溃：</p><p>该worker已运行完的task不用重新运行（结果已存到GFS）</p><p>只需重新运行未完成的task</p><p>如果Reduce worker写数据中途崩溃，不要紧，GFS会在写入完成时才重命名文件，所以相当于原子操作，未写入完成可重新运行</p><p>其他问题：</p><p>给两个worker分配了同样的Map task — 只会告诉Reduce worker其中的一个；</p><p>给两个worker分配了同意的Reduce task — GFS的原子写入操作可解决</p><h5 id="详解MapReduce流程"><a href="#详解MapReduce流程" class="headerlink" title="详解MapReduce流程"></a>详解MapReduce流程</h5><p>MapReduce 编程模型开发简单且功能强大，专门为并行处理大规模数据量而设计，接下来，通过一张图来描述 MapReduce 的工作过程，如图所示</p><p><img src="https://s2.loli.net/2024/07/01/WUEdQxVR1YjkirO.png" alt="20210617002320632[1].png"></p><h6 id="整体流程（5步）"><a href="#整体流程（5步）" class="headerlink" title="整体流程（5步）"></a><strong>整体流程</strong>（5步）</h6><p>在上图中， MapReduce 的工作流程大致可以分为5步，具体如下:</p><p><img src="https://s2.loli.net/2024/07/01/tnpNC4mId71EfB9.png" alt="20210617001737183[1].png"></p><h6 id="1-分片、格式化数据源："><a href="#1-分片、格式化数据源：" class="headerlink" title="1.分片、格式化数据源："></a>1.分片、格式化数据源：</h6><p>输入 Map 阶段的数据源，必须经过分片和格式化操作。</p><p>分片操作：指的是将源文件划分为大小相等的小数据块( Hadoop 2.x 中默认 128MB )，也就是分片( split )，<br>Hadoop 会为每一个分片构建一个 Map 任务，并由该任务运行自定义的 map() 函数，从而处理分片里的每一条记录;<br>格式化操作：将划分好的分片( split )格式化为键值对&lt;key,value&gt;形式的数据，其中， key 代表偏移量， value 代表每一行内容。</p><h6 id="2-执行-MapTask"><a href="#2-执行-MapTask" class="headerlink" title="2.执行 MapTask"></a>2.执行 MapTask</h6><p>每个 Map 任务都有一个<strong>内存缓冲区(<strong>缓冲区大小 100MB )，输入的分片( split )数据经过 <strong>Map 任务处理后的中间结果会写入内存缓冲区</strong>中。<br>如果写入的数据达到内存缓冲的阈值( 80MB )，会启动一个线程将内存中的</strong>溢出数据写入磁盘</strong>，同时不影响 Map 中间结果继续写入缓冲区。<br>在溢写过程中， MapReduce 框架会对 key 进行排序，如果中间结果比较大，会形成多个溢写文件，最后的缓冲区数据也会全部溢写入磁盘形成一个溢写文件，如果是多个溢写文件，则最后合并所有的溢写文件为一个文件。</p><p><img src="https://s2.loli.net/2024/07/01/xX9Zz4vyNIRLVUu.png" alt="20210617001954380[1].png"></p><ol><li><strong>Read 阶段</strong>： MapTask 通过用户编写的 RecordReader ，从输入的 InputSplit 中解析出一个个 key &#x2F; value 。</li><li><strong>Map 阶段</strong>：将解析出的 key &#x2F; value 交给用户编写的 Map ()函数处理，并产生一系列新的 key &#x2F; value 。</li><li><strong>Collect 阶段：</strong>在用户编写的 map() 函数中，数据处理完成后，一般会调用 <strong>outputCollector.collect() 输出结果</strong>，在该函数内部，它会将生成的 key &#x2F; value 分片(通过调用 partitioner )，并写入一个环形内存缓冲区中(该缓冲区默认大小是 100MB )。</li><li><strong>Spill 阶段</strong>：即“溢写”，当缓冲区快要溢出时(默认达到缓冲区大小的 80 %)，会在<strong>本地文件系统创建一个溢出文件</strong>，将该缓冲区的数据写入这个文件。</li></ol><ul><li><p>将数据写入本地磁盘前，先要对数据进行一次<strong>本地排序</strong>，并在必要时对数据进行<strong>合并、压缩</strong>等操作。写入磁盘之前，线程会根据 ReduceTask 的数量，将数据分区，一个 Reduce 任务对应一个分区的数据。</p><p>这样做的目的是为了避免有些 Reduce 任务分配到大量数据，而有些 Reduce 任务分到很少的数据，甚至没有分到数据的尴尬局面。</p><p>如果此时设置了 Combiner ，将排序后的结果进行 Combine 操作，这样做的目的是尽可能少地执行数据写入磁盘的操作。</p></li></ul><ol start="5"><li><strong>Combine 阶段</strong>：当所有数据处理完成以后， MapTask 会对所有<strong>临时文件</strong>进行一次合并，以确保最终只会生成一个数据文件</li></ol><ul><li>合并的过程中会不断地进行排序和 Combine 操作，</li><li>其目的有两个：一是尽量减少每次写入磁盘的数据量;二是尽量减少下一复制阶段网络传输的数据量。</li><li>最后合并成了一个已分区且已排序的文件。</li></ul><h6 id="3-执行-Shuffle-过程"><a href="#3-执行-Shuffle-过程" class="headerlink" title="3.执行 Shuffle 过程"></a>3.执行 Shuffle 过程</h6><p>MapReduce 工作过程中， Map 阶段处理的数据如何传递给 Reduce 阶段，这是 MapReduce 框架中关键的一个过程，这个过程叫作 Shuffle 。<br>Shuffle 会将 <strong>MapTask 输出的处理结果数据分发给 ReduceTask ，并在分发的过程中，对数据按 key 进行分区和排序。</strong></p><h6 id="4-执行-ReduceTask"><a href="#4-执行-ReduceTask" class="headerlink" title="4.执行 ReduceTask"></a>4.执行 ReduceTask</h6><p>输入 ReduceTask 的数据流是&lt;key, {value list}&gt;形式，用户可以自定义 reduce()方法进行逻辑处理，最终以&lt;key, value&gt;的形式输出。</p><p><img src="https://s2.loli.net/2024/07/01/NmOz8SnbXaMeAET.png" alt="20210617002008269[1].png"></p><ol><li><p><strong>Copy 阶段：</strong> Reduce 会从各个 MapTask 上远程复制一片数据（每个 MapTask 传来的数据都是有序的），并针对某一片数据，<strong>如果其大小超过一定國值，则写到磁盘上，否则直接放到内存中</strong></p></li><li><p><strong>Merge 阶段</strong>：在远程复制数据的同时， ReduceTask 会启动两个后台线程，分别对内存和磁盘上的文件进行合并，以防止内存使用过多或者磁盘文件过多。</p></li><li><p><strong>Sort 阶段</strong>：用户编写 reduce() 方法输入数据是按 key 进行聚集的一组数据。<br>为了将 key 相同的数据聚在一起， Hadoop 采用了基于排序的策略。<br>由于各个 MapTask 已经实现对自己的处理结果进行了<strong>局部排序</strong>，因此， ReduceTask 只需对所有数据进行一次<strong>归并排序即可</strong>。</p></li><li><p><strong>Reduce 阶段：</strong>对排序后的键值对调用 reduce() 方法，键相等的键值对调用一次 reduce()方法，每次调用会产生零个或者多个键值对，最后把这些输出的键值对写入到 HDFS 中</p></li><li><p><strong>Write 阶段</strong>： reduce() 函数将计算结果写到 HDFS 上。<br>合并的过程中会产生许多的中间文件(写入磁盘了)，但 MapReduce 会让写入磁盘的数据尽可能地少，并且最后一次合并的结果并没有写入磁盘，而是直接输入到 Reduce 函数。</p></li></ol><h6 id="5-写入文件"><a href="#5-写入文件" class="headerlink" title="5.写入文件"></a>5.写入文件</h6><p>MapReduce 框架会自动把 ReduceTask 生成的&lt;key, value&gt;传入 OutputFormat 的 write 方法，实现文件的写入操作。</p><h5 id="MapReduce论文阅读"><a href="#MapReduce论文阅读" class="headerlink" title="MapReduce论文阅读"></a>MapReduce论文阅读</h5><h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>MapReduce，是 Google 早年提出了一种软件架构模型，支持大规模数据集的并行运算。现在这个概念被运用在大量分布式系统中。</p><p>相关的理论由 Google 在 2004 年发表在论文《MapReduce: Simplified Data Processing on Large Clusters》中，可以在这里阅读全文。13 页的小论文，信息密度比某些小论文不知道高到哪里去了。</p><p>由于本文是边阅读论文边记录下来的笔记，所以内容可能比较混乱。</p><h6 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h6><p>MapReduce 是一个很简单的并行处理模型，使用 MapReduce 框架，用户只需要指定两个函数：</p><p>Map 函数，负责将一个键值对处理成一系列中间键值对<br>Reduce 函数，负责将所有具有相同 key 的中间值合并<br>剩下的，就由框架自行处理，包括数据分发、任务分发、错误处理、负载均衡等等细节。用户无需掌握这些细节，更能关注于业务逻辑。</p><p>一个大致的处理流程是这样的：</p><p>Map 接受一个输入键值对，产生一系列中间键值对。MapReduce 框架将所有具有相同的中间 key 的中间值组织到一起，传递给 Reduce 函数。Reduce 函数，接收一个中间 key 和一系列中间值，函数通常将这些值聚合成一个较小的集合，有时每次 Reduce 函数调用只会产生一个结果值，甚至不产生结果。</p><p>以大规模文本单词计数为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">    // key：文章名称</span><br><span class="line">    // value：文章内容</span><br><span class="line">    for 单词 w in value:</span><br><span class="line">        增加中间计数(w, &quot;1&quot;)</span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">    // key：一个单词</span><br><span class="line">    // value：一系列计数</span><br><span class="line">    int result = 0;</span><br><span class="line">    for v in values:</span><br><span class="line">        result += ParseInt(v);</span><br><span class="line">    输出(ToString(result))</span><br></pre></td></tr></table></figure><h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><h6 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h6><p>MapReduce 作为一种编程模型或者说编程思想，实现方式可以有很多。Google 在论文中给出了一种实现方法，用于局域网内互相连接的大量机器。执行流程如下图：</p><p><img src="https://s2.loli.net/2024/07/01/8MI6BTnkWy12GSt.jpg" alt="f292944c2748e9621815ada5cdb50bc7[1].png"></p><p>MapReduce 框架首先将输入文件划分为 M 片，每片通常为 16MB 到 64MB 大小。随后会启动集群中的机器（进程）。<br>集群中的一个进程是一个特殊的 master 进程。剩余的 worker 进程都由 master 分配任务。一共有 M 个 map 任务和 R 个 reduce 任务需要分配。master 会挑选空闲的 worker，一次分配一个 map 任务或者一个 reduce 任务。<br>被分配到 map 任务的 worker 读入对应分片的输入，从输入中解析出键值对，并分别将其传给用户定义的 map 函数。map 函数返回的中间键值对会被暂时缓存在内存里。<br>worker 内存中缓存的键值对，会被分片函数分成 R 个分片，并周期性地写进本地磁盘。这些键值对在磁盘上的位置会被发生给 master，master 负责将位置发送给被分配到 reduce 任务的 worker。<br>当一个 reduce worker 接收到 master 发送的这些位置，它会向保存这些内容的 map worker 发送 RPC 请求来读取这些内容。当一个 reducer worker 读取完所有的中间数据，就会将其根据 key 进行排序，这样所有相同 key 的数据就会聚合在一起。这种排序是必要的，因为通常许多不同的 key 会由同一个 reduce 任务处理。如果数据过大，可能会使用外部排序。<br>reduce worker 遍历有序的中间数据，对遇到的所有 key，都会将 key 和对应的值集合传给用户定义的 reduce 函数。reduce 函数的输出会被追加到一个最终的输出文件（每个 reduce 分片一个）。<br>当所有的 map 任务和 reduce 任务都完成后，MapReduce 的任务也就完成了。<br>运行结束后，MapReduce 的运行结果保存在 R 个输出文件中，通常这些文件会被用作下一个 mapreduce 任务的输入。</p><h6 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h6><p>这里只考虑 worker 挂掉的情况，不考虑 master 挂掉的情况，因为这可能涉及选举共识等复杂情况。</p><p>master 和 worker 会维持一个心跳，如果一段时间没有收到 worker 的回应，就会认为这个 worker 挂掉了。所有由这个 worker 完成的 map 任务都会被重新变成未开始状态，会被重新分配给其他 worker 执行。所有挂掉时正在进行的 map 或者 reduce 任务会被标记为未开始。</p><p>已完成的 map 任务需要重新执行是因为它们的结果存储在已经挂掉机器的本地硬盘上，而已经完成的 reduce 任务无需重新执行，reduce 任务的结果被放在全局的文件系统上。</p><p>如果一个 map 任务最初由 A 执行，后来 A 挂掉了，被重新分配给 B 执行，这个消息会被通知到所有执行 reduce 任务的 worker。所有还没有从 A 中读取数据的 reduce 任务会转而选择从 B 读取数据。</p><p>有时，会出现这种情况：部分机器的性能很低，但是由于网络通畅，不会被判定为挂掉，这种机器就会成为整个系统的短板，整个系统不得不等待慢速机器慢吞吞地执行完他们的任务。对于这种情况，Google 的实现采用的一种机制来提升：在整体 MapReduce 操作快要结束时，master 会将所有仍然在进行的任务分配给其他空闲的 worker 执行。无论是原来的 worker，还是二次分配的 worker 完成了任务，这个任务都算是成功完成。</p><p>性能提升与小优化小扩展略去。</p><h4 id="GFS"><a href="#GFS" class="headerlink" title="GFS"></a>GFS</h4><ul><li><p>GFS（google file system）</p><ul><li><p>大数据存储难点：容错能力（分片副本）、数据一致性、性能（快捷）</p></li><li><p>特点：大文件（分为64Mb的多个chunk块存储）、速度快、通用存储系统、chunk server副本、自动恢复、顺序读取、成本低</p></li><li><p>GFS架构：<br>client结点<br>master结点（保存元数据）：文件名—数据块列表映射、版本、主数据块、作为master的时限、log、checkpoint，磁盘存储来容错<br>块handle（句柄）<br>块server结点：默认副本数为3来容错，顺序存储数据</p><p><img src="https://s2.loli.net/2024/07/01/z8pWkisElhwFQYB.png" alt="20201208211708899[1].png"></p></li><li><p>GFS读：</p><p>1.client将想读的文件名，偏移量发送到master服务器</p><p>2.master发送<strong>块handle</strong>和<strong>块服务器号</strong>等元数据给client</p><p>3.client<strong>缓存</strong>master发回的数据</p><p>4.client将请求根据元数据发送到最近的副本</p><p>5.副本返回数据给client</p></li><li><p>GFS写：（追加写）</p><p>没有主数据块：<br>找到更新到最新的副本们，<br>master选取一个作为<strong>主数据块</strong>，写入磁盘，设置主数据块的<strong>时效</strong><br>增加<strong>版本号</strong>，写入磁盘<br>主数据块写入，再<strong>同步所有副本</strong><br>返回给client 插入成功 or 插入失败</p></li></ul></li></ul><h5 id="GFS详解"><a href="#GFS详解" class="headerlink" title="GFS详解"></a>GFS详解</h5><p><strong>是什么？</strong><br>GFS是一个<strong>可扩展的分布式文件系统</strong>，用于大型的、分布式的、对大量数据进行访问的应用。它运行于廉价的普通硬件上，并提供容错功能。它可以给大量的用户提供总体性能较高的服务。</p><p><strong>为什么要用GFS?</strong><br>大量数据的存储会面临很多的难点：</p><p>大数据下需要良好的表现就需要分片和容错。在具体操作过程中，涉及到容错一般使用副本来解决，然而<strong>副本的使用会面临不一致问题</strong>。如果有一致性的要求，就会导致表现降低。</p><p>所谓的一致性，就是在集群中表现的像与一台机器或一个副本进行交互那样</p><p>因为GFS不但是一个理论成熟的框架结构，更是一种通过长期实际使用证明了其优秀性能的分布式架构。GFS是一种松散一致性模型，这是其具有优越的性能主要原因之一。</p><p>松散一致性模型关键：</p><p>依靠添加而不是重写<br>检查点<br>自我验证（校验和）<br>自我认证记录</p><p><strong>组成？</strong><br>一个GFS集群通常由1个Master，多个ChunkServer组成，并同时接受多个Client的访问。</p><p><strong>交互概要图</strong></p><p><img src="https://s2.loli.net/2024/07/01/z8pWkisElhwFQYB.png" alt="20201208211708899[1].png"></p><p><strong>流程介绍：</strong></p><ol><li><p>client发送请求给Master，寻找存储了对应副本的chunkserver。</p></li><li><p>Master通过遍历本地记录获取chunkserver的信息，包括处理信息和地址信息</p><p>Master不但会在<strong>启动时获取</strong>集群中所有chunkserver的信息，还会在<strong>后续的周期性的获取</strong>chunkserver信息。所有的信息都是存在Master的<strong>RAM里</strong></p></li><li><p>Master将信息返回给client</p></li><li><p>client之后直接通过地址信息与chunkserver交互</p></li></ol><p><strong>GFS交互流程图：</strong></p><p><img src="https://s2.loli.net/2024/07/01/KXZtz9TYPAw58mh.png" alt="a72fcfcd40764bc1adaca3eece85a10e[1].png"></p><p>Secondary Replica:辅助副本</p><p><strong>要点：</strong></p><ol><li><p><strong>Master</strong>通过lease(租约)和Primary Replica(主副本)本来构建交互的流程。</p><p>Master是做出决策、创建新的块和赋值，并协调各种系统范围的活动，以保证块完全复制，平衡所有chunkserver的负载，同时还负责垃圾回收。</p><p>Master的操作通过锁来保证命名空间范围内的序列化</p></li><li><p><strong>主副本</strong>是从众多chunkserver中选出的<strong>唯一特殊副本</strong>，该副本的特殊性在于其维护了一个定时的租约列表。</p></li><li><p><strong>租约</strong>指的是<strong>一组由用户发来的有顺序的指令集合</strong></p></li><li><p>主副本之外的副本都需要通过主副本中的这个列表来执行指令，以保证每个副本执行的最终结果相同。</p></li></ol><p><strong>Master失效怎么办</strong><br>有<strong>副本master</strong>，拥有master状态的完整副本；GFS论文中设计需要人工干预才能切换到其中一种主故障后的副本。</p><p><strong>如何保障副本记录的正确性</strong><br>使用<strong>原子记录</strong>至少追加一次的方法。</p><p><strong>为什么不使用完全追加？</strong></p><p>如果在其中一个写入失败时客户端重新尝试写入，这将导致数据在未失败的副本上多次附加。不同的设计可能会检测到重复的客户端请求，例如，原始故障之间的主要故障请求和客户端的重试。</p><p><strong>应用程序如何知道哪些部分组成填充，哪些是重复记录？</strong><br>为了<strong>检测填充</strong>，应用程序可以放置一个可预测的幻数在有效记录的开头，或包含<strong>一个校验和</strong>，该校验和可能<strong>仅当记录有效时才有效</strong>。该应用程序可以检测通过在记录中包含唯一 ID 来复制。然后，如果它读取与先前记录具有相同 ID 的记录，它知道它们是彼此的重复。GFS 为应用程序提供了一个库处理这些情况。</p><p><strong>什么是校验和？</strong><br>校验和算法将<strong>一个字节块</strong>作为输入<strong>并返回一个单个数字</strong>，它是所有输入字节的函数。例如，一个简单校验和可能是输入中所有字节的总和（mod一些大数字）。GFS 存储每个块的校验和以及块。当一个chunkserver在它的磁盘上写一chunk时，它首先<strong>计算新块的校验和，并将校验和保存在磁盘上以及块</strong>。当一个chunkserver从磁盘读取一个chunk时，它还读取先前<strong>保存的校验和</strong>，从磁盘<strong>读取的块</strong>，并检查两个校验和是否匹配。如果数据已被磁盘损坏，校验和不匹配，并且chunkserver 会知道返回错误。另外，一些 GFS应用程序存储自己的校验和，而不是应用程序定义的记录，在 GFS 文件中，以区分正确的记录和填充。</p><p><strong>GFS 以正确性换取性能在多大程度上可以接受</strong><br>这是分布式系统中反复出现的主题。强一致性通常出现在需要复杂且需要交互的协议机器之间。经过利用特定应用程序类可以容忍的放松方式一致性，可以设计出具有良好性能和足够的一致性。例如，<strong>GFS 针对 MapReduce 进行了优化对大文件需要高读取性能的应用程序可以在文件中有漏洞，记录显示多次，并且不一致的读取</strong>。</p><p><strong>Google 是否仍使用 GFS？</strong><br>有传言说 GFS 已经被一个叫做Colossus，总体目标相同，但在 master 方面有所改进性能和容错性。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 6.824 </tag>
            
            <tag> MapReduce </tag>
            
            <tag> GFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日本数据基础设施-调研</title>
      <link href="/2024/06/28/%E6%97%A5%E6%9C%AC%E6%95%B0%E6%8D%AE-%E8%B0%83%E7%A0%94/"/>
      <url>/2024/06/28/%E6%97%A5%E6%9C%AC%E6%95%B0%E6%8D%AE-%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="日本数据基础设施-调研"><a href="#日本数据基础设施-调研" class="headerlink" title="日本数据基础设施-调研"></a>日本数据基础设施-调研</h1><h3 id="1）法律法规"><a href="#1）法律法规" class="headerlink" title="1）法律法规"></a>1）法律法规</h3><h4 id="促进数据流通与利用基本法"><a href="#促进数据流通与利用基本法" class="headerlink" title="促进数据流通与利用基本法"></a>促进数据流通与利用基本法</h4><p>日本的促进数据流通与利用基本法并不是一个单独的具体法律名称，而是对日本在数据流通与利用方面进行的一系列法律和政策探索的统称。以下是一些关键点，概述了日本在这一领域的实践和政策框架：</p><ol><li><p><strong>多方协作机制</strong> : 日本通过政府、产业界和行业协会的协作，推动数据流通与利用。政府层面成立新机构专项推进，如“数字厅”取代IT综合战略本部，统筹推进全国数字社会建设、数字化转型。</p></li><li><p><strong>《综合数据战略》</strong> : 数字厅作为责任部门推动实施《综合数据战略》，旨在建立一个放心高效的数据使用机制，推动数据在国内以及跨国安全、高效流通。</p></li><li><p><strong>数据基础设施建设</strong> : 产业层面积极建设数据基础设施、研发数据安全技术、建设数据交易市场。例如，NTT集团构建数据协作平台——全球可信数据空间，推动跨企业、跨行业、跨国界的数据利用与协作。</p></li><li><p><strong>数据社会联盟</strong> : 成立数据社会联盟，对产业数据空间等领域的技术标准进行规范，推进数字技术研发和数据流通领域标准及规范的建立。目前正在开发跨学科的数据协作平台DATA-EX。</p></li><li><p><strong>数据流通利用基础</strong> : 日本政府以及各行业组织在数据交易基础制度、数据流通基础设施等方面开展了一系列探索，包括数据权属、定价等相关制度规定。</p></li><li><p><strong>跨境数据流动</strong> : 日本倡导数据自由流动，寻求在跨境数据流动方面发挥领导作用。例如，在G20大阪峰会上提出建立“数据流通圈”概念，推动建立新的国际数据监督体系。</p></li><li><p><strong>数据空间建设</strong> : 推动数据空间建设，如政务数据GBiz平台、农业数据WAGRI平台、防灾信息SIP4D平台等，以实现企业间数据安全、可信、高效流通共享。</p></li><li><p><strong>多层次数据交易市场</strong> : 鼓励多层次数据交易市场发展，推动数据资产化、资本化，例如“个人数据商店”和“数据银行”模式，探索个人数据收益分享制度。</p></li><li><p><strong>《数字社会形成基本法》</strong> : 该法律是<strong>日本数字化转型的核心</strong>，它规定了数字社会形成措施的基本原则和政策，包括设立数字机构和制定优先计划，强调数据的流通和利用是数字社会的重要基石。</p></li><li><p><strong>个人号码制度</strong> : 作为数字化政务的大前提，个人号码制度是日本政府推行的一项个人识别制度，通过个人号码卡实现行政手续的“一站式”服务。</p></li></ol><p>这些措施和政策体现了日本在促进数据流通与利用方面的全面战略和实践，旨在建立一个安全、高效、开放的数据生态系统。</p><h4 id="2003：日本个人信息保护法"><a href="#2003：日本个人信息保护法" class="headerlink" title="2003：日本个人信息保护法"></a>2003：日本个人信息保护法</h4><p>日本的个人信息保护法（Act on the Protection of Personal Information, APPI）在2003年首次制定，是一部旨在保护个人信息的法律，它规定了个人数据的处理方式，以确保个人权利和利益得到尊重，并在随后的几年中经过了多次修订，以应对新的挑战和需求，如技术进步和国际合作的需要。该法律的最近一次重大修订是在2020年，预计将在2022年6月11日前由政令规定的日期起施行。此外，2021年9月，日本个人信息保护委员会更新了关于该法律的指南问答，新增了人脸识别信息使用等具体规定。</p><p>以下是关于该法律的一些关键点：</p><ol><li><strong>立法目的</strong>: 该法律的目的是保护个人信息的合理和有效应用，同时促进新产业的创造和经济社会的活力，提高日本人民的生活质量。</li><li><strong>适用范围</strong>: 它适用于所有处理个人信息的实体，包括公司、政府机构和独立行政法人等。</li><li><strong>定义</strong>: 法律中定义了“个人信息”（personal information）是指可以识别特定个人的信息，以及“匿名处理信息”（anonymously processed information），即通过系统化的方式处理，使其无法识别特定个人的信息。</li><li><strong>基本原则</strong>: 法律提出了适当处理个人信息的总体愿景，并要求政府制定基本政策来促进个人信息保护措施的全面和整体推进。</li><li><strong>数据主体的权利</strong>: 法律赋予数据主体一系列权利，包括访问权、更正权和删除权等，以确保个人信息的准确性和安全。</li><li><strong>数据处理者的义务</strong>: 数据处理者必须采取必要的措施来保护个人信息，防止未经授权的访问、泄露、丢失或破坏，并在处理个人信息时遵守法律规定的原则和标准。</li><li><strong>数据泄露报告</strong>: 如果发生个人信息泄露，数据处理者必须按照规定向个人信息保护委员会（Personal Information Protection Commission, PPC）报告，并在必要时通知受影响的个人。</li><li><strong>跨境数据传输</strong>: 法律对个人信息的跨境传输提出了要求，确保在将个人信息传输到国外时，接收方有足够的保护措施来维护个人信息的安全。</li><li><strong>监管机构</strong>: 日本个人信息保护委员会是负责监督和执行个人信息保护法的独立行政机构。</li><li><strong>违规处罚</strong>: 违反个人信息保护法的行为可能会受到行政处罚，包括责令改正、业务暂停或终止，以及在某些情况下的刑事处罚。</li></ol><h4 id="2021年6月：综合数据战略"><a href="#2021年6月：综合数据战略" class="headerlink" title="2021年6月：综合数据战略"></a>2021年6月：综合数据战略</h4><ul><li><p><strong>法律&#x2F;政策名称</strong>: 综合数据战略</p></li><li><p><strong>概要介绍</strong>:  2021年6月，日本发布“综合数据战略”，旨在“通过确保信赖和公益性，构筑安心且高效地使用数据的结构，<strong>同时，从世界范围内确保对日本数据本身及其生成、流通方式的信赖，在世界范围内放心地利用日本数据，也让世界数据能在日本放心存放的社会”。</strong>日本政府计划使行政机构本身成为全国最大的平台，让公共数据充分流动。其由日本数字政府内阁阁员会议下设置“数据战略特别工作组”具体制定。内阁会议决定将该工作组成果与《面向实现数字社会的重点计划》合并为《综合数据战略》。《综合数据战略》旨在建设日本打造世界顶级数字国家所需的数字基础；明确了数据战略的基本思路，制定了社会愿景以及实现该愿景的基本行动指南。</p><p><strong>2021年9月，日本成立了数字厅以实施该“综合数据战略”。</strong>在“综合数据战略”中，日本设想了一个<strong>“七层两要素”的数据治理架构：</strong></p><p>表1：日本“综合数据战略”提出的数据治理架构</p><table><thead><tr><th>层级</th><th>内容</th><th>要素</th></tr></thead><tbody><tr><td>第七层</td><td>战略、政策</td><td>要素一：社会实施和业务改革</td></tr><tr><td>第六层</td><td>组织：行政及民间业务改革</td><td></td></tr><tr><td>第五层</td><td>规则：除了完善数据标准和质量等数据联合所需的规则外，还完善了用于放心利用数据的信任基础等规则。</td><td>要素二：数据环境建设</td></tr><tr><td>第四层</td><td>利用环境：为各种各样的主体熟练使用个人数据存储、信息银行和数据交易市场等联合的数据提供有利环境。</td><td></td></tr><tr><td>第三层</td><td>合作平台（工具）：为了系统地联合上述数据，配备了目录等数据联合工具。</td><td></td></tr><tr><td>第二层</td><td>数据：从社会活动基础数据着手，从结构上构筑必要的数据。</td><td></td></tr><tr><td>第一层</td><td>基础设施：支撑数字社会的5G、数据中心、计算基础设施等基础设施</td><td></td></tr></tbody></table><p>之所以实施数据全产业链战略，是因为日本意识到其存在数字化设施不健全、缺乏基础数据、官民商数据共享不充分、社会整体的数据素养低、对隐私强烈担忧等问题。如不实施全面的措施，数据共享难以开展。此外，日本政府还计划使作为最大数据持有者的行政机构本身成为全国最大的平台，让公共数据充分流动。</p></li></ul><h4 id="数字改革关联六法"><a href="#数字改革关联六法" class="headerlink" title="数字改革关联六法"></a>数字改革关联六法</h4><p>（相当一部分查不到细则，重点是《数字社会形成基本法》）</p><p>日本国会在2021年5月通过了六部与数字化改革相关的法案，这些法案被统称为“数字改革关联六法”。这些法案的核心目标是推动日本的数字化转型，包括设立数字厅来统筹全国信息系统的管理，确立数字化社会的基本发展理念等。其中，《数字社会形成基本法》是这一系列法案中的重要组成部分，它规定了数字社会形成措施的基本原则和基本政策，以及中央政府、地方政府和企业经营者的责任。日本政府决定于2021年9月1日正式设立数字厅，作为数字化改革的统一领导部门。这些法案的通过被视为日本数字化改革向前迈出的一大步，标志着日本数字化战略重心从“网络建设”转向“数据活用”的新阶段。</p><ol><li><p><strong>《数字社会形成基本法》</strong>:</p><ul><li>该法律是数字改革的核心，规定了数字社会形成措施的基本原则和基本政策，明确了中央政府、地方政府和企业经营者的责任，以及设立数字机构和制定优先计划的要求。</li></ul></li><li><p><strong>《数字厅设置法》</strong>:</p><ul><li>该法律明确了数字厅作为数字化改革的统一领导部门的组织和职责，确立了数字厅在数字化改革中的中心地位。</li></ul></li><li><p><strong>《数字改革关联法》</strong>:</p><ul><li>该法律是日本官方和民间的数字化改革指挥塔，涉及国家信息系统的统筹管理规则。</li></ul></li><li><p><strong>《个人信息保护法》修正案</strong>:</p><ul><li>通过修改，将统一日本各地方自治体、民间机构等各不相同的个人信息保护法则，并导入全国统一的个人信息保护制度，推进日本行政手续线上化改革等数字化改革。</li></ul></li><li><p><strong>《地方公共团体信息系统标准化法》</strong>:</p><ul><li>该法律旨在统一地方政府的信息系统，规定地方政府的信息系统应统一为国家指定的格式，以促进数据互通和标准化。</li></ul></li><li><p><strong>其他相关法律</strong>:</p><ul><li>除了上述法律外，还包括其他与数字化改革相关的法律，如促进数据的开放和利用、加强网络安全等。</li></ul></li></ol><p>这六部法律共同推动了日本数字化改革，旨在解决数字化进程中的各种问题，如行政电子化程度低下、数据孤岛、个人信息保护等，同时促进数据的开放、流通和利用，提高行政效率和透明度，推动经济社会的数字化转型。通过这些法律的实施，日本政府希望建立一个安全、便捷、高效的数字社会。</p><h5 id="2021年5月：数字社会形成基本法（重点）"><a href="#2021年5月：数字社会形成基本法（重点）" class="headerlink" title="2021年5月：数字社会形成基本法（重点）"></a>2021年5月：数字社会形成基本法（重点）</h5><ul><li><strong>法律&#x2F;政策名称</strong>: 数字社会形成基本法</li><li><strong>概要介绍</strong>:  该法规定了数字社会形成措施制定的基本原则和基本政策，中央政府、地方政府和企业经营者的责任，设立数字机构，制定优先计划，标志着日本数字化的战略重心已从“网络建设”转向“数据活用”。</li><li>相关涉及名词：<ol><li><strong>个人数据商店（Personal Data Store，PDS）</strong>:<ul><li><strong>定义</strong>: 个人数据商店代表用户管理其个人数据，并根据用户个人意愿将其提供给第三方。它允许用户控制自己的数据，并在第三方需要时提供数据，从而实现数据的有序流通及价值增值。</li></ul></li><li><strong>数据银行</strong>:<ul><li><strong>定义</strong>: 数据银行模式下，银行根据与用户个人签订的合同管理个人数据，并根据个人的指示或预先指定的条件向第三方提供数据。</li></ul></li><li><strong>Data Plaza</strong>:<ul><li><strong>定义</strong>: 由富士通公司在2013年4月建立，旨在为客户提供一个互通有无、促进合作创新的平台，打破数据孤岛，使不同领域的客户能够安全、高效地共享信息。</li><li><strong>分类</strong>: Data Plaza可以归类为“数据的流通、开发利用”基础设施，因为它不仅促进了数据的流通，还提供了数据增值解决方案。</li></ul></li><li><strong>数据使用权交易市场</strong>:<ul><li><strong>定义</strong>: 这是一个以“数据使用权证书”作为数据交易标的的市场，将合法使用数据的权利证券化。</li></ul></li><li><strong>个人号码制度</strong>:<ul><li><strong>定义</strong>: 每位拥有日本在留卡的居民都将拥有一个12位数字的号码，用于多种行政和服务场合。</li></ul></li><li><strong>数字厅</strong>:<ul><li><strong>定义</strong>: 数字厅是日本政府为了推进数字化改革而设立的统一领导部门。</li></ul></li><li><strong>地方公共团体信息系统标准化法</strong>:<ul><li><strong>定义</strong>: 该法律旨在统一地方政府的信息系统，规定地方政府的信息系统应统一为国家指定的格式。</li></ul></li></ol></li></ul><h5 id="2021年5月：数字厅设置法"><a href="#2021年5月：数字厅设置法" class="headerlink" title="2021年5月：数字厅设置法"></a>2021年5月：数字厅设置法</h5><p>《数字厅设置法》 是日本为了推进行政数字化和改革而制定的一项重要法律。该法律确立了数字厅的组织结构、职责和运作方式。以下是《数字厅设置法》的一些关键点：</p><ol><li><p><strong>成立时间</strong>: 2021年5月，日本国会通过了包括《数字厅设置法》在内的六部“数字改革关联法案”，并于2021年9月1日正式设立数字厅。</p></li><li><p><strong>目的</strong>: 数字厅的成立旨在加速日本的数字化改革，提高行政手续线上操作的便捷性，削减行政运营成本，并解决政府在数字化方面的滞后问题。</p></li><li><p><strong>组织结构</strong>: 数字厅由日本首相担任厅长，下设数字大臣负责具体事务。除数字大臣外，还有副大臣、大臣政务官以及数字总监等职位。</p></li><li><p><strong>人员构成</strong>: 数字厅的人员规模约为600人，其中包括约200名来自私营部门的数字化领域人才，体现了政府对民间专业人才的重视。</p></li><li><p><strong>职责</strong>: 数字厅负责统筹全国信息系统的管理，推进政府内部的数字化改革，实现从“数字化”到“数字治理”的质的提升。此外，数字厅还负责制定数字社会形成的基本政策和优先计划。</p></li><li><p><strong>权限</strong>: 数字厅拥有向其他中央政府部门发出业务修改等建议的权限，以促进不同政府部门间的标准化和互通化。</p></li><li><p><strong>目标</strong>: 数字厅的远期目标是“用智能手机在60秒内完成所有行政程序”，体现了日本政府对于提高行政效率的坚定决心。</p></li><li><p><strong>其他职责</strong>: 数字厅还负责推广“我的号码”系统，为所有居民提供身份证号码，这被视为改善公共数字服务的关键。</p></li></ol><p>《数字厅设置法》的制定和数字厅的成立标志着日本政府在数字化转型方面迈出了重要一步，展现了其推动国家治理现代化和提升公共服务效率的决心。</p><h5 id="2021年9月：数字厅的设立"><a href="#2021年9月：数字厅的设立" class="headerlink" title="2021年9月：数字厅的设立"></a>2021年9月：数字厅的设立</h5><ul><li><strong>法律&#x2F;政策名称</strong>: 数字厅的设立</li><li><strong>概要介绍</strong>:  数字厅的成立旨在迅速且重点推进数字社会进程，统筹推进全国数字社会建设、数字化转型。</li><li>IT方面技术战略的政府组织体制包括：<ul><li>由内阁的综合创新战略推进会议，负责政府内部调整及推进《综合创新战略》；</li><li>内阁府的综合科学技术创新会议，汇总各部门的科学技术创新方面相关政策，实施综合调整；</li><li>各省厅机构在各自管辖的产业和领域中，负责具体措施的制定和执行。</li></ul></li></ul><h5 id="2021年5月：地方公共团体信息系统标准法"><a href="#2021年5月：地方公共团体信息系统标准法" class="headerlink" title="2021年5月：地方公共团体信息系统标准法"></a>2021年5月：地方公共团体信息系统标准法</h5><p>地方公共团体信息系统标准化法是日本为推进地方行政数字化和信息系统标准化而制定的法律。这项法律的目的是统一地方政府的信息系统，以促进数据互通和标准化。以下是关于该法律的一些关键点：</p><ol><li><p><strong>统一信息系统</strong>: 该法律要求地方政府的信息系统应统一为国家指定的格式，以实现不同地方政府间的信息共享和系统互通。</p></li><li><p><strong>标准化对象</strong>: 标准化的对象包括儿童津贴、居民基本台帐、选举人名簿管理、固定资产税、个人居民税、法人居民税、轻型汽车税、就学、国民健康保险、国民年金、残疾人福利、后期高龄者医疗护理保险等。</p></li><li><p><strong>制定主体</strong>: 由中央政府负责制定地方公共团体信息系统标准化的基本方针；具体主管上述领域的负责人负责制定信息系统标准；首相和总务大臣负责制定数据协作、网络安全、云利用等各信息系统共通事项的标准。</p></li><li><p><strong>地方政府的义务</strong>: 地方政府必须在省厅规定的期限内使其信息系统达标，并努力在国家准备的“云活用”环境中活用信息系统。</p></li><li><p><strong>提高行政效率</strong>: 通过标准化，旨在提高行政手续线上操作的便捷性，削减行政运营成本，实现更高效的政府服务。</p></li><li><p><strong>促进数据共享</strong>: 该法律有助于打破数据孤岛，促进不同地方政府和中央政府之间数据的共享和利用。</p></li><li><p><strong>支持数字化改革</strong>: 作为数字改革关联六法的一部分，该法律支持日本政府推动的全面数字化改革，包括数字厅的设立和运作。</p></li></ol><p>地方公共团体信息系统标准化法是日本数字化转型战略的关键组成部分，它通过标准化措施，加强了地方政府信息系统的整合和互操作性，为建立一个更加高效和透明的行政体系奠定了基础。</p><h3 id="2）相关名词概念"><a href="#2）相关名词概念" class="headerlink" title="2）相关名词概念"></a>2）相关名词概念</h3><table><thead><tr><th>年份</th><th>法规&#x2F;法律&#x2F;政策&#x2F;定义</th><th>名词</th><th>解释</th><th>属于哪类的范围</th></tr></thead><tbody><tr><td>2021年</td><td>数字社会形成基本法</td><td>个人数据商店（Personal Data Store，PDS）</td><td>个人数据商店代表<strong>用户管理其个人数据</strong>，<strong>并根据用户个人意愿将其提供给第三方。它允许用户控制自己的数据，并在第三方需要时提供数据，从而实现数据的有序流通及价值增值。</strong></td><td>个人</td></tr><tr><td>2021年</td><td>数字社会形成基本法</td><td>数据银行</td><td>数据银行模式下，银行根据与用户个人签订的合同管理个人数据，并根据个人的指示或预先指定的条件向第三方提供数据。</td><td>政府</td></tr><tr><td>2021年</td><td>数字社会形成基本法</td><td>政务数据GBiz平台、农业数据WAGRI平台、防灾信息SIP4D平台</td><td>这些平台作为<strong>数据空间</strong>，促进不同领域数据的安全、可信、高效流通共享，属于数据流通的基础设施。</td><td>政府</td></tr><tr><td>2021年</td><td>数字社会形成基本法</td><td>Data Plaza</td><td>富士通公司2013年4月建立的数据交易机构，为客户提供互通有无、促进合作创新的平台，打破数据孤岛。</td><td>企业</td></tr><tr><td>2021年</td><td>数字社会形成基本法</td><td>数据使用权交易市场</td><td>这个市场属于“数据的流通、开发利用”类别，因为它提供了一个平台，使得数据使用权可以像证券一样被交易和流通，从而促进了数据的开发利用。</td><td>企业&#x2F;政府</td></tr><tr><td>2021年</td><td>数字社会形成基本法</td><td>个人号码制度</td><td>每位拥有日本在留卡的居民都将拥有一个12位数字的号码，用于多种行政和服务场合的制度。</td><td>政府</td></tr><tr><td>2021年</td><td>数字厅设置法</td><td>数字厅</td><td>日本政府设立的统一领导部门，推进数字化改革，负责制定和推进相关政策。</td><td>政府</td></tr><tr><td>-</td><td>《综合数据战略》的背景下</td><td>DATA-EX</td><td>建立一个数据协作平台，促进不同领域和不同行业的数据交换与利用，目标是连接各行业的特定数据平台，通过提供一个统一的数据交换环境，促进不同领域的数据交换和协作。</td><td>日本数据社会联盟</td></tr></tbody></table><h3 id="3）数据基础设施相关概念介绍"><a href="#3）数据基础设施相关概念介绍" class="headerlink" title="3）数据基础设施相关概念介绍"></a>3）数据基础设施相关概念介绍</h3><table><thead><tr><th>年份</th><th>法规&#x2F;法律&#x2F;政策&#x2F;定义</th><th>名词</th><th>解释</th><th>属于哪类的范围</th><th>属于哪种基础设施</th></tr></thead><tbody><tr><td>2021年</td><td>数字社会形成基本法</td><td>个人数据商店（Personal Data Store，PDS）</td><td>个人数据商店代表<strong>用户管理其个人数据</strong>，<strong>并根据用户个人意愿将其提供给第三方。它允许用户控制自己的数据，并在第三方需要时提供数据，从而实现数据的有序流通及价值增值。</strong></td><td>个人</td><td>数据的流通</td></tr><tr><td>2021年</td><td>数字社会形成基本法</td><td>数据银行</td><td>数据银行模式下，银行根据与用户个人签订的合同管理个人数据，并根据个人的指示或预先指定的条件向第三方提供数据。</td><td>个人</td><td>数据的供给</td></tr><tr><td>2021年</td><td>数字社会形成基本法</td><td>政务数据GBiz平台、农业数据WAGRI平台、防灾信息SIP4D平台</td><td>这些平台作为<strong>数据空间</strong>，促进不同领域数据的安全、可信、高效流通共享，属于数据流通的基础设施。</td><td>政府</td><td>数据的流通、供给</td></tr><tr><td>2021年</td><td>数字社会形成基本法</td><td>Data Plaza</td><td>富士通公司2013年4月建立的数据交易机构，为客户提供互通有无、促进合作创新的平台，打破数据孤岛。</td><td>企业</td><td>数据的供给、流通</td></tr><tr><td>2021年</td><td>数字社会形成基本法</td><td>数据使用权交易市场</td><td>以“数据使用权证书”作为交易标的，将合法使用数据的权利证券化，激活数据交易流通的市场。</td><td>企业&#x2F;政府</td><td>数据的流通</td></tr><tr><td>-</td><td>《综合数据战略》的背景下</td><td>DATA-EX</td><td>建立一个数据协作平台，促进不同领域和不同行业的数据交换与利用，目标是连接各行业的特定数据平台，通过提供一个统一的数据交换环境，促进不同领域的数据交换和协作。</td><td>日本数据社会联盟（政府）</td><td>数据的流通</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 调研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础设施 </tag>
            
            <tag> 数据空间 </tag>
            
            <tag> 数字化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分布式系统（七）案例研究</title>
      <link href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/"/>
      <url>/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="案例研究"><a href="#案例研究" class="headerlink" title="案例研究"></a>案例研究</h1><h4 id="7-1-分布式文件系统"><a href="#7-1-分布式文件系统" class="headerlink" title="7.1 分布式文件系统"></a>7.1 分布式文件系统</h4><p>GFS</p><p><a href="https://blog.csdn.net/tianwailaibin/article/details/6722956/?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8D%B7%E6%98%AF%E4%BB%80%E4%B9%88&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-6722956.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(459条消息) 什么是簇：什么是卷_tianwailaibin的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/354450124">【MIT 6.824】学习笔记 3: GFS - 知乎 (zhihu.com)</a></p><p><img src="https://s2.loli.net/2024/06/26/zCHi1YPJGlQMZUo.webp" alt="v2-75851b9c18c4b4b4b84507a9122129fa_1440w[1].webp"></p><h4 id="7-2-分布式协调服务"><a href="#7-2-分布式协调服务" class="headerlink" title="7.2 分布式协调服务"></a>7.2 分布式协调服务</h4><p>Zookeeper</p><p><a href="https://zhuanlan.zhihu.com/p/62526102">什么是ZooKeeper？ - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/64702090">zookeeper原理详解 - 知乎 (zhihu.com)</a></p><p>[Zookeeper纸上谈兵——Zookeeper与CAP原则-CSDN博客](<a href="https://blog.csdn.net/qq_38194699/article/details/109016025?ops_request_misc=%7B%22request_id%22:%22171939403416800178545807%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=171939403416800178545807&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-109016025-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=Zookeeper%E7%BA%B8%E4%B8%8A%E8%B0%88%E5%85%B5%E2%80%94%E2%80%94Zookeeper%E4%B8%8ECAP%E5%8E%9F%E5%88%99_cap">https://blog.csdn.net/qq_38194699/article/details/109016025?ops_request_misc=%7B%22request%5Fid%22%3A%22171939403416800178545807%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=171939403416800178545807&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-109016025-null-null.142^v100^pc_search_result_base8&amp;utm_term=Zookeeper纸上谈兵——Zookeeper与CAP原则_cap</a> zookeeper_Amazing Coder的博客-CSDN博客]&amp;spm&#x3D;1018.2226.3001.4187)</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 深入理解分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分布式系统（五）分布式事务</title>
      <link href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="5-1-什么是分布式事务"><a href="#5-1-什么是分布式事务" class="headerlink" title="5.1 什么是分布式事务"></a>5.1 什么是分布式事务</h2><p><strong>ACID:</strong></p><ul><li>原子性（Atomicity）：一个事务被视为一个不可分割的最小工作单位，事务中的所有操作要么全部完成，要么全部撤销回滚，不允许出现部分完成的情况。</li><li>一致性（Consistency）：事务开始前和结束后，数据库必须处于一致的状态，即事务执行后所得的结果必须符合预期的规定的结构和约束条件。</li><li>隔离性（Isolation）：多个事务相互隔离不受干扰，每个事务只能“看到”其所执行的数据和其他事务已提交的数据，而看不到其他事务未提交的数据。</li><li>持久性（Durability）：一个事务提交后，它对数据库的改变必须被永久保存到数据库中，即使出现断电等故障，其对数据库的改变也不能丢失。</li></ul><p>分布式事务两种变体：</p><ul><li>同一份数据需要在多个副本上更新，一个分布式事务需要更新所有的副本，如果有的节点提交了事务，有的节点回滚了事务，那么这样的结果对于用户来说是无法接受的。（可利用单主复制解决）</li><li>数据进行了分区，事务跨越多个节点，还要同时保证整体数据一致和事务的ACID属性。（常见且重点）</li></ul><p>分布式事务通常不讨论ACID中的一致性。</p><p>想要实现持久性，只需在向客户端返回响应之前，确保将数据存储再非易失性存储设备即可，通常还会包括一些WAL或其他日志文件，虽然非易失性存储设备可能会损坏，但不考虑极端的情况，通过备份就可以解决该问题。、</p><p>原子性：原子提交（Atomic Commit）</p><p>隔离性：并发控制（Concurrency Control）(锁和MVCC)</p><h2 id="5-2-原子提交"><a href="#5-2-原子提交" class="headerlink" title="5.2 原子提交"></a>5.2 原子提交</h2><p>原子性的保证在分布式和单机系统中都很难。</p><p>方法：日志&#x2F;WAL，可以回滚，撤销</p><p>分布式的原子性的实现：</p><ul><li>原子提交协议（Atomic Commit Protocol）<ul><li>协定性：所有的都同意一个值，那么所有进程要么一起提交事务，要么一起终止事务</li><li>有效性：如果所有进程都没问题，就提交，但凡有一个有问题，就终止</li><li>终止性：<ul><li>弱终止条件：如果没有任何故障发生，那么<strong>所有进程</strong>最终都会作出决议</li><li>强终止条件：<strong>没有发生故障的进程</strong>最终会做出决议</li></ul></li></ul></li></ul><h3 id="5-2-1-两阶段提交协议"><a href="#5-2-1-两阶段提交协议" class="headerlink" title="5.2.1 两阶段提交协议"></a>5.2.1 两阶段提交协议</h3><p><img src="https://s2.loli.net/2024/06/26/ngkdOJCI5bAxcLz.png" alt="两阶段提交.png"></p><p><a href="https://blog.csdn.net/a1102325298/article/details/96481642">(443条消息) 两阶段提交协议（two phase commit protocol，2PC）详解_两阶段协议_延迟满足的博客-CSDN博客</a></p><p>两阶段协议存在的问题：</p><ul><li>同步阻塞问题</li><li>单点故障问题</li><li>数据不一致问题</li><li>提交阶段不确定问题</li></ul><p>基于 2PC 存在的问题，后来有人提出了三阶段提交协议，在其中引入超时的机制，将阶段 1 分解为两个阶段：在超时发生以前，系统处于不确定阶段；在超时发生以后，系统则转入确定阶段。</p><p>还有解决方法：Parallel Commits，第一阶段的结果已知（写入全局日志中），返回给客户端，异步执行第二阶段，该方法要跟共识算法一起工作。</p><h3 id="5-2-2-三阶段提交"><a href="#5-2-2-三阶段提交" class="headerlink" title="5.2.2 三阶段提交"></a>5.2.2 三阶段提交</h3><p>非阻塞协议，可以在协调者寄了的时候选出新的协调者推进事务执行</p><p><a href="https://blog.csdn.net/m0_37840000/article/details/119743288?ops_request_misc=%7B%22request_id%22:%22168174759216800225586584%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168174759216800225586584&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-119743288-null-null.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&utm_term=%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE&spm=1018.2226.3001.4187">(443条消息) 三阶段提交协议(3PC)_愿好的博客-CSDN博客</a></p><p>缺点：并没有解决所有的问题。</p><ul><li>可用性以正确性为代价，同时很容易收到网络分区的影响（导致脑裂选出多个协调者）</li><li>至少三轮往返消息，增加了事务的完成时间</li></ul><p>满足强终止性</p><p>二阶段提交依然是</p><h3 id="5-2-3-Paxos提交算法"><a href="#5-2-3-Paxos提交算法" class="headerlink" title="5.2.3 Paxos提交算法"></a>5.2.3 Paxos提交算法</h3><p><img src="https://s2.loli.net/2024/06/26/zKvrtxhjepDL52d.jpg" alt="B8468E68C68D719758DFA7091B1C834D.jpg"></p><h3 id="5-2-4-基于Quorum的提交协议"><a href="#5-2-4-基于Quorum的提交协议" class="headerlink" title="5.2.4 基于Quorum的提交协议"></a>5.2.4 基于Quorum的提交协议</h3><p>每个节点有一票，总共V票：</p><ul><li>Vc：最小提交票数，要提交必须达到这个票数，0&lt;Vc&lt;&#x3D;V</li><li>Va：最小中止票数，要中止必须达到这个票数，0&lt;Va&lt;&#x3D;V</li></ul><p>Vc+Va&gt;V</p><p>三个子协议：</p><ul><li>提交协议：事务开始时使用（类似三阶段中的pre commit，但是需要等待Vc票数）</li><li>中止协议：网络分区时开始使用（出现网络分区，会在与协调者失联的分区中选出代理协调者，如果在失联分区中有在提交&#x2F;中止状态（哪怕一个），都推进所有参与者到该状态；如果至少有一个参与者处于预提交状态，并且至少Vc个参与者在等待提交投票的结果，则代理协调者向所有参与者发送预提交消息，如果有超过Vc个参与者恢复响应，那么代理协调者就会发送真正的提交消息;如果没有处于准备提交状态的参与者，并且至少Va个参与者在等待中止事务的投票结果，那么代理协调者就会发送真正的中止消息）</li><li>合并协议：当系统从网络分区中恢复过来的时候使用</li></ul><h3 id="5-2-5-Saga事务"><a href="#5-2-5-Saga事务" class="headerlink" title="5.2.5 Saga事务"></a>5.2.5 Saga事务</h3><p>用来处理长活事务（Long-Lived Transaction，LLT）</p><p><a href="https://blog.csdn.net/flynetcn/article/details/124592621?ops_request_misc=%7B%22request_id%22:%22168183647416800211561980%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168183647416800211561980&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-124592621-null-null.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&utm_term=saga%E4%BA%8B%E5%8A%A1&spm=1018.2226.3001.4187">(443条消息) 分布式事务系列：Saga_saga事务_码出钞能力的博客-CSDN博客</a></p><h2 id="5-3-并发控制"><a href="#5-3-并发控制" class="headerlink" title="5.3 并发控制"></a>5.3 并发控制</h2><p>悲观并发控制（Pessimistic Concurrency Control）：假设多个事务之间会相互干扰，因此在任何时候都将资源加锁，避免其他事务修改该资源。悲观并发控制的主要优点是简单易懂，但由于频繁加锁导致效率低下，不适合高并发场景。</p><p>乐观并发控制（Optimistic Concurrency Control）：假设多个事务之间不会相互干扰，并行访问数据，而在提交时进行冲突检测。如果两个事务的修改发生冲突，则其中一个事务必须回滚并重试。乐观并发控制可以最大程度地提高并发性，但需要开发人员自己实现数据版本控制，相对较为复杂。</p><p>多版本并发控制（Multi-Version Concurrency Control）：每当一个事务对数据库进行更新操作时，会将当前数据的快照存储为新的版本，并使用版本号进行标识。在读取数据时，事务不会阻塞其他事务的读写操作，同时也不会锁定当前版本的数据。如果发现其他事务已经更新了数据，则会从前一个版本中获取数据。多版本并发控制的主要优点是高效、可扩展性好，但需要占用更多的磁盘空间。</p><h3 id="5-3-1-两阶段锁"><a href="#5-3-1-两阶段锁" class="headerlink" title="5.3.1 两阶段锁"></a>5.3.1 两阶段锁</h3><p>两阶段锁（Two-Phase Locking）是一种常用于并发控制的技术，旨在解决并发操作下出现的数据一致性问题。</p><p>在两阶段锁策略中，事务必须分为两个阶段：增长阶段和收缩阶段。</p><ol><li><p>增长阶段：当事务请求资源时，该事务会先申请锁定所需资源。在此阶段中，锁可以被占用但不能被释放，每个事务只能逐渐获得锁，不能释放锁。</p></li><li><p>收缩阶段：当事务完成所需工作时，它将释放所有已经锁定的资源，并且这些锁不再被使用。在此阶段中，锁可以被释放但不能被继续占用，每个事务只能逐渐释放锁。</p></li></ol><p>在这个过程中，锁的状态保持不变。所有的事务都必须遵循这些规则，以确保并发操作的正确性和一致性。</p><p>两阶段锁的优点是可以避免死锁的发生，但是也有一些缺点，例如可能会导致事务等待时间较长，从而影响系统的响应速度。此外，还有许多其他的并发控制技术，如乐观并发控制、基于时间戳的并发控制等，可以用于替代或补充两阶段锁。</p><p><strong>三种方法避免死锁：</strong></p><p>死锁是一种并发控制问题，指两个或多个事务或进程相互等待释放已经占用的资源，导致所有事务或进程都无法继续执行。为了避免死锁，可以采取以下几种方法：</p><ol><li>死锁预防（破坏死锁条件）：通过约定加锁顺序、引入超时机制、限制某些进程对资源的访问等方式，在程序设计时直接避免死锁发生。</li><li>死锁避免（银行家算法）：通过安全序列算法对每个事务或进程的资源请求进行安全性检查，只有当该事务或进程的资源请求不会导致死锁时才会被允许。<ul><li>等待-死亡：该方案是基于非剥夺方法。当进程Pi请求的资源正被进程Pj占有时，只有当Pi的时间戳比进程Pj的时间戳小时，Pi才能等待。否则Pi被卷回（roll-back），即死亡。</li><li>伤害-等待：它是一种基于剥夺的方法。当进程Pi请求的资源正被进程Pj占有时，只有当进程Pi的时间戳比进程Pj的时间戳大时，Pi才能等待。否则Pj被卷回（roll-back），即死亡。</li></ul></li><li>死锁检测与恢复：在程序运行过程中，周期性地监测系统中是否发生了死锁，一旦检测到死锁，就采取资源抢夺或事务回滚等方式，进行死锁恢复。</li></ol><p>以上三种方法可以单独或组合使用，以达到更好的死锁预防效果。同时，在程序设计时，应注意不要通过不合理的代码逻辑、数据库设计等导致死锁现象的出现。</p><h3 id="5-3-2-乐观并发控制（不要锁）"><a href="#5-3-2-乐观并发控制（不要锁）" class="headerlink" title="5.3.2 乐观并发控制（不要锁）"></a>5.3.2 乐观并发控制（不要锁）</h3><p>两类，基于检查的并发控制和基于时间戳的并发控制。</p><ol><li><p>基于检查的并发控制</p><ul><li>读取：创建副本，放到私有空间，读是读的副本，写操作被记录到私有空间的临时文件中。</li><li>校验：没有冲突就提交，有冲突就中止。</li><li>写入：校验没问题，就把私有空间的数据持久化存储。</li></ul></li><li><p>基于时间戳的并发控制</p><p>每个数据项有两个时间戳</p><ul><li><p>写时间戳： W-TS(X)</p></li><li><p>读时间戳：R-TS(X)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#1.读操作</span><br><span class="line">if TS(T_i) &lt; W-TS(X)&#123;</span><br><span class="line">abort(R_i(X))</span><br><span class="line">&#125;else&#123;</span><br><span class="line">accept(R_i(X))</span><br><span class="line">R-TS(X)=TS(T_i)</span><br><span class="line">&#125;</span><br><span class="line">#2.写操作</span><br><span class="line">TS(T_i)必须大于R-TS(X)和W-TS(X)，否则丢弃</span><br><span class="line">if TS(T_i)&lt;R-TS(X)||TS(T_i)&lt;W-TS(X)&#123;</span><br><span class="line">abort(W_i(X))</span><br><span class="line">&#125;else &#123;</span><br><span class="line">accept(W_i(X))</span><br><span class="line">W-TS(X)=TS(T_i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难点：</p><ol><li>时间戳的精确性</li><li>可能产生不可恢复的操作（后面的读事务基于前面的写事务，但前面的写事务回滚）</li></ol><p>看起来没有锁，但是实际上在修改时间戳的时候，仍可能要获取锁</p></li></ul></li></ol><h3 id="5-3-3-多版本并发控制（很像celldb啊）"><a href="#5-3-3-多版本并发控制（很像celldb啊）" class="headerlink" title="5.3.3 多版本并发控制（很像celldb啊）"></a>5.3.3 多版本并发控制（很像celldb啊）</h3><p>可以看作在乐观并发控制的基础上增加了多个版本，为每个数据项存储多个版本</p><p>读到的是某个版本的数据，写是增加版本而并非覆盖</p><p>衍生出三种主流多版本并发控制：</p><ul><li>多版本两阶段锁</li><li>多版本乐观并发控制</li><li>多版本时间戳排序</li></ul><p>元数据（Tuple存储到数据项头部）：</p><ul><li><p>Tid：唯一单调递增的时间戳（事务开始的时间戳）</p></li><li><p>txn-id：获得当前写锁的事务的Tid，如果没有事务持有该数据的写锁，则为0，可通过<strong>CAS</strong>来修改此字段，避免使用锁</p><ul><li><p>CAS，即 Compare-And-Swap，是一种原子操作，用于实现并发控制。在多线程编程中，CAS可以保证对共享变量的操作在多线程情况下能够正确地执行。</p><p>CAS操作需要三个参数：内存地址 V、旧的预期值 A 和新值 B。当且仅当当前内存地址的值等于旧的预期值 A 时，才会将该内存地址的值更新为新值 B。否则，不做任何操作。</p><p>CAS操作的基本流程如下：</p><ol><li>线程读取内存地址 V 的当前值；</li><li>线程比较内存地址 V 的当前值与旧的预期值 A 是否相等；</li><li>如果相等，线程将新值 B 写入内存地址 V，并返回操作成功；</li><li>如果不相等，线程不做任何操作，并返回操作失败。</li></ol><p>通过CAS操作，可以避免传统并发控制方法（如锁定）的一些问题，例如死锁和竞争条件。但同时，也存在一些限制。例如，CAS只能应用于单个变量的操作；如果需要对多个变量进行联合操作，则需要使用其他并发控制方式。</p></li></ul></li><li><p>begin-ts: 创建该版本的数据项的事务提交的时间戳（开始肯定是提交了才有嘛）,Tcommit</p></li><li><p>end-ts：最新版本的话，则为无限大，否则该数据项等于上一个或下一个版本数据项的begin-ts</p></li></ul><ol><li><p>多版本两阶段锁(这里的锁，是根据对于数据的元数据的版本来进行判断来实现的)：</p><p>代表MySQL,Oracle,Postgres</p><ul><li><p>txn-id</p></li><li><p>read-cnt：当前数据的读锁的数量。可以将read-cnt和txn-id组合成一个64位整型值，用CAS来更新两个</p></li><li><p>begin-ts</p></li><li><p>end-ts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#对于读操作Ti Xv为版本</span><br><span class="line">find Xv where begin-ts(Xv) &lt;= Ti &lt;end-ts(Xv)</span><br><span class="line">if txn-id(Xv)==0 || txn-id(Xv)==Ti&#123;</span><br><span class="line">read-cnt(Xv)+=1</span><br><span class="line">accept(Read(Xv))</span><br><span class="line">&#125;else&#123;</span><br><span class="line">abort()and rollback(T)</span><br><span class="line">&#125;</span><br><span class="line">#对于写操作 找到最新版本Xv</span><br><span class="line">finx Xv where end-ts(Xv) ==INF</span><br><span class="line">if txn-id(Xv)==0||txn-id(Xv)==Ti&#123;</span><br><span class="line">txn-id(Xv)=Ti</span><br><span class="line">new(Xv+1)</span><br><span class="line">txn-id(Xv+1)=Ti</span><br><span class="line">accept(Write(Xv+1))</span><br><span class="line">&#125;else&#123;</span><br><span class="line">abort() and rollback(T)</span><br><span class="line">&#125;</span><br><span class="line">#善后</span><br><span class="line">#for write</span><br><span class="line">for all write data item&#123;</span><br><span class="line">txn-id(Xv+1)=0</span><br><span class="line">begin-ts(Xv+1)=Tcommit</span><br><span class="line">end-ts(Xv+1)=INF</span><br><span class="line">txn-id(Xv)=0</span><br><span class="line">end-ts(Xv)=Tcommit</span><br><span class="line">&#125;</span><br><span class="line">#for read</span><br><span class="line">for all read data item&#123;</span><br><span class="line">read-cnt(Xv) -=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>多版本乐观并发控制</p><p>MemSQL用这个</p><p>Metadata:</p><ul><li>txn-id</li><li>begin-ts</li><li>end-ts</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#读</span><br><span class="line">find Xv where begin-ts(Xv)&lt;= Ti &lt; end-ts(Xv)</span><br><span class="line">if txn-id(Xv)==0 || txn-id(Xv)==Ti&#123;</span><br><span class="line">accept(Read(Xv))</span><br><span class="line">&#125;else&#123;</span><br><span class="line">abort()and rollback(T)</span><br><span class="line">&#125;</span><br><span class="line">#写</span><br><span class="line">find Xv where end-ts(Xv) == INF //确保最新</span><br><span class="line">if txn-id(Xv) == 0 ||txn-id(Xv)==Ti&#123;</span><br><span class="line">txn-id(Xv) = Ti</span><br><span class="line">new(Xv+1)</span><br><span class="line">txn-id(Xv+1) = Ti</span><br><span class="line">begin-ts(Xv+1) = INF</span><br><span class="line">accept(Write(Xv+1))</span><br><span class="line">&#125;else&#123;</span><br><span class="line">abort() and rollback(T)</span><br><span class="line">&#125;</span><br><span class="line">#提交事务</span><br><span class="line">for all read data item&#123;</span><br><span class="line">if begin-ts(Xv) &gt;Ti&#123;</span><br><span class="line"> //数据项被其他事务修改过，读到了过期的数据</span><br><span class="line"> abort() and rollback(T)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for all write data item&#123;</span><br><span class="line">txn-id(Xv+1) = 0</span><br><span class="line">begin-ts(Xv+1) = Tcommit</span><br><span class="line">end-ts(Xv+1) = INF</span><br><span class="line">txn-id(Xv) = 0</span><br><span class="line">end-ts(Xv) = Tcommit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多版本时间戳排序</p><ul><li><p>txn-id</p></li><li><p>read-ts(最大的读过的事务的Tid)</p></li><li><p>begin-ts</p></li><li><p>end-ts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#读</span><br><span class="line">find Xv where begin-ts(Xv)&lt;=Ti&lt;end-ts(Xv)</span><br><span class="line">if txn-id(Xv) == 0 || txn-id(Xv) == Ti&#123;</span><br><span class="line">accept(read(Xv))</span><br><span class="line">read-ts(Xv)=max(Ti,read-ts(xV))</span><br><span class="line">&#125;else&#123;</span><br><span class="line"> abort() rollback(T)</span><br><span class="line">&#125;</span><br><span class="line">#写</span><br><span class="line">find Xv where end-ts(Xv) ==INF</span><br><span class="line">if txn-id(Xv)=0&amp;&amp;Ti &gt; read-ts(Xv)&#123;</span><br><span class="line">txn-id(Xv) = Ti</span><br><span class="line">new(Xv+1)</span><br><span class="line">txn-id(Xv+1) =Ti</span><br><span class="line">read-ts(Xv+1) = 0</span><br><span class="line">accept(Write(Xv+1))</span><br><span class="line">&#125;else &#123;</span><br><span class="line">abort() and rollback(T)</span><br><span class="line">&#125;</span><br><span class="line">#善后</span><br><span class="line">for all write data item&#123;</span><br><span class="line">txn-id(Xv+1) = 0</span><br><span class="line">begin-ts(Xv+1) = Ti</span><br><span class="line">end-ts(Xv+1) = INF</span><br><span class="line">txn-id(Xv) = 0</span><br><span class="line">end-ts(Xv) = Ti</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>版本存储和垃圾回收</p><p>版本存储：</p><ol><li>仅追加存储（Append-Only Storage）<ul><li>有指针</li><li>如果说恰好有很大数据的一个属性，在新版本中又不发生改变，则很占空间（所以要复用）</li><li>MemSQL、PG</li></ul></li><li>时间旅行存储（Time-Travel Storage）<ul><li>单独用一个时间旅行表来存储历史版本</li><li>最新版本的数据存储到主表</li></ul></li><li>增量存储（Delta Storage）<ul><li>只将发生变化的字段信息存储到增量存储中</li><li>增量存储在MySQL和Oracle中被称为回滚段</li><li>对于更新频繁的工作负载，可以减少内存分配，对于读操作频繁的工作负载，需要访问回滚段才能重新拼出需要的信息，开销会更高</li></ul></li></ol><p>垃圾回收：</p><ol><li>元组级别（Tuple-Level Garbage Collection) ：<ul><li>后台清理（Background Vaccuuming, VAC）:后台线程周期性清理:star2:</li><li>协同清理 (Cooperative Cleaning, COOP)：遍历最老到最新，事务执行时清理</li></ul></li><li>事务级别垃圾回收（Transaction-Level Garbage Collection）:<ul><li>如果一个事务创建的版本不被任何活跃事务访问，意味着该事务已经过期。</li><li>系统会根据该事务读写的数据集合（Read&#x2F;Write Sets）清理相对应的版本</li></ul></li></ol></li></ol><h2 id="5-4-Percolator"><a href="#5-4-Percolator" class="headerlink" title="5.4 Percolator"></a>5.4 Percolator</h2><p>分布式事务解决方案：Percolator</p><p>构建于Bigtable的基础上，主要用于网页搜索索引等服务</p><p>支持多行事务</p><p>依赖一个单点授时，单时间源的授时服务（TSO，Timestamp Oracle）</p><p>使用多版本时间戳排序来实现快照隔离</p><p>利用如下元数据实现快照隔离：</p><ul><li>lock:锁信息</li><li>write：事务提交时间戳</li><li>data：数据</li></ul><p>事务处理步骤：</p><ol><li><p>分配事务开始时间戳:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_ts=oracle.GetTimestamp()</span><br></pre></td></tr></table></figure></li><li><p>将所有写操作缓冲起来，直到提交时再一并写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void set(Write w)&#123;</span><br><span class="line">writes_.push_back(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>preWrite:</p><ul><li><p>所有写操作挑选一个作为主锁（随意挑选，固定使用第一个写操作作为主锁）：锁住事务中写操作涉及的所有数据</p></li><li><p>其他写操作作为次锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool preWrite(Write w,Write primary)&#123;</span><br><span class="line"> Column c = w.col;</span><br><span class="line"> bigtable::Txn T = bigtable::StartRowTransaction(w.row);</span><br><span class="line"> //如果事务开始后该数据被修改，则中止事务</span><br><span class="line"> if (T.Read(w.row,c+&quot;write&quot;,[start_ts,INF]))return false;</span><br><span class="line"> //尝试获取锁</span><br><span class="line"> if (T.Read(w.row,c+&quot;lock&quot;,[0,INF]))return fasle;</span><br><span class="line">  </span><br><span class="line"> T.Write(w.row,c+&quot;data&quot;,start_ts,w.value);</span><br><span class="line"> T.Write(w.row,c+&quot;lock&quot;,start_ts,&#123;primary.row,primary.col&#125;);</span><br><span class="line"> return T.Commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>提交事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#写</span><br><span class="line">bool Commit()&#123;</span><br><span class="line">Write Primary = writes_[0];</span><br><span class="line">vector&lt;Write&gt; secondaries(writes_.begin()+1,wirtes_.end());</span><br><span class="line">if (!PreWrite(primary,primary))return false;</span><br><span class="line">for (Write w:secondaries)</span><br><span class="line">if (!PreWrite(w,parimary)) return false;</span><br><span class="line"></span><br><span class="line">int commit_ts = oracle.GetTimestamp();</span><br><span class="line">//先提交主锁的写操作</span><br><span class="line">Write p = primary;</span><br><span class="line">bigtable::Txn T= bigtable::StartRowTransaction(p.row);</span><br><span class="line">if (!T.Read(p.row,p.col+&quot;lock&quot;,[start_ts,start_ts]))</span><br><span class="line">return false;</span><br><span class="line">T.Write(p.row,p.col+&quot;write&quot;,commit_ts,start_ts);</span><br><span class="line">T.Erase(p.row,p.col+&quot;lock&quot;,commit_ts);</span><br><span class="line">if (!T.commit())return false;</span><br><span class="line">//第二阶段，更新所有次(secondary)锁的写操作</span><br><span class="line">for (Write w:secondaries)&#123;</span><br><span class="line">bigtable::Write(w.row,w.rol+&quot;write&quot;,commit_ts,start_ts);</span><br><span class="line">bigtable::Erase(w.row,w.rol+&quot;lock&quot;,commit_ts);</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">#读</span><br><span class="line">bool Get(Row row,Column c,string *value)&#123;</span><br><span class="line">while(true)&#123;</span><br><span class="line">bigtable::Txn T = bigtable::StartRowTransaction(row);</span><br><span class="line">//检查是否有并发写入的锁</span><br><span class="line">if (T.Read(row,c+&quot;lock&quot;,[0,start_ts]))&#123;</span><br><span class="line">//存在锁，尝试清理并等待锁释放</span><br><span class="line">BackoffAndMaybeCleanupLock(row,c);</span><br><span class="line">Continue;</span><br><span class="line">&#125;</span><br><span class="line">//找到小于开始时间戳的最新写入版本</span><br><span class="line">latest_write=T.Read(row,c+&quot;write&quot;,[0,start_ts]);</span><br><span class="line">if (!latest_write.found()) return false; //没有找到</span><br><span class="line">int data_ts =latest_write.start_timestamp();</span><br><span class="line">*value = T.Read(row,c+&quot;data&quot;,[data_ts,data_ts]);</span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 深入理解分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分布式系统（三）分布式系统基础</title>
      <link href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系统基础"><a href="#分布式系统基础" class="headerlink" title="分布式系统基础"></a>分布式系统基础</h1><h2 id="3-1-分区"><a href="#3-1-分区" class="headerlink" title="3.1 分区"></a>3.1 分区</h2><p>在分布式系统中，分区是指将数据分成若干个部分，分别存储在不同的节点上，以达到提高系统性能和可扩展性的目的。分区是分布式系统中数据管理的基础。</p><p>在分区中，通常采用哈希算法对数据进行划分。具体来说，首先根据数据的某个属性进行哈希计算，得到一个哈希值，然后将这个哈希值映射到某个节点上，将对应的数据存储到这个节点上。通过这种方式，相同属性的数据会被分配到同一个节点上，从而提高数据访问的效率。</p><p>分区可以带来以下好处：</p><ol><li>提高系统的可扩展性：由于数据被分割成多个部分，每个部分可以分别存储在不同的节点上，因此可以更容易地进行横向扩展，增加节点数量来提高系统的处理能力。</li><li>提高系统的性能：由于相同属性的数据被分配到同一个节点上，因此可以更快地访问这些数据，从而提高系统的处理效率。</li><li>提高系统的容错性：当某个节点发生故障时，只有该节点上的数据会受到影响，而其他节点上的数据仍然可以正常访问，从而提高了系统的容错性。</li></ol><p>但是，分区也会带来一些挑战和问题，如数据的一致性和分区策略的选择等。因此，在设计分布式系统时，需要仔细考虑分区策略和数据一致性等问题，以确保系统的正确性和稳定性。</p><p>水平分区、垂直分区、列式数据库和行式数据库是关系型数据库的四种常见的数据分区和存储方式。</p><ol><li><strong>水平分区</strong></li></ol><p>水平分区是指将数据按照行进行切分，将每个分区的数据存储在不同的节点上。每个节点独立维护一个数据子集，这些数据子集之间相互独立。通常，水平分区的数据切分依据是数据的关键字或者某个属性，以便于查询时能够快速地定位数据。</p><p>使用场景：水平分区通常适用于<strong>数据访问压力比较大的场景</strong>，如互联网应用、金融等领域，这些场景中<strong>需要高效的读写操作和数据访问</strong>。</p><p>特点：水平分区的优点是能够将数据分散在多个节点上，减少单节点的压力，提高系统性能和可扩展性。缺点是需要考虑数据一致性的问题，当某个节点发生故障时，需要采取相应的措施保证数据的一致性。</p><ol start="2"><li><strong>垂直分区</strong></li></ol><p>垂直分区是指将数据按照列进行切分，将不同的列存储在不同的节点上。不同的节点维护不同的数据子集，但是数据之间存在关联关系。垂直分区的目的是将数据分开存储，减少节点之间的冗余数据。</p><p>使用场景：垂直分区适用于需要对数据进<strong>行复杂查询和分析</strong>的场景，如数据仓库等。</p><p>特点：垂直分区的优点是可以减少冗余数据，提高系统性能和存储效率，同时也能提高数据的安全性。缺点是可能会增加系统的复杂度，同时需要进行多表连接查询，对系统性能有一定影响。</p><ol start="3"><li>列式数据库</li></ol><p>列式数据库是指将数据按照列进行存储和访问的数据库系统。相比于传统的行式数据库，列式数据库更加适用于大规模数据的分析和查询，能够提供更高的查询效率和存储效率。列式数据库将每列数据存储在一个独立的文件或数据块中，这样可以避免读取不必要的数据，从而提高查询效率。</p><p>使用场景：列式数据库适用于大规模数据的分析和查询，如数据仓库、在线分析处理等领域。</p><p>特点：列式数据库的优点是<strong>查询效率高，存储效率高，能够快速响应复杂查询请求。缺点是更新效率相对较低，不适用于需要频繁进行更新操作的场景</strong>。</p><ol start="4"><li>行式数据库</li></ol><p>行式数据库是指将数据按照行进行存储和访问的数据库系统。行式数据库将同一行的数据存储在一起，这样能够提高数据的插入和更新效率。相比于列式数据库，行式数据库更适用于需要频繁进行更新操作的场景。</p><p>使用场景：行式数据库适用于需要频繁进行更新操作的场景，如在线交易系统、客户关系管理等领域。</p><p>特点：行式数据库的优点是<strong>支持高并发的写入操作，适用于需要频繁进行更新操作的场景。缺点是查询效率相对较低，尤其是对于大规模数据的查询</strong>，查询效率明显低于列式数据库。</p><h3 id="3-1-1-水平分区算法"><a href="#3-1-1-水平分区算法" class="headerlink" title="3.1.1 水平分区算法"></a>3.1.1 水平分区算法</h3><p>水平分区算法是指将数据按照某个属性值进行分区的一种算法。以下是几种常见的水平分区算法：</p><ol><li>范围分区</li></ol><p>范围分区是将数据按照某个属性值的范围进行分区的算法。例如，对于一个学生表，可以将学生按照年龄范围进行分区，比如0-10岁、11-20岁、21-30岁等等。</p><ol start="2"><li>哈希分区</li></ol><p>哈希分区是将数据按照某个属性值的哈希值进行分区的算法。例如，对于一个学生表，可以将学生按照学生编号进行哈希分区，将相同哈希值的学生存储在同一个分区中。</p><ol start="3"><li>轮询分区</li></ol><p>轮询分区是将数据按照一定的轮询方式进行分区的算法。例如，对于一个负载均衡系统，可以将请求按照轮询的方式分配给不同的服务器处理，以达到负载均衡的效果。</p><p>以上算法只是水平分区的几种常见方法，实际应用中还可以根据具体的需求和数据特点进行适当的调整和优化。</p><p><strong>一致性哈希：</strong></p><p><strong>一致性哈希</strong>（Consistent Hashing）是一种分布式哈希算法，它可以将数据和节点映射到同一个哈希环上，从而方便进行数据的分布式存储和访问。一致性哈希算法的核心思想是通过哈希函数将数据和节点映射到同一个环上，然后根据数据的哈希值在环上查找节点，从而实现分布式存储和访问。</p><p>一致性哈希算法的优点是可以有效地解决节点的动态增加和删除问题。当新的节点加入系统时，只需要将它的哈希值插入到哈希环上，然后将相邻的数据重新映射到新节点上即可。当节点离开系统时，只需要将它的哈希值从哈希环上移除，然后将相邻的数据重新映射到其他节点上即可。</p><p>另外，一致性哈希算法也可以有效地解决数据倾斜问题。由于哈希函数的随机性，一些节点可能会负责更多的数据，从而导致负载不均衡的问题。为了解决这个问题，一致性哈希算法引入了虚拟节点的概念，将每个物理节点映射到多个虚拟节点上，从而平衡节点的负载。</p><p>总之，一致性哈希算法是一种简单有效的分布式哈希算法，可以在分布式系统中实现数据的高效分布式存储和访问。</p><h3 id="3-1-2-分区的挑战"><a href="#3-1-2-分区的挑战" class="headerlink" title="3.1.2 分区的挑战"></a>3.1.2 分区的挑战</h3><p>查询困难和事务</p><h2 id="3-2-复制"><a href="#3-2-复制" class="headerlink" title="3.2 复制"></a>3.2 复制</h2><p>  在分布式系统中，复制（Replication）是一种常见的技术，它将数据和计算资源复制到多个节点上。复制的好处包括：</p><ol><li>高可用性：如果一个节点失效，复制的数据和计算资源可以在其他节点上继续运行，保证系统的可用性。</li><li>改善性能：通过将数据和计算资源复制到多个节点上，可以减少网络延迟和瓶颈，提高系统的响应速度和吞吐量。</li><li>容错性：复制可以提高系统的容错性，即使某个节点发生故障，也可以在其他节点上继续运行，从而保障数据的完整性和可用性。</li><li>提高可扩展性：复制可以提高系统的可扩展性，因为复制的数据和计算资源可以在不同的节点上进行并行处理，从而提高系统的处理能力。</li></ol><p>需要注意的是，复制也会带来一些负面影响，例如增加系统的复杂度和维护成本，以及可能导致数据一致性的问题。因此，在使用复制技术时，需要仔细考虑各种因素，并根据具体情况进行权衡。</p><h3 id="3-2-1-单主复制"><a href="#3-2-1-单主复制" class="headerlink" title="3.2.1 单主复制"></a>3.2.1 单主复制</h3><p>单主复制是指在分布式系统中，只有一个节点拥有写入权限，其他节点只能进行读取操作，并且该节点负责将写入的数据复制到其他节点上。单主复制的好处包括：</p><ol><li>简单易用：单主复制相对于其他复制方案来说比较简单，易于实现和维护。</li><li>数据一致性：由于只有一个节点拥有写入权限，所以数据的一致性相对较容易维护，可以避免多个节点同时对同一数据进行写入操作导致的数据不一致问题。</li><li>安全性：单主复制可以避免多个节点同时写入数据可能导致的数据冲突问题，从而保证数据的安全性。</li></ol><p>需要注意的是，单主复制也有一些缺点，例如：</p><ol><li>单点故障：由于只有一个节点拥有写入权限，如果该节点发生故障，整个系统将不可用。</li><li>性能瓶颈：由于所有的写入操作都要经过单个节点，可能会成为性能瓶颈，限制了系统的扩展性和吞吐量。</li><li>可用性问题：如果节点之间的网络连接出现问题，可能会导致数据无法及时复制到其他节点，从而影响系统的可用性。</li></ol><p>因此，在使用单主复制技术时，需要仔细考虑各种因素，并根据具体情况进行权衡。</p><p>在单主复制中，可以进一步分为以下两种类型：</p><ol><li>主从复制（Master-Slave Replication）：在主从复制中，只有一个节点（主节点）拥有写入权限，其他节点（从节点）只能进行读取操作，并且主节点负责将写入的数据复制到从节点上。主节点的写入操作会被异步地复制到从节点上，从节点的数据与主节点可能<strong>存在一定的延迟</strong>，但从节点的数据最终会与主节点保持一致。主从复制可以提供高可用性和数据一致性，并且相对简单易用。</li><li>主备复制（Master-Standby Replication）：在主备复制中，也只有一个节点（主节点）拥有写入权限，其他节点（备节点）只能进行读取操作，并且备节点与主节点之间的数据同步是<strong>实时的</strong>。当主节点发生故障时，备节点会接管主节点的功能，成为新的主节点，从而保证系统的高可用性。主备复制相对于主从复制来说，可用性更高，但是实现和维护的复杂度更高。</li></ol><p><strong>脑裂：</strong></p><p>脑裂（Split-Brain）是指在分布式系统中，由于网络分区或者其他原因，导致系统中的节点失去联系，无法进行通信，进而导致系统出现数据不一致或者操作冲突的问题。</p><p>当出现网络分区时，系统中的节点可能会被分为两个或者多个独立的部分，每个部分都认为自己是整个系统的唯一部分，而且可能会独立地进行写入操作，导致数据不一致的问题。这种情况被称为脑裂。</p><p>脑裂可能会导致系统数据的不一致性，从而影响系统的正确性和可用性。为了避免脑裂的发生，可以采取以下措施：</p><ol><li>使用复制技术：通过将数据和计算资源复制到多个节点上，可以提高系统的可用性和容错性，减少脑裂的可能性。</li><li>使用投票机制：在系统中使用投票机制，可以避免脑裂的发生。例如，在主从复制中，主节点可以将写入操作同步到多个从节点上，然后通过投票机制来确定哪个从节点应该成为新的主节点，从而避免脑裂的发生。</li><li>限制节点的数量：在分布式系统中，可以限制节点的数量，从而减少系统的复杂度和容错难度，降低脑裂的风险。</li><li>监控系统状态：对系统状态进行监控，及时发现和解决潜在的问题，可以有效地避免脑裂的发生。</li></ol><p>需要注意的是，虽然可以通过上述措施来减少脑裂的风险，但是完全避免脑裂是非常困难的，因此需要在设计和实现分布式系统时充分考虑脑裂的风险，并制定相应的应对策略。</p><h3 id="3-2-2-多主复制"><a href="#3-2-2-多主复制" class="headerlink" title="3.2.2 多主复制"></a>3.2.2 多主复制</h3><p>在分布式系统中，多主复制（Multi-Master Replication）是指多个节点拥有写入权限，并且可以同时进行写入操作的一种复制方式。每个节点都可以独立地进行写入操作，写入的数据会被异步地复制到其他节点上，从而实现数据的复制和同步。</p><p>多主复制相对于单主复制来说，具有以下几个优点：</p><ol><li><strong>高并发性</strong>：多主复制允许多个节点同时进行写入操作，可以提高系统的并发性和吞吐量，从而满足高并发场景下的需求。</li><li><strong>高可用性</strong>：多主复制允许多个节点同时拥有写入权限，当某个节点出现故障时，其他节点可以继续进行写入操作，从而保证系统的高可用性和容错性。</li><li><strong>灵活性</strong>：多主复制可以根据实际需求进行灵活配置，可以在多个节点之间平衡负载，提高系统的稳定性和可靠性。</li></ol><p>但是，多主复制也存在一些挑战和限制：</p><ol><li>冲突问题：当多个节点同时进行写入操作时，可能会发生数据冲突的问题，需要采取相应的冲突解决策略来避免数据不一致的问题。</li><li>一致性问题：多主复制需要保证节点之间数据的一致性，需要使用相应的协调机制来保证数据的正确性和一致性。</li><li>实现和维护的复杂度：多主复制的实现和维护相对复杂，需要考虑节点之间的同步和冲突解决等问题，增加了系统的复杂度和维护难度。</li></ol><p>需要注意的是，在设计和实现多主复制时，需要综合考虑系统的性能、可用性和一致性等方面的需求，以及各种冲突解决和协调机制的复杂度和实现难度，从而选择最合适的复制方式。</p><p><strong>解决冲突：</strong></p><p>在多主复制中，当多个节点同时对同一个数据进行写入操作时，可能会发生冲突，从而导致数据的不一致性。为了避免冲突问题，可以采用以下几种解决办法：</p><ol><li><p>乐观锁机制：每个节点在进行写入操作前，先获取当前数据的版本号，并在写入时附带版本号信息。当其他节点进行写入时，会发现版本号不一致，从而引发冲突。此时，节点可以根据具体的策略进行相应的处理，例如选择最新的版本进行更新，或者放弃当前的写入操作等。</p></li><li><p>悲观锁机制：每个节点在进行写入操作时，先尝试获取对应的锁，如果获取不到，则说明有其他节点正在进行写入操作，此时可以等待一段时间后再次尝试获取锁，或者放弃当前的写入操作。</p></li><li><p>时序复制机制：在多主复制中，通过使用全局唯一的时间戳或序列号来协调多个节点之间的写入操作，从而避免冲突。每个节点在进行写入操作时，需要带上对应的时间戳或序列号，当其他节点接收到写入请求时，会根据时间戳或序列号来确定写入的先后顺序，从而保证数据的一致性。</p></li><li><p>基于版本向量的机制：每个节点在进行写入操作时，不仅记录当前数据的版本号，还记录其他节点最近的版本号信息。当其他节点进行写入时，会将自己的版本号信息传递给其他节点，从而形成一个版本向量，用于判断不同节点之间的数据冲突和一致性。</p></li><li><p>由客户端解决冲突</p></li><li><p>“最后写入胜利”（Last Writer Wins，LWW）是一种常见的多主复制冲突解决策略。该策略的基本思想是，当多个节点对同一个数据进行写入时，以最后写入的节点为准，即后来的写入操作会覆盖之前的写入操作。</p><p>具体实现时，每个节点在进行写入操作时，都会记录对应的时间戳或版本号，当其他节点收到写入请求时，会比较当前节点的时间戳或版本号和自身记录的时间戳或版本号，以此来判断哪个写入操作更晚，从而决定是否接受该写入请求。当发生冲突时，以最后写入的节点为准，更新数据。</p><p>需要注意的是，LWW策略虽然简单易实现，但也存在一些潜在的问题，例如可能导致数据的丢失、数据的不一致性等。因此，在选择冲突解决策略时，需要根据具体的应用场景和需求进行综合考虑，权衡不同策略的优缺点。</p></li><li><p>因果关系跟踪</p><p>因果关系跟踪（Causal tracing）是一种在分布式系统中用于跟踪不同节点之间交互的技术。在分布式系统中，不同节点之间的交互往往是异步的，并且可能经过多个中间节点，因此需要一种机制来跟踪交互的因果关系，以便分析和调试系统的行为。</p><p>因果关系跟踪通常基于事件模型，即将系统的行为抽象为一系列事件，并记录事件之间的因果关系。具体来说，当一个节点发送请求给另一个节点时，需要将请求的相关信息（例如请求ID、时间戳等）附加到请求中，并在接收到响应时将响应的相关信息（例如响应ID、时间戳等）附加到响应中。这样，每个事件就可以通过相关的信息与之前和之后的事件建立因果关系。</p><p>通过因果关系跟踪，可以实现分布式系统中的故障定位、性能调优、容错处理等功能。例如，在进行故障定位时，可以根据事件之间的因果关系，追溯出故障的来源；在进行性能调优时，可以通过分析事件之间的时间关系，找出系统中的瓶颈和优化空间；在进行容错处理时，可以根据因果关系判断不同节点之间的依赖关系，从而决定如何进行容错处理。</p><p>目前，因果关系跟踪已经成为分布式系统中的一个重要组成部分，并且在开源工具和云服务平台中得到了广泛应用，例如OpenTelemetry、Zipkin、Jaeger等。</p></li></ol><p>需要注意的是，不同的解决办法适用于不同的场景和需求，选择合适的冲突解决策略需要综合考虑多方面的因素，包括系统的性能、可靠性、一致性和复杂度等。</p><h3 id="3-2-3-无主复制"><a href="#3-2-3-无主复制" class="headerlink" title="3.2.3 无主复制"></a>3.2.3 无主复制</h3><p>无主复制（Masterless replication）是一种分布式系统中常见的数据复制策略，与单主复制和多主复制不同，无主复制不需要指定特定的节点作为主节点，而是让<strong>所有节点都能够读取和写入数据</strong>。具体来说，无主复制通常采用以下两种方式实现：</p><ol><li>基于<strong>副本集</strong>：无主复制可以基于副本集实现，即将数据复制到多个节点上，并保证每个节点上的数据副本是一致的。当进行写入操作时，所有节点都可以接受写入请求，并将<strong>写入操作广播</strong>给其他节点进行更新。当进行读取操作时，每个节点都可以从自己本地的数据副本中读取数据。</li><li>基于<strong>分片</strong>：无主复制也可以基于分片实现，即将数据划分为多个分片，并将每个分片复制到多个节点上。当进行写入操作时，只需要将<strong>写入操作发送给对应的分片所在的节点</strong>，并更新该节点上的数据副本。当进行读取操作时，只需要根据读取请求所涉及的分片，从对应的节点中读取数据。</li></ol><p>无主复制相比于单主复制和多主复制，具有<strong>更好的可伸缩性和容错性</strong>，因为每个节点都可以独立地接受读写请求，并且可以通过增加节点数目来提高系统的容错能力和吞吐量。但同时，无主复制也需要考虑数据一致性和冲突解决等问题，例如如何解决并发写入操作导致的冲突，如何保证数据的一致性等。</p><p>Dynamo架构中的两种数据修复方法：</p><ol><li><p>读修复（Read repair）：读修复是一种在读取数据时自动修复损坏或不一致数据的技术。在分布式系统中，由于数据副本之间可能存在网络分区或写冲突等问题，导致某些节点上的数据副本可能已经过期或损坏。当客户端<strong>从一个节点读取数据时，如果发现该节点上的数据副本已经过期或与其他节点上的副本不一致，该节点会尝试从其他节点中读取最新的数据，并将其与自己的数据副本进行比较和合并，从而实现数据的修复。</strong></p></li><li><p>反熵过程（Anti-entropy）：反熵过程是一种<strong>定期检查</strong>和修复数据不一致问题的技术。在分布式系统中，由于网络故障或其他原因，不同节点上的数据副本可能会出现不一致的情况，为了解决这个问题，系统可以定期启动反熵过程来检查和修复数据不一致。具体来说，反熵过程会<strong>周期性地比较不同节点之间的数据副本，将不同的数据副本进行合并，从而实现数据的一致性。</strong></p><p><strong>反熵过程通常会使用Merkle树来检测和修复数据不一致问题。</strong></p><p>Merkle树是一种树形结构，它可以用来验证分布式系统中的数据一致性。在Merkle树中，每个叶子节点都是数据块的哈希值，每个非叶子节点都是其子节点哈希值的哈希值。通过比较不同节点之间的Merkle树，可以快速检测数据不一致的位置，并将不同的数据块进行合并。</p><p>在反熵过程中，系统会对不同节点之间的Merkle树进行比较，检测不一致的位置，并将不同的数据块进行合并。具体来说，反熵过程会周期性地对所有节点的Merkle树进行比较，如果发现两个节点的Merkle树有不一致的位置，系统会将不同的数据块进行合并，并更新相应的节点。</p><p>使用Merkle树来进行反熵过程有以下优点：</p><ol><li>高效性：Merkle树具有高效的验证和合并性能，可以快速检测和修复数据不一致问题。</li><li>安全性：Merkle树可以有效地保护数据的安全性，因为如果任何一个节点的数据发生了改变，其对应的哈希值也会发生改变，从而导致整个Merkle树的哈希值发生改变。</li></ol><p>因此，Merkle树是反熵过程中常用的技术之一，可以有效地检测和修复分布式系统中的数据不一致问题。</p></li></ol><p><strong>Quorum的数据冗余机制：</strong></p><p>Quorum是一种基于Raft协议的分布式一致性算法，它允许在一个集群中同时运行多个副本来提高系统的可靠性和容错性。在Quorum中，数据冗余机制通常通过副本集群来实现。</p><p>具体来说，Quorum通过将数据复制到多个节点来实现数据冗余。在一个Quorum集群中，通常会有多个节点运行相同的应用程序，每个节点上都有一个或多个副本存储相同的数据。这些副本可以保证在节点故障或网络故障时，数据仍然可用。</p><p>Quorum的数据冗余机制具有以下特点：</p><ol><li>多副本：每个节点上通常会运行多个副本，确保数据的可靠性和容错性。</li><li>复制同步：Quorum使用Raft协议来保证多个副本之间的数据同步，确保每个副本都存储相同的数据。</li><li>副本数量：Quorum要求在集群中<strong>至少有一半以上的节点存储相同的数据</strong>，这样可以确保在一定程度上抵御节点故障和网络故障。</li><li>容错性：Quorum可以在节点故障或网络故障的情况下继续工作，确保数据的可用性。</li></ol><p>除了数据冗余机制，Quorum还支持其他一些功能，如数据复制和数据恢复。数据复制是指在集群中将数据从一个节点复制到另一个节点，以确保数据的可靠性和容错性。数据恢复是指在节点故障或网络故障的情况下，将数据从备份节点恢复到故障节点，以确保数据的可用性。这些功能都可以提高Quorum集群的可靠性和容错性。</p><p>W&gt;N&#x2F;2</p><p>W和R通常比N小（因为为了降低延迟）</p><h2 id="3-3-CAP定理"><a href="#3-3-CAP定理" class="headerlink" title="3.3 CAP定理"></a>3.3 CAP定理</h2><p>CAP定理是指在一个分布式系统中，一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）这三个特性无法同时满足，只能满足其中的两个。</p><p>具体来说：</p><ul><li>一致性：所有节点在同一时刻看到的数据是相同的。</li><li>可用性：客户端能够获得系统的响应，即使某些节点出现故障。</li><li>分区容错性：即使网络中断或节点故障，系统仍能继续运行。</li></ul><p>CAP定理的核心观点是，在分布式系统中，当网络分区发生时，系统必须要做出选择：是保证一致性还是可用性。由于分布式系统不可避免地会发生网络分区，因此系统必须要容忍分区，否则会导致系统的不可用性。因此，CAP定理的实质是，在网络分区发生时，系统必须要在一致性和可用性之间做出取舍。</p><p>需要注意的是，CAP定理中提到的一致性和可用性是指强一致性和高可用性，而不是最终一致性和可接受的可用性。最终一致性是指在一定时间内，系统最终会达到一致的状态；而可接受的可用性是指系统可以在一定时间内保证响应客户端的请求，但可能不是实时的。</p><p>CAP定理是分布式系统设计和实现的基础原则之一，它提醒我们在设计分布式系统时要充分考虑系统的一致性、可用性和分区容错性之间的关系，并根据具体需求进行取舍。</p><p>在网络分区发生时，分布式系统可能无法同时满足高可用性和强一致性，但是可以通过实现最终一致性来保证系统的可用性，并在一定时间内达到一致的状态。同时，如果系统对一致性要求不是非常高，也可以采用可接受的可用性来满足系统的需求。</p><p>需要注意的是，最终一致性并不是一个具体的算法或协议，而是一种设计思想或范式。不同的分布式系统可以采用不同的最终一致性策略，例如基于版本的控制、基于时间戳的控制、基于向量时钟的控制等，来保证数据在不同节点之间的最终一致性。</p><p><strong>意义：</strong></p><ul><li>系统开发需要取舍！不存在完美的系统！</li><li>CP</li><li>AP</li></ul><h3 id="3-3-1-PACELC定理"><a href="#3-3-1-PACELC定理" class="headerlink" title="3.3.1 PACELC定理"></a>3.3.1 PACELC定理</h3><p><a href="https://zhuanlan.zhihu.com/p/348923238">分布式理论 PACELC 了解么？ - 知乎 (zhihu.com)</a></p><p>PACELC定理是指，在分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）三者不可同时兼备，只能选择其中的两项。</p><p>PACELC定理是基于CAP定理发展而来的。CAP定理指出，在一个分布式系统中，Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性）这三个因素不可同时保证。在分布式系统出现网络分区时，必须选择放弃一致性还是可用性中的一项，以保证系统的可靠性。</p><p>PACELC定理是对CAP定理的进一步扩展和细化，将一致性进一步划分为了强一致性（Strong Consistency）和弱一致性（Weak Consistency），并在此基础上提出了三种情况：当出现网络分区时，系统只能保证两项中的其中之一，而具体保证哪两项则取决于分布式系统的设计和应用场景。</p><p>具体来说，PACELC定理认为，在分布式系统中，当发生网络分区时，可以选择以下三种策略：</p><ol><li>保证分区容错性和强一致性，放弃可用性（PA&#x2F;EC）：这种情况下，系统会在网络分区发生时，停止接受请求，以保证数据的一致性。</li><li>保证分区容错性和可用性，放弃强一致性（PA&#x2F;EL）：这种情况下，系统会允许不同节点的数据出现短时间的不一致，以保证系统的可用性。</li><li>保证可用性和强一致性，放弃分区容错性（CA&#x2F;EL）：这种情况下，系统会在网络分区发生时，仍然继续接受请求，但可能会导致节点之间的数据不一致，以保证系统的可用性和数据的一致性。</li></ol><p>在实际应用中，选择哪种策略取决于具体的应用场景和需求，需要根据系统的性能要求、可用性要求、数据一致性要求以及成本等因素进行权衡和选择。</p><h3 id="3-3-2-BASE"><a href="#3-3-2-BASE" class="headerlink" title="3.3.2 BASE"></a>3.3.2 BASE</h3><p>在分布式系统的上下文中，BASE 是 “Basically Available, Soft state, Eventually consistent” 的缩写。这是一组原则，可用于设计和实现分布式系统，优先考虑可用性和分区容忍性，而不是强一致性。</p><p>Basically Available 指的是分布式系统应始终能够响应客户端请求，即使系统遇到故障或网络分区。Soft state 指的是系统状态随时间变化的想法，只要变化不是关键的，系统最终能够收敛到一致的状态，就是可接受的。Eventually consistent 指的是在足够的时间和适当的同步下，系统最终会在所有节点上变得一致。</p><p>与优先考虑强一致性的 ACID（原子性，一致性，隔离性，持久性）原则不同，BASE 是一种更为松散的方法，可以在分布式系统中实现更高的可用性和可伸缩性，但代价是一些一致性上的权衡。</p><h2 id="3-4-一致性模型"><a href="#3-4-一致性模型" class="headerlink" title="3.4 一致性模型"></a>3.4 一致性模型</h2><p>一致性模型是指在分布式计算中，确保多个节点之间数据的一致性和可靠性的模型。在分布式系统中，节点可能会同时读取和写入共享数据，因此必须确保在所有节点上数据的状态是一致的。</p><p>常见的一致性模型包括：</p><ol><li>强一致性模型（线性一致性）：在任何时候，所有节点都能够读取到相同的数据。强一致性模型可以保证数据的完全一致性，但可能会影响系统的性能。</li><li>弱一致性模型：在任何时候，不同节点读取到的数据可能会不一样。弱一致性模型通常可以提高系统的性能，但需要更复杂的算法来确保数据的一致性。</li><li>最终一致性模型：在一定时间内，所有节点最终都能够读取到相同的数据。最终一致性模型通常是弱一致性模型和强一致性模型之间的一种妥协方案。</li></ol><p>一致性模型的选择取决于系统的需求和设计目标，需要综合考虑系统的性能、可靠性、一致性和可扩展性等方面。</p><h3 id="3-4-1-线性一致性模型"><a href="#3-4-1-线性一致性模型" class="headerlink" title="3.4.1 线性一致性模型"></a>3.4.1 线性一致性模型</h3><p>线性一致性模型是一种强一致性模型，它保证在分布式系统中所有节点读取到的数据是一致的，即如果一个节点在时间轴上比另一个节点先写入数据，则先写入的数据一定先于后写入的数据被读取到。线性一致性模型是对强一致性模型的一种加强形式，它要求所有节点读取到的数据的顺序与它们写入的顺序一致，即数据的全局顺序与它们的时间戳有关。</p><p>线性一致性模型的实现通常需要使用一些特殊的算法和技术，例如基于向量时钟（vector clock）的数据版本控制机制、分布式锁机制等。这些技术可以确保所有节点读取到的数据的顺序是一致的，同时还可以保证系统的性能和可扩展性。</p><p>线性一致性模型通常用于需要强一致性保证的分布式应用，例如金融交易系统、在线游戏等。</p><p><strong>向量时钟：</strong></p><p>向量时钟是一种用于分布式系统中维护事件顺序的数据结构。它可以帮助分布式系统中的不同节点确定事件的先后顺序，并保证在不同节点中的时间戳的一致性。</p><p>向量时钟的基本思想是：每个节点都维护一个向量，向量的长度等于节点的数量，每个节点的向量元素表示该节点上的事件数目。当节点上发生一个事件时，它会将该节点的向量元素加1，并将整个向量发送给其它节点。接收到向量后，节点会将它的本地向量与接收到的向量进行合并，并更新本地向量的元素值，以反映出其它节点上发生的事件情况。这样，每个节点都可以通过比较向量来判断事件的先后顺序。</p><p>具体来说，如果向量V和W都是节点数为N的向量时钟，则V &lt;&#x3D; W的含义是V中的每个元素都小于等于W中对应元素。如果V &lt;&#x3D; W并且W &lt;&#x3D; V，则V和W是相等的。当向量V和W不相等时，就可以根据它们的比较结果来判断事件的先后顺序。</p><p>向量时钟通常用于实现一些需要维护事件顺序的分布式应用，例如分布式数据库系统、分布式文件系统、分布式共识算法等。</p><p><strong>分布式锁：</strong></p><p>分布式锁是一种在分布式系统中实现互斥访问的机制，它可以帮助不同节点之间协调并发操作，避免出现冲突和竞争条件。</p><p>在分布式系统中，多个节点可能同时访问共享资源，例如数据库、文件系统等。为了避免多个节点同时修改同一份数据，需要使用分布式锁来保证资源的互斥访问。当一个节点想要访问共享资源时，它需要先获取一个分布式锁，确保其他节点不能同时访问该资源。当节点完成操作后，需要释放锁，以允许其他节点继续访问资源。</p><p>实现分布式锁的方法有很多种，其中比较常见的包括：</p><ol><li>基于数据库实现的分布式锁：将锁状态保存在数据库中，节点需要先获取数据库的一个排他锁，才能对锁进行操作。</li><li>基于ZooKeeper实现的分布式锁：利用ZooKeeper提供的原子操作和临时节点机制，实现分布式锁。</li><li>基于Redis实现的分布式锁：利用Redis提供的SETNX命令和expire命令，实现分布式锁。</li></ol><p>需要注意的是，在使用分布式锁时，需要考虑锁的粒度和性能等问题。如果锁的粒度过大，可能会导致锁竞争和性能瓶颈；如果锁的粒度过小，可能会导致锁冲突和死锁等问题。因此，在实际应用中，需要根据具体情况选择合适的锁粒度，并进行性能测试和优化。</p><p><a href="https://blog.csdn.net/m0_67645544/article/details/124768505?ops_request_misc=%7B%22request_id%22:%22168594407216800192234961%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168594407216800192234961&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124768505-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&spm=1018.2226.3001.4187">(459条消息) 什么是分布式锁？几种分布式锁分别是怎么实现的？_Java后端架构猛猛的博客-CSDN博客</a></p><h3 id="3-4-2-线性一致性的代价"><a href="#3-4-2-线性一致性的代价" class="headerlink" title="3.4.2 线性一致性的代价"></a>3.4.2 线性一致性的代价</h3><p>线性一致性通常需要付出较高的代价，因为要保证数据的全局顺序一致性，需要牺牲一定的可用性和延迟。</p><p>在实现线性一致性时，需要考虑以下几个方面的代价：</p><ol><li>通信代价：为了保证数据的一致性，需要不断进行节点间的通信和同步操作，这会增加网络带宽的使用和延迟。</li><li>吞吐量代价：由于要对所有的操作进行全局排序，需要在整个系统范围内协调所有节点的操作，这会对系统的吞吐量产生影响。</li><li>可用性代价：在实现线性一致性时，如果某个节点发生故障，会影响整个系统的可用性。因此，在实现线性一致性时，需要采取一些机制来保证故障时的容错和恢复能力。</li><li>性能代价：由于要保证全局顺序一致性，系统可能需要进行多轮操作和协调，这会增加系统的延迟和响应时间。</li></ol><p>因此，在实际应用中，需要根据具体需求和场景，综合考虑各种代价，选择合适的一致性模型和实现方式，以达到最优的性能和可用性。</p><h3 id="3-4-3-顺序一致性"><a href="#3-4-3-顺序一致性" class="headerlink" title="3.4.3 顺序一致性"></a>3.4.3 顺序一致性</h3><p>顺序一致性是一种弱一致性模型，它要求系统的操作按照提交的顺序执行，但不要求所有节点都看到相同的执行顺序。</p><p>具体来说，对于任意两个操作，如果它们在一个节点上执行并且提交的顺序是相同的，则在所有节点上的执行顺序必须保持一致。但是，如果两个操作在不同节点上执行，则可能存在不同的执行顺序，即存在并发执行的可能性。因此，顺序一致性保证了操作的有序性，但是不保证全局的一致性。</p><p>在实现顺序一致性时，系统可以采用一些机制来保证操作的有序性，例如对操作进行时间戳或序列号标记，或者采用基于向量时钟的算法来实现。</p><p>相对于线性一致性来说，顺序一致性的代价较低，因为它不需要保证所有节点都看到相同的执行顺序。因此，顺序一致性通常用于一些对一致性要求不是特别高的场景，例如社交网络应用、在线游戏等。</p><h3 id="3-4-4-因果一致性（微信朋友圈）"><a href="#3-4-4-因果一致性（微信朋友圈）" class="headerlink" title="3.4.4 因果一致性（微信朋友圈）"></a>3.4.4 因果一致性（微信朋友圈）</h3><p>因果一致性是一种弱一致性模型，它要求系统的操作按照因果关系执行，即如果一个操作A在另一个操作B之前发生，那么操作B在所有节点上的执行必须在操作A之后。这意味着，因果一致性可以保证操作的有序性和因果关系，但不要求所有节点都看到相同的执行顺序。</p><p>具体来说，因果一致性要求系统中的所有节点都按照相同的因果顺序执行操作。在实现因果一致性时，通常采用向量时钟或其他类似的机制来维护操作的因果关系。</p><p>因果一致性相对于线性一致性和顺序一致性来说，代价更低，因为它不需要对所有操作进行全局排序，只需要保证操作的因果关系即可。因此，因果一致性通常用于一些对一致性要求不是特别高的场景，例如分布式日志系统、分布式数据库等。</p><p>值得注意的是，因果一致性仅仅保证了操作的因果关系和有序性，而不保证操作的结果和值。因此，在使用因果一致性时，需要考虑数据一致性和可用性等方面的问题。</p><h3 id="3-4-5-最终一致性（搜索引擎、社交网络）"><a href="#3-4-5-最终一致性（搜索引擎、社交网络）" class="headerlink" title="3.4.5 最终一致性（搜索引擎、社交网络）"></a>3.4.5 最终一致性（搜索引擎、社交网络）</h3><p>最终一致性是一种弱一致性模型，它允许系统中的不同节点在一段时间内保持数据的不一致性，但最终会达到一致的状态。这意味着，当系统中存在多个副本时，这些副本在某个时间点上的状态可能不同，但经过一段时间的同步和协调后，最终会达到一致的状态。</p><p>在实现最终一致性时，通常采用异步复制或延迟复制的方式，即不要求所有节点在短时间内达到一致的状态，而是允许节点在本地更新数据，并在后续的时间点上将更新的数据同步到其他节点。这样做可以提高系统的可用性和性能，并减少系统之间的通信负担。</p><p>最终一致性适用于一些对数据一致性要求不是特别高的场景，例如<strong>搜索引擎、社交网络</strong>等。但是，最终一致性也存在一些问题，例如数据冲突和合并、数据同步的延迟等，需要在实际应用中进行适当的处理和解决。</p><h3 id="3-4-6-以客户端为中心的一致性模型"><a href="#3-4-6-以客户端为中心的一致性模型" class="headerlink" title="3.4.6 以客户端为中心的一致性模型"></a>3.4.6 以客户端为中心的一致性模型</h3><p> 以客户端为中心的一致性模型是一种应用程序在客户端上维护数据一致性的模型。在这个模型中，客户端负责维护数据的一致性，而不是依赖于分布式系统来维护数据的一致性。</p><p>具体来说，以客户端为中心的一致性模型通常采用乐观并发控制的策略。在这个策略中，客户端通过在本地缓存中保存数据副本来维护数据的一致性，并在修改数据时对缓存中的数据进行验证。如果数据未被其他客户端修改，则客户端可以直接提交修改。否则，客户端需要处理数据冲突，并根据一些策略来解决冲突。</p><p>以客户端为中心的一致性模型适用于一些对一致性要求不是特别高的场景，例如移动应用、离线应用等。这种模型具有良好的可用性和性能，因为客户端可以通过本地缓存快速读写数据，而不必依赖于分布式系统进行通信。但是，它也存在一些问题，例如数据冲突和合并、数据同步的延迟等，需要在实际应用中进行适当的处理和解决。</p><p>单调读（Monotonic Reads）和单调写（Monotonic Writes）是指一个线程对于一个特定变量的读操作或写操作，必须按照执行顺序，按照先后顺序看到最近的操作结果。</p><p>例如，如果线程A先写入变量x，然后线程B读取变量x，那么线程B必须看到线程A的写入结果，而不是之前的旧值。</p><p>读你所写（Read Your Writes，RYW）是指一个线程对于一个特定变量的读操作，必须在它自己的最近的写操作之后进行。这个特性在分布式系统中非常重要，因为它可以保证一个线程在写入某个变量之后，能够看到它自己的写入结果，而不是其他线程的旧值。</p><p>PRAM（Parallel Random Access Machine）是一种并行计算模型，它描述了一种在共享内存并行计算机上进行并行计算的方式。PRAM模型中，所有处理器共享一个全局内存，并且可以在O(1)时间内进行读写操作。</p><p>在PRAM模型中，单调读、单调写和读你所写是非常重要的一些性质，因为它们可以保证在并行计算中不会发生数据冲突和数据不一致的问题，从而保证并行计算的正确性和性能。</p><h2 id="3-5-隔离级别"><a href="#3-5-隔离级别" class="headerlink" title="3.5 隔离级别"></a>3.5 隔离级别</h2><p>隔离级别是指在数据库事务中不同事务之间对数据的读写所采用的不同的隔离策略。常见的隔离级别有四种：读未提交、读已提交、可重复读和串行化。</p><ol><li>读未提交（Read Uncommitted）：最低的隔离级别，允许一个事务读取另一个事务未提交的数据，可能导致脏读、不可重复读、幻读等问题。</li><li>读已提交（Read Committed）：在一个事务中，读取数据时只能读取已经提交的数据，可以避免脏读问题，但是可能会出现不可重复读和幻读问题。</li><li>可重复读（Repeatable Read）：保证一个事务在多次读取同一数据时，能够看到同样的数据，即同一事务内多次查询结果集相同。但是，其他事务可以向该数据表中插入新的数据，导致幻读问题。</li><li>串行化（Serializable）：最高的隔离级别，完全隔离每个事务，事务只能一个接一个地执行，避免了所有并发问题，但是效率较低。</li></ol><p>不同的隔离级别在事务处理中的性能和正确性上有不同的影响，需要根据具体的业务需求进行选择。一般来说，读已提交和可重复读是应用比较广泛的隔离级别。</p><h2 id="3-6-一致性和隔离级别的对比"><a href="#3-6-一致性和隔离级别的对比" class="headerlink" title="3.6 一致性和隔离级别的对比"></a>3.6 一致性和隔离级别的对比</h2><p>线性一致性和串行化都是数据库中保证事务正确性的机制，但是它们有不同的实现方式和应用场景。</p><p>线性一致性（Linearizability）是指，在分布式系统中，每个操作都有一个全局的先后顺序，该顺序满足原子性、顺序性、一致性和实时性的要求。也就是说，线性一致性保证了分布式系统中的操作顺序与单个系统中的操作顺序相同，而且保证了操作的原子性、一致性和实时性。线性一致性保证了分布式系统中的操作表现出和单个系统一样的行为，对于应用程序来说，感知不到分布式环境的存在。</p><p>串行化（Serialization）是指，在多个事务并发访问同一份数据时，数据库系统会把这些事务串行执行，以保证数据的正确性。串行化可以消除脏读、不可重复读和幻读等问题，但是会降低并发性能。</p><p>虽然线性一致性和串行化都能保证数据的正确性，但是它们的应用场景不同。线性一致性更适用于分布式环境下的系统，例如分布式缓存、分布式队列等。而串行化更适用于事务并发访问同一份数据时，需要严格控制并发执行顺序的场景，例如银行转账、订单处理等。</p><p>需要注意的是，线性一致性和串行化都会影响数据库的并发性能，因此需要根据具体的业务需求和系统架构来选择适合的一致性控制机制，以保证系统的正确性和并发性能。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 深入理解分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分布式系统（四）分布式共识</title>
      <link href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86/"/>
      <url>/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a>分布式共识</h1><h2 id="4-1-分布式共识简介"><a href="#4-1-分布式共识简介" class="headerlink" title="4.1 分布式共识简介"></a>4.1 分布式共识简介</h2><p>分布式共识（Distributed Consensus）是指在分布式系统中，多个节点（或进程）协同完成某个任务或达成某个决策的过程。在这个过程中，每个节点需要就该任务或决策达成一致，并且能够互相通信、协调、协作。</p><p>分布式共识的一个重要应用是在区块链技术中，用于解决双花问题（Double-spending problem）和确定哪些交易会被写入区块链。比特币等加密货币就是通过共识算法来实现去中心化的交易记录。</p><p>常见的分布式共识算法包括拜占庭将军问题（Byzantine fault tolerance, BFT）、Raft、Paxos、Proof of Work（PoW）、Proof of Stake（PoS）等。这些算法都有各自的优缺点，适用于不同的场景。例如，PoW 算法被应用在比特币等加密货币中，而 PoS 算法则被用在以太坊等区块链平台中。</p><h3 id="4-1-1-什么是分布式共识"><a href="#4-1-1-什么是分布式共识" class="headerlink" title="4.1.1 什么是分布式共识"></a>4.1.1 什么是分布式共识</h3><p>分布式共识是指在一个分布式系统中，多个节点之间需要就某些决策达成一致意见的过程。在这个过程中，各个节点通过相互通信和协作来达成共识，以保证系统能够正常运作并避免出现错误或冲突。</p><p>在分布式系统中，由于节点之间的网络延迟、节点故障等原因，不同节点的状态可能存在不一致的情况。因此，需要通过分布式共识算法来解决这些问题。常用的分布式共识算法包括 Paxos、Raft、Byzantine Fault Tolerance 等。</p><p>分布式共识算法的基本思路是，通过节点之间的通信和协作，选出一个“领导者”节点来负责提出某个决策，其他节点通过投票和确认的方式来达成共识，以保证系统在多个节点之间的一致性和可靠性。这种算法在分布式数据库、区块链等系统中都得到了广泛应用。</p><h3 id="4-1-2-为什么要达成共识"><a href="#4-1-2-为什么要达成共识" class="headerlink" title="4.1.2 为什么要达成共识"></a>4.1.2 为什么要达成共识</h3><p>在分布式系统中，节点之间的状态可能存在不一致的情况，如果不对这些状态进行协调，就可能导致系统出现错误或冲突。为了避免这种情况的发生，需要在分布式系统中实现共识机制，保证各个节点之间的状态达成一致，从而保证系统的正确性和可靠性。</p><p>具体来说，如果在一个分布式系统中，某些节点的状态发生了变化，但其他节点还没有收到这个变化的通知，那么这些节点就会基于过期的状态进行操作，从而导致数据不一致或操作冲突。通过分布式共识算法，可以确保所有节点在进行操作前都已经达成了共识，从而保证了数据的一致性和操作的正确性。</p><p>另外，分布式共识还能够防止拜占庭错误的发生。拜占庭错误是指分布式系统中存在恶意节点或网络攻击，导致节点之间的通信受到干扰或伪造。通过分布式共识算法，可以检测和排除这些恶意行为，确保系统的安全性和可靠性。</p><h2 id="4-2-异步系统中的共识"><a href="#4-2-异步系统中的共识" class="headerlink" title="4.2 异步系统中的共识"></a>4.2 异步系统中的共识</h2><h3 id="4-2-1-FLP不可能定理"><a href="#4-2-1-FLP不可能定理" class="headerlink" title="4.2.1 FLP不可能定理"></a>4.2.1 FLP不可能定理</h3><p>FLP不可能定理是指，<strong>在一个异步的分布式系统中，不存在一个算法能够保证在存在至少一个节点故障的情况下，仍然能够保证所有节点能够在有限时间内达成共识。</strong></p><p>该定理由Fischer、Lynch和Paterson在1985年提出，是分布式共识领域的一个重要理论。其基本思想是，由于节点之间的通信存在延迟和不可靠性，因此在存在故障节点的情况下，无法确定某个节点是否已经停止工作或者只是延迟。这种不确定性会导致共识过程无法完成。</p><p>FLP不可能定理的证明使用了卡慕尔异步通信模型，即假设节点之间的消息传输可以无限制地延迟，但必须保证每个节点最终能够收到所有消息。基于这种通信模型，可以证明在存在至少一个节点故障的情况下，无法保证所有节点能够在有限时间内达成共识。</p><p>虽然FLP不可能定理指出了分布式共识问题的困难性，但是在实际应用中，往往会使用一些近似算法来解决共识问题。例如，Paxos算法、Raft算法等就是通过一些特殊的约束条件来实现了共识，从而在实际应用中得到了广泛的应用。</p><ul><li>安全性: 在一个任期内只会确定一个值（something wrong not happen）</li><li>活性：分布式系统最终会认同某一个值(something right must happen)</li><li>容错性</li></ul><p><a href="https://lrita.github.io/2018/10/23/safety-and-liveness-in-distributed/">分布式系统中的 safety 和 liveness — 源代码 (lrita.github.io)</a></p><p>和CAP一样，三选二</p><p><strong>证明：</strong></p><p>FLP不可能定理的证明是基于卡慕尔异步通信模型的，该模型假设节点之间的消息传输可以无限制地延迟，但必须保证每个节点最终能够收到所有消息。在这种通信模型下，证明FLP不可能定理的基本思路是，通过构造一个反例来说明在异步通信模型下，不存在一个算法能够保证在存在至少一个节点故障的情况下，仍然能够保证所有节点能够在有限时间内达成共识。</p><p>具体来说，假设有一个分布式系统，其中包含n个节点，节点之间通过消息传递来达成共识。为了方便起见，假设系统中只有两种状态：0和1。初始状态下，每个节点的状态都是不确定的。节点之间的通信是异步的，消息传输可以无限制地延迟，且无法保证消息的可靠性。</p><p>接下来，假设有一个算法A，可以在存在至少一个节点故障的情况下，仍然能够保证所有节点能够在有限时间内达成共识。为了证明FLP不可能定理，需要构造一个反例来说明这个算法是不可行的。</p><p>具体来说，假设存在两个节点p和q，它们的状态初始时均为不确定状态。为了达成共识，节点p发送一个消息m给节点q，告诉节点q它当前的状态是0。但由于通信是异步的，消息m可能会被延迟或者丢失，导致节点q无法知道节点p的状态。因此，节点q可以选择继续等待消息m，或者猜测节点p的状态是1。如果节点q猜测节点p的状态是1，那么节点q会发送一个消息n给节点p，告诉节点p它当前的状态是1。由于节点p也无法确定节点q的状态，节点p也有可能会猜测节点q的状态是0，从而发送一个消息k给节点q，告诉节点q它当前的状态是0。这样，就形成了一个死锁状态，导致节点p和q无法达成共识。</p><p>从上述分析可以看出，由于异步通信模型的存在，无法保证消息的可靠性和节点状态的一致性，从而导致FLP不可能定理的存在。虽然该定理证明了在异步通信模型下，不存在一个算法能够保证在存在至少一个节点故障的情况下，仍然能够保证所有节点能够在有限时间内达成共识，但在实际应用中，可以采用一些近似算法来解决共识问题。</p><ul><li>故障屏蔽</li><li>使用故障检测器</li><li>使用随机性算法</li></ul><p>这三种方法可以绕开FLP不可能定理</p><h3 id="4-2-2-故障屏蔽"><a href="#4-2-2-故障屏蔽" class="headerlink" title="4.2.2 故障屏蔽"></a>4.2.2 故障屏蔽</h3><p>故障屏蔽（Fault tolerance）和故障检测器（Fault detection）是分布式系统中常用的技术，用于提高系统的可靠性和鲁棒性。使用随机性算法是实现这些技术的一种常用方法。</p><p>故障屏蔽是一种技术，可以在系统中发生故障时保证系统的正常运行。一种常见的故障屏蔽技术是冗余备份（Redundancy），即在系统中增加多个备份，当一个节点发生故障时，备份节点可以接管其任务，保证系统的正常运行。在实现冗余备份时，常常使用随机性算法，如随机化选举（Randomized election）和随机化复制（Randomized replication）等技术，来提高系统的可靠性和鲁棒性。</p><h3 id="4-2-3-使用故障检测器"><a href="#4-2-3-使用故障检测器" class="headerlink" title="4.2.3 使用故障检测器"></a>4.2.3 使用故障检测器</h3><p>故障检测器是一种技术，用于检测分布式系统中的故障节点。一种常见的故障检测器是心跳检测（Heartbeat detection），即每个节点定期向其他节点发送心跳消息，检测是否有节点故障。在实现心跳检测时，常常使用随机性算法，如随机化时间间隔（Randomized interval）和随机化路线（Randomized routing）等技术，来避免故障检测过程中的死锁和瓶颈等问题，提高检测的准确性和效率。</p><p>虽然完美的故障检测器具备以下条件：</p><ul><li>完全性：每一个故障的进程都会被每一个正确的进程怀疑</li><li>精确性：每一个正确的进程都不会被其他进程怀疑</li></ul><p>但实际上，实现困难。而论文证明，即使使用”不完美”的故障检测器，只要通信可靠，失效进程不超过一半，依然可以用来解决共识问题。因此实现最终弱故障检测器：</p><ul><li>最终弱完全性：每一个故障的进程最终都会被一些正确的进程检测到。</li><li>最终弱精确性：经过一段时间后，一个正确的进程不会被其他正确的进程怀疑。</li></ul><h3 id="4-2-4-使用随机性算法"><a href="#4-2-4-使用随机性算法" class="headerlink" title="4.2.4 使用随机性算法"></a>4.2.4 使用随机性算法</h3><p>随机性算法是指在算法设计和实现中引入随机性的一种技术，可以用于解决一些分布式系统中的复杂问题，如分布式计算、分布式存储、分布式共识等问题。随机性算法具有一些优点，如简单、快速、容易实现和分布式化等特点，可以提高分布式系统的性能和效率。</p><p><strong>区块链：</strong></p><p>Proof of Work（PoW）和Proof of Stake（PoS）是两种常见的区块链共识机制，用于保证区块链的安全性和去中心化特性。它们的主要区别在于如何选举出下一个区块的记账节点。</p><p>PoW机制是通过计算一定难度的工作量来选举出下一个区块的记账节点。矿工需要通过计算一个随机数，使得计算结果符合一定的规则，以此获得记账权。这种机制需要大量的计算能力和电力消耗，因此存在能源浪费和环境污染等问题。</p><p>PoS机制则是通过拥有一定数量的代币来选举出下一个区块的记账节点。持有更多代币的用户会有更大的概率被选中作为记账节点。这种机制可以避免计算资源和能源的浪费，但需要考虑如何避免寡头垄断和激励机制的问题。</p><p>以下是PoW和PoS机制的一些优缺点：</p><p>Proof of Work（PoW）:</p><ul><li>优点：安全性高，攻击成本高，可预测性好。</li><li>缺点：能源浪费，环境污染，效率低，中心化问题。</li></ul><p>Proof of Stake（PoS）:</p><ul><li>优点：节省能源，环保，效率高，可扩展性好，分散化程度高。</li><li>缺点：可能导致寡头垄断，激励机制难以设计，安全性有待验证。</li></ul><p>[(459条消息) [区块链]共识算法（POW,POS,DPOS,PBFT）介绍和心得_dpos共识机制_乐扣老师lekkoliu的博客-CSDN博客](<a href="https://blog.csdn.net/lsttoy/article/details/61624287?ops_request_misc=%7B%22request_id%22:%22168594614916800186538613%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168594614916800186538613&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-61624287-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=pow">https://blog.csdn.net/lsttoy/article/details/61624287?ops_request_misc=%7B%22request%5Fid%22%3A%22168594614916800186538613%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168594614916800186538613&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-61624287-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=pow</a> pos&amp;spm&#x3D;1018.2226.3001.4187)</p><p>[(459条消息) 区块链必知基础知识、POS、POW、DPOS、公有链、私有链、联盟链_区块链pos_yida&amp;yueda的博客-CSDN博客](<a href="https://blog.csdn.net/qq_40585384/article/details/124678390?ops_request_misc=&request_id=&biz_id=102&utm_term=pow">https://blog.csdn.net/qq_40585384/article/details/124678390?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=pow</a> pos&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-124678390.142^v88^control_2,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="4-3-同步系统中的共识"><a href="#4-3-同步系统中的共识" class="headerlink" title="4.3 同步系统中的共识"></a>4.3 同步系统中的共识</h2><p>Dolev-Strong算法是一种用于解决密码学中的安全多方计算（Secure Multiparty Computation，SMC）问题的算法。该算法由Danny Dolev和Hadas Shachnai-Strong于1991年提出。</p><p>安全多方计算是一种加密技术，允许多个参与者在不泄露私有信息的情况下共同计算出一个结果。在安全多方计算中，每个参与者需要负责保护自己的私有信息，同时协调计算过程以达到预期的结果。Dolev-Strong算法就是一种用于实现安全多方计算的算法之一。</p><p>Dolev-Strong算法基于一种名为交互式验证协议（Interactive Verification Protocol，IVP）的技术，通过多轮的通信和验证来确保计算的正确性和安全性。该算法可以在不需要信任第三方的情况下完成安全计算，因此具有很好的去中心化特性。</p><p>Dolev-Strong算法的主要思想是，<strong>将计算任务分解成多个子任务，每个参与者只负责计算其中的一部分，并将计算结果加密后传递给下一个参与者。在每个子任务之间，参与者需要进行验证，以确保计算的正确性和安全性。通过多轮的交互和验证，参与者最终可以得到正确的计算结果，同时保护自己的私有信息不被泄露。</strong></p><p>总的来说，Dolev-Strong算法是一种基于<strong>交互式验证协议</strong>的安全多方计算算法，可以在不需要信任第三方的情况下实现安全计算，具有很好的<strong>去中心化特性</strong>，被广泛应用于密码学、区块链和分布式系统等领域。</p><h2 id="4-4-Paxos"><a href="#4-4-Paxos" class="headerlink" title="4.4 Paxos"></a>4.4 Paxos</h2><p><a href="https://blog.csdn.net/weixin_45525272/article/details/127698249?ops_request_misc=%7B%22request_id%22:%22168174848616800213085420%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168174848616800213085420&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-127698249-null-null.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&utm_term=paxos&spm=1018.2226.3001.4187">(443条消息) 分布式共识算法——Paxos算法（图解）_杨 戬的博客-CSDN博客</a></p><p>Paxos算法是一种用于解决分布式系统中达成一致性的算法，由Leslie Lamport于1998年提出。Paxos算法的目的是保证分布式系统中各个节点之间的状态一致性，即在不可靠的网络环境下，保证不同节点对共享资源的操作具有相同的效果。</p><p>Paxos算法的核心思想是通过一个协调者（coordinator）和多个参与者（acceptor）之间的协作来达成共识。在Paxos算法中，协调者的主要任务是向参与者发起提案（proposal），而参与者的主要任务是接受并决策是否通过提案，进而达成一致性。</p><p>具体来说，Paxos算法分为三个阶段：</p><ol><li>准备阶段（prepare phase）：协调者向参与者发起提案，并请求参与者发送自己曾经接受的最大提案编号（proposal number），以便协调者了解当前的提案状态。</li><li>接受阶段（accept phase）：如果协调者获得了大多数参与者的反馈，并且没有其他提案正在进行，那么协调者就可以向参与者发起新的提案，并请求参与者接受该提案。</li><li>学习阶段（learn phase）：一旦协调者成功地向大多数参与者发送了新的提案，并得到了反馈，那么协调者就可以通知所有参与者接受该提案，从而完成一致性达成的过程。</li></ol><p>总的来说，Paxos算法是一种用于解决分布式系统中达成一致性的算法，通过协调者和参与者之间的协作来实现共识。该算法被广泛应用于分布式存储、分布式计算、分布式数据库和区块链等领域。</p><p>Paxos算法是一种非常复杂的算法，实现和理解上有一些细节需要注意：</p><ol><li>提案编号（proposal number）的生成方式需要确保唯一性和可比较性，一般使用时间戳和节点编号等信息组合而成。</li><li>在准备阶段，参与者需要检查当前提案的编号是否比自己之前接受的所有提案编号都要大。如果有更大的提案编号，参与者就需要返回该提案的编号和对应的值，以便协调者做出决策。</li><li>在接受阶段，协调者需要确保至少有半数的参与者接受了新的提案，并将其值写入日志。如果无法达成一致，协调者需要回退并重新发起提案。</li><li>在学习阶段，协调者需要通知所有参与者已经达成共识，并将提案值写入共享存储中。</li><li>Paxos算法还需要考虑一些异常情况，例如节点宕机、网络延迟和网络分区等，需要通过复杂的协议来保证系统的可用性和一致性。</li></ol><p>需要注意的是，Paxos算法是一种非常复杂的算法，对于初学者来说理解起来比较困难。因此，建议在实践中结合阅读相关文献和代码实现，逐步理解其细节和原理。</p><p><strong>为什么要提案编号？</strong></p><ul><li>分布式系统使用时间戳之类的物理时间可能并不准确</li><li>轮次+服务器id</li></ul><h2 id="4-5-Go实现Paxos"><a href="#4-5-Go实现Paxos" class="headerlink" title="4.5 Go实现Paxos"></a>4.5 Go实现Paxos</h2><h2 id="4-6-Multi-Paxos"><a href="#4-6-Multi-Paxos" class="headerlink" title="4.6 Multi-Paxos"></a>4.6 Multi-Paxos</h2><p>Multi-Paxos是Paxos算法的一个变种，用于优化Paxos算法在多次提案的情况下的性能。在Paxos算法中，每次提案都需要执行一次完整的Paxos流程，包括准备、接受和学习三个阶段，这会导致Paxos算法的性能比较低。</p><p>Multi-Paxos通过引入领导者（leader）的概念来优化Paxos算法的性能。在Multi-Paxos中，领导者负责向参与者发起提案，而参与者则只需要根据领导者的指示来决策是否接受提案。因此，领导者可以在一段时间内发起多个提案，从而避免了每次提案都需要执行完整的Paxos流程的问题。</p><p>具体来说，Multi-Paxos的流程如下：</p><ol><li>领导者向参与者发起一个提案，包括提案编号和提案值。</li><li>参与者根据提案编号进行决策：如果当前的提案编号比之前接受的所有提案编号都要大，那么参与者就接受该提案，并向领导者发送接受消息；否则，参与者就拒绝该提案，并向领导者发送拒绝消息。</li><li>如果领导者收到了大多数参与者的接受消息，那么该提案就被确定，并向所有参与者发送确定消息，完成该提案的学习阶段。</li><li>如果领导者收到了大多数参与者的拒绝消息，那么领导者就需要重新选择一个提案编号，并重新发起提案。</li></ol><p>需要注意的是，Multi-Paxos仍然需要保证Paxos算法的正确性和一致性，但通过引入领导者来优化性能，使得Multi-Paxos在实际应用中更加高效。</p><h2 id="4-8-Raft算法"><a href="#4-8-Raft算法" class="headerlink" title="4.8 Raft算法"></a>4.8 Raft算法</h2><p><strong>要持久化存储的信息：</strong></p><ul><li>currentTerm：当前任期，用于恢复</li><li>votefor:向谁投票，只投个第一个发送RequestVote RPC的人而拒绝其他发送RequestVote RPC的人</li><li>日志：包含索引位置，任期号，命令本身，如果日志在半数节点上被存储，则该记录可提交。注意，领导者先将日志持久化存储到本地，再并行用AppendEntries RPC发送到其他节点上。这时，如果收到超过半数的响应，则领导者将命令应用于自己的状态机，提交该日志，然后向客户端返回响应。后续的日志复制RPC中还包含LeaderCommit表明领导者已经提交的日志的最大索引，跟随者收到此RPC时也会提交所有小于该索引的日志</li></ul><p><strong>两个RPC：</strong></p><ul><li>RequestVote RPC ：用于领导者选举，包含term,id,lastLogIndex,lastLogTerm，同样在用于领导者选举中，最后两个属性若term&gt;跟随者的term或者term相等但index大于跟随者最后一条日志的index，则跟随者才会投票，同理也需要一半投票才行，这确保了领导者在超过半数给他投票的节点中拥有最完整的日志。</li><li>AppendEntries RPC ： 用于复制日志&#x2F;发送心跳信息，后续的日志复制RPC中还包含LeaderCommit表明领导者已经提交的日志的最大索引，跟随者收到此RPC时也会提交所有小于该索引的日志</li></ul><p><strong>节点转换流程：</strong></p><ul><li><p><img src="https://s2.loli.net/2024/06/26/Ta59hwiKOP8bEAI.jpg" alt="184BF7AF3986E254E406FB773D48170F.jpg"></p></li><li><p>只有发生以下三种情况之一才更新自己的状态</p><ul><li>RequestVote RPC收到超过半数的选票，变为领导者</li><li>收到来自其他领导者的AppendEntries，退化为跟随者</li><li>没发生上述两种情况，任期++，投自己一票</li><li><img src="https://s2.loli.net/2024/06/26/PAk64Yw2OWc7rzm.jpg" alt="D2DEF7CFA7530BD2C2B1301FAA8C0159.jpg"></li></ul></li></ul><p><strong>保证两个特性：</strong></p><ul><li>安全性：一个任期内最多只有一个领导者被选出来</li><li>活性：系统最终能选出一个领导者</li></ul><p><strong>解决活锁问题（没人可以获得超过一半选票）：</strong></p><ul><li>节点随机选择超时时间（T-2T期间，T越大于网络传播时间效果越加，但同时不能太大，否则性能会受到影响）</li></ul><p><strong>两个特性：</strong></p><ul><li>如果任期和索引相同，则日志条目完全相同，日志内容相同，且之前的日志也完全相同（数学归纳法？）</li><li>RAFT不允许出现日志空洞，必须连续提交日志</li><li>为了维护这两个特性，在AppendEntries中还有之前一个日志的prevLogIndex和任期prevLogTerm，跟随者收到后，会检查自己最后一条日志的index和term是否匹配，若匹配，则接受，否则拒绝。（一致性检查）</li></ul><p><strong>延迟提交：</strong></p><ul><li>为什么需要延迟提交？<ul><li>若出现网络分区，导致B分区中的一个服务器拥有更新任期的日志（比如3），而A分区中的领导者（此时在任期4，而最新的日志任期为2），若提交后宕机（而A分区中其他服务器的日志任期也为2，但未提交），而B分区中的服务器此时恰好又成为新的领导者（任期5），此时则会覆盖掉A分区中未提交任期为日志2的服务器的日志，而实际上，A分区之前的领导者实际上已经提交了该日志，这不符合已提交日志不能被修改的需求</li></ul></li><li>怎么延迟提交<ul><li>日志必须存储在超过半数节点上</li><li>领导者必须看到超过半数节点上还存储着至少一条自己任期内的记录</li><li>领导者只能提交自己任期的日志，从而间接提交之前任期的日志</li><li>no-op日志：只有索引和日期，保持领导者的权威<ul><li>在领导者刚选举成功时，就本地追加no-op日志（只包含任期），同时appendEntries到其他的节点，显然，no-op日志的任期就是领导者当前的任期，当然能提交，从而间接提交之前的任期的日志</li></ul></li></ul></li></ul><p><strong>清理不一样的日志：</strong></p><ul><li>两种不一样的日志，缺失&#x2F;多出来的<ul><li>前者直接AppendEntries来补齐（也要用到nextIndex）</li><li>后者，领导者为每个跟随者保存nextIndex[]变量，存储领导者最后一条日志的索引+1</li></ul></li><li>流程<ul><li>针对缺失的：领导者检查自己的日志，最新index为10，然后比如对于跟随者1，nextIndex[1]&#x3D;11,带上前一个日志条目的唯一标识（10，任期6），跟随者1索引为10处没有日志，递减nextIndex[1],直到nextIndex[1]&#x3D;5,索引4且任期4的日志匹配，补齐索引5-10</li><li>针对多出来的，跟上面一样，直到找到匹配的index，而之后的全部删除即可</li></ul></li></ul><p><strong>处理旧领导者：</strong></p><ul><li>RPC请求有自己的任期，如果发生网络分区，老的领导者还以为自己是领导者，他的RPC在被其他Follower接收到的时候，但凡Follower已知的任期比他新，都会返回拒绝消息，但凡接收到拒绝消息，老的领导者就跟咽了气的皮球似的变为跟随者。</li></ul><p><strong>配置变更：</strong></p><ul><li>使用 <strong>Joint Consensus</strong>（联合共识）完成两阶段协议<ul><li>第一阶段,C<strong>old+new</strong>，多数派，提交</li><li>第二阶段,Cnew，多数派，提交，提交后后续配置都基于Cnew（不在Cnew的领导者下台）<ul><li>不在Cnew的领导者下台会导致一个问题就是，不在Cnew的跟随者将不再收到心跳，因此其会参与领导者选举（尽管会因为日志不够新而导致竞选失败，但是还是会影响竞选过程导致可用性变差）<ul><li>解决：Pre-Vote阶段，就还是发送Pre-Vote请求询问整个系统“我到底有没有资格参与竞选”（这个资格还是根据任期以及日志Index来判断的）。但这样会有个问题就是，如果在Cnew集群中的领导者还没有把Cnew的日志发到其跟随者上，也就是说，跟随者的日志还不够新，那么就算有Pre-Vote，可能还是会影响选举，导致不在Cnew的服务节点竞选成功</li><li>增强Pre-Vote判断条件：<ul><li>任期更大，或者任期相同索引更大</li><li>至少一次选举时间内没有收到领导者心跳</li></ul></li><li>注意到在Pre-Vote阶段不会增加自己的任期，所以Pre-Vote不仅可以解决配置更改干扰领导者的问题，还能解决网络分区脑裂和任期爆炸增长的问题</li><li>示例：etcd，将候选者细分为预候选者和候选者，前者发送Pre-Vote，不增加日期，后者发送RequestVote，会增加任期</li></ul></li></ul></li></ul></li></ul><p><strong>日志压缩：</strong></p><ul><li>关注最终状态</li><li>压缩后得到快照，持久化存储</li><li>每个服务器独立地压缩其已提交的日志</li><li>保存最后一条被丢弃的日志的索引和任期，用AppendEntries进行日志一致性的检查</li><li>一旦丢弃了前面部分的日志，领导者要承担两个责任：<ul><li>如果服务器重启了，则需要将最新的快照加载到状态机后再接收日志</li><li>向较慢的跟随着发送一致的状态快照(InstrallSnapshot RPC)</li></ul></li><li>LastIncludeIndex和LastIncludeTerm，记录状态，之前的日志全部丢弃</li><li>在正常运行期间通过写时复制技术（COW）生成快照（开源LogCabin）</li></ul><h2 id="4-9-Raft和Paxos"><a href="#4-9-Raft和Paxos" class="headerlink" title="4.9 Raft和Paxos"></a>4.9 Raft和Paxos</h2><p>Raft和Paxos都是分布式一致性算法，它们都被广泛应用于构建高可用性、高可靠性的分布式系统。</p><p>Paxos是最早提出的分布式一致性算法之一，由Leslie Lamport在1990年代初期提出。Paxos算法包含了两个主要的组件：leader选举和状态复制。它的核心思想是通过在节点之间达成共识来实现状态的复制和一致性。</p><p>Raft是一种新近出现的分布式一致性算法，由Diego Ongaro和John Ousterhout于2013年提出。Raft算法也包含了leader选举和状态复制两个主要部分，它强化了容错机制和可读性，使得它更容易被理解和实现。</p><p>相比而言，Raft与Paxos相比较具有以下优势：</p><ol><li>理解和实现容易：Raft算法把分布式一致性问题分成了几个独立的子问题，分别处理，每个子问题都比较容易理解和实现，使得整个算法更加容易理解和实现。</li><li>更好的可读性：Raft的算法描述更接近日常使用中的术语，更容易理解，在阅读和修改代码时更加方便。</li><li>更好的性能：Raft算法的性能比Paxos算法更好，特别是在网络不稳定或者出现网络分区的情况下，Raft算法的表现更加优秀。</li></ol><p>总之，虽然Raft和Paxos都是用于实现分布式一致性的算法，但是它们有着不同的设计思路和实现方式。Raft算法在易用性和可读性方面，相对Paxos算法更胜一筹，但在实际的应用场景中，不同的问题需要选择最适合的算法来解决。</p><h2 id="4-10-拜占庭容错和PBFT算法"><a href="#4-10-拜占庭容错和PBFT算法" class="headerlink" title="4.10 拜占庭容错和PBFT算法"></a>4.10 拜占庭容错和PBFT算法</h2><p>Raft和Paxos，都是非常高效的算法，他们只支持CFT（Crash fault tolerance），只允许系统内节点宕机（crash），并不考虑系统内有作恶节点。</p><p><a href="https://zhuanlan.zhihu.com/p/53897982">共识算法系列：PBFT算法关键点综述、优缺点总结 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/35847127">共识算法系列之一：raft和pbft算法 - 知乎 (zhihu.com)</a></p><p><img src="https://s2.loli.net/2024/06/26/KorHVJc7exkftXw.webp" alt="v2-1b29af254f0cc338876f232e32415878_1440w[1].webp"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 深入理解分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分布式系统（六）时间和事件顺序</title>
      <link href="/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89%E6%97%B6%E9%97%B4%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A1%BA%E5%BA%8F/"/>
      <url>/2024/06/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89%E6%97%B6%E9%97%B4%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="时间和事件顺序"><a href="#时间和事件顺序" class="headerlink" title="时间和事件顺序"></a>时间和事件顺序</h1><h2 id="6-1-物理时钟"><a href="#6-1-物理时钟" class="headerlink" title="6.1 物理时钟"></a>6.1 物理时钟</h2><ul><li>机械时钟</li><li>石英时钟</li><li>原子钟：原子共振频率标准来计算</li><li>GPS</li></ul><h2 id="6-2-时钟同步"><a href="#6-2-时钟同步" class="headerlink" title="6.2 时钟同步"></a>6.2 时钟同步</h2><p>NTP:<a href="https://blog.csdn.net/weixin_45057618/article/details/120200341?ops_request_misc=%7B%22request_id%22:%22168243248816800182751293%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168243248816800182751293&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-120200341-null-null.142%5Ev86%5Einsert_down38v5,239%5Ev2%5Einsert_chatgpt&utm_term=NTP%E5%8D%8F%E8%AE%AE&spm=1018.2226.3001.4187">(430条消息) NTP详解(网络时间协议)_127.127.1.0 ntp含义_思福迪小白的博客-CSDN博客</a></p><p>针对NTP同步导致时间回退甚至是负数的情况–单调时钟，保证返回的时间严格单调增长</p><p>Cloudflare没用单调时钟，而是在发现时间差为负数或者0时变为一个默认值（golang没暴露单调时钟）</p><p>单调时钟的局限性：以自身所在的计算机的某个时间为起点，也就是说，来自同一个节点的单调时钟才有意义。</p><p>如何发明分布式系统中的单调时钟？</p><h2 id="6-3-逻辑时钟"><a href="#6-3-逻辑时钟" class="headerlink" title="6.3 逻辑时钟"></a>6.3 逻辑时钟</h2><p>Lamport Clock</p><p>Happens-Before:</p><p>​if a-&gt;b</p><ul><li>if a and b are in the same process, and a is before b, then a-&gt;b</li><li>if a is the event that sends a message , b is the event that receives the message, then a-&gt;b.</li><li>if a-&gt;b and b-&gt;c, then a-&gt;c; if a &#x2F;-&gt;b or b&#x2F;-&gt;a, then a and b are in concurrency(a||b).</li></ul><p>a-&gt;b, then C(a)&lt;C(b)</p><p>C(a)&lt;C(b), a&#x2F;-&gt;b</p><ul><li>每个进程都有自己的逻辑时钟，初始值为0</li><li>如果进程i内部发生一个新的事件，那么将其逻辑时钟加一，即Ci&#x3D; Ci+1</li><li>if process i sends a message to process j , and the logic clock in process i is C(i), then, firstly, C(i)&#x3D;C(i)+1, and then, i sends Ci and the message to process j, and then, process j updates its logic clock Cj&#x3D; max(Ci,Cj)+1</li></ul><p>根据离散数学的关系而言，逻辑时钟和物理时钟的区别在于，物理时钟的先后关系是一种total ordering，是全局可见的一种关系，谁先谁后一目了然；然而逻辑时钟 is a kind of partial ordering，只有部分元素的先后关系（本质原因是，我们不能根据逻辑时间的先后去判定逻辑业务的先后）</p><p>如何使逻辑时钟也具有全序关系？给进程加上优先级，但是赋予进程不同的优先级排序会有不同的全序关系</p><p>RAFT的任期、选举算法、日志和状态机的思想等都出自这篇论文（Lamport,Leslie.”Time,clocks,and the ordering of events in a distributed system.”Concurrency: the Works of Leslie Lamport. 2019.179-196）：</p><ul><li>一个<strong>去中心化的算法</strong>，通过逻辑时钟实现分布式资源互斥来分配资源</li><li>每个进程维护一个消息队列，消息的格式为Tm: Pi, 即为第i个进程在Tm的逻辑时钟下发送的消息</li><li>进程维护自己的消息，也接收别人的消息，决定自己是否能够获取资源的条件<ul><li>消息队列中除开自己的消息之外的消息的逻辑时间，均大于自己的消息</li><li>排在队头的消息是自己的消息（这里消息的插入可以是对头队尾，也可以是中间）</li></ul></li></ul><h2 id="6-4-向量时钟"><a href="#6-4-向量时钟" class="headerlink" title="6.4 向量时钟"></a>6.4 向量时钟</h2><p>跟逻辑时钟很类似，只不过逻辑时钟只考虑了本地的逻辑时间，而向量时钟的维度为节点数，维护全局的时间。</p><p>向量时钟（Vector Clock）是一种在分布式系统中用于记录事件发生顺序的机制。它通过给每个节点分配一个独特的向量来跟踪每个节点上的事件发生次数，这个向量被称为向量时钟。</p><p>向量时钟的大小等于节点数，每个元素代表了一个节点的时间戳。当一个事件发生时，对应节点的时间戳会自增1。如果两个事件发生在不同的节点上，那么它们的时间戳是相互独立的，无法比较先后顺序；但如果它们发生在同一个节点上，就可以用向量时钟来比较它们的先后顺序。比如说，设有A,B,C三个节点，此时在A节点上发生了一个事件，那么其向量时钟会变为[1,0,0]，因为这是A节点上第一个事件。如果随后在C节点上发生了一个事件，那么其向量时钟会变为[0,0,1]，因为这是C节点上第一个事件。如果再在B节点上发生了一个事件，那么其向量时钟会变为[0,1,0]，因为这是B节点上第一个事件。这样，在整个分布式系统中，我们得到了A为[1,0,0]，B为[0,1,0]，C为[0,0,1]的向量时钟。</p><p>当一条消息从一个节点传递到另一个节点时，消息中会包含发送方的向量时钟。接收方在收到消息后，将它自己的向量时钟和接收到的消息中的向量时钟进行比较，取每个位置上较大的值作为新的时间戳。然后将接收到的消息的时间戳同步到本地，再加上1，表示接收到了这条消息。这样，接收方就可以知道这条消息是在哪个节点上发送的，以及这条消息的先后顺序。</p><p>向量时钟不仅能够帮助我们比较事件间的先后关系，还能检测出并发事件。比如说，如果两个事件A和B同时发生，那么它们对各自持有的向量时钟都会影响到相应的位置上，导致这两个节点上的向量时钟不一致。这样，我们就可以检测出这两个事件的并发性。</p><p>缺点在于，向量的维度与节点数正相关，随着节点增多，向量时钟越大，向量时钟需要大量的磁盘和内存空间，同时需要更长的时间来计算和比较。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 深入理解分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4&amp;SRV6</title>
      <link href="/2024/06/24/B-EP2/"/>
      <url>/2024/06/24/B-EP2/</url>
      
        <content type="html"><![CDATA[<h1 id="B-EP2"><a href="#B-EP2" class="headerlink" title="B-EP2"></a>B-EP2</h1><p>背景：互联网变得臃肿，网络管理员迫切需要一种快速高效的<strong>网络遥测方案</strong>，能够利用采集到的实时准确的网络状态信息来快速检测和定位常见网络故障，然后需要一个有效的<strong>网络控制和管理（NC&amp;M）方案</strong>，以实现只能及时决策以在网络路径上<strong>梳理和路由流量</strong>，以同时实现<strong>高效的利用和高质量的服务（QoS</strong>）。</p><ul><li>采集网络信息，定位故障</li><li>有效的网络控制和管理方案</li></ul><p><a href="https://blog.csdn.net/hjxzb/article/details/91141685?ops_request_misc=%7B%22request_id%22:%22168753985816782427413509%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168753985816782427413509&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-91141685-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=P4&spm=1018.2226.3001.4187">(465条消息) P4学习笔记（一）初识P4_p4接口是干嘛的_程序员学编程的博客-CSDN博客</a></p><ol><li><p>基于P4的主动遥测</p><ul><li><p>探针代替数据分组进行遥测，降低了遥测开销（因为数组分组比如INT即带内网络遥测<a href="https://blog.csdn.net/weixin_47104688/article/details/123229563?ops_request_misc=%7B%22request_id%22:%22168606788516800222871187%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168606788516800222871187&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-123229563-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=INT%E5%B8%A6%E5%86%85&spm=1018.2226.3001.4187">(460条消息) 带内网络遥测INT–In-band Network Telemetry_袁冬至的博客-CSDN博客</a></p><p><img src="https://s2.loli.net/2024/06/24/pdxWMcIf7mgeRLJ.jpg" alt="SDN.png"></p><p><a href="https://www.sdnlab.com/23822.html">https://www.sdnlab.com/23822.html</a></p><p><a href="https://blog.csdn.net/changqing1234/article/details/103669835?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-103669835-blog-123229563.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-103669835-blog-123229563.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=1">(465条消息) Telemetry 技术概述_LeocenaY的博客-CSDN博客</a></p><p>，在转发数据分组时能够在数据在网络结构流动的过程中，通过在路径中间节点插入元数据，监控系统可以通过这些元数据进行收集网络状态，但这样载荷比就大)，INT之类的带内网络遥测也存在一些局限性，难以获取全局网络试图。这样就加入了探针进行主动遥测，提高数据分组的有效载荷比。</p><p><a href="https://www.sdnlab.com/23822.html">一文读懂带内网络遥测技术 | SDNLAB | 专注网络创新技术</a></p></li></ul></li><li><p>基于段路由（基于IPV6的一向技术）</p><p><img src="https://s2.loli.net/2024/06/26/CJNZUQIAzHT2E6O.png" alt="image-20230607005803362.png"></p><p><a href="https://blog.csdn.net/m0_49864110/article/details/123591943?ops_request_misc=%7B%22request_id%22:%22168606977016800225513092%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168606977016800225513092&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123591943-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=SRV6&spm=1018.2226.3001.4187">(460条消息) 广域网技术——SRv6 SID讲解_静下心来敲木鱼的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/Ether_Dzh/article/details/119847548?ops_request_misc=%7B%22request_id%22:%22168754187716800227440687%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168754187716800227440687&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-119847548-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=SRV6&spm=1018.2226.3001.4187">(465条消息) 1.2、SRv6(Segment Routing Over IPv6) 介绍_srv6技术是什么_Ether_Dzh的博客-CSDN博客</a></p><p><img src="https://s2.loli.net/2024/06/24/zMpDeVWXRC46Fnd.jpg" alt="网络编程.png"></p><ul><li>改变SR标签和排列顺序指定探测路径</li><li>探针加入SR标签栈获取全面的网络视图，环形探测路径，单个探测点具备探针发送端和接收端功能，减少多个探测点之间同步协调探针等复杂操作。</li><li>减少遥测冗余，探针分组中加入遥测指示域，指定需要采集的遥测数据</li><li>将可编程设备的内部状态的状态信息嵌入到探针中，通过可编程设备的定制化能力自定义数据分组处理逻辑来是实现。</li></ul></li></ol><p>SDN控制面：可编程环境</p><p>可集中控制网络：SDN域由集中统一的控制单元实施管理</p><p>转发和控制分离</p><p>P4：</p><ul><li><p>可以对网络设备芯片逻辑进行编程</p></li><li><p>可重配置性：支持转发逻辑代码经过编译部署到具体平台上之后动态修改报文</p></li><li><p>不绑定某个具体的网络协议</p></li><li><p>平台无关性：独立于特定的底层运行平台来编写数据报文处理逻辑</p></li><li><p>需要特定交换机的支持</p></li><li><p>数据采集与感知：</p><ol><li>通过ONOS（一体化的网络操作系统）的Restful北向接口查询得到的ONOS特有数据库内的全局网络信息（但忽略细节）<a href="https://blog.csdn.net/weixin_34384681/article/details/91849632?ops_request_misc=%7B%22request_id%22:%22168606907716800227458444%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168606907716800227458444&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-6-91849632-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=ONOS&spm=1018.2226.3001.4187">(460条消息) ONOS预热篇之ONOS简介_weixin_34384681的博客-CSDN博客</a></li><li>数据层交换机中的数据流，插入探针，数据采集服务链，提取各个包的特征进行统计</li><li>基于段路由机制，进行INT主动遥测（INT本身是有局限性的，探测路径需要提前指定，而借助段路由机制进行主动网络遥测，降低成本提高了灵活性），流量包中插入探针，快速获取探测包路径上的第一手数据平面遥测数据</li></ol></li><li><p>这里的智能分析与决策采用深度学习相关的东西</p></li><li><p>可编程动态管控（P4）：仅管理数据平面如何处理数据包，定义控制平面与数据平面通信的接口，但不描述控制平面功能</p></li><li><p>传统交换机和P4交换机</p><p>在传统交换机中，制造商定义了数据平面的功能，控制平面通过一些管理表（如路由表）中的条目以及处理控制数据包（如路由协议数据包）或异步事件（如链路状态更改或学习通知）来控制数据平面。</p><p>P4可编程交换机与传统交换机的区别主要体现在两个方面：</p><ul><li>数据平面功能不是预先固定的，而是由 P4 程序定义的。数据平面在初始化时配置为实现 P4 程序描述的功能（由红色长箭头显示），并且没有现有网络协议的内置知识。</li><li>控制平面使用与固定功能设备中相同的通道与数据平面进行通信，但数据平面中的表集合和其他对象不再是固定的，因为它们由 P4 程序定义。P4 编译器生成控制平面用于与数据平面通信的 API。</li></ul></li><li><p>控制平面（SDN控制器）如何与P4的设备进行通信？</p><ul><li><p>P4Runtime（基于gRPC框架）</p></li><li><p>OpenFlow协议中，控制器和设备是由控制器开放端口，设备才能连接上控制器；而P4Runtime是设备上开始gRPC,控制器连接设备，因此，在支持P4的设备上也会有一个代理的Agent去处理控制器来的连接</p></li></ul></li></ul><p>鉴于基于P4的被动网络遥测可扩展性不足的缺点，首先要保证的就是主动遥测的探测路径在运行时是灵活可控的，我们采用段路由机制来灵活控制探针的探测路径（这里的路径生成采用了<a href="https://blog.csdn.net/KCDCY/article/details/124732427?ops_request_misc=%7B%22request_id%22:%22168606887816800222897225%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168606887816800222897225&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124732427-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%AC%A7%E6%8B%89%E9%80%9A%E8%B7%AF%E7%AE%97%E6%B3%95">Hierholzer <em>算法</em>，欧拉回路</a>）。段路由机制简单易用，不需要额外的协议支持，通过组合一系列简单的网络操作指令就可以完全控制数据分组的转发路径。在降低了网络成本的同时也提高了灵活性。最后段路由能够支持增量部署，降低了部署难度，可行性好。该系统下可以灵活定义遥测路径，按需探测可能或已经出现问题的路径，快速定位故障位置。同时，可以在探针格式中加入探测遥测数据类型的字段来支持按需获取遥测数据。同时要保证能够采集到网络设备内部的状态信息等细粒度准确的遥测数据，我们可以通过修改可编程设备的数据平面处理逻辑来区分正常数据分组和探针数据分组，对于正常数据分组直接正常转发，而对于探针数据分组匹配其中的路径转发标签以及遥测指令字段，将实时的网络状态信息封装在探针数据分组中。</p>]]></content>
      
      
      <categories>
          
          <category> SDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN </tag>
            
            <tag> P4 </tag>
            
            <tag> SRV6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研复习准备</title>
      <link href="/2024/06/24/%E4%BF%9D%E7%A0%94/"/>
      <url>/2024/06/24/%E4%BF%9D%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h1><p><a href="https://blog.csdn.net/zqm_0015/article/details/109236372">(453条消息) 2021年计算机保研面试题_一个主机将两个端口接到网络上是否会提升吞吐量_Challow的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/Baoyan_cs/article/details/124314177">(453条消息) 吐血整理，20个计算机保研常见问题及回答模板_计算机专业20个面试常见问题_Baoyan_cs的博客-CSDN博客</a></p><p>[(453条消息) 2021计算机保研经历(清软, 北深, 浙大, 南大, 中科大, 北航, 哈深, 南开, 华科, 武大, 中大)_inicho的博客-CSDN博客](<a href="https://blog.csdn.net/qq_43280818/article/details/123450451?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">https://blog.csdn.net/qq_43280818/article/details/123450451?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=计算机网络</a> 保研&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-9-123450451.142^v87^insert_down28,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><p>[(453条消息) 计算机网络保研面试题整理（自用）_乌鸡摸鱼的博客-CSDN博客](<a href="https://blog.csdn.net/m0_52571748/article/details/119513761?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">https://blog.csdn.net/m0_52571748/article/details/119513761?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=计算机网络</a> 保研&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-1-119513761.142^v87^insert_down28,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><p>[(453条消息) 计算机专业保研面试复习笔记——计算机网络_计算机保研复习_欧二lord的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_43117620/article/details/109198194?ops_request_misc=%7B%22request_id%22:%22168433738716800227438825%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168433738716800227438825&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-109198194-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">https://blog.csdn.net/weixin_43117620/article/details/109198194?ops_request_misc=%7B%22request%5Fid%22%3A%22168433738716800227438825%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168433738716800227438825&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-109198194-null-null.142^v87^insert_down28,239^v2^insert_chatgpt&amp;utm_term=计算机网络</a> 保研&amp;spm&#x3D;1018.2226.3001.4187)</p><p><a href="https://blog.csdn.net/weixin_46893257/article/details/116306838?ops_request_misc=%7B%22request_id%22:%22168470925916800215052847%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168470925916800215052847&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-116306838-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=IPv6%E6%B5%81%E6%A0%87%E7%AD%BE&spm=1018.2226.3001.4187">(454条消息) IPV6基本报头_ipv6报头_yibasuo18176的博客-CSDN博客</a></p><p>[(454条消息) BGP、IBGP、EBGP、IGP、EGP_bgp和egp的区别_zhaomax的博客-CSDN博客](<a href="https://blog.csdn.net/zhaomax/article/details/52399403?ops_request_misc=&request_id=&biz_id=102&utm_term=IGP">https://blog.csdn.net/zhaomax/article/details/52399403?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=IGP</a> BGP&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-4-52399403.142^v87^insert_down28,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><a href="https://blog.csdn.net/m0_52571748/article/details/119512934">(453条消息) 计算机操作系统保研面试题整理（自用）_乌鸡摸鱼csdn_乌鸡摸鱼的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/love521314123/article/details/119682266">(453条消息) 操作系统笔记（含王道计算机考研——操作系统课件）_操作系统考研笔记_一只不吃老鼠的猫的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/lishanleilixin/article/details/89709194">(454条消息) OS之存储管理 — 磁盘调度算法_os 对磁盘操作 写优先_如是说如是的博客-CSDN博客</a></p><h2 id="计组"><a href="#计组" class="headerlink" title="计组"></a>计组</h2><p><a href="https://blog.csdn.net/m0_52571748/article/details/119530739?ops_request_misc=%7B%22request_id%22:%22168433894316800197057897%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168433894316800197057897&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-119530739-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BF%9D%E7%A0%94&spm=1018.2226.3001.4187">(453条消息) 计算机组成原理保研面试题整理（自用）_计算机组成原理面试题_乌鸡摸鱼的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/love521314123/article/details/122825247#comments_26524593">(453条消息) 王道计算机考研——计算机组成原理笔记_王道计算机组成原理_一只不吃老鼠的猫的博客-CSDN博客</a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="https://blog.csdn.net/weixin_43790779/article/details/120934734?ops_request_misc=%7B%22request_id%22:%22168433902416800226547104%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168433902416800226547104&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120934734-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BF%9D%E7%A0%94&spm=1018.2226.3001.4187">(453条消息) 保研面试复习之数据结构篇_数据结构保研复习_abtgu的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_40113925/article/details/100938378?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-100938378-blog-120934734.235%5Ev36%5Epc_relevant_anti_vip&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-100938378-blog-120934734.235%5Ev36%5Epc_relevant_anti_vip&utm_relevant_index=3">(453条消息) 数据结构基础概念知识点_保研&#x2F;考研&#x2F;面试复习_顺序哈希分块折半_Raising_的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/whz_zb/article/details/7425152?ops_request_misc=%7B%22request_id%22:%22168465798116800182114693%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168465798116800182114693&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-7425152-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%83%9C%E8%80%85%E6%A0%91%E5%92%8C%E8%B4%A5%E8%80%85%E6%A0%91&spm=1018.2226.3001.4187">(454条消息) 胜者树与败者树_胜者树和败者树_whz_zb的博客-CSDN博客</a></p><p>[(454条消息) 详解全局变量，全局变量与静态变量的区别_静态变量和全局变量_舒泱的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_43222324/article/details/106989714?ops_request_misc=%7B%22request_id%22:%22168474123716800226594104%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168474123716800226594104&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-106989714-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">https://blog.csdn.net/weixin_43222324/article/details/106989714?ops_request_misc=%7B%22request%5Fid%22%3A%22168474123716800226594104%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168474123716800226594104&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-106989714-null-null.142^v87^insert_down28,239^v2^insert_chatgpt&amp;utm_term=全局变量</a> 静态变量&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><p><a href="https://uestc.feishu.cn/file/boxcnT7mKncOLwyhbDjSGrCPhed">概率论.pdf - 成电飞书云文档 (feishu.cn)</a></p><h2 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h2><p><a href="https://uestc.feishu.cn/file/QdMtbKWaDofazmxMw6EcHqFyndc">高等数学知识点最全汇总.pdf - 成电飞书云文档 (feishu.cn)</a></p><p><a href="https://blog.csdn.net/crj0926/article/details/101761433?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%E5%92%8C%E5%8F%98%E6%8D%A2%E5%8C%BA%E5%88%AB&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-101761433.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(454条消息) 傅里叶级数和傅里叶变换简介和推导_傅里叶级数和傅里叶变换的区别和联系_HKDER的博客-CSDN博客</a></p><h2 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h2><p><a href="https://uestc.feishu.cn/file/PjBcbDESvoKrngxSYHScvkCInJd">离散数学.docx - 成电飞书云文档 (feishu.cn)</a></p><h2 id="线代"><a href="#线代" class="headerlink" title="线代"></a>线代</h2><p><a href="https://uestc.feishu.cn/file/HzV3b1Wxno1LFaxF6G9c1VKunzg">线代.pdf - 成电飞书云文档 (feishu.cn)</a></p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><a href="https://uestc.feishu.cn/file/boxcn0xg2vSIlKrccY2Y32c7Hye">数据库.pdf - 成电飞书云文档 (feishu.cn)</a></p><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><h2 id="JAVA-C"><a href="#JAVA-C" class="headerlink" title="JAVA&amp;C++"></a>JAVA&amp;C++</h2><p>[(454条消息) java—垃圾回收算法(GC)_会飞的猪zhu的博客-CSDN博客](<a href="https://blog.csdn.net/m0_58196614/article/details/126426266?ops_request_misc=&request_id=&biz_id=102&utm_term=Java">https://blog.csdn.net/m0_58196614/article/details/126426266?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Java</a> 的垃圾回收算法&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-126426266.142^v87^insert_down28,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="经验贴"><a href="#经验贴" class="headerlink" title="经验贴"></a>经验贴</h2><p><a href="https://zhuanlan.zhihu.com/p/415169966">2021年计算机保研经验帖 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/569448591">2022南大cs夏令营笔试面试准备 - 知乎 (zhihu.com)</a></p><p><a href="https://www.rstk.cn/news/624725.html?action=onClick">https://www.rstk.cn/news/624725.html?action=onClick</a></p><p><a href="https://zhuanlan.zhihu.com/p/377444777">2021年半跨CS保研经历（已上岸pku） - 知乎 (zhihu.com)</a></p><h2 id="机试真题"><a href="#机试真题" class="headerlink" title="机试真题"></a>机试真题</h2><p><a href="https://github.com/Muyiyunzi/BUAA-CS-Codes">Muyiyunzi&#x2F;BUAA-CS-Codes: 北京航空航天大学计算机学院研究生考试复试上机部分往年试题及解答 (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研经验贴</title>
      <link href="/2024/06/24/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
      <url>/2024/06/24/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="保研经验贴"><a href="#保研经验贴" class="headerlink" title="保研经验贴"></a>保研经验贴</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天被两三个25届的同学问到保研的事 尘封许久的记忆再次打开 再次汇总了之前收到的所有信息和仅存的记忆 给一点模板上的参考<br>注:是疫情解封后第一次线下 故之前很多经验贴没有参考性</p><p>bg: 985本SE</p><p>rank: 3&#x2F;181 3.99&#x2F;4.00</p><p>论文: 无</p><p>竞赛: 双国三 双省一 一省三 n校奖</p><p>奖学金: 两年国奖</p><p>方向: 分布式系统&#x2F;存储 偏架构和系统设计方向</p><p>实习: 某自驾公司地图存储系统&#x2F;字节抖音电商开发岗</p><p>由于夏令营已经上岸 故没有参加后续预推免</p><p>入营:</p><p>夏令营:</p><p>①北大计算机 直博（放弃且意愿不强 真不想读博）</p><p>②北大软微 硕士（计算机学院组➕老师 最终去向）</p><p>③中国科学院计算所 硕士</p><p>④上海交通大学电院 硕士</p><p>⑤南京大学计算机学院 硕士</p><p>⑥北京航空航天大学计算机学院 硕士（放弃）</p><p>⑦中国人民大学信院 硕士</p><p>⑧西安交通大学计算机学院 硕士</p><p>被拒:</p><p>①复旦大学计算机学院（只要第一我也没办法）</p><p>参加:</p><p>由于在实习真抽不开时间去其他地方参营</p><p>①北大软微</p><p>②北航计算机</p><p>③南大计算机（参加了部分 获得软件所的通过了但后面不是很想去参加了…跟北大有冲突也是个重要原因）<br>优营</p><p>①北大软微</p><p>②北航计算机</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>数学方面:</p><p>①概率论②线性代数③微积分④离散数学</p><p>这部分需要从头到尾过一遍 相关概念、联系一定要熟，各部分重点其实网上总结🉐十分详细了 一定好好准备！</p><p>英语方面:</p><p>①各种日常口语➕部分计算机相关专业的词汇 不需要特别详细 但我建议提早一个月进入状态</p><p>专业知识:</p><p>①数据结构②计算机网络③操作系统④计组⑤编译原理⑥机试！！！（别说其他语言了 现在学c++还来得及 STL弄熟➕王道机试指南➕力扣➕到处搜集真题 爆！！！）</p><p>四五很少考 南大计算机的笔试特别喜欢考编译原理——题简直又多又长又难 数据结构重中之重 机试一定好好准备！！！</p><h2 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h2><p>南大计算机（流程繁琐）</p><p>①最开始我记得是软件所有个面试，线上的，会问一些离散数学（平面图 哈密顿图等等）和一些数据结构的题 差不多十五分钟（这一部分是提前了差不多两个月进行的）</p><p>②后续在临近夏令营的时候还有一轮线上笔试 巨难（如果没学过编译原理就寄了）</p><p>③后续就是去线下啦 但遗憾没去看看美丽的仙林校区😭</p><p>北航计算机（特色大模拟➕不报销车费路费 甚至不包吃）</p><p>①第一天就是两道机试 总共两小时 第一道大模拟真的搞的头大（好在还是写对了） 第二道真是完全一点不会（不是常规的算法题） 这一轮🉐至少做对一个才能进入下一轮</p><p>②第二天面试 数学➕英语➕各种专业问题 甚至还问了我前端➕后端➕java和c++ python语言特性使用场景（好在哥们也是实习面试了几十轮还是信手拈来的）</p><p>老师全程压力面，不能怂！</p><p>然后优营发的很快，我记得是7月2号就发了，也是我第一个优营</p><p>北大软微</p><p>软微从22年开始比较特殊，首先据说要退学费，其次夏令营的师资和实验室可以是计算机学院&#x2F;智能学院的，加上还是硕士简直不要太香好吧</p><p>①第一天闲聊吹水 我就记得紫燕百味鸡外卖还挺好吃</p><p>②先来三道算法题！（30min 我们组跟系统方向强相关三道分别是mid mid hard难度的 可以写伪代码）其实我第三道有点问题但由于太自信甚至后续面试当场给出来数学证明让老师也疑惑住了</p><p>③面试: 自我介绍➕各种问题的提问 甚至问到我一些关于实习用到的juiceFS和一些底层的概念&#x2F;分布式共识&#x2F;运维&#x2F;缓存等，还问到代码量（必然是多多），以及数学上面的证明➕算法题复盘➕一些其他的问题，其实都还好，虽然没全准备过但意外达的非常好（最终拟录取看复试分数排名竟然差不多前1％）</p><p>优营隔了几天就发了 </p><h2 id="一些被问到的问题"><a href="#一些被问到的问题" class="headerlink" title="一些被问到的问题"></a>一些被问到的问题</h2><ol><li><p>论文是必须的吗？</p><p>有最好，如果搞ai必须有相关实习&#x2F;科研经历，如果走system路线有实习或者经历都行</p></li><li><p>四六级真的重要吗？</p><p>我觉得一般重要 不要太低就行</p></li><li><p>给计算机专业课重要程度排个序</p><p>数据结构＞计算机网络&#x3D;操作系统＞计组＞编译原理</p></li><li><p>事先套磁了吗？</p><p>五月份套了一个，但强com。我建议现在3月份就可以开始套了，越早越好！</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 经验贴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java刷题</title>
      <link href="/2024/06/24/Java%20algo/"/>
      <url>/2024/06/24/Java%20algo/</url>
      
        <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p><a href="https://blog.csdn.net/leader_song/article/details/132094080?ops_request_misc=%7B%22request_id%22:%22171151104816800211548110%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171151104816800211548110&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-132094080-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%872023&spm=1018.2226.3001.4187">2024年 Java 面试八股文（20w字）_java八股文2023-CSDN博客</a></p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p><a href="https://blog.csdn.net/weixin_43004044/article/details/126557968?ops_request_misc=%7B%22request_id%22:%22172025351316800188511203%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172025351316800188511203&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126557968-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=SQL%E9%A2%98&spm=1018.2226.3001.4187">SQL 50 题（MySQL 版，包括建库建表、插入数据等完整过程，适合复习 SQL 知识点）_sql50题-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_47882020/article/details/120826208?ops_request_misc=%7B%22request_id%22:%22172025532416800215087064%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172025532416800215087064&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-120826208-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=sql%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95&spm=1018.2226.3001.4187">SQL常见语句及用法_sql语句大全及用法-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq7652401741/article/details/100121549?ops_request_misc=%7B%22request_id%22:%22172033820916800188561235%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172033820916800188561235&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-100121549-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=SQL%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E5%92%8Cwhere&spm=1018.2226.3001.4187">SQL中的 聚合函数 ,where ,having_where后面可以跟聚合函数吗-CSDN博客</a></p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p><a href="https://blog.csdn.net/qq_62124267/article/details/135418799?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-135418799-blog-124295453.235%5Ev43%5Epc_blog_bottom_relevance_base7&spm=1001.2101.3001.4242.1&utm_relevant_index=1">面试被问了几百遍的 IOC 和 AOP ，一篇文章带你搞清楚！！！_ioc和aop的原理面试-CSDN博客</a></p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p><a href="https://blog.csdn.net/crazymakercircle/article/details/125059491?ops_request_misc=%7B%22request_id%22:%22171164453116800225568300%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171164453116800225568300&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125059491-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=sentinel&spm=1018.2226.3001.4187">sentinel （史上最全）-CSDN博客</a></p><h2 id="Gradle-Maven"><a href="#Gradle-Maven" class="headerlink" title="Gradle&amp;Maven"></a>Gradle&amp;Maven</h2><p><a href="https://flydean.blog.csdn.net/article/details/113803536?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-113803536-blog-133955312.235%5Ev43%5Epc_blog_bottom_relevance_base7&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-113803536-blog-133955312.235%5Ev43%5Epc_blog_bottom_relevance_base7&utm_relevant_index=2">gradle中的build script详解_gradle buildscript-CSDN博客</a></p><p>[Gradle和Maven的区别-CSDN博客](<a href="https://blog.csdn.net/weixin_45626288/article/details/131973787?ops_request_misc=%7B%22request_id%22:%22172024305816800185819613%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024305816800185819613&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-131973787-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=gradle">https://blog.csdn.net/weixin_45626288/article/details/131973787?ops_request_misc=%7B%22request%5Fid%22%3A%22172024305816800185819613%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=172024305816800185819613&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-131973787-null-null.142^v100^pc_search_result_base8&amp;utm_term=gradle</a> maven&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="线程池和锁"><a href="#线程池和锁" class="headerlink" title="线程池和锁"></a>线程池和锁</h2><p><a href="https://blog.csdn.net/qq_54070103/article/details/124108541?ops_request_misc=%7B%22request_id%22:%22172024328716800184129598%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024328716800184129598&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124108541-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E9%94%81&spm=1018.2226.3001.4187">面试+基础—–详细解读多线程（线程池、锁、死锁…）_多线程井发、死锁问题、线程池原理等-CSDN博客</a></p><p><a href="https://blog.csdn.net/u013541140/article/details/95225769?ops_request_misc=%7B%22request_id%22:%22172024532116800211519152%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024532116800211519152&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-95225769-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=%E7%BA%BF%E7%A8%8B%E6%B1%A0&spm=1018.2226.3001.4187">Java 多线程：彻底搞懂线程池_java线程池-CSDN博客</a></p><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p><a href="https://blog.csdn.net/qq_35190492/article/details/113174359?ops_request_misc=%7B%22request_id%22:%22172024555916800184190893%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024555916800184190893&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-113174359-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=netty&spm=1018.2226.3001.4187">【硬核】肝了一月的Netty知识点-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_33384191/article/details/129187707?ops_request_misc=%7B%22request_id%22:%22172024555916800184190893%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024555916800184190893&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129187707-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=netty&spm=1018.2226.3001.4187">超详细Netty入门，看这篇就够了！_netty框架-CSDN博客</a></p><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p><a href="https://blog.csdn.net/qq_41317495/article/details/108553894?ops_request_misc=%7B%22request_id%22:%22172024618916800185817050%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024618916800185817050&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108553894-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=JUnit&spm=1018.2226.3001.4187">JUnit详解-CSDN博客</a></p><h2 id="Pytest"><a href="#Pytest" class="headerlink" title="Pytest"></a>Pytest</h2><p><a href="https://blog.csdn.net/lovedingd/article/details/98952868?ops_request_misc=%7B%22request_id%22:%22172024619416800226527972%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024619416800226527972&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-98952868-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=pytest&spm=1018.2226.3001.4187">Python测试框架之pytest详解_pytest框架详解-CSDN博客</a></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><a href="https://blog.csdn.net/m0_61503020/article/details/125456520?ops_request_misc=%7B%22request_id%22:%22172024335816800225519741%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172024335816800225519741&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125456520-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=docker&spm=1018.2226.3001.4187">docker入门，这一篇就够了。-CSDN博客</a></p><blockquote><p>docker run [可选参数] image 命令 #启动容器（无镜像会先下载镜像）<br>#参数说明<br>–name &#x3D; “Name”   容器名字<br>-c   后面跟待完成的命令<br>-d   以后台方式运行并且返回ID，启动守护进程式容器<br>-i   使用交互方式运行容器，通常与t同时使用<br>-t   为容器重新分配一个伪输入终端。也即启动交互式容器<br>-p   指定容器端口    -p 容器端口:物理机端口  映射端口<br>-P   随机指定端口<br>-v   给容器挂载存储卷</p></blockquote><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>[JAVA内存分配原理解析–栈、堆、常量池_堆,栈,常量池详解-CSDN博客](<a href="https://blog.csdn.net/gb702250823/article/details/92801716?ops_request_misc=%7B%22request_id%22:%22171151029816800225558425%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171151029816800225558425&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-92801716-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=java">https://blog.csdn.net/gb702250823/article/details/92801716?ops_request_misc=%7B%22request%5Fid%22%3A%22171151029816800225558425%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171151029816800225558425&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-92801716-null-null.142^v100^pc_search_result_base2&amp;utm_term=java</a> 常量池 栈 堆&amp;spm&#x3D;1018.2226.3001.4187)</p><p><a href="https://blog.csdn.net/LJWfbj666/article/details/139120947?ops_request_misc=&request_id=&biz_id=102&utm_term=java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-139120947.142%5Ev100%5Epc_search_result_base8&spm=1018.2226.3001.4187">java的垃圾回收(GC)详解_java gc-CSDN博客</a></p><p><a href="https://blog.csdn.net/ZHHX666/article/details/124484199?ops_request_misc=%7B%22request_id%22:%22172025262616800182710898%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172025262616800182710898&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124484199-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8&spm=1018.2226.3001.4187">Java - 类加载器_java类加载器-CSDN博客</a></p><h2 id="常用数据结构和库"><a href="#常用数据结构和库" class="headerlink" title="常用数据结构和库"></a>常用数据结构和库</h2><p><a href="https://blog.csdn.net/CodePlayMe/article/details/130724568?ops_request_misc=%7B%22request_id%22:%22170261719316777224420083%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170261719316777224420083&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-130724568-null-null.142%5Ev96%5Epc_search_result_base2&utm_term=java%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1018.2226.3001.4187">java刷题前常用的数据结构及方法_java刷题常用方法-CSDN博客</a></p><h3 id="ACM模式"><a href="#ACM模式" class="headerlink" title="ACM模式"></a>ACM模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意类名必须为 Main, 不要有任何 package xxx 信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="int-转Integer"><a href="#int-转Integer" class="headerlink" title="int 转Integer"></a>int 转Integer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(num);</span><br></pre></td></tr></table></figure><h3 id="int到string数据类型的转换"><a href="#int到string数据类型的转换" class="headerlink" title="int到string数据类型的转换"></a><strong>int到string数据类型的转换</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">Integer.toString(num);</span><br></pre></td></tr></table></figure><p>或者<strong>String.valueOf(num);</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="comment">// 引号带上数据</span></span><br><span class="line">    <span class="type">int</span> num=<span class="number">100</span>;</span><br><span class="line">    String a=<span class="string">&quot;&quot;</span>+num;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">   <span class="comment">// 直接类型转换</span></span><br><span class="line">    Integer num2=<span class="number">100</span>;</span><br><span class="line">    String b=Integer.toString(num2);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串定义</span></span><br><span class="line">    String c=String.valueOf(num2);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String到int类型的转换"><a href="#String到int类型的转换" class="headerlink" title="String到int类型的转换"></a><strong>String到int类型的转换</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line">    <span class="comment">// parseInt</span></span><br><span class="line">    <span class="comment">// 加上static的方法，方法属于类，需要使用类名进行调用，没有加上static的，方法属于对象，可以new一个对象再调用</span></span><br><span class="line">    <span class="type">int</span> e=Integer.parseInt(s);</span><br><span class="line">    System.out.println(e);</span><br></pre></td></tr></table></figure><h3 id="ArrayList动态转换为Array数组"><a href="#ArrayList动态转换为Array数组" class="headerlink" title="ArrayList动态转换为Array数组"></a>ArrayList动态转换为Array数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String [] array=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[size]);</span><br></pre></td></tr></table></figure><p>除此之外，<strong>ArrayList</strong>还有以下的常用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> 将指定元素插入此列表中的指定位置。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>将指定的元素追加到此列表的末尾。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>如果此列表包含指定的元素，则返回 <span class="literal">true</span> 。</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> 返回此列表中指定位置的元素。</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> 返回此列表中第一次出现的指定元素的索引，如果此列表不包含该元素，则返回-<span class="number">1</span>。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> 如果此列表不包含任何元素，则返回 <span class="literal">true</span> 。</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>返回此列表中指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-<span class="number">1</span>。</span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> 删除此列表中指定位置的元素。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>从该列表中删除指定元素的第一个匹配项（如果存在）</span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> 用指定的元素替换此列表中指定位置的元素。</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> 返回此列表中的元素数。</span><br></pre></td></tr></table></figure><h3 id="Array数组转为ArrayList"><a href="#Array数组转为ArrayList" class="headerlink" title="Array数组转为ArrayList"></a>Array数组转为ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;list= Arrays.asList(array)</span><br></pre></td></tr></table></figure><h3 id="Arrays的常用方法"><a href="#Arrays的常用方法" class="headerlink" title="Arrays的常用方法"></a>Arrays的常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建数组</span></span><br><span class="line"><span class="type">int</span> nums[]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//获取长度</span></span><br><span class="line">nums.length;</span><br><span class="line"></span><br><span class="line">Arrays.toString(nums)</span><br><span class="line">Arrays.sort(nums)<span class="comment">//升序</span></span><br><span class="line">Arrays.fill(nums)<span class="comment">//初始化数组的时候会用到（比如全部给-1）</span></span><br><span class="line">Arrays.equal(nums)</span><br><span class="line">Arrays.copyof(nums)</span><br><span class="line">Arrays.compare(nums)</span><br><span class="line">Arrays.binarySearch(nums)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ArrayList的常用用法"><a href="#ArrayList的常用用法" class="headerlink" title="ArrayList的常用用法"></a>ArrayList的常用用法</h3><p>Array：只可存储基本数据类型和对象。被设置为<strong>固定大小</strong>。所包含的方法没有ArrayList多<br>ArrayList：只能<strong>存储对象</strong>。是一个<strong>可变数组</strong>，大小可自动调整。有很多操作方法：<a href="https://so.csdn.net/so/search?q=addAll&spm=1001.2101.3001.7020">addAll</a>、removeAll、iteration等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        sites.remove(<span class="number">3</span>); <span class="comment">// 删除第四个元素</span></span><br><span class="line"><span class="comment">//计算大小</span></span><br><span class="line">sites.size();</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">Collections.sort(sites);</span><br><span class="line"><span class="comment">//是否包含</span></span><br><span class="line">sites.contains();</span><br><span class="line"><span class="comment">//addAll()</span></span><br><span class="line">这个方法括号中类型是list，拼接</span><br><span class="line">    </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> 将指定元素插入此列表中的指定位置。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>将指定的元素追加到此列表的末尾。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>如果此列表包含指定的元素，则返回 <span class="literal">true</span> 。</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> 返回此列表中指定位置的元素。</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> 返回此列表中第一次出现的指定元素的索引，如果此列表不包含该元素，则返回-<span class="number">1</span>。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> 如果此列表不包含任何元素，则返回 <span class="literal">true</span> 。</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>返回此列表中指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-<span class="number">1</span>。</span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> 删除此列表中指定位置的元素。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>从该列表中删除指定元素的第一个匹配项（如果存在）</span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> 用指定的元素替换此列表中指定位置的元素。</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> 返回此列表中的元素数。</span><br></pre></td></tr></table></figure><h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a><strong>Collections类</strong></h3><p>对list进行反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.reverse(list)</span><br></pre></td></tr></table></figure><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String获取长度是.length()（要加括号）</p><p><a href="https://blog.csdn.net/weixin_62756510/article/details/124698100?ops_request_misc=%7B%22request_id%22:%22171013865416777224481954%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171013865416777224481954&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124698100-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=stringbuilder&spm=1018.2226.3001.4187">String、StringBuilder类超详细笔记_stringbuilder可以用equalsignorecase-CSDN博客</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">重要：<span class="type">char</span> charAt​(<span class="type">int</span> index) 返回指定索引处的 <span class="type">char</span>值。</span><br><span class="line"><span class="type">int</span> indexOf​(String ch) 返回指定字符第一次出现的字符串中的索引。</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(<span class="string">&#x27;c&#x27;</span>); <span class="comment">//效率最高的方法</span></span><br><span class="line">- <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> ，当且仅当， length()是 <span class="number">0</span> 返回 <span class="literal">true</span></span><br><span class="line"><span class="type">int</span> lastIndexOf​(<span class="type">int</span> ch) 返回指定字符最后一次出现的字符串中的索引。</span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> 返回此字符串的长度。</span><br><span class="line">    String <span class="title function_">trim</span><span class="params">()</span> 去除两端的空格</span><br><span class="line">String replace​(CharSequence target, CharSequence replacement) 将此字符串中与文字目标序列匹配的每个子字符串替换为指定的文字替换序列。</span><br><span class="line">String replaceAll​(String regex, String replacement) 将给定替换的给定 regular expression匹配的此字符串的每个子字符串替换。</span><br><span class="line">String[] split​(String regex) <span class="comment">//将此字符串拆分为给定 regular expression的匹配 项 。（如果有多个空格，则会在Arrays中有空的&quot;&quot;出现）</span></span><br><span class="line"><span class="type">boolean</span> startsWith​(String prefix) 测试此字符串是否以指定的前缀开头。</span><br><span class="line">String substring​(<span class="type">int</span> beginIndex) 返回一个字符串，该字符串是此字符串的子字符串。</span><br><span class="line"><span class="type">char</span>[] toCharArray() 将此字符串转换为新的字符数组。</span><br><span class="line">String <span class="title function_">toLowerCase</span><span class="params">()</span> 使用默认语言环境的规则将此 String所有字符转换为小写。</span><br><span class="line">String <span class="title function_">toUpperCase</span><span class="params">()</span> 使用默认语言环境的规则将此 String所有字符转换为大写。</span><br><span class="line">比较大小的话</span><br><span class="line">    String c= <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">c.compareTo(b);</span><br><span class="line">或者</span><br><span class="line">    c.equals(b);</span><br></pre></td></tr></table></figure><h3 id="字符类Chracter"><a href="#字符类Chracter" class="headerlink" title="字符类Chracter"></a>字符类Chracter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//char转Character</span></span><br><span class="line">Character.valueOf(<span class="string">&#x27;I&#x27;</span>);</span><br><span class="line">Character.compare(<span class="type">char</span> x, <span class="type">char</span> y) 以数字方式比较两个 <span class="type">char</span>值。</span><br><span class="line">Character.equals(Object obj) 将此对象与指定的对象进行比较。</span><br><span class="line">Character.isDigit(<span class="type">char</span> ch) 确定指定的字符是否为数字。</span><br><span class="line">Character.isLetter(<span class="type">char</span> ch) 确定指定的字符是否为字母。</span><br><span class="line">Character.isLowerCase(<span class="type">char</span> ch) 确定指定的字符是否为小写字符。</span><br><span class="line">Character.isUpperCase(<span class="type">char</span> ch) 确定指定的字符是否为大写字符。</span><br><span class="line">Character.toString(<span class="type">char</span> c) 返回表示指定的 <span class="type">char</span>的 String对象。</span><br><span class="line">Character.valueOf(<span class="type">char</span> c) 返回表示指定的 <span class="type">char</span>值的 Character实例。</span><br><span class="line">Character.toLowerCase(<span class="string">&quot;A&quot;</span>); 转为小写</span><br><span class="line">Character.toUpperCase(<span class="string">&quot;a&quot;</span>); 转为大写</span><br><span class="line"><span class="comment">//char数组转String</span></span><br><span class="line"><span class="type">char</span>[] data = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data);</span><br><span class="line">System.out.println(str);  <span class="comment">//输出abc</span></span><br></pre></td></tr></table></figure><h3 id="字符串构造器StringBuilder"><a href="#字符串构造器StringBuilder" class="headerlink" title="字符串构造器StringBuilder"></a>字符串构造器StringBuilder</h3><p><a href="https://blog.csdn.net/qq_46634307/article/details/126283200?ops_request_misc=%7B%22request_id%22:%22171014028016800192229813%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=171014028016800192229813&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-126283200-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=stringbuilder%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%AD%97%E7%AC%A6&spm=1018.2226.3001.4187">Java-修改 String 指定位置的字符最全方法总结（StringBuilder 和 StringBuffer 的使用以及区别）_string替换指定位置字符-CSDN博客</a></p><p><a href="https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-89966303-blog-124698100.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-89966303-blog-124698100.235%5Ev43%5Epc_blog_bottom_relevance_base1&utm_relevant_index=1">String、StringBuffer与StringBuilder之间区别_string stringbuffer stringbuilder区别-CSDN博客</a></p><p>可变字符串，StringBuilder对象的内容可以修改。</p><ol><li><p>StringBuilder类的常用方法</p><ol><li><p>append()方法<br>使用append()方法可实现字符串的拼接操作，返回拼接后的StringBuilder对象。</p></li><li><p>reverse()方法<br>使用reverse()方法可实现StringBuilder字符串的反转操作。</p></li><li><p>delete(int start, int end)方法<br>删除字符串中指定索引范围为 [start,end) 的所有内容。</p><p>Java中大多数范围均为左闭右开区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">sb.delete(<span class="number">5</span>,<span class="number">8</span>);  <span class="comment">//删除索引范围为[5,8)内的所有内容，即从w开始删除到l之前</span></span><br><span class="line">System.out.println(sb);  <span class="comment">//输出hellold</span></span><br></pre></td></tr></table></figure></li><li><p>insert(int start, 任意数据类型)方法<br>在索引start处开始插入任意数据类型的内容。插入内容的起始索引是start。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">sb1.insert(<span class="number">2</span>,<span class="number">77</span>);</span><br><span class="line">System.out.println(sb1);  <span class="comment">//输出he77llo</span></span><br><span class="line">sb1.insert(<span class="number">3</span>,<span class="string">&quot;ooo&quot;</span>);</span><br><span class="line">System.out.println(sb1);  <span class="comment">//输出he7ooo7llo</span></span><br></pre></td></tr></table></figure></li><li><p>setCharAt(index,character)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.setCharAt(j,Character.toUpperCase(sb.charAt(j)));</span><br></pre></td></tr></table></figure></li></ol></li><li><p>StringBuilder与String的相互转换<br> 1）String转为StringBuilder<br> ① 构造方法StringBuilder(String str)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>② 字符串拼接方法append(String str)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><p>2）StringBuilder转为String<br>通过StringBuilder对象调用toString()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">String、StringBuilder、StringBuffer的区别</span><br><span class="line">String为不可变字符串类，StringBuilder、StringBuffer为可变字符串类。</span><br><span class="line">StringBuilder类性能较高，但存在线程安全问题; StringBuffer类线程安全，但性能较差。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="双链表LinkedList"><a href="#双链表LinkedList" class="headerlink" title="双链表LinkedList"></a>双链表LinkedList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> <span class="comment">// 判断链表中是否存在元素o 复杂度O(N)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span></span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span> <span class="comment">//删除，返回的是删除的元素</span></span><br><span class="line">E getFirst/Last()</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">( E e)</span></span><br><span class="line">Collections.reverse(link); <span class="comment">// 翻转链表</span></span><br></pre></td></tr></table></figure><h3 id="哈希表Hashmap"><a href="#哈希表Hashmap" class="headerlink" title="哈希表Hashmap"></a>哈希表Hashmap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>如果这个映射包含指定键映射，则返回<span class="literal">true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> 如果此映射将一个或多个键映射到指定值，则返回 <span class="literal">true</span> 。</span><br><span class="line">V <span class="title function_">get</span><span class="params">(Object key)</span> 返回指定键映射到的值，如果此映射不包含键的映射，则返回 <span class="literal">null</span> 。</span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span> 将指定的值与此映射中的指定键相关联。</span><br><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span> 从此映射中删除指定键的映射（如果存在）。</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> 返回此映射中键 - 值映射的数量。</span><br><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> 返回此映射中包含的值的Collection视图。</span><br><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> 返回此映射中包含的键的Set视图。</span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> 返回指定键映射到的值，如果此映射不包含键的映射，则返回 defaultValue 。这个方法继承自Map接口</span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> 如果key存在则什么都不做，否则put()，并且返回当前值</span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射的Set视图。</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 初始化哈希表 */</span></span><br><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加操作 */</span></span><br><span class="line"><span class="comment">// 在哈希表中添加键值对 (key, value)</span></span><br><span class="line">map.put(<span class="number">12836</span>, <span class="string">&quot;小哈&quot;</span>);   </span><br><span class="line">map.put(<span class="number">15937</span>, <span class="string">&quot;小啰&quot;</span>);   </span><br><span class="line">map.put(<span class="number">16750</span>, <span class="string">&quot;小算&quot;</span>);   </span><br><span class="line">map.put(<span class="number">13276</span>, <span class="string">&quot;小法&quot;</span>);</span><br><span class="line">map.put(<span class="number">10583</span>, <span class="string">&quot;小鸭&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询操作 */</span></span><br><span class="line"><span class="comment">// 向哈希表中输入键 key ，得到值 value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> map.get(<span class="number">15937</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除操作 */</span></span><br><span class="line"><span class="comment">// 在哈希表中删除键值对 (key, value)</span></span><br><span class="line">map.remove(<span class="number">10583</span>);</span><br></pre></td></tr></table></figure><h3 id="哈希集合HashSet"><a href="#哈希集合HashSet" class="headerlink" title="哈希集合HashSet"></a>哈希集合HashSet</h3><p>[【Java 基础篇】Java Set 详解-CSDN博客](<a href="https://blog.csdn.net/qq_21484461/article/details/131383848?ops_request_misc=%7B%22request_id%22:%22171015290416800180682690%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171015290416800180682690&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131383848-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=Java">https://blog.csdn.net/qq_21484461/article/details/131383848?ops_request_misc=%7B%22request%5Fid%22%3A%22171015290416800180682690%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171015290416800180682690&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131383848-null-null.142^v99^pc_search_result_base2&amp;utm_term=Java</a> set&amp;spm&#x3D;1018.2226.3001.4187)</p><p>不能保证集合迭代的顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> 如果指定的元素尚不存在，则将其添加到此集合中。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> 如果存在，则从该集合中移除指定的元素。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> 如果此set包含指定的元素，则返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h3><p>栈，后进先出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化栈 */</span></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入栈 */</span></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出栈 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> stack.isEmpty();</span><br></pre></td></tr></table></figure><h3 id="队列Queue、双端队列Deque（都可用LinkedList来实例化，因为二者都是接口）"><a href="#队列Queue、双端队列Deque（都可用LinkedList来实例化，因为二者都是接口）" class="headerlink" title="队列Queue、双端队列Deque（都可用LinkedList来实例化，因为二者都是接口）"></a>队列Queue、双端队列Deque（都可用LinkedList来实例化，因为二者都是接口）</h3><p>队列，先进先出，Queue和Deque都是接口，而LinkedList类继承了这两个队列，<strong>可以是用LinkedList来实例化Queue或者Deque</strong>，可以作为单向队列或者双向队列来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Queue</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> 将指定元素插入此列表中的指定位置。</span><br><span class="line">E <span class="title function_">element</span><span class="params">()</span> 检索但不删除此列表的头部（第一个元素）。</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> 返回此列表中指定位置的元素。</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> 返回此列表中第一次出现的指定元素的索引，如果此列表不包含该元素，则返回-<span class="number">1</span>。</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> 返回此列表中指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-<span class="number">1</span>。</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> 将指定的元素添加为此列表的尾部（最后一个元素）。</span><br><span class="line">E <span class="title function_">peek</span><span class="params">()</span> 检索但不删除此列表的头部（第一个元素）</span><br><span class="line">E <span class="title function_">poll</span><span class="params">()</span> 检索并删除此列表的头部（第一个元素）。</span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> 用指定的元素替换此列表中指定位置的元素。</span><br><span class="line"><span class="comment">/* 翻转队列 */</span></span><br><span class="line">Collections.reverse(queue) </span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> queue.isEmpty();</span><br></pre></td></tr></table></figure><p>双端队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化双向队列 */</span></span><br><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">deque.offerLast(<span class="number">2</span>);   <span class="comment">// 添加至队尾</span></span><br><span class="line">deque.offerLast(<span class="number">5</span>);</span><br><span class="line">deque.offerLast(<span class="number">4</span>);</span><br><span class="line">deque.offerFirst(<span class="number">3</span>);  <span class="comment">// 添加至队首</span></span><br><span class="line">deque.offerFirst(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peekFirst</span> <span class="operator">=</span> deque.peekFirst();  <span class="comment">// 队首元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peekLast</span> <span class="operator">=</span> deque.peekLast();    <span class="comment">// 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">popFirst</span> <span class="operator">=</span> deque.pollFirst();  <span class="comment">// 队首元素出队</span></span><br><span class="line"><span class="type">int</span> <span class="variable">popLast</span> <span class="operator">=</span> deque.pollLast();    <span class="comment">// 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> deque.isEmpty();</span><br></pre></td></tr></table></figure><p>…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList可以作为堆栈使用，并且在类中实现了对应的方法</span><br><span class="line">E <span class="title function_">pop</span><span class="params">()</span> 弹出此列表所代表的堆栈中的元素。</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> 将元素推送到此列表所表示的堆栈上。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优先队列-作为堆来用"><a href="#优先队列-作为堆来用" class="headerlink" title="优先队列(作为堆来用)"></a>优先队列(作为堆来用)</h3><p>默认小顶堆，但如果是数据结构就还是要重写comparator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//读</span></span><br><span class="line">minHeap.peek();</span><br><span class="line">minHeap.poll();(会弹出)</span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line">minHeap.add();</span><br><span class="line">minHeap.offer();</span><br><span class="line"><span class="comment">//优先队列自然排序示例</span></span><br><span class="line">Queue&lt;Integer&gt; integerPriorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">7</span>);<span class="comment">//容量为7</span></span><br><span class="line"><span class="comment">//优先队列使用示例</span></span><br><span class="line">Queue&lt;Customer&gt; customerPriorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(idComparator);</span><br><span class="line"><span class="comment">//匿名Comparator实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Customer&gt; idComparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Customer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Customer c1, Customer c2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (c1.getId() - c2.getId());<span class="comment">//这是小顶堆，反着写就是大顶堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//或者实现Comparator接口也行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">idComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Customer c1, Customer c2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(c1.getId()-c2.getId)());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化堆 */</span></span><br><span class="line"><span class="comment">// 初始化小顶堆</span></span><br><span class="line">Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 初始化大顶堆（使用 lambda 表达式修改 Comparator 即可）</span></span><br><span class="line">Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入堆 */</span></span><br><span class="line">maxHeap.offer(<span class="number">1</span>);</span><br><span class="line">maxHeap.offer(<span class="number">3</span>);</span><br><span class="line">maxHeap.offer(<span class="number">2</span>);</span><br><span class="line">maxHeap.offer(<span class="number">5</span>);</span><br><span class="line">maxHeap.offer(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取堆顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> maxHeap.peek(); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 堆顶元素出堆 */</span></span><br><span class="line"><span class="comment">// 出堆元素会形成一个从大到小的序列</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 5</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 4</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 3</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 2</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取堆大小 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> maxHeap.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断堆是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> maxHeap.isEmpty();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入列表并建堆 */</span></span><br><span class="line">minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><h3 id="数学库"><a href="#数学库" class="headerlink" title="数学库"></a>数学库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil(<span class="number">3.3</span>); <span class="comment">//向上取整</span></span><br><span class="line">Math.floor(<span class="number">3.3</span>); <span class="comment">//向下取整</span></span><br><span class="line">Math.round(<span class="number">3.4</span>); <span class="comment">//四舍五入</span></span><br><span class="line">Math.pow(<span class="number">3</span>,<span class="number">2</span>) <span class="comment">//幂运算</span></span><br><span class="line">Math.abs(-<span class="number">1</span>); <span class="comment">//绝对值 </span></span><br><span class="line">Math.max(<span class="number">9999</span>,<span class="number">10000</span>);</span><br><span class="line">Math.min(<span class="number">9999</span>,<span class="number">10000</span>);</span><br><span class="line">Math.ramdom(); <span class="comment">//返回0-1的随机数，左闭右开</span></span><br><span class="line">Math.sqrt(<span class="number">3.644</span>); <span class="comment">//开方</span></span><br></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>邻接矩阵</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于邻接矩阵实现的无向图类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjMat</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; vertices; <span class="comment">// 顶点列表，元素代表“顶点值”，索引代表“顶点索引”</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; adjMat; <span class="comment">// 邻接矩阵，行列索引对应“顶点索引”</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphAdjMat</span><span class="params">(<span class="type">int</span>[] vertices, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertices = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.adjMat = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vertices) &#123;</span><br><span class="line">            addVertex(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加边</span></span><br><span class="line">        <span class="comment">// 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">            addEdge(e[<span class="number">0</span>], e[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取顶点数量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertices.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加顶点 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addVertex</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> size();</span><br><span class="line">        <span class="comment">// 向顶点列表中添加新顶点的值</span></span><br><span class="line">        vertices.add(val);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中添加一行</span></span><br><span class="line">        List&lt;Integer&gt; newRow = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            newRow.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        adjMat.add(newRow);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中添加一列</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; row : adjMat) &#123;</span><br><span class="line">            row.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除顶点 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeVertex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="comment">// 在顶点列表中移除索引 index 的顶点</span></span><br><span class="line">        vertices.remove(index);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中删除索引 index 的行</span></span><br><span class="line">        adjMat.remove(index);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中删除索引 index 的列</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; row : adjMat) &#123;</span><br><span class="line">            row.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加边 */</span></span><br><span class="line">    <span class="comment">// 参数 i, j 对应 vertices 元素索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引越界与相等处理</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= size() || j &gt;= size() || i == j)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="comment">// 在无向图中，邻接矩阵关于主对角线对称，即满足 (i, j) == (j, i)</span></span><br><span class="line">        adjMat.get(i).set(j, <span class="number">1</span>);</span><br><span class="line">        adjMat.get(j).set(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除边 */</span></span><br><span class="line">    <span class="comment">// 参数 i, j 对应 vertices 元素索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引越界与相等处理</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= size() || j &gt;= size() || i == j)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        adjMat.get(i).set(j, <span class="number">0</span>);</span><br><span class="line">        adjMat.get(j).set(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印邻接矩阵 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;顶点列表 = &quot;</span>);</span><br><span class="line">        System.out.println(vertices);</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接矩阵 =&quot;</span>);</span><br><span class="line">        PrintUtil.printMatrix(adjMat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邻接表的BFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 广度优先遍历 */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line">List&lt;Vertex&gt; <span class="title function_">graphBFS</span><span class="params">(GraphAdjList graph, Vertex startVet)</span> &#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    List&lt;Vertex&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    Set&lt;Vertex&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    visited.add(startVet);</span><br><span class="line">    <span class="comment">// 队列用于实现 BFS</span></span><br><span class="line">    Queue&lt;Vertex&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    que.offer(startVet);</span><br><span class="line">    <span class="comment">// 以顶点 vet 为起点，循环直至访问完所有顶点</span></span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">vet</span> <span class="operator">=</span> que.poll(); <span class="comment">// 队首顶点出队</span></span><br><span class="line">        res.add(vet);            <span class="comment">// 记录访问顶点</span></span><br><span class="line">        <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">        <span class="keyword">for</span> (Vertex adjVet : graph.adjList.get(vet)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(adjVet))</span><br><span class="line">                <span class="keyword">continue</span>;        <span class="comment">// 跳过已被访问的顶点</span></span><br><span class="line">            que.offer(adjVet);   <span class="comment">// 只入队未访问的顶点</span></span><br><span class="line">            visited.add(adjVet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回顶点遍历序列</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邻接表的DFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 深度优先遍历辅助函数 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(GraphAdjList graph, Set&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet)</span> &#123;</span><br><span class="line">    res.add(vet);     <span class="comment">// 记录访问顶点</span></span><br><span class="line">    visited.add(vet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex adjVet : graph.adjList.get(vet)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(adjVet))</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过已被访问的顶点</span></span><br><span class="line">        <span class="comment">// 递归访问邻接顶点</span></span><br><span class="line">        dfs(graph, visited, res, adjVet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 深度优先遍历 */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line">List&lt;Vertex&gt; <span class="title function_">graphDFS</span><span class="params">(GraphAdjList graph, Vertex startVet)</span> &#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    List&lt;Vertex&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    Set&lt;Vertex&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    dfs(graph, visited, res, startVet);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatrixUDG</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mEdgNum;        <span class="comment">// 边的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] mVexs;       <span class="comment">// 顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] mMatrix;    <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE;   <span class="comment">// 最大值</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floyd最短路径。</span></span><br><span class="line"><span class="comment"> * 即，统计图中各个顶点间的最短路径。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     path -- 路径。path[i][j]=k表示，&quot;顶点i&quot;到&quot;顶点j&quot;的最短路径会经过顶点k。</span></span><br><span class="line"><span class="comment"> *     dist -- 长度数组。即，dist[i][j]=sum表示，&quot;顶点i&quot;到&quot;顶点j&quot;的最短路径的长度是sum。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">(<span class="type">int</span>[][] path, <span class="type">int</span>[][] dist)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mVexs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; mVexs.length; j++) &#123;</span><br><span class="line">            dist[i][j] = mMatrix[i][j];    <span class="comment">// &quot;顶点i&quot;到&quot;顶点j&quot;的路径长度为&quot;i到j的权值&quot;。</span></span><br><span class="line">            path[i][j] = j;                <span class="comment">// &quot;顶点i&quot;到&quot;顶点j&quot;的最短路径是经过顶点j。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; mVexs.length; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mVexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; mVexs.length; j++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]);</span><br><span class="line">                <span class="keyword">if</span> (dist[i][j] &gt; tmp) &#123;</span><br><span class="line">                    <span class="comment">// &quot;i到j最短路径&quot;对应的值设，为更小的一个(即经过k)</span></span><br><span class="line">                    dist[i][j] = tmp;</span><br><span class="line">                    <span class="comment">// &quot;i到j最短路径&quot;对应的路径，经过k</span></span><br><span class="line">                    path[i][j] = path[i][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印floyd最短路径的结果</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;floyd: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mVexs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; mVexs.length; j++)</span><br><span class="line">            System.out.printf(<span class="string">&quot;%2d  &quot;</span>, dist[i][j]);</span><br><span class="line">        System.out.printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="迪杰斯特拉"><a href="#迪杰斯特拉" class="headerlink" title="迪杰斯特拉"></a>迪杰斯特拉</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatrixUDG</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mEdgNum;        <span class="comment">// 边的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] mVexs;       <span class="comment">// 顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] mMatrix;    <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE;   <span class="comment">// 最大值</span></span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Dijkstra最短路径。</span></span><br><span class="line"><span class="comment"> * 即，统计图中&quot;顶点vs&quot;到其它各个顶点的最短路径。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *       vs -- 起始顶点(start vertex)。即计算&quot;顶点vs&quot;到其它顶点的最短路径。</span></span><br><span class="line"><span class="comment"> *     prev -- 前驱顶点数组。即，prev[i]的值是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径所经历的全部顶点中，位于&quot;顶点i&quot;之前的那个顶点。</span></span><br><span class="line"><span class="comment"> *     dist -- 长度数组。即，dist[i]是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径的长度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> vs, <span class="type">int</span>[] prev, <span class="type">int</span>[] dist)</span> &#123;</span><br><span class="line">    <span class="comment">// flag[i]=true表示&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径已成功获取</span></span><br><span class="line">    <span class="type">boolean</span>[] flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[mVexs.length];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mVexs.length; i++) &#123;</span><br><span class="line">        flag[i] = <span class="literal">false</span>;          <span class="comment">// 顶点i的最短路径还没获取到。</span></span><br><span class="line">        prev[i] = <span class="number">0</span>;              <span class="comment">// 顶点i的前驱顶点为0。</span></span><br><span class="line">        dist[i] = mMatrix[vs][i];  <span class="comment">// 顶点i的最短路径为&quot;顶点vs&quot;到&quot;顶点i&quot;的权。</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 对&quot;顶点vs&quot;自身进行初始化</span></span><br><span class="line">    flag[vs] = <span class="literal">true</span>;</span><br><span class="line">    dist[vs] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 遍历mVexs.length-1次；每次找出一个顶点的最短路径。</span></span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; mVexs.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 寻找当前最小的路径；</span></span><br><span class="line">        <span class="comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; mVexs.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[j]==<span class="literal">false</span> &amp;&amp; dist[j]&lt;min) &#123;</span><br><span class="line">                min = dist[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记&quot;顶点k&quot;为已经获取到最短路径</span></span><br><span class="line">        flag[k] = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 修正当前最短路径和前驱顶点</span></span><br><span class="line">        <span class="comment">// 即，当已经&quot;顶点k的最短路径&quot;之后，更新&quot;未获取最短路径的顶点的最短路径和前驱顶点&quot;。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; mVexs.length; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j]));</span><br><span class="line">            <span class="keyword">if</span> (flag[j]==<span class="literal">false</span> &amp;&amp; (tmp&lt;dist[j]) ) &#123;</span><br><span class="line">                dist[j] = tmp;</span><br><span class="line">                prev[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 打印dijkstra最短路径的结果</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;dijkstra(%c): \n&quot;</span>, mVexs[vs]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; mVexs.length; i++)</span><br><span class="line">        System.out.printf(<span class="string">&quot;  shortest(%c, %c)=%d\n&quot;</span>, mVexs[vs], mVexs[i], dist[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="构建树（前序-中序）"><a href="#构建树（前序-中序）" class="headerlink" title="构建树（前序+中序）"></a>构建树（前序+中序）</h4><p><a href="https://www.hello-algo.com/chapter_divide_and_conquer/build_binary_tree_problem/#3">12.3  构建树问题 - Hello 算法 (hello-algo.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构建二叉树：分治 */</span></span><br><span class="line">TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] preorder, Map&lt;Integer, Integer&gt; inorderMap, <span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 子树区间为空时终止</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 初始化根节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[i]);</span><br><span class="line">    <span class="comment">// 查询 m ，从而划分左右子树</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> inorderMap.get(preorder[i]);</span><br><span class="line">    <span class="comment">// 子问题：构建左子树</span></span><br><span class="line">    root.left = dfs(preorder, inorderMap, i + <span class="number">1</span>, l, m - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 子问题：构建右子树</span></span><br><span class="line">    root.right = dfs(preorder, inorderMap, i + <span class="number">1</span> + m - l, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//构建右子树稍微复杂一些。首先，需要确定右子树的根节点在前序遍历中的位置。由于左子树的根节点之后的所有元素都属于右子树，所以右子树的根节点在前序遍历中的位置是 i + 1 + (m - l)。这里的 m - l 表示左子树的大小，即左子树有多少个节点。</span></span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构建二叉树 */</span></span><br><span class="line">TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化哈希表，存储 inorder 元素到索引的映射</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; inorderMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        inorderMap.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> dfs(preorder, inorderMap, <span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回溯问题"><a href="#回溯问题" class="headerlink" title="回溯问题"></a>回溯问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(State state, List&lt;Choice&gt; choices, List&lt;State&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否为解</span></span><br><span class="line">    <span class="keyword">if</span> (isSolution(state)) &#123;</span><br><span class="line">        <span class="comment">// 记录解</span></span><br><span class="line">        recordSolution(state, res);</span><br><span class="line">        <span class="comment">// 不再继续搜索</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (Choice choice : choices) &#123;</span><br><span class="line">        <span class="comment">// 剪枝：判断选择是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (isValid(state, choice)) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            makeChoice(state, choice);</span><br><span class="line">            backtrack(state, choices, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            undoChoice(state, choice);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：全排列 I */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span>[] choices, <span class="type">boolean</span>[] selected, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 当状态长度等于元素数量时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (state.size() == choices.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; choices.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">choice</span> <span class="operator">=</span> choices[i];</span><br><span class="line">        <span class="comment">// 剪枝：不允许重复选择元素</span></span><br><span class="line">        <span class="keyword">if</span> (!selected[i]) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            selected[i] = <span class="literal">true</span>;</span><br><span class="line">            state.add(choice);</span><br><span class="line">            <span class="comment">// 进行下一轮选择</span></span><br><span class="line">            backtrack(state, choices, selected, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            selected[i] = <span class="literal">false</span>;</span><br><span class="line">            state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全排列 I */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permutationsI</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    backtrack(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(), nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length], res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子集和问题"><a href="#子集和问题" class="headerlink" title="子集和问题"></a>子集和问题</h4><p>类似于全排列问题，我们可以把子集的生成过程想象成一系列选择的结果，并在选择过程中实时更新“元素和”，当元素和等于 <code>target</code> 时，就将子集记录至结果列表。</p><p>而与全排列问题不同的是，<strong>本题集合中的元素可以被无限次选取</strong>，因此无须借助 <code>selected</code> 布尔列表来记录元素是否已被选择。我们可以对全排列代码进行小幅修改，初步得到解题代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：子集和 I */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span> target, <span class="type">int</span> total, <span class="type">int</span>[] choices, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (total == target) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; choices.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝：若子集和超过 target ，则跳过该选择</span></span><br><span class="line">        <span class="keyword">if</span> (total + choices[i] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新元素和 total</span></span><br><span class="line">        state.add(choices[i]);</span><br><span class="line">        <span class="comment">// 进行下一轮选择</span></span><br><span class="line">        backtrack(state, target, total + choices[i], choices, res);</span><br><span class="line">        <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">        state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解子集和 I（包含重复子集） */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumINaive</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 状态（子集）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子集和</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 结果列表（子集列表）</span></span><br><span class="line">    backtrack(state, target, total, nums, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样的问题是，其在进行选取的时候，会造成重复，解决办法是先排序</p><ul><li>在开启搜索前，先将数组 <code>nums</code> 排序。在遍历所有选择时，<strong>当子集和超过 <code>target</code> 时直接结束循环</strong>，因为后边的元素更大，其子集和一定超过 <code>target</code> 。</li><li>省去元素和变量 <code>total</code> ，<strong>通过在 <code>target</code> 上执行减法来统计元素和</strong>，当 <code>target</code> 等于 0 时记录解。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：子集和 I */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span> target, <span class="type">int</span>[] choices, <span class="type">int</span> start, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="comment">// 剪枝二：从 start 开始遍历，避免生成重复子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; choices.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝一：若子集和超过 target ，则直接结束循环</span></span><br><span class="line">        <span class="comment">// 这是因为数组已排序，后边元素更大，子集和一定超过 target</span></span><br><span class="line">        <span class="keyword">if</span> (target - choices[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新 target, start</span></span><br><span class="line">        state.add(choices[i]);</span><br><span class="line">        <span class="comment">// 进行下一轮选择</span></span><br><span class="line">        backtrack(state, target - choices[i], choices, i, res);</span><br><span class="line">        <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">        state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解子集和 I */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumI</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 状态（子集）</span></span><br><span class="line">    Arrays.sort(nums); <span class="comment">// 对 nums 进行排序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 遍历起始点</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 结果列表（子集列表）</span></span><br><span class="line">    backtrack(state, target, nums, start, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="N皇后问题（经典）"><a href="#N皇后问题（经典）" class="headerlink" title="N皇后问题（经典）"></a>N皇后问题（经典）</h4><p><a href="https://www.hello-algo.com/chapter_backtracking/n_queens_problem/#3">13.4  N 皇后问题 - Hello 算法 (hello-algo.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：n 皇后 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> n, List&lt;List&lt;String&gt;&gt; state, List&lt;List&lt;List&lt;String&gt;&gt;&gt; res,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span>[] cols, <span class="type">boolean</span>[] diags1, <span class="type">boolean</span>[] diags2)</span> &#123;</span><br><span class="line">    <span class="comment">// 当放置完所有行时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; copyState = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; sRow : state) &#123;</span><br><span class="line">            copyState.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(sRow));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(copyState);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">// 计算该格子对应的主对角线和次对角线</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">diag1</span> <span class="operator">=</span> row - col + n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diag2</span> <span class="operator">=</span> row + col;</span><br><span class="line">        <span class="comment">// 剪枝：不允许该格子所在列、主对角线、次对角线上存在皇后</span></span><br><span class="line">        <span class="keyword">if</span> (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) &#123;</span><br><span class="line">            <span class="comment">// 尝试：将皇后放置在该格子</span></span><br><span class="line">            state.get(row).set(col, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 放置下一行</span></span><br><span class="line">            backtrack(row + <span class="number">1</span>, n, state, res, cols, diags1, diags2);</span><br><span class="line">            <span class="comment">// 回退：将该格子恢复为空位</span></span><br><span class="line">            state.get(row).set(col, <span class="string">&quot;#&quot;</span>);</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解 n 皇后 */</span></span><br><span class="line">List&lt;List&lt;List&lt;String&gt;&gt;&gt; <span class="title function_">nQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化 n*n 大小的棋盘，其中 &#x27;Q&#x27; 代表皇后，&#x27;#&#x27; 代表空位</span></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        List&lt;String&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            row.add(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        state.add(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span>[] cols = <span class="keyword">new</span> <span class="title class_">boolean</span>[n]; <span class="comment">// 记录列是否有皇后</span></span><br><span class="line">    <span class="type">boolean</span>[] diags1 = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>]; <span class="comment">// 记录主对角线上是否有皇后</span></span><br><span class="line">    <span class="type">boolean</span>[] diags2 = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>]; <span class="comment">// 记录次对角线上是否有皇后</span></span><br><span class="line">    List&lt;List&lt;List&lt;String&gt;&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    backtrack(<span class="number">0</span>, n, state, res, cols, diags1, diags2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记忆化搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] mem)</span> &#123;</span><br><span class="line">    <span class="comment">// 已知 dp[1] 和 dp[2] ，返回之</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || i == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">// 若存在记录 dp[i] ，则直接返回之</span></span><br><span class="line">    <span class="keyword">if</span> (mem[i] != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> mem[i];</span><br><span class="line">    <span class="comment">// dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> dfs(i - <span class="number">1</span>, mem) + dfs(i - <span class="number">2</span>, mem);</span><br><span class="line">    <span class="comment">// 记录 dp[i]</span></span><br><span class="line">    mem[i] = count;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 爬楼梯：记忆化搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">climbingStairsDFSMem</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// mem[i] 记录爬到第 i 阶的方案总数，-1 代表无记录</span></span><br><span class="line">    <span class="type">int</span>[] mem = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(mem, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dfs(n, mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>暴力搜索 O(2^n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：暴力搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">knapsackDFS</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> i, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 若已选完所有物品或背包无剩余容量，则返回价值 0</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若超过背包容量，则只能选择不放入背包</span></span><br><span class="line">    <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">        <span class="keyword">return</span> knapsackDFS(wgt, val, i - <span class="number">1</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算不放入和放入物品 i 的最大价值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> knapsackDFS(wgt, val, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yes</span> <span class="operator">=</span> knapsackDFS(wgt, val, i - <span class="number">1</span>, c - wgt[i - <span class="number">1</span>]) + val[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 返回两种方案中价值更大的那一个</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(no, yes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间优化加动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：空间优化后的动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">knapsackDPComp</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cap + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 倒序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> cap; c &gt;= <span class="number">1</span>; c--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &lt;= c) &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[c] = Math.max(dp[c], dp[c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><p>空间优化加动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 完全背包：空间优化后的动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unboundedKnapsackDPComp</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cap + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">                <span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">                dp[c] = dp[c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[c] = Math.max(dp[c], dp[c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="零钱兑换问题2"><a href="#零钱兑换问题2" class="headerlink" title="零钱兑换问题2"></a>零钱兑换问题2</h4><p>凑硬币</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换 II：动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">coinChangeIIDP</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][amt + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) &#123;</span><br><span class="line">                <span class="comment">// 若超过目标金额，则不选硬币 i</span></span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选硬币 i 这两种方案之和</span></span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a] + dp[i][a - coins[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加空间优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换 II：空间优化后的动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">coinChangeIIDPComp</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amt + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) &#123;</span><br><span class="line">                <span class="comment">// 若超过目标金额，则不选硬币 i</span></span><br><span class="line">                dp[a] = dp[a];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选硬币 i 这两种方案之和</span></span><br><span class="line">                dp[a] = dp[a] + dp[a - coins[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h4><p><a href="https://www.hello-algo.com/chapter_dynamic_programming/edit_distance_problem/#1">14.6  编辑距离问题 - Hello 算法 (hello-algo.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> datastructure.dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Levenshtein</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">distance</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> a.length();</span><br><span class="line">         <span class="type">int</span> <span class="variable">length2</span> <span class="operator">=</span> b.length();</span><br><span class="line">         <span class="type">int</span> dp[][] = <span class="keyword">new</span> <span class="title class_">int</span>[length1+<span class="number">1</span>][length2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=length1;i++)&#123;</span><br><span class="line">             dp[i][<span class="number">0</span>]=i;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=length2;j++)&#123;</span><br><span class="line">             dp[<span class="number">0</span>][j]=j;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ;i&lt;=length1;i++)&#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=length2;j++)&#123;</span><br><span class="line">                 <span class="keyword">if</span> (a.charAt(i-<span class="number">1</span>)==b.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;kitten&quot;</span>;</span><br><span class="line">          <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;sitting&quot;</span>;</span><br><span class="line">          <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> distance(s1,s2);</span><br><span class="line">          System.out.println(ans);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>一般情况下，贪心算法的适用情况分以下两种。</p><ol><li><strong>可以保证找到最优解</strong>：贪心算法在这种情况下往往是最优选择，因为它往往比回溯、动态规划更高效。</li><li><strong>可以找到近似最优解</strong>：贪心算法在这种情况下也是可用的。对于很多复杂问题来说，寻找全局最优解非常困难，能以较高效率找到次优解也是非常不错的。</li></ol><p>贪心问题的解决流程大体可分为以下三步。</p><ol><li><strong>问题分析</strong>：梳理与理解问题特性，包括状态定义、优化目标和约束条件等。这一步在回溯和动态规划中都有涉及。</li><li><strong>确定贪心策略</strong>：确定如何在每一步中做出贪心选择。这个策略能够在每一步减小问题的规模，并最终解决整个问题。</li><li><strong>正确性证明</strong>：通常需要证明问题具有贪心选择性质和最优子结构。这个步骤可能需要用到数学证明，例如归纳法或反证法等。</li></ol><h4 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumGas</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumCost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sumCost += cost[i];</span><br><span class="line">            sumGas += gas[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sumCost &gt; sumGas)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hasPassed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; hasPassed &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == n)</span><br><span class="line">                    j = <span class="number">0</span>;</span><br><span class="line">                rest += gas[j];</span><br><span class="line">                <span class="keyword">if</span> (rest &gt;= cost[j]) &#123;</span><br><span class="line">                    rest -= cost[j];</span><br><span class="line">                    hasPassed++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasPassed == n)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCP-03-机器人大冒险"><a href="#LCP-03-机器人大冒险" class="headerlink" title="LCP 03. 机器人大冒险"></a><a href="https://leetcode.cn/problems/programmable-robot/">LCP 03. 机器人大冒险</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">robot</span><span class="params">(String cmd, <span class="type">int</span>[][] obstacles, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cmd.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sx</span> <span class="operator">=</span> <span class="number">0</span>, sy = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录走完一轮后机器人的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cmd.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;U&#x27;</span>) ++ sy;</span><br><span class="line">            <span class="keyword">else</span> ++ sx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先计算能否到达终点 不考虑障碍物</span></span><br><span class="line">        <span class="comment">// 若不能直接返回false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">canFinish</span> <span class="operator">=</span> canReach(cmd, x, y, sx, sy);</span><br><span class="line">        <span class="keyword">if</span> (!canFinish) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 判断在终点前会不会遇到障碍物 </span></span><br><span class="line">        <span class="comment">// 若遇到则返回false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] o : obstacles) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o[<span class="number">0</span>] &gt; x || o[<span class="number">1</span>] &gt; y)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (canReach(cmd, o[<span class="number">0</span>], o[<span class="number">1</span>], sx, sy)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断能否从坐标(x, y)到达(tx, ty)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canReach</span><span class="params">(String cmd, <span class="type">int</span> tx, <span class="type">int</span> ty, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// round记录走到目标点至少要走多少轮</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">round</span> <span class="operator">=</span> Math.min(tx/x, ty/y);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> round*x, ny = round*y;</span><br><span class="line">        <span class="keyword">if</span> (nx == tx &amp;&amp; ny == ty) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cmd.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cmd.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;U&#x27;</span>) ++ ny;</span><br><span class="line">            <span class="keyword">else</span> ++ nx;</span><br><span class="line">            <span class="keyword">if</span> (nx &gt; tx || ny &gt; ty) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (nx == tx &amp;&amp; ny == ty) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Leetcode-135-分发糖果"><a href="#Leetcode-135-分发糖果" class="headerlink" title="Leetcode 135.分发糖果"></a>Leetcode 135.分发糖果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">1</span>, dec = <span class="number">0</span>, pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt;= ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dec = <span class="number">0</span>;</span><br><span class="line">                pre = ratings[i] == ratings[i - <span class="number">1</span>] ? <span class="number">1</span> : pre + <span class="number">1</span>;</span><br><span class="line">                ret += pre;</span><br><span class="line">                inc = pre;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dec++;</span><br><span class="line">                <span class="keyword">if</span> (dec == inc) &#123;</span><br><span class="line">                    dec++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret += dec;</span><br><span class="line">                pre = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Leetcode-42-接雨水"><a href="#Leetcode-42-接雨水" class="headerlink" title="Leetcode 42.接雨水"></a>Leetcode 42.接雨水</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max_left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span> (height[j]&gt;max_left)</span><br><span class="line">                max_left = height[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max_right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (height[j]&gt;max_right)</span><br><span class="line">                max_right = height[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (height[i]&lt;Math.min(max_left,max_right))&#123;</span><br><span class="line">                ans+=Math.min(max_left,max_right)- height[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Leetcode-13-罗马数字转整形"><a href="#Leetcode-13-罗马数字转整形" class="headerlink" title="Leetcode 13.罗马数字转整形"></a>Leetcode 13.罗马数字转整形</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; romanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        romanMap.put(<span class="string">&#x27;I&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;V&#x27;</span>,<span class="number">5</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;X&#x27;</span>,<span class="number">10</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;L&#x27;</span>,<span class="number">50</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;C&#x27;</span>,<span class="number">100</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;D&#x27;</span>,<span class="number">500</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;M&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i==length-<span class="number">1</span>)ans+=romanMap.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (romanMap.get(s.charAt(i))&lt;romanMap.get(s.charAt(i+<span class="number">1</span>)))&#123;</span><br><span class="line">                    ans-=romanMap.get(s.charAt(i));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans+=romanMap.get(s.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Leetcode-12-整数转罗马数字"><a href="#Leetcode-12-整数转罗马数字" class="headerlink" title="Leetcode 12.整数转罗马数字"></a>Leetcode 12.整数转罗马数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">roman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> values[i];</span><br><span class="line">            <span class="type">String</span> <span class="variable">symbol</span> <span class="operator">=</span> symbols[i];</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= value) &#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman.append(symbol);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roman.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Leetcode-63-不同路径2"><a href="#Leetcode-63-不同路径2" class="headerlink" title="Leetcode 63.不同路径2"></a>Leetcode 63.不同路径2</h3><p>递归的方法会超时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid == <span class="literal">null</span> || obstacleGrid.length == <span class="number">0</span> || obstacleGrid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示到达 (i, j) 的路径数</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 遇到障碍物，之后的格子路径数为0</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 遇到障碍物，之后的格子路径数为0</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充 dp 表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>; <span class="comment">// 遇到障碍物，路径数为0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]; <span class="comment">// 返回右下角的路径数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid == <span class="literal">null</span> || obstacleGrid.length == <span class="number">0</span> || obstacleGrid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示到达 (i, j) 的路径数</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 遇到障碍物，之后的格子路径数为0</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 遇到障碍物，之后的格子路径数为0</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充 dp 表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>; <span class="comment">// 遇到障碍物，路径数为0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]; <span class="comment">// 返回右下角的路径数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Leetcode-68-文本左右对齐"><a href="#Leetcode-68-文本左右对齐" class="headerlink" title="Leetcode 68.文本左右对齐"></a>Leetcode 68.文本左右对齐</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">fullJustify</span><span class="params">(String[] words, <span class="type">int</span> maxWidth)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>, n = words.length;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> right; <span class="comment">// 当前行的第一个单词在 words 的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sumLen</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 统计这一行单词长度之和</span></span><br><span class="line">            <span class="comment">// 循环确定当前行可以放多少单词，注意单词之间应至少有一个空格</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; n &amp;&amp; sumLen + words[right].length() + right - left &lt;= maxWidth) &#123;</span><br><span class="line">                sumLen += words[right++].length();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格</span></span><br><span class="line">            <span class="keyword">if</span> (right == n) &#123;</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> join(words, left, n, <span class="string">&quot; &quot;</span>);</span><br><span class="line">                sb.append(blank(maxWidth - sb.length()));</span><br><span class="line">                ans.add(sb.toString());</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">numWords</span> <span class="operator">=</span> right - left;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numSpaces</span> <span class="operator">=</span> maxWidth - sumLen;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前行只有一个单词：该单词左对齐，在行末填充剩余空格</span></span><br><span class="line">            <span class="keyword">if</span> (numWords == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(words[left]);</span><br><span class="line">                sb.append(blank(numSpaces));</span><br><span class="line">                ans.add(sb.toString());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前行不只一个单词</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">avgSpaces</span> <span class="operator">=</span> numSpaces / (numWords - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">extraSpaces</span> <span class="operator">=</span> numSpaces % (numWords - <span class="number">1</span>);</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            sb.append(join(words, left, left + extraSpaces + <span class="number">1</span>, blank(avgSpaces + <span class="number">1</span>))); <span class="comment">// 拼接额外加一个空格的单词</span></span><br><span class="line">            sb.append(blank(avgSpaces));</span><br><span class="line">            sb.append(join(words, left + extraSpaces + <span class="number">1</span>, right, blank(avgSpaces))); <span class="comment">// 拼接其余单词</span></span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// blank 返回长度为 n 的由空格组成的字符串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">blank</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sb.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// join 返回用 sep 拼接 [left, right) 范围内的 words 组成的字符串</span></span><br><span class="line">    <span class="keyword">public</span> StringBuffer <span class="title function_">join</span><span class="params">(String[] words, <span class="type">int</span> left, <span class="type">int</span> right, String sep)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(words[left]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>; i &lt; right; ++i) &#123;</span><br><span class="line">            sb.append(sep);</span><br><span class="line">            sb.append(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Leetcode-125-验证回文串"><a href="#Leetcode-125-验证回文串" class="headerlink" title="Leetcode 125.验证回文串"></a>Leetcode 125.验证回文串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.toLowerCase();</span><br><span class="line">        <span class="type">Stack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s2.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetter(s2.charAt(i))||Character.isDigit(s2.charAt(i)))&#123;</span><br><span class="line">                stack.push(s2.charAt(i));</span><br><span class="line">                queue.offer(s2.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.peek()==queue.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Leetcode-167-两数之和-II-输入有序数组"><a href="#Leetcode-167-两数之和-II-输入有序数组" class="headerlink" title="Leetcode 167.两数之和 II - 输入有序数组"></a>Leetcode 167.<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[low] + numbers[high];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;low + <span class="number">1</span>, high + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                ++low;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --high;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Leetcode-11-盛最多水的容器"><a href="#Leetcode-11-盛最多水的容器" class="headerlink" title="Leetcode 11.盛最多水的容器"></a>Leetcode 11.盛最多水的容器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法会超时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> ((j-i)*Math.min(height[i],height[j])&gt;ans)&#123;</span><br><span class="line">                    ans = (j-i)*Math.min(height[i],height[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双指针，正确性可以用反证法：如果高度更高的反而改变了，那么能装的水肯定是变小的，所以这种策略一定是让能装的水变多的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minHeight</span> <span class="operator">=</span> Math.min(height[start],height[end]);</span><br><span class="line">            <span class="keyword">if</span> ((end-start)*minHeight&gt;ans)&#123;</span><br><span class="line">                ans = (end-start)*minHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minHeight==height[start])start++;</span><br><span class="line">            <span class="keyword">else</span> end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于动态规划/性价比/背包问题的思考</title>
      <link href="/2024/06/24/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%E6%80%A7%E4%BB%B7%E6%AF%94%E9%97%AE%E9%A2%98%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2024/06/24/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%E6%80%A7%E4%BB%B7%E6%AF%94%E9%97%AE%E9%A2%98%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="关于动态规划-性价比-背包问题的思考"><a href="#关于动态规划-性价比-背包问题的思考" class="headerlink" title="关于动态规划&#x2F;性价比&#x2F;背包问题的思考"></a>关于动态规划&#x2F;性价比&#x2F;背包问题的思考</h1><p>01背包本质上就可以用空间换时间，动规本质上也是那空间换时间，本身也就是一个贪心算法，所以<br>01背包&lt;–&gt;贪心&lt;–&gt;动态规划</p><p>如果说是0-1背包问题，需要逆序更新，原因是东西只有一个，不能影响之前的部分</p><p>如果是东西有无数个，则直接顺序更新</p><p>如果东西是牛奶之类的，有性价比，并且可以买非整数数量的，可以退化为贪心来做，结构体：数量，价格，性价比，sort一下就完事儿了。</p><p>讲究序列（排列问题），先遍历背包，不要求序列（组合问题），先遍历物品</p><p>滚动数组</p><p>另外，0-1背包要求倒序，若要求组合而非排列，即为先物品，再背包，且倒顺序，滚动数组添加</p><p>而且，如果是算有多少种，直接加就行,dp[0]&#x3D;1，其他为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[j]+=dp[j-nums[i]]</span><br><span class="line">    <span class="comment">//这里怎么去理解呢，会导致重复吗？</span></span><br><span class="line">    <span class="comment">//不会重复</span></span><br></pre></td></tr></table></figure><p>如果是要算最多&#x2F;最少，还要min和max比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j]=<span class="built_in">max</span>(dp[j],dp[j-nums[i]]+value[i])</span><br></pre></td></tr></table></figure><p>[(425条消息) 背包问题（背包九讲）_你好世界wxx的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_42638946/article/details/114028588?ops_request_misc=%7B%22request_id%22:%22167933155516800186567314%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=167933155516800186567314&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-6-114028588-null-null.142%5Ev74%5Epc_new_rank,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">https://blog.csdn.net/weixin_42638946/article/details/114028588?ops_request_misc=%7B%22request%5Fid%22%3A%22167933155516800186567314%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=167933155516800186567314&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-6-114028588-null-null.142^v74^pc_new_rank,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=01背包问题</a> 凑整&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by WXX on 2021/2/24 14:36</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j--) <span class="comment">//倒叙</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by WXX on 2021/2/24 15:21</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; j++)<span class="comment">//顺序</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by WXX on 2021/2/24 16:07</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  <span class="comment">// 先循环物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)  <span class="comment">// 再循环容量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++)  <span class="comment">// 最后循环决策</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研夏令营他人经验总结</title>
      <link href="/2024/06/24/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%BA%90/"/>
      <url>/2024/06/24/%E4%BF%9D%E7%A0%94%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="保研夏令营"><a href="#保研夏令营" class="headerlink" title="保研夏令营"></a><strong>保研夏令营</strong></h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h2><ul><li>CSP，最好300+？（<strong>对于北航有效</strong>）</li><li>报名一般5月开始，联系老师建议4月</li></ul><h2 id="入营"><a href="#入营" class="headerlink" title="入营"></a><strong>入营</strong></h2><ul><li>主要看<strong>成绩</strong>，<strong>高质量科研</strong>成果加分，实习经历、获奖<strong>无用</strong>，入营后成绩影响不大（rank1可加<strong>印象分</strong>）——郑博文</li><li>清北上交学硕rank1都不一定进得去</li><li>都留给本校学生了</li><li>复旦卡rank1</li><li>南大比较海rank5&#x2F;6好像就行</li><li>中科大有点歧视非计科出身，软院入营看运气</li><li>自动化所要rank1&#x2F;2</li><li>计算所联系老师</li><li>清深热门专业也比较难入</li><li>其他方向还好</li><li>北大整个都是联系老师流的</li><li>浙大夏令营没有学硕，就不说了</li><li>清华也没学硕，直博也不给offer</li><li>人大高瓴要rank1&#x2F;2        ——郑博文</li></ul><h2 id="机试"><a href="#机试" class="headerlink" title="机试"></a><strong>机试</strong></h2><ul><li>非常不推荐力扣（不需要自己设计数据结构、不需要自己处理输入输出），不推荐其他语言</li><li>语言：<strong>C++</strong>        平台：<strong>洛谷、AcWing</strong>        ——郑博文</li><li>狠抓，因为很多学校都因为这个初筛，人工智能机试卷中卷，尽量现在就连起来  leetcode（主要看思想） pat要相对难一点，重点！！！要看输入输出；在保研成绩稳的情况下，准备机试（我摔了很多次的地方一定要在强调很多遍） 数据结构——刘欣宇</li><li>计算所机试vipl实验室如果用c++的话  不能调用stl库  考的也就是用c实现了  其他的都是可以调用库的——刘欣宇</li><li>有一本王道机试指南  你可以找找电子版  里面题很经典 前面的比较简单  尽量早点过  后面图论也比较容易考，算法里面很爱考贪心  动态规划，你也可以看看时间函数  我遇到过两次机试  是考时间的  题目大概是  上班打卡，下班也要打卡，打卡方式有很多种，但是都是同一个人的，这个人会进出公司，看谁累计上班时间长 ——刘欣宇</li></ul><h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a><strong>笔试</strong></h2><ul><li>看是计算机学院还是ai学院，数据结构比较重视，其他三门专业课主要看知识点，数据结构刷了一本王道        ——郑博文</li><li>大多数学校没有笔试，南大、计算所有，南大难，考底层，计算所  有单独的数学考试（他还考了少量的微积分  极少极少）——刘欣宇</li></ul><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><ul><li>408和数学也要复习 面试会问你，408里面 数据结构》计网》操作系统  计组</li><li>先看数据结构  数学（线代很爱问正定矩阵  概率论很爱问大数定律和中心极限定理） 然后在看计网 os ，计组基本上没问——刘欣宇</li></ul><h2 id="科研"><a href="#科研" class="headerlink" title="科研"></a><strong>科研</strong></h2><ul><li>最好找个<strong>外校</strong>的实验室，<strong>计院</strong>的也行，本校实验室不算实习，但可以让老师帮挂公司</li><li>一定要<strong>高质量</strong>科研成果        ——郑博文</li></ul><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><ul><li>突然想起来  心态也很重要  有可能夏令营啥也没拿到  或者只有一个  但是别慌 预推免还有  预推免先都报上  如只要能面试  就有很大概率候补到  不要全都选很好的专业  很容易落得一场空  坚信  只要我面试了 肯定会有候补到的时候；今年浙软  南大计算机  北航计算机 国防科大都快被鸽穿了 ——刘欣宇</li></ul><h2 id="一些文章链接"><a href="#一些文章链接" class="headerlink" title="一些文章链接"></a>一些文章链接</h2><p><a href="https://blog.csdn.net/mengwuyaaa/article/details/82918032?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-82918032-blog-125315403.pc_relevant_vip_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-82918032-blog-125315403.pc_relevant_vip_default&utm_relevant_index=2">https://blog.csdn.net/mengwuyaaa/article/details/82918032?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-82918032-blog-125315403.pc_relevant_vip_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-82918032-blog-125315403.pc_relevant_vip_default&amp;utm_relevant_index=2</a></p><h1 id="经验贴的一些阅读"><a href="#经验贴的一些阅读" class="headerlink" title="经验贴的一些阅读"></a>经验贴的一些阅读</h1><h2 id="人品"><a href="#人品" class="headerlink" title="人品"></a>人品</h2><p>导师人品最重要，千万不要去坑导直博，即使是清北的。</p><p>可以先去导师评价网找找，目前可用的有 <a href="https://link.zhihu.com/?target=https://www.yankong.org/">研控</a> 、<a href="https://link.zhihu.com/?target=https://www.daoshipingjia.xyz/">硕博导师评价网</a>，另外我这里还有导师评价网后台数据库 excel（包含全国各大院校 1 万条导师评价信息），以及上交电院导师评价，不方便发，需要的话可以私戳。</p><p>然后就是在百度、谷歌上搜，还可以去问组内 &#x2F; 隔壁组学长学姐。如何联系学长学姐？<strong>一种方法是找本校保研到该校或在绿群找到保研到该校的学长学姐，请他介绍介绍；另一种方法是通过导师的论文，推测出学长学姐的名字，然后在论文网站里找邮箱发邮件问。注意要兼听则明</strong></p><h2 id="专业课怎么复习"><a href="#专业课怎么复习" class="headerlink" title="专业课怎么复习"></a>专业课怎么复习</h2><p>如果时间不是很充裕，不要全面撒网，每门课要复习的也就一二十个常见问题，找找保研 &#x2F; 考研面试重点问题来看看就行。</p><p>要复习的课有：</p><ul><li>数学：线性代数、概率论、高数</li><li>计算机：数据结构、计组、操作系统、计网、算法、数据库、软件工程、编译原理、编程语言</li><li>人工智能：机器学习、深度学习</li></ul><p>注意这些课不必完全复习，挑几门和研究方向相关的看看重点就行，比如对于 AI 方向，最重要的是数学、数据结构、人工智能。</p><h2 id="没有科研经历咋办"><a href="#没有科研经历咋办" class="headerlink" title="没有科研经历咋办"></a>没有科研经历咋办</h2><p>和老师方向一致的科研经历非常重要，即使没有产出论文，也是巨大的加分项，这就像去找工作，实习经历是巨大的加分项一样。</p><p>如果你现在是大三下学期开学之前的话，可以去联系本校老师进实验室做科研。如果已经很晚了，如六月份了，可以去找一些论文，复现或者读懂代码，掌握好细节，包装成一个项目，耗时半个月左右，前提是不能被问穿，得答得上来。</p><p>一段科研经历，老师更关注你做了什么，而不是这个科研做的结果。要讲好一个项目，需要讲好 motivation（为什么做）、method（做了什么）、result（做得咋样）、contribution（你做了啥），其中最重要的是 contribution 和 motivation。不要说得太直白，尽量学术化一点。（可以参考顶会论文的 Introduction，看看怎样讲好一个故事）。老师也非常喜欢问你的科研项目里面用到的东西的底层原理，而这些东西你可能就是在 PyTorch 里面调了个库，需要注意一下。</p><p>如果有论文，论文的内容、细节一定要清楚，还有 EI 会议之类的水文不建议写在简历，如果被问穿了，可能是减分项</p><h2 id="要准备哪些文书"><a href="#要准备哪些文书" class="headerlink" title="要准备哪些文书"></a>要准备哪些文书</h2><p>文书材料的模板后续我会整理发出来。</p><ul><li>简历：推荐 <a href="https://link.zhihu.com/?target=https://www.wondercv.com/">超级简历WonderCV</a> ，内容写保研要素中比较重要的就行，包括：联系方式、学校、专业、成绩、排名、获奖、项目、数学、编程、英语、读博意向等，自己的劣势部分不要往上面写。</li><li>个人陈述：准备 1000 字、2000 字的，就是简历的扩充，重点是讲做过的项目，研究规划等。</li><li>推荐信：准备 2 封教授推荐信即可，这东西没人看，注意复旦、北航等学校需正教授推荐信，清华、复旦等学校要求老师本人在线填写或用本人的邮箱发送推荐信。</li><li>套磁信：既要简洁了当，直言主题，又不能不客套。edu邮箱比较正式，gmail有邮件追踪插件mailtrack。</li><li>PPT：相当于把简历讲出来，大部分的篇幅应该讲项目，和学习无关的不要讲太多。</li><li>各种证明材料：成绩单、排名证明、获奖证书、身份证、学生证、英语证明，都扫描成pdf。</li></ul><h2 id="一些有用的网站"><a href="#一些有用的网站" class="headerlink" title="一些有用的网站"></a>一些有用的网站</h2><ul><li>邮件追踪：Gmail 有个插件 mailtrack，可以看到你发的邮件什么时候被老师打开了，打开了几次。</li><li>查老师学术水平：<a href="https://link.zhihu.com/?target=https://scholar.google.com/">Google Scholar</a>、<a href="https://link.zhihu.com/?target=https://dblp.org/">dblp</a>、<a href="https://link.zhihu.com/?target=https://www.aminer.cn/">AMiner</a>、<a href="https://link.zhihu.com/?target=https://csrankings.org/%23/index?all&cn">CSRankings</a>、<a href="https://link.zhihu.com/?target=https://www.semanticscholar.org/">Semantic Scholar</a></li><li>查国家自然科学基金：<a href="https://link.zhihu.com/?target=https://www.ceshigo.com/Nsfc/fund">测试狗基金查询</a>、<a href="https://link.zhihu.com/?target=https://grants.nsfc.gov.cn/egrantindex/funcindex/prjsearch-list">基金委查询系统</a></li><li>导师评价网：<a href="https://link.zhihu.com/?target=https://www.yankong.org/">研控</a> 、<a href="https://link.zhihu.com/?target=https://www.daoshipingjia.xyz/">硕博导师评价网</a></li><li>机试刷题平台：<a href="https://link.zhihu.com/?target=https://www.acwing.com/">AcWing</a></li><li>夏令营 &#x2F; 预推免开营信息：<a href="https://link.zhihu.com/?target=http://pc.baoyanwang.com.cn/">保研信息网</a></li><li>中科院计算所各实验室介绍：<a href="https://link.zhihu.com/?target=http://cskaoyan.com/thread-237791-1-2.html">中科院计算所实验室情况简要介绍-王道论坛</a></li></ul><h1 id="清北华五院系分析"><a href="#清北华五院系分析" class="headerlink" title="清北华五院系分析"></a>清北华五院系分析</h1><h2 id="1-清华大学"><a href="#1-清华大学" class="headerlink" title="1 清华大学"></a>1 清华大学</h2><p>清华的 offer 基本在预推免发，夏令营发 offer 的只有叉院、深研院。除了软件、深研院外，外校基本只能拿直博。夏令营各院系自己组织，可以报多个，但有些院系没有夏令营。预推免是学校系统上报，最多报两个。</p><ul><li>计算机系（贵系）：国内计算机 top1，需要尽早联系导师。开夏令营，但不发 offer，通过机试的，预推免免试。机试很难，3 道编程题，难度和 CSP 第 3-4 题差不多。</li><li>自动化系（雷系）：有做 AI 的老师，注意自动化系的硕士分三种，学硕、大数据工程（要去贵州）、校企联培（要去企业）。</li><li>叉院：国内 bar 最高的学院，至少要 985 rk1 + 在投顶会 &#x2F; ACM，6 月初就开营。</li><li>软件学院：没有夏令营，基本上是专硕，强com，主要看机试成绩，机试难度中等。</li><li>网研院：相当于贵系网安专业，难度比贵系低。</li><li>深研院：有计算机技术、人工智能、大数据、TBSI 四个方向，TBSI 是学硕，其他都是专硕，计算机技术机试很难，人工智能最卷，TBSI 要求六级 500+。</li><li>高等研究院：有 msra 校企联培博士，导师郭百宁，但是好像没啥人知道，可以早点联系捡漏。</li></ul><h2 id="2-北京大学"><a href="#2-北京大学" class="headerlink" title="2 北京大学"></a>2 北京大学</h2><p>北大的 offer 大多是夏令营发出去，预推免相当于补录了，可以报多个院系。</p><ul><li><p>计算机学院：超弱 com，完全取决于老师要不要你，夏令营无机试，面试走过场，需要尽早联系导师，去进组实习，bar 比贵系低，985 前 5% 就可以试试。夏令营之后，软件所一般鸽的比较多，还有外校基本只能拿直博。</p></li><li><p>智能学院：原信科智能所，和计算机学院的情况差不多。</p></li><li><p>软微：基本全是专硕，纯就业向，强com，入营主要看排名，不过据说从今年开始，也要做科研了。</p></li><li><p>深研院：基本全是学硕，弱com，不过坑导较多。</p></li><li><p>软微：</p><ul><li><p>不得不说北京真的是大城市，这是我第一次来北京，真的感受到了首都的魅力。</p><p>   复试分为两个部分：手撕算法题 + 面试</p><pre><code>  手撕算法题部分，当天面试的所有人都在一起写题，一共有三道题，选其中一道题手撕代码就可以了，难度大概是 easy 到 medium 之间吧，手撕快排也有，大模拟也有。  面试部分，首先你要给每位老师发你的简历，老师看到我是湖大的，就要我英文描述一下湖大的风景，其实我早有准备，当时背的是介绍长沙，我就活用了。然后老师让我抽一道基础题，我抽到了数据库系统，其实很不巧我就数据库没怎么复习，但是还是凭自己的记忆说了一通，然后老师还问了数据库系统和数据库管理系统的区别，我记得他说的是 DBS 和 DBMS 的区别，当时我秒懂，DBMS 我会啊，所以我又说了一通。  接着老师会拿出刚刚手撕的算法题问你觉得怎么样，写得对不对，你要尽可能展现出你的算法功底就好了，比方说一个很简单的求平方和，没有给你数据范围时，其实是一个大数乘法 + 大数加法。然后老师开始问我项目了，大概问了我的代码量和实现难点。</code></pre></li><li></li></ul></li></ul><h2 id="3-中科院"><a href="#3-中科院" class="headerlink" title="3 中科院"></a>3 中科院</h2><p>中科院各所差别极大，所内各组也差别极大，所谓“强组清北，弱组211”。中科院的师生比很高，一般硕导一年 0-1 个硕士名额，博导一年1硕1博，中科院可以报任意多个所（多准备几个邮箱多注册几个号就行）。计算机相关的研究所有：</p><p>表格 还在加载中，请等待加载完成后再尝试复制</p><p>各所基本是夏令营就招完学生，预推免相当于补录，另外，国科大计算机学院、人工智能学院也招生（比两所容易一些），导师基本是两所的。最后再说一下，虽然两所的实力要略强于华五，如果你以后从事专业相关的事情（如：学术届、企业技术岗），可以来两所；但如果以后从事非专业相关的事情（如：考公），更建议去华五。</p><ul><li>计算所：体系结构方向亚洲第一，AI 方向实力也很强，超弱com，你甚至没入营都可以拿 offer，有霸面机制，即如果你没有入营，老师也可以邀请你来面试，和入营的没区别。计算所是分组来考核的，所里不管，牛组竞争非常激烈（如寒武纪、龙芯、vipl等）。体系结构和 AI 的大牛很多，就不细说了。还有要注意很多组要求博士延毕一年。</li><li>自动化所：体量很大，光模式识别国重就 100 多位老师，AI 方向特别 CV 很强，模式识别国重有很多 AI 大牛。强 com，bar 985 前 5，以“未来的邀约”闻名于保研圈。</li><li>软件所：有计算机科学国重（软件与理论方向），另外中文信息实验室的孙l、韩xp老师也比较强（NLP 方向）。</li><li>信工所：有网安国重，有个 CV 组也很强（操xc组），不过，操老师去年跳槽到中山当院长了。</li><li>神仙院：深圳先进技术研究院，下面的数字所有个 MM Lab 很强，和港中大那个 MM Lab 、商汤、上海浦江实验室关系密切，负责人是乔y老师（3万引），另外组里董c老师也是大牛。</li></ul><h2 id="4-上海交通大学"><a href="#4-上海交通大学" class="headerlink" title="4 上海交通大学"></a>4 上海交通大学</h2><p>招生主要在夏令营，预推免招的少。注意上交电院博士毕业是出了名的难，据说基本 6 年起步。密西根是单独报名，其他院系在学校系统上报名，只能报一个。</p><ul><li>计算机系、网安：上交计算机系像贵系那样，各方向都有，都比较强。硕士非常难，2021 年非华五只录了 4 个，有机试。直博入营容易，没有机试，关键是要找到导师接收（直博没有导师接收，拿了优营也没用）。上交牛导很多，AI 方向有几个年轻老师特别火，如卢cw、张wn、张qs、严jc 等。</li><li>软件学院：国内最强的软件学院，以 ipads实验室（分布式系统方向）闻名，机试听说是开发软件，比较硬核。</li><li>网安学院：比计算机系要容易。</li><li>密西根学院：想去上交，密西根最容易，不过学费贵，导师一般。</li></ul><h2 id="5-浙江大学"><a href="#5-浙江大学" class="headerlink" title="5 浙江大学"></a>5 浙江大学</h2><p>浙大的计算机图形学国内第一，计算机学院体量也非常大。浙大只能报一个学院。</p><ul><li>计算机学院：夏令营只有直博，要去做一个多月的项目，内容由报名老师指定，8月下旬，每个博导可以推荐 1 名学生（院士 2 名），进入学院答辩环节（走过场）。浙大大量名额（含所有硕士名额）在预推免，不过要跟浙大本校竞争。CAD&amp;CG 国重里面有很多 CG、CV 大牛。</li><li>软件学院：在宁波，纯就业向，夏令营入营点击就送，千人海王营，考核要做项目，优营容易拿，但没什么用，还是要参加预推免，预推免有机试。</li><li>工程师学院：夏令营、预推免都有，比计算机学院容易。</li><li>国际联合学院：在嘉兴市海宁市（县级市），不太了解，招计算机专业的学生。</li></ul><h2 id="6-复旦大学"><a href="#6-复旦大学" class="headerlink" title="6 复旦大学"></a>6 复旦大学</h2><p>复旦的计算机是 B+，但是人工智能方向很强，学校 title 好，魔都位置好。复旦只能报一个学院。</p><ul><li>计算机学院：发放 offer 夏令营：预推免 &#x3D; 1 : 2，夏令营的 bar 巨高，985 一个专业只能入一个。有机试但不算分。NLP 组（黄邱张）很强，CV 方向姜yg组、薛xy组也比较强。</li><li>大数据学院：发统计学或金融学位证，难度不比计算机学院低，对数学要求高。</li><li>工研院：难度比计算机学院低。</li><li>类脑智能研究院：有部分老师做 AI 和生物交叉。</li></ul><h2 id="7-南京大学"><a href="#7-南京大学" class="headerlink" title="7 南京大学"></a>7 南京大学</h2><p>南大三个学院都可以报，但只能入一个，海王营，入营后有线上笔试，考408等专业课，没有机试，南大是超强 com。</p><ul><li>计算机系：软件所非常强，软件所在学院夏令营前有自己办的夏令营，另外 MCG 组的王lm老师是南大 CV 最强的老师，NLP 组黄sj老师也比较强。</li><li>人工智能学院：lamda（周zh组）非常强，主要是做机器学习、数据挖掘的， lamda 在学院夏令营前也有自己办的夏令营，lamda 一共两轮面试，第一轮学长面，第二轮报考老师面。注意拿了 lamda offer 后，还需要人工智能学院优营才能录取，南大的 com 非常强。</li><li>软件学院：比 CS、AI 容易一些，纯就业型。</li></ul><h2 id="8-中国科学技术大学"><a href="#8-中国科学技术大学" class="headerlink" title="8 中国科学技术大学"></a>8 中国科学技术大学</h2><p>中科大没有直博，全是硕士，系统里可以报三个志愿，只能入一个，基本上只有一志愿有用，中科大是弱 com。还有入营中科大后会收到入营大礼包！！！</p><ul><li>计算机学院：入营歧视软件专业，我校计算机前5%可入，软件只能入1%，没有预推免。AI方向做数据挖掘的多，几乎没有做CV的（都在自动化系、电子系）。BDAA（陈eh组）很强，陈eh老师是杰青，组里还有刘q、连df两位优青，人好学术好。网络方向李xy（ACM &#x2F; IEEE fellow）组很牛，组里张yy老师也是IEEE fellow，做智能感知的。另外计算机学院还有网红教授张l（逃）</li><li>自动化系（10系）：自动化系和电子系虽然同属信息学院，但招生是分开的，必须导师推荐才能入营，预推免有少量名额。CV 方向的张tz，查zj老师很强，都是优青+万引。</li><li>电子系（6系）：虽然叫电子系，其实很多老师是做人工智能的，大牛很多。何xn组（巨牛，30岁，2.2万引）非常强，何老师组里两位小老板也很强，王x（7k引）、冯fl（4k引），都是30岁出头。电子系AI方向还有吴f（院士候选人）、李hq、张yd等杰青，周wg、刘d、谢ht、王j等优青，实力非常强。</li><li>大数据学院：就是计算机、自动化、电子的老师，一般科大本校喜欢拿大数据学院名额，所以外校入营难，没有预推免。</li><li>网安学院：何xn的两个小老板都挂在网安学院，这里甚至还能找到潘建伟。</li><li>软件学院：一共就几个保研招生名额，主要招考研。</li><li>苏州研究院：比本部简单一些，值得一提的是，中科院计算所奇迹组的周sh老师（IEEE fellow，万引，医学影像大牛）全职来中科大，在这里招生物医学工程专业的学生（医学 CV 方向）。</li><li>先研院：比本部简单一些。</li><li>科学岛：中科院合肥物质研究院，发中科大毕业证，入营点击就送，最容易上岸华五的地方。</li></ul><h2 id="9-中国人民大学"><a href="#9-中国人民大学" class="headerlink" title="9 中国人民大学"></a>9 中国人民大学</h2><p>人大在中关村，位置好，学术强的老师大多在高瓴，强 com。人大信息和高瓴可以都报，也可以都入营，</p><ul><li>信息学院（王老吉）：夏令营 4 月 20 号左右就开放报名了，然后愣是 6 月 29 才发入营名单，官网通告栏一直是王老吉奖学金获奖公示，绿群群友们天天去刷学院官网都等不到入营名单，故称为王老吉学院。王老吉招生人数少，之前入营也少，bar 很高（学硕卡 985 rk2 左右），但今年是海王营了。王老吉数据库方向比较强，无预推免。</li><li>高瓴人工智能学院（加多宝）：王老吉的 hxd 当然是加多宝了。高瓴的老师基本都是做 AI 的（偏信息检索、数据挖掘），没有什么比较差的，下限很高，都做学术。高瓴只有学硕和直博，都在夏令营招生，没有预推免，鸽子比较多，一般入营即 offer，学硕 bar 挺高，可能 985 2% 左右，直博低一些。文jr、徐j等老师都是 msra 过来的，IR 大牛，严r老师是北大王选所过来的，NLP 大牛，还有几个姚班毕业的 AP 也很强。高瓴最大的劣势就是人大这个 title 不够好了吧。</li></ul><h2 id="10-其他学校的部分AI牛组"><a href="#10-其他学校的部分AI牛组" class="headerlink" title="10 其他学校的部分AI牛组"></a>10 其他学校的部分AI牛组</h2><p>我保研过程中了解到的其他学校的一些 AI 牛组（还有很多没列上来）：</p><p>南开大学程mm组（CV）、哈工大SCIR实验室（刘t组，NLP）、北航VR国重（CV）、厦门大学mac实验室（纪rr组，CV）、东南大学palm实验室（耿x组）、中山大学郑ws组（CV）、华科白x组（OCR）、上科大虞jy组（CV）、西湖大学李zq组（原自动化所大牛）、西湖大学张y组（NLP）。</p>]]></content>
      
      
      <categories>
          
          <category> 经验贴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 夏令营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分布式系统（一）认识分布式系统</title>
      <link href="/2024/06/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/06/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="认识分布式系统"><a href="#认识分布式系统" class="headerlink" title="认识分布式系统"></a>认识分布式系统</h1><h2 id="1-1-什么是分布式系统"><a href="#1-1-什么是分布式系统" class="headerlink" title="1.1 什么是分布式系统"></a>1.1 什么是分布式系统</h2><p>定义：</p><p>分布式系统指的是由多台计算机组成的系统，这些计算机通过网络连接起来，协同工作以实现共同的目标。在分布式系统中，各个计算机之间相互独立，同时也需要协同工作来处理大量的数据和任务。分布式系统可以包括不同类型的计算机，包括服务器、台式机、移动设备等等。</p><p>分布式系统的一个主要特点是其高度的可扩展性，可以随着需求增长而增加计算机的数量。分布式系统还具有高可靠性，因为即使其中一个计算机发生故障，系统也可以继续运行，不会因为单一点的故障而完全崩溃。分布式系统还可以提供更好的性能和更快的响应时间，因为可以将任务分配给多个计算机并行处理，而不是依靠单个计算机来处理所有任务。</p><p>分布式系统的应用非常广泛，包括云计算、大数据处理、分布式数据库、分布式存储系统、分布式搜索引擎等等。</p><h2 id="1-2-为什么需要分布式系统"><a href="#1-2-为什么需要分布式系统" class="headerlink" title="1.2 为什么需要分布式系统"></a>1.2 为什么需要分布式系统</h2><p>分布式系统是由多个独立计算机组成的网络，这些计算机通过网络互相通信和协调，共同完成某些任务或提供某些服务。分布式系统之所以重要，是因为它可以带来以下几个好处：</p><ol><li>可靠性：分布式系统可以提高系统的可靠性，因为它可以在某个节点或多个节点发生故障的情况下继续工作。</li><li>可扩展性：分布式系统可以通过增加计算机节点来扩展系统的处理能力，从而应对更大的工作负载。</li><li>高性能：分布式系统可以将任务分割成多个子任务，并在多个节点上并行处理，从而提高系统的处理速度。</li><li>负载均衡：分布式系统可以将负载分配到多个节点上，避免某个节点过度负载的情况发生，从而提高系统的稳定性和可用性。</li><li>数据共享：分布式系统可以让不同节点之间共享数据，从而使得数据更容易被访问和处理。</li></ol><p>总之，分布式系统可以提高系统的可靠性、可扩展性、高性能和负载均衡能力，使得系统更加稳定和高效。因此，在大规模应用中，分布式系统已成为一种必要的技术手段。</p><h2 id="1-3-分布式系统的示例"><a href="#1-3-分布式系统的示例" class="headerlink" title="1.3 分布式系统的示例"></a>1.3 分布式系统的示例</h2><h3 id="1-3-1-搜索引擎"><a href="#1-3-1-搜索引擎" class="headerlink" title="1.3.1 搜索引擎"></a>1.3.1 搜索引擎</h3><p>DNS是一个将IP地址和域名相互映射的分布式数据库，主要特点包括去中心化、可扩展性和健壮性。</p><p>搜索引擎背后的分布式基础设施：</p><ul><li>一个全球化、巨大的多数据中心（一个中心上万台物理机）</li><li>一个分布式文件系统（GFS）</li><li>大规模结构化数据的存储系统（Bigtable）</li><li>分布式锁服务(chubby)</li><li>并行和分布式计算的编程模式（MapReduce）</li><li>分布式数据库（Spanner）</li></ul><h3 id="1-3-2-加密货币"><a href="#1-3-2-加密货币" class="headerlink" title="1.3.2 加密货币"></a>1.3.2 加密货币</h3><p>加密货币和分布式系统密不可分。事实上，加密货币的核心技术就是基于分布式系统。</p><p>加密货币使用的是一种称为区块链的分布式账本技术。这种技术将账本数据分散存储在网络上的多个节点中，每个节点都有完整的账本副本，并通过加密算法进行验证和保护。这种分布式存储和验证方式使得区块链上的交易记录无法被篡改或删除，从而确保了加密货币的安全性和去中心化特点。</p><p>此外，分布式系统还能够实现去中心化的交易和转账，以及实现智能合约等功能。智能合约是一种自动执行的计算机程序，可以自动化完成各种事务，例如支付、转账、投票等。</p><p><a href="https://blog.csdn.net/weixin_40413961/article/details/122639770?ops_request_misc=%7B%22request_id%22:%22168554858916800213023799%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168554858916800213023799&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122639770-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6&spm=1018.2226.3001.4187">(458条消息) 区块链技术必杀技之——智能合约_区块链智能合约_jeff-y的博客-CSDN博客</a></p><p>总的来说，加密货币和分布式系统密切相关，加密货币的实现离不开分布式系统的技术支持，同时分布式系统也因为加密货币的需求而得到了广泛的应用和发展。</p><p>加密货币中的区块链技术使用了Merkle Tree来实现快速验证交易的有效性。</p><p>Merkle Tree是一种树状结构，它将数据分成小块并对这些块进行哈希运算。每个哈希值代表了它所对应数据块的内容。然后再将这些哈希值进行哈希，得到新的哈希值，称为父节点。父节点也可以再和其他父节点一起哈希，形成新的父节点，最终形成根节点。这个过程就像一棵树一样，因此被称为Merkle Tree。</p><p>在加密货币的交易验证中，Merkle Tree被用来快速验证某个交易是否属于某个区块。每个区块中的所有交易数据被组织成Merkle Tree结构，根节点的哈希值被包含在区块头中。当其他节点需要验证某个交易是否属于该区块时，只需要验证该交易的哈希值与Merkle Tree中的对应哈希值是否匹配，如果匹配，则该交易有效，否则无效。</p><p>通过Merkle Tree的结构，交易数据可以被高效地组织和验证，从而提高了加密货币系统的安全性和效率。</p><h2 id="1-4-分布式系统的挑战"><a href="#1-4-分布式系统的挑战" class="headerlink" title="1.4 分布式系统的挑战"></a>1.4 分布式系统的挑战</h2><p>网络延迟问题，部分失效问题，时钟问题</p><h3 id="1-4-1-网络延迟问题"><a href="#1-4-1-网络延迟问题" class="headerlink" title="1.4.1 网络延迟问题"></a>1.4.1 网络延迟问题</h3><p>分布式系统中的网络延迟是一个常见的问题，特别是在跨越不同的地理位置和数据中心时。网络延迟指的是从一个节点发送消息到另一个节点所需的时间。这个时间可以受到多种因素的影响，包括网络拓扑、带宽、传输协议和网络拥塞等。</p><p>为了降低网络延迟，可以采取以下措施：</p><ol><li>网络拓扑优化：设计一个合理的网络拓扑，使得节点之间的距离尽可能短，减少网络传输所需的时间。</li><li>协议选择优化：选择合适的协议，例如使用TCP&#x2F;IP协议时可以采用TCP快速打开（TCP Fast Open）协议来减少握手时间，或使用UDP协议来减少传输延迟。</li><li>数据压缩优化：对需要传输的数据进行压缩，可以减少数据传输量，从而减少网络传输所需的时间。</li><li>缓存优化：使用缓存技术可以减少对数据的重复访问，从而减少网络传输所需的时间。</li><li>负载均衡优化：使用负载均衡技术可以将请求分散到多个节点上，减少单个节点的负载，从而减少网络传输所需的时间。</li></ol><p>综上所述，网络延迟是分布式系统中的一个重要问题，需要采取多种优化措施来降低延迟，提高系统的性能和可靠性。</p><h3 id="1-4-2-部分失效问题"><a href="#1-4-2-部分失效问题" class="headerlink" title="1.4.2 部分失效问题"></a>1.4.2 部分失效问题</h3><p>分布式系统中的部分失效问题是指在分布式系统中的某些节点或者服务发生故障或失效，而系统的其他部分仍然正常运行。这种情况下，分布式系统需要采取措施来保证系统的可用性和稳定性。</p><p>以下是分布式系统中解决部分失效问题的一些常见方法：</p><ol><li>冗余备份：通过在分布式系统中增加冗余节点或服务来保证系统的可用性。当某些节点或服务失效时，冗余节点或服务可以接管其工作，从而保证系统的正常运行。</li><li>负载均衡：将请求分散到多个节点上，可以减轻单个节点的负担，从而减少故障的发生概率。负载均衡也可以将请求转发到最近的可用节点上，提高系统的性能和可用性。</li><li>异常检测和恢复：当某些节点或服务发生故障时，需要及时检测并采取恰当的措施进行恢复。这可以通过使用异常检测和恢复机制来实现，例如使用心跳检测机制来检测节点或服务是否存活。</li><li>限流和熔断：当某些节点或服务的负载过高时，可以采用限流和熔断机制来保护系统免受过度负载的影响。限流机制可以控制流量的速率，熔断机制可以暂时关闭某些节点或服务，以防止它们的故障影响整个系统的正常运行。</li><li>事务处理和回滚：当某些节点或服务发生故障时，可能会导致分布式事务失败。在这种情况下，需要采取事务处理和回滚机制来恢复故障，保证数据的一致性和可靠性。</li></ol><p>综上所述，分布式系统中的部分失效问题是一个常见的挑战，需要采取多种技术和机制来保证系统的可用性和稳定性。</p><h3 id="1-4-3-时钟问题"><a href="#1-4-3-时钟问题" class="headerlink" title="1.4.3 时钟问题"></a>1.4.3 时钟问题</h3><p>分布式系统中的时钟问题是指由于系统中的节点位于不同的地理位置，所以节点的时钟存在偏差和不同步的问题。时钟偏差和不同步会导致分布式系统中的数据同步、事务处理和协议执行等方面出现问题，从而影响系统的正确性和可靠性。</p><p>以下是分布式系统中解决时钟问题的一些常见方法：</p><ol><li>物理时钟同步：物理时钟同步是通过使用网络时间协议（NTP）或其他时钟同步协议来保证系统中的节点时钟保持同步。这可以减少节点之间的时钟偏差，从而提高系统的可靠性和正确性。</li><li>逻辑时钟：逻辑时钟是一种基于事件顺序的时钟，可以用于跨越不同节点的事件顺序标记。例如，Lamport时钟和向量时钟可以记录事件的发生顺序，并通过比较时间戳来确定事件的先后关系。</li><li>时钟漂移和修正：由于硬件时钟存在漂移，因此需要定期对时钟进行修正。例如，可以使用时间同步协议来校正时钟漂移，或者在节点之间进行时钟校准，从而减少时钟漂移的影响。</li><li>时钟容忍度：时钟容忍度是指在分布式系统中接受的时钟误差范围。节点之间的时钟误差超出容忍度范围时，系统会采取相应的措施来避免时钟问题对系统产生不良影响。</li></ol><p>综上所述，时钟问题是分布式系统中的一个重要挑战，需要采取多种技术和机制来解决。物理时钟同步、逻辑时钟、时钟漂移和修正以及时钟容忍度等技术和机制可以用来解决时钟问题，提高系统的可靠性和正确性。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 深入理解分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++刷题</title>
      <link href="/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2024/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p>[(459条消息) 【C语言】程序运行过程：预处理&#x2F;编译&#x2F;汇编&#x2F;链接_预处理编译汇编链接_慕雪华年的博客-CSDN博客](<a href="https://blog.csdn.net/muxuen/article/details/123227200?ops_request_misc=%7B%22request_id%22:%22168596052316800182799736%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168596052316800182799736&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123227200-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E9%A2%84%E5%A4%84%E7%90%86">https://blog.csdn.net/muxuen/article/details/123227200?ops_request_misc=%7B%22request%5Fid%22%3A%22168596052316800182799736%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168596052316800182799736&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123227200-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=预处理</a> 编译 汇编 链接&amp;spm&#x3D;1018.2226.3001.4187)</p><p><a href="https://blog.csdn.net/weixin_54338498/article/details/126953046?ops_request_misc=%7B%22request_id%22:%22168175034116800197040062%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168175034116800197040062&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-126953046-null-null.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&utm_term=%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95&spm=1018.2226.3001.4187">(443条消息) 保研机试——1基础算法（排序、哈希、模拟（日期、图形、查找、进制、字符串）、递归与分治、贪心）_Yuezero_的博客-CSDN博客</a></p><p>[(425条消息) 数据结构保研面试题整理（自用）_保研数据结构常温问题_乌鸡摸鱼的博客-CSDN博客](<a href="https://blog.csdn.net/m0_52571748/article/details/120505195?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">https://blog.csdn.net/m0_52571748/article/details/120505195?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=数据结构</a> 保研&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-120505195.142^v73^pc_search_v2,201^v4^add_ask,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><p><a href="https://blog.csdn.net/qq_53524653/article/details/121522229?ops_request_misc=%7B%22request_id%22:%22168740926216782425172942%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168740926216782425172942&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121522229-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187">(463条消息) 插入排序–折半插入排序（来一来，看一看，走过路过，不要错过）_老 胡的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/385907273">P问题、NP问题、NPC问题、NP-hard问题详解 - 知乎 (zhihu.com)</a></p><p>[保研机试整理 - 知乎 (zhihu.com)</p><p>什么时候才考虑用二分答案的技巧？<br>正向求出答案不好入手，求解答案远远没有验证答案简单。</p><p>已知前序后序算中序有多少种：</p><p>[<a href="https://blog.csdn.net/qq_37437983/article/details/79613947">(441条消息) 二叉树遍历（已知前序和后序遍历，求中序遍历的可能的序列数）_已知二叉树的前序遍历和后序遍历_我要出家当道士的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/40915131"></a></p><p><a href="https://blog.csdn.net/yizhiniu_xuyw/article/details/109596961?ops_request_misc=%7B%22request_id%22:%22168707250016800213049573%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168707250016800213049573&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-109596961-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%A0%86%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1018.2226.3001.4187">(462条消息) 堆排序的时间复杂度分析_一只牛_007的博客-CSDN博客</a></p><p>建立索引树：[(462条消息) 2020北航计算机夏令营机试题目个人理解_北航夏令营 机试_四处碰壁嘤嘤怪的博客-CSDN博客](<a href="https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request_id%22:%22168715279416800185829257%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168715279416800185829257&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%8C%97%E8%88%AA%E5%A4%8F%E4%BB%A4%E8%90%A5">https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request%5Fid%22%3A%22168715279416800185829257%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168715279416800185829257&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=北航夏令营</a> 机试&amp;spm&#x3D;1018.2226.3001.4187)</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>scanf后，用getchar()吃掉回车</p><p>表示最大 INT_MAX(climits)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//malloc</span></span><br><span class="line"><span class="type">int</span> *nums;</span><br><span class="line">nums=(*<span class="type">int</span>)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//long long int 别用cin cout</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>scanf还会返回成功输入的变量的个数,因此可判定EOF</p><p>Floyd判圈法很吊</p><p>1.lower_bound(v.begin(), v.end(), key)-v.begin()返回有序序列中大于等于key的第一个值的位置<br>2.upper_bound(v.begin(), v.end(), key)-v.begin()返回有序序列中大于key的第一个值的位置<br>3.lower_bound(v.begin(), v.end(), key, greater<int>())-v.begin()返回有序序列中小于等于key的第一个值的位置<br>4.upper_bound(v.begin(), v.end(), key, greater<int>())-v.begin()返回有序序列中小于key的第一个值的位置<br>5.上述四个函数，若无满足条件的值，则返回v.size() </p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;1.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br></pre></td></tr></table></figure><h2 id="一些常用的库"><a href="#一些常用的库" class="headerlink" title="一些常用的库"></a>一些常用的库</h2><ol><li>algorithm</li><li>vector</li><li>map</li><li>queue</li><li>iostream</li><li>string</li><li>bits&#x2F;stdc++.h（带上就对了）</li><li>cmath(sqrt之类的)</li><li>climits（INT_MAX INT_MIN）</li></ol><p><strong>STL内置find()复杂度</strong>：<br><code>algorithm的find</code> 复杂度是<code>O(n)</code>，对vector，string等 顺序查询。<br><code>map::find</code> 和 <code>set::find</code> 复杂度是<code>O(logn)</code>，因为map和set底层都是红黑树。</p><hr><h3 id="vector"><a href="#vector" class="headerlink" title="vector:"></a><strong>vector:</strong></h3><p>下面是一些常用的vector方法：</p><ol><li><p><code>push_back</code>：在vector的末尾添加一个元素。</p></li><li><p><code>pop_back</code>：删除vector末尾的一个元素。</p></li><li><p><code>size</code>：返回vector中元素的个数。</p></li><li><p><code>clear</code>：删除vector中所有的元素。</p></li><li><p><code>empty</code>：判断vector是否为空。</p></li><li><p><code>at</code>：返回vector中指定位置的元素。</p></li><li><p><code>front</code>：返回第一个元素。</p></li><li><p><code>back</code>：返回最后一个元素。</p></li><li><p><code>erase</code>：删除vector中指定位置的元素。</p></li><li><p><code>insert</code>：在vector中指定位置插入一个元素或多个元素。</p></li><li><p><code>resize</code>：改变vector的大小。</p></li><li><p><code>reserve</code>：为vector预留一定的空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li><li><p><code>swap</code>：交换两个vector中的元素。</p></li><li><p><code>begin</code>：返回指向vector第一个元素的迭代器。</p></li><li><p><code>end</code>：返回指向vector最后一个元素之后的迭代器。 这些方法能够满足大部分情况下的需求，可以根据具体的使用场景选择合适的方法进行操作。</p></li></ol><p>要取迭代器的值，直接*指针取值</p><p>对于向量(vector)，它是一种支持随机访问的容器，因此<strong>可以直接通过下标访问向量中的元素</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 使用auto关键字定义迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector不能直接使用sort函数进行排序，需要传入一个迭代器指定排序的范围。修改代码如下：</p><p>sort(v.begin(),v.end(),com);</p><hr><h3 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h3><p>以下是C++中map类的常用方法：</p><ol><li><p>insert(make_pair&lt;key, value&gt;)：向map中插入一个键值对。</p></li><li><p>erase(key)：删除map中指定键的元素。</p></li><li><p>clear()：清空map中所有元素。</p></li><li><p>size()：返回map中元素的个数。</p></li><li><p>empty()：返回map是否为空。</p></li><li><p>find(key)：查找map中是否存在指定键的元素，如果存在则返回指向该元素的迭代器，否则返回end()迭代器。</p><p>常常和end联合起来用判断找到没。(<strong>这个适合动态查找，底层红黑树实现</strong>)</p></li><li><p>count(key)：返回指定键在map中出现的次数，如果不存在则返回0或1。</p></li><li><p>begin()：返回指向map第一个元素的迭代器。</p></li><li><p>end()：返回指向map最后一个元素后面的位置的迭代器。</p></li><li><p>operator[]：通过键访问map中的元素，如果键不存在，则自动插入一个新的键值对并返回对应的值。</p></li><li><p>lower_bound(key)：返回第一个大于或等于指定键的元素的迭代器。</p></li><li><p>upper_bound(key)：返回第一个大于指定键的元素的迭代器。</p></li><li><p>equal_range(key)：返回一个pair对象，其中包含lower_bound和upper_bound返回的迭代器。</p></li><li><p>swap(map2)：交换当前map和map2的元素。 C++中的map类是一种关联式容器，用于存储键值对，其中每个键都唯一，并且按照一定的顺序排列。map的底层实现通常是红黑树，因此查找、插入和删除操作的时间复杂度为O(log n)，其中n是map中元素的个数。map类提供了丰富的方法，可以方便地进行键值对的操作，例如插入、删除、查找、排序等。同时，由于map使用键值对来存储数据，因此可以将map看作是一种特殊的数组，其下标为键，对应的值为数组元素。因此，可以通过下标来访问和修改map中的元素。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;&#123;<span class="string">&quot;apple&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 使用auto关键字定义迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a><strong>stack</strong></h3><p>C++ 中的 stack 库提供了以下常用的方法：</p><ul><li>push(elem)：将元素 elem 压入栈顶。</li><li>pop()：弹出栈顶元素。</li><li>top()：返回栈顶元素，但不弹出。</li><li>empty()：判断栈是否为空。</li><li>size()：返回栈中元素的个数。 除此之外，stack 还支持以下操作：</li><li>emplace(args…)：构造一个新元素并将其压入栈顶。</li><li>swap(stack)：交换两个 stack 的元素。</li><li>operator&#x3D;&#x3D;、operator!&#x3D;、operator&lt;、operator&lt;&#x3D;、operator&gt;、operator&gt;&#x3D;：比较两个 stack 是否相等、不相等、小于、小于等于、大于、大于等于。 具体用法可以参考下面的示例代码</li></ul><p>stack元素可以是任何类型。</p><hr><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a><strong>queue</strong></h3><p>C++中的queue是一种容器适配器，用于实现“先进先出”（FIFO）的数据结构。queue基于deque或list进行实现，提供了一些方法来操作队列，包括入队、出队、获取队首元素、获取队列大小等。以下是queue的常用方法：</p><ol><li>push(element)：将一个元素加入队列的尾部。</li><li>pop()：将队列头部的元素弹出，但没有返回值。</li><li>front()：返回队列头部的元素。</li><li>top():返回队列头部元素（和front一样）</li><li>back()：返回队列尾部的元素。</li><li>empty()：判断队列是否为空。</li><li>size()：返回队列中元素的个数。 使用queue需要包含头文件，可以通过以下方式创建一个queue对象：</li></ol><p>对于队列(queue)，由于它是一种先进先出(FIFO)的数据结构，因此只能通过front()和back()函数来访问队列的头部和尾部元素，<strong>而不能直接通过下标访问</strong>。如果要使用下标访问队列元素，需要先将队列转换为数组或向量。 </p><hr><h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a><strong>priority_queue</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;string&gt; b;</span><br></pre></td></tr></table></figure><p>对于优先队列，复杂结构类型要重载运算符<a href="https://blog.csdn.net/qq_27278957/article/details/85269245?ops_request_misc=%7B%22request_id%22:%22168033538216800213097640%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168033538216800213097640&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-85269245-null-null.142%5Ev80%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=c++%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1018.2226.3001.4187">(436条消息) C++ 运算符重载_c 重载运算符_高祥xiang的博客-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="type">int</span> real;</span><br><span class="line"><span class="type">int</span> imag;</span><br><span class="line">......</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Complex c)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> real*real+imag*imag&lt;c.real*c.real+c.imag*c.imag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面这个const是必须要有的</p><hr><h3 id="string"><a href="#string" class="headerlink" title="string"></a><strong>string</strong></h3><p>C++中的string类是一个封装了字符串操作的类，提供了一系列方法来处理和操作字符串。以下是常用的string类方法：</p><ol><li><p>length()：返回字符串的长度。</p></li><li><p>size()：返回字符串的长度。</p></li><li><p>clear()：清空字符串。</p></li><li><p>empty()：判断字符串是否为空。</p></li><li><p>assign(str)：将字符串的值设置为str。</p></li><li><p>assign(str, pos, len)：将字符串的值设置为str中从pos位置开始的长度为len的子串。</p></li><li><p>append(str)：在字符串的末尾添加str。</p></li><li><p>append(str, pos, len)：在字符串的末尾添加str中从pos位置开始的长度为len的子串。</p></li><li><p>push_back(ch)：在字符串的末尾添加一个字符。</p></li><li><p>insert(pos, str)：在字符串的pos位置插入str。</p></li><li><p>erase(pos, len)：删除从pos位置开始长度为len的子串。</p><p>erase(n):删除indexn后面的字符</p></li><li><p>replace(pos, len, str)：替换从pos位置开始长度为len的子串为str。</p></li><li><p><strong>substr(pos, len)：返回从pos位置开始长度为len的子串。</strong></p></li><li><p><strong>find(str)：查找str在字符串中第一次出现的位置，返回该位置的索引值。</strong>(找不到就是-1)</p></li><li><p>rfind(str)：查找str在字符串中最后一次出现的位置，返回该位置的索引值。</p></li><li><p>compare(str)：比较字符串和str的大小，返回0（相等）、1（大于）或-1（小于）。 除了以上列举的方法，string类还支持重载运算符，例如+（字符串拼接）、+&#x3D;（字符串拼接赋值）、&#x3D;&#x3D;（字符串相等判断）、[]（访问字符串中指定位置的字符）等。string类的使用非常方便，可以像使用普通变量一样对字符串进行赋值、拼接、查找、替换等操作。例如：</p></li></ol><p>注意string s，其s[i]类型为char，char强制类型转换可以这样转换</p><p>string(1,s[i])，1表示char长度</p><p>s[i]可以直接比较</p><p>输入str1,如果str1为空则退出</p><p><img src="C:\Users\11505\AppData\Roaming\Typora\typora-user-images\image-20230313213418581.png" alt="image-20230313213418581"></p><p>scanf不会读回车，如果下一行是gets会直接读取缓冲区中的回车，所有会用一个getchar()在中间把缓冲区中的回车抵消掉</p><p>stoi(str) 将其转换为整数，注意，如果是”04”,直接变成4</p><p>string::npos用于判断结尾（其实找不到直接-1也行）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find函数返回 jk 在 s 中的下标位置</span></span><br><span class="line">position = s.<span class="built_in">find</span>(<span class="string">&quot;jk&quot;</span>);</span><br><span class="line"><span class="comment">// 如果没找到，返回一个特别的标志</span></span><br><span class="line"><span class="comment">// c++中用npos表示，我这里npos取值是4294967295</span></span><br><span class="line"><span class="keyword">if</span>(position != s.npos)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;position: &quot;</span> &lt;&lt; position &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Not found the flag&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果输入的字符串有空格，那么用如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin,str)</span><br></pre></td></tr></table></figure><p>可以直接通过下标修改字符</p><p>删除字符串内重复字符:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;aadfgggh&quot;</span>;</span><br><span class="line"><span class="comment">//去重复</span></span><br><span class="line"><span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="built_in">unique</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>()),str.<span class="built_in">end</span>());  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除字符串内某个指定字符:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;aadfgggh&quot;</span>;</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>(),<span class="string">&#x27;a&#x27;</span>),str.<span class="built_in">end</span>()); <span class="comment">//在容器中, 删除[begin,end)之间的所有值等于&#x27;a&#x27;的值.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line">string::<span class="built_in">erase</span>(begin,end)：删除[begin,end)之间的所有值c</span><br></pre></td></tr></table></figure><p>在Find the Smallest Number中，我发现string的超出index一位的位置依然可以访问，但是没有数</p><hr><h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a><strong>algorithm</strong></h3><p>C++标准库中的algorithm库提供了许多常用的算法，这些算法可以用于处理容器中的数据，例如排序、查找、遍历等。以下是algorithm库中常用的方法：</p><ol><li>sort(first, last, func)：对[first, last)区间内的元素进行升&#x2F;降序排序（取决于func返回）。</li><li>reverse(first, last)：对[first, last)区间内的元素进行翻转。</li><li>find(first, last, val)：在[first, last)区间内查找值为val的元素，返回该元素的迭代器。如果没有找到，返回last。</li><li>find_if(first, last, pred)：在[first, last)区间内查找满足条件pred的第一个元素，返回该元素的迭代器。如果没有找到，返回last。</li><li>count(first, last, val)：统计[first, last)区间内值为val的元素个数。</li><li>count_if(first, last, pred)：统计[first, last)区间内满足条件pred的元素个数。</li><li>accumulate(first, last, init)：对[first, last)区间内的元素进行累加，初始值为init。</li><li>max_element(first, last)：返回[first, last)区间内的最大元素的迭代器。</li><li>min_element(first, last)：返回[first, last)区间内的最小元素的迭代器。</li><li>unique(first, last)：对[first, last)区间内的元素去重，返回去重后的末尾迭代器。</li><li>remove(first, last, val)：删除[first, last)区间内值为val的元素，返回删除后的末尾迭代器。</li><li>remove_if(first, last, pred)：删除[first, last)区间内满足条件pred的元素，返回删除后的末尾迭代器。</li><li>for_each(first, last, func)：对[first, last)区间内的元素执行操作func。</li><li>transform(first1, last1, first2, result, op)：将[first1, last1)区间内的元素和[first2, …)区间内的元素进行op操作，并将结果存储到[result, …)区间内。</li></ol><h3 id="climits"><a href="#climits" class="headerlink" title="climits"></a>climits</h3><p><climits>中定义的常量主要有以下几种：</p><ol><li>整数类型的最大值和最小值：INT_MAX、INT_MIN、LONG_MAX、LONG_MIN、SHRT_MAX、SHRT_MIN等等。</li><li>字符类型的最大值和最小值：CHAR_MAX、CHAR_MIN、SCHAR_MAX、SCHAR_MIN、UCHAR_MAX等等。</li><li>位数相关的常量：CHAR_BIT、INT_BIT、LONG_BIT等等。</li><li>其他常量：MB_LEN_MAX表示一个多字节字符的最大长度，FLT_MAX、FLT_MIN、DBL_MAX、DBL_MIN等等表示浮点类型的最大值和最小值。</li></ol><h2 id="设置输出精度"><a href="#设置输出精度" class="headerlink" title="设置输出精度"></a>设置输出精度</h2><p>设置输出精度为1位小数</p><p>cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; ans &lt;&lt; endl</p><h2 id="设置输出位数"><a href="#设置输出位数" class="headerlink" title="设置输出位数"></a>设置输出位数</h2><p>printf(“%02d”,&amp;)</p><p>前面补零，两位，不够两位就补零</p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p><a href="https://zhuanlan.zhihu.com/p/83334559">KMP 算法详解 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/v_JULY_v/article/details/7041827?ops_request_misc=%7B%22request_id%22:%22167957843316800227474381%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167957843316800227474381&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-7041827-null-null.142%5Ev76%5Epc_new_rank,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=KMP&spm=1018.2226.3001.4187">(427条消息) 从头到尾彻底理解KMP（2014年8月22日版）_kmp算法难吗是什么级别_v_JULY_v的博客-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(<span class="type">char</span>* p,<span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k]) </span><br><span class="line">&#123;</span><br><span class="line">++k;</span><br><span class="line">++j;</span><br><span class="line">next[j] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kmp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    </span></span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    </span></span><br><span class="line"><span class="comment">//next[j]即为j所对应的next值      </span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == pLen)</span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="最大连续子序列"><a href="#最大连续子序列" class="headerlink" title="最大连续子序列"></a>最大连续子序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> nums[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;N)&#123;</span><br><span class="line"><span class="keyword">if</span> (N==EOF)<span class="keyword">break</span>;</span><br><span class="line"><span class="type">int</span> maxnum=INT_MIN;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">cin&gt;&gt;nums[i];</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (N==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">dp[i]=<span class="built_in">max</span>(nums[i],dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">maxnum=<span class="built_in">max</span>(dp[i],maxnum);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最大子矩阵"><a href="#最大子矩阵" class="headerlink" title="最大子矩阵"></a>最大子矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> matrix[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> support[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hangmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> maxnum;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=<span class="built_in">max</span>(arr[i],dp[i<span class="number">-1</span>]+arr[i]);</span><br><span class="line">maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">allmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> maxnum;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">1</span>)&#123;</span><br><span class="line">arr[k]=support[j][k];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">arr[k]=support[j][k]-support[i<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">maxnum=<span class="built_in">max</span>(<span class="built_in">hangmax</span>(n),maxnum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">cin&gt;&gt;matrix[i][j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">1</span>)support[i][j]=matrix[i][j];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">support[i][j]=matrix[i][j]+support[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxnum;</span><br><span class="line">maxnum=<span class="built_in">allmax</span>(n);</span><br><span class="line">cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长递增-减序列"><a href="#最长递增-减序列" class="headerlink" title="最长递增&#x2F;减序列"></a>最长递增&#x2F;减序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> daodan[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> maxnum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (daodan[i]&lt;=daodan[j])</span><br><span class="line">dp[i]=<span class="built_in">max</span>(<span class="number">1</span>,dp[j]+<span class="number">1</span>);</span><br><span class="line">maxnum=<span class="built_in">max</span>(maxnum,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;daodan[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxnum;</span><br><span class="line">maxnum=<span class="built_in">countmax</span>(n);</span><br><span class="line">cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大上升子序列和（O-N-2-）"><a href="#最大上升子序列和（O-N-2-）" class="headerlink" title="最大上升子序列和（O(N^2)）"></a>最大上升子序列和（O(N^2)）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> nums[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> maxsum;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i]&gt;nums[j])</span><br><span class="line">dp[i]=<span class="built_in">max</span>(nums[i],dp[j]+nums[i]);</span><br><span class="line">maxsum=<span class="built_in">max</span>(maxsum,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxsum;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;nums[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">maxsum=<span class="built_in">countmax</span>(n);</span><br><span class="line">cout&lt;&lt;maxsum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h3><p>1<br>7<br>3<br>5<br>9<br>4<br>8<br>3</p><p><a href="https://blog.csdn.net/lxt_Lucia/article/details/81209962?ops_request_misc=%7B%22request_id%22:%22168639963816800225544693%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168639963816800225544693&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81209962-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=LCS&spm=1018.2226.3001.4187">(461条消息) 最长公共子序列 (LCS) 详解+例题模板（全）_lxt_Lucia的博客-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s1;</span><br><span class="line">string s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countmax</span><span class="params">(string s1,string s2)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> length1=s1.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> length2=s2.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> dp[length1][length2];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;length1;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;length2;j++)&#123;</span><br><span class="line">dp[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxnum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;length1;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;length2;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (s1[i]==s2[j])&#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">dp[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">dp[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">maxnum=<span class="built_in">max</span>(maxnum,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;s1&gt;&gt;s2)&#123;</span><br><span class="line"><span class="type">int</span> maxnum=<span class="built_in">countmax</span>(s1,s2);</span><br><span class="line">cout&lt;&lt;maxnum&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LIS（Nlogn）"><a href="#LIS（Nlogn）" class="headerlink" title="LIS（Nlogn）"></a>LIS（Nlogn）</h3><p><a href="https://blog.csdn.net/lxt_Lucia/article/details/81206439?ops_request_misc=%7B%22request_id%22:%22168766303316800185860492%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168766303316800185860492&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81206439-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97&spm=1018.2226.3001.4187">(465条消息) 最长上升子序列 (LIS) 详解+例题模板 (全)_lxt_Lucia的博客-CSDN博客</a></p><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">d</span>&#123;</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> C,N;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;C&gt;&gt;N)&#123;</span><br><span class="line"><span class="keyword">if</span> (C==<span class="number">0</span>&amp;&amp;N==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="type">int</span> dp[C+<span class="number">1</span>];</span><br><span class="line">d deal[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=C;i++)&#123;</span><br><span class="line">dp[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">cin&gt;&gt;price&gt;&gt;score;</span><br><span class="line">deal[i].price=price;</span><br><span class="line">deal[i].score=score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=C;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span> (j&gt;=deal[i].price)&#123;</span><br><span class="line">dp[j]=<span class="built_in">max</span>(dp[j-deal[i].price]+deal[i].score,dp[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[C]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个背包的变种</p><p><a href="https://blog.csdn.net/weixin_41994332/article/details/115829716?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-115829716-blog-109011034.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-115829716-blog-109011034.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=1">(465条消息) 复旦大学2021年计算机学院机试题解_复旦oj_PyKt的博客-CSDN博客</a></p><p>这里是直接顺序的</p><h2 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS BFS"></a>DFS BFS</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> hight)</span>  <span class="comment">//合并函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>[hight - low + <span class="number">1</span>];  <span class="comment">//用 new 申请一个辅助函数</span></span><br><span class="line"><span class="type">int</span> i = low, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;    <span class="comment">// k为 b 数组的小标</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= hight)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">&#123;</span><br><span class="line">b[k++] = a[i++];  <span class="comment">//按从小到大存放在 b 数组里面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">b[k++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)  <span class="comment">// j 序列结束，将剩余的 i 序列补充在 b 数组中 </span></span><br><span class="line">&#123;</span><br><span class="line">b[k++] = a[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= hight)<span class="comment">// i 序列结束，将剩余的 j 序列补充在 b 数组中 </span></span><br><span class="line">&#123;</span><br><span class="line">b[k++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line">k = <span class="number">0</span>;  <span class="comment">//从小标为 0 开始传送</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= hight; i++)  <span class="comment">//将 b 数组的值传递给数组 a</span></span><br><span class="line">&#123;</span><br><span class="line">a[i] = b[k++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]b;     <span class="comment">// 辅助数组用完后，将其的空间进行释放（销毁）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> hight)</span> <span class="comment">//归并排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; hight)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (low + hight) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">mergesort</span>(a, low, mid);          <span class="comment">//对 a[low,mid]进行排序</span></span><br><span class="line"><span class="built_in">mergesort</span>(a, mid + <span class="number">1</span>, hight);    <span class="comment">//对 a[mid+1,hight]进行排序</span></span><br><span class="line"><span class="built_in">merge</span>(a, low, mid, hight);       <span class="comment">//进行合并操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, a[<span class="number">100</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入数列中的元素个数 n 为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请依次输入数列中的元素：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mergesort</span>(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;归并排序结果&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> m=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quickpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="comment">//与运算，可判断奇偶，详细见注释</span></span><br><span class="line">sum=sum*a%m;<span class="comment">//取模运算</span></span><br><span class="line">a=a*a%m;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;<span class="comment">//位运算，右移，相当于除以2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="模拟问题"><a href="#模拟问题" class="headerlink" title="模拟问题"></a>模拟问题</h2><p>就是找规律，还行</p><h2 id="日期问题"><a href="#日期问题" class="headerlink" title="日期问题"></a>日期问题</h2><p>要预处理</p><h2 id="最大公因数-最小公倍数"><a href="#最大公因数-最小公倍数" class="headerlink" title="最大公因数&#x2F;最小公倍数"></a>最大公因数&#x2F;最小公倍数</h2><p>最小公倍数&#x3D;a*b&#x2F;c</p><p>c为最大公因数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大公因数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">biggest</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b!=<span class="number">0</span>?<span class="built_in">biggest</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最小公倍数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">smallest</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> big=<span class="built_in">biggest</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> a*b/big;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;n)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">2</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> sushu[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sushu[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (sushu[i]==<span class="literal">false</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=i;j*i&lt;=n;j++)&#123; <span class="comment">//j直接从i开始，提高效率</span></span><br><span class="line"><span class="keyword">if</span> (j*i&lt;n)&#123;</span><br><span class="line">sushu[j*i]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (sushu[i])&#123;</span><br><span class="line"><span class="keyword">if</span> (i%<span class="number">10</span>==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个数n，其质因数最多只有一个大于其平方根！</p><h2 id="矩阵乘法（构造函数）"><a href="#矩阵乘法（构造函数）" class="headerlink" title="矩阵乘法（构造函数）"></a>矩阵乘法（构造函数）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line"><span class="type">int</span> matrix[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> row;</span><br><span class="line"><span class="type">int</span> col;</span><br><span class="line"><span class="built_in">Matrix</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">row</span>(a),<span class="built_in">col</span>(b)&#123;&#125;<span class="comment">//注意构造函数的写法</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Matrix <span class="title">Multiply</span><span class="params">(Matrix a,Matrix b)</span></span>&#123;</span><br><span class="line">Matrix ans=<span class="built_in">Matrix</span>(a.row,b.col);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.row;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;b.col;j++)&#123;</span><br><span class="line"><span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;a.col;k++)&#123;</span><br><span class="line">temp+=a.matrix[i][k]*b.matrix[k][j];</span><br><span class="line">&#125;</span><br><span class="line">ans.matrix[i][j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMatrix</span><span class="params">(Matrix m)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> row=m.row;</span><br><span class="line"><span class="type">int</span> col=m.col;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (j!=<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;m.matrix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Matrix a=<span class="built_in">Matrix</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Matrix b=<span class="built_in">Matrix</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">cin&gt;&gt;a.matrix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">cin&gt;&gt;b.matrix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Matrix c=<span class="built_in">Multiply</span>(a,b);</span><br><span class="line"><span class="built_in">printMatrix</span>(c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><a href="https://so.csdn.net/so/search?spm=1000.2115.3001.4498&q=prim%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91&t=&u=">prim算法求最小生成树- CSDN搜索</a></p><p>kruscal</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(edge c)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> weight&gt;c.weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">edge</span>(<span class="type">int</span> q,<span class="type">int</span> w,<span class="type">int</span> e):<span class="built_in">a</span>(q),<span class="built_in">b</span>(w),<span class="built_in">weight</span>(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;edge,vector&lt;edge&gt;,greater&lt;edge&gt;&gt;edges;</span><br><span class="line"><span class="type">int</span> graph[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (graph[x]==<span class="number">-1</span>)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">temp=<span class="built_in">find</span>(graph[x]);</span><br><span class="line">graph[x]=temp;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;n)&#123;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="type">int</span> a,b,weight;</span><br><span class="line"><span class="type">int</span> num=n*(n<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">memset</span>(graph,<span class="number">-1</span>,<span class="built_in">sizeof</span>(graph));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">graph[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (num--)&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">edge edge1=<span class="built_in">edge</span>(a,b,weight);</span><br><span class="line">edges.<span class="built_in">push</span>(edge1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!edges.<span class="built_in">empty</span>()&amp;&amp;count&lt;n<span class="number">-1</span>)&#123;</span><br><span class="line">edge temp=edges.<span class="built_in">top</span>();</span><br><span class="line">edges.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> a=<span class="built_in">find</span>(temp.a);</span><br><span class="line"><span class="type">int</span> b=<span class="built_in">find</span>(temp.b);</span><br><span class="line"><span class="type">int</span> weight=temp.weight;</span><br><span class="line"><span class="keyword">if</span> (a!=b)&#123;</span><br><span class="line">graph[a]=b;</span><br><span class="line">count++;</span><br><span class="line">sum+=weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="弗洛伊德"><a href="#弗洛伊德" class="headerlink" title="弗洛伊德"></a>弗洛伊德</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;k ++) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++) &#123; </span><br><span class="line"> <span class="keyword">if</span> (ans[i][k] == 无穷 || ans[k][j] == 无穷) <span class="keyword">continue</span>; </span><br><span class="line"> <span class="keyword">if</span> (ans[i][j] == 无穷 || ans[i][k] + ans[k][j] &lt; ans[i][j]) </span><br><span class="line"> ans[i][j] = ans[i][k] + ans[k][j]; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h2 id="迪杰斯特拉"><a href="#迪杰斯特拉" class="headerlink" title="迪杰斯特拉"></a>迪杰斯特拉</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123; <span class="comment">//初始化</span></span><br><span class="line"> Dis[i] = <span class="number">-1</span>; <span class="comment">//所有距离为-1，即不可达</span></span><br><span class="line"> mark[i] = <span class="literal">false</span>; <span class="comment">//所有结点不属于集合K</span></span><br><span class="line"> &#125; </span><br><span class="line"> Dis[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//得到最近的点为结点1,长度为0</span></span><br><span class="line"> mark[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//将结点1加入集合K</span></span><br><span class="line"> <span class="type">int</span> newP = <span class="number">1</span>; <span class="comment">//集合K中新加入的点为结点1 </span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i ++) &#123; <span class="comment">//循环n-1次,按照最短路径递增的顺序确定其他n-1个点的最短路径长度</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; edge[newP].<span class="built_in">size</span>();j ++) &#123; <span class="comment">//遍历与该新加入集合</span></span><br><span class="line">K中的结点直接相邻的边</span><br><span class="line"> <span class="type">int</span> t = edge[newP][j].next; <span class="comment">//该边的另一个结点</span></span><br><span class="line"> <span class="type">int</span> c = edge[newP][j].c; <span class="comment">//该边的长度</span></span><br><span class="line"> <span class="keyword">if</span> (mark[t] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">//若另一个结点也属于集合K,则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[t] == - <span class="number">1</span> || Dis[t] &gt; Dis[newP] + c) <span class="comment">//若该结点尚不可</span></span><br><span class="line">达,或者该结点从新加入的结点经过一条边到达时比以往距离更短</span><br><span class="line"> Dis[t] = Dis[newP] + c; <span class="comment">//更新其距离信息</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="type">int</span> min = <span class="number">123123123</span>; <span class="comment">//最小值初始化为一个大整数,为找最小值做准备</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++) &#123; <span class="comment">//遍历所有结点</span></span><br><span class="line"> <span class="keyword">if</span> (mark[j] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">//若其属于集合K则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[j] == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">//若该结点仍不可达则跳过</span></span><br><span class="line"> <span class="keyword">if</span> (Dis[j] &lt; min) &#123; <span class="comment">//若该结点经由结点1至集合K中的某点在经过一条</span></span><br><span class="line">边到达时距离小于当前最小值</span><br><span class="line"> min = Dis[j]; <span class="comment">//更新其为最小值</span></span><br><span class="line"> newP = j; <span class="comment">//新加入的点暂定为该点</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉回路（hierholzer）"><a href="#欧拉回路（hierholzer）" class="headerlink" title="欧拉回路（hierholzer）"></a>欧拉回路（hierholzer）</h2><p><a href="https://blog.csdn.net/weixin_44316314/article/details/96898445?ops_request_misc=%7B%22request_id%22:%22168707940816800182775723%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168707940816800182775723&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-96898445-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E7%9A%84%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(462条消息) 欧拉回路（hierholzer算法）_逐步插入回路法_run around的博客-CSDN博客</a></p><h2 id="关键路径（AOE网）"><a href="#关键路径（AOE网）" class="headerlink" title="关键路径（AOE网）"></a>关键路径（AOE网）</h2><p>最早开始时间&#x3D;最晚开始时间</p><p>用拓扑图</p><p>最早开始时间（所有先序活动的最晚完成时间）</p><p>最晚开始时间（所有后续活动的最早开始时间减去该活动花费的时间）</p><p>注意源点的最早开始时间不一定为0，要初始化</p><p>汇点的最晚开始时间初始化为totalTime-该汇点任务的时间</p><p>非汇点的最晚开始时间为无穷</p><p>如果只是要求关键路径的长度，其实在earliest[i]初始化的时候就设置为任务的时间就行，但如果要算其他的，就还是设置为0</p><p>7 5<br>11 20 17 10 11 17 17<br>5 4<br>6 1<br>7 3<br>2 4<br>2 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yushu 1e9+7</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;zero;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;re;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line"><span class="type">int</span> to;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> in[<span class="number">100001</span>];</span><br><span class="line">vector&lt;edge&gt;edges[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> task[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> earliest[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> latest[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">in[i]=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;task[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num=m;</span><br><span class="line"><span class="type">int</span> allTime=<span class="number">0</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;input edge&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">while</span> (num--)&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">in[b]++;</span><br><span class="line">edge temp;</span><br><span class="line">temp.to=b;</span><br><span class="line">temp.weight=task[b];</span><br><span class="line">edges[a].<span class="built_in">push_back</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;input finished.&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[i]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span> (in[i]==<span class="number">0</span>)&#123;</span><br><span class="line">zero.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!zero.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> node=zero.<span class="built_in">front</span>();</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;zero:&quot;</span>&lt;&lt;node&lt;&lt;endl;</span><br><span class="line">zero.<span class="built_in">pop</span>();</span><br><span class="line">re.<span class="built_in">push_back</span>(node);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;edges[node].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> to=edges[node][i].to;</span><br><span class="line"><span class="type">int</span> weight=edges[node][i].weight;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;edge:&quot;</span>&lt;&lt;node&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;to&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;weight&lt;&lt;endl;</span><br><span class="line">earliest[to]=<span class="built_in">max</span>(earliest[to],earliest[node]+task[node]);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;to&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[to]&lt;&lt;endl;</span><br><span class="line">in[to]--;</span><br><span class="line"><span class="keyword">if</span> (in[to]==<span class="number">0</span>)&#123;</span><br><span class="line">zero.<span class="built_in">push</span>(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">allTime=<span class="built_in">max</span>(allTime,earliest[i]+task[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;reverse:&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=re.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> u=re[i];</span><br><span class="line"><span class="keyword">if</span> (edges[u].<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">latest[u]=allTime-task[u];</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;latest:[&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[u]&lt;&lt;endl;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">latest[u]=<span class="number">99999999</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;edges[u].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line"><span class="type">int</span> to=edges[u][j].to;</span><br><span class="line"><span class="type">int</span> weight=edges[u][j].weight;</span><br><span class="line">latest[u]=<span class="built_in">min</span>(latest[u],latest[to]-task[u]);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;latest:[&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[u]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;earliest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;earliest[i]&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;latest[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;latest[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sum*=(latest[i]-earliest[i]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;allTime&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u011240016/article/details/53171808?ops_request_misc=%7B%22request_id%22:%22168784579716782425186584%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168784579716782425186584&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-53171808-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=AOE&spm=1018.2226.3001.4187">(466条消息) AOE问题总结_DrCrypto的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_44880154/article/details/114380592?ops_request_misc=&request_id=&biz_id=102&utm_term=AOE%E9%A2%98&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-114380592.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(466条消息) AOE网关键路径求解例题_关键路径例题图解_HardyDragon_CC的博客-CSDN博客</a></p><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><p><a href="https://blog.csdn.net/yc_cy1999/article/details/104580701?ops_request_misc=&request_id=&biz_id=102&utm_term=%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95%E9%A2%98%E5%8D%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104580701.142%5Ev84%5Epc_search_v2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(443条消息) 2019年南京大学计算机考研复试机试真题_南大计算机专业考研机试_yc_cy1999的博客-CSDN博客</a></p><p>一个整数可以变为多少个整数相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//存所有状态</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j ++)<span class="comment">//j是容量</span></span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h2><p><a href="https://blog.csdn.net/qq12323qweeqwe/article/details/123083331?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-123083331.nonecase&spm=1018.2226.3001.4187">(462条消息) 291. 蒙德里安的梦想（状压dp）_seez的博客-CSDN博客</a></p><p>[(462条消息) <a href="https://blog.csdn.net/yl_puyu/article/details/109631735?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-109631735.nonecase&spm=1018.2226.3001.4187">状压dp] 蒙德里安的梦想(模板题+状压dp)_状压dp模板题_Ypuyu的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_27262727/article/details/105700957?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B4%AA%E5%BF%83%E9%A2%98%E7%9B%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105700957.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(462条消息) C++笔试题模版汇总(五)动态规划&#x2F;贪心_c++笔试题 考动态规划么_ai_XZP_master的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/hzf0701/article/details/117430400?ops_request_misc=&request_id=&biz_id=102&utm_term=%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-117430400.142%5Ev100%5Epc_search_result_base8&spm=1018.2226.3001.4187">状态压缩DP学习总结+经典例题精解_状压dp-CSDN博客</a></p><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p>结论：把i个盘子移到另一个柱面上，需要2^i-1步</p><p><a href="https://zhuanlan.zhihu.com/p/392523306">关于汉诺塔问题 - 知乎 (zhihu.com)</a></p><h2 id="放置街灯（Placing-Lampposts-UVa-10859）-star"><a href="#放置街灯（Placing-Lampposts-UVa-10859）-star" class="headerlink" title="放置街灯（Placing Lampposts, UVa 10859）:star:"></a>放置街灯（Placing Lampposts, UVa 10859）:star:</h2><p><img src="C:\Users\11505\AppData\Roaming\Typora\typora-user-images\image-20230515221130204.png" alt="image-20230515221130204"></p><h2 id="经典贪心"><a href="#经典贪心" class="headerlink" title="经典贪心"></a>经典贪心</h2><p><a href="https://blog.csdn.net/KXL5180/article/details/82824003?ops_request_misc=%7B%22request_id%22:%22168424305316800227456811%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168424305316800227456811&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-82824003-null-null.142%5Ev87%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&utm_term=UVa10382&spm=1018.2226.3001.4187">(450条消息) UVA-10382经典贪心问题，区间覆盖_uva 10382_KXL5180的博客-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//酸奶工程</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="comment">//定义long long，防止爆int</span></span><br><span class="line">ll n,s;</span><br><span class="line">ll c[<span class="number">10010</span>],y[<span class="number">10010</span>];<span class="comment">//存储费用和交互数量</span></span><br><span class="line">ll f[<span class="number">10010</span>];</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;c[i],&amp;y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            f[i]=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[i]=<span class="built_in">min</span>(c[i],f[i<span class="number">-1</span>]+s);</span><br><span class="line">        &#125;</span><br><span class="line">        sum=sum+f[i]*y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳跃问题"><a href="#跳跃问题" class="headerlink" title="跳跃问题"></a>跳跃问题</h2><p><a href="https://blog.csdn.net/weixin_41570890/article/details/110795229?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%982&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-110795229.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(462条消息) Leetcode——跳跃问题II_跳跃问题2_Purple.’’的博客-CSDN博客</a></p><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p><a href="https://blog.csdn.net/youngyangyang04/article/details/111190664?ops_request_misc=%7B%22request_id%22:%22168647702416800197016860%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168647702416800197016860&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-111190664-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C&spm=1018.2226.3001.4187">(462条消息) 「leetcode」135.分发糖果【贪心算法】详细图解_代码随想录的博客-CSDN博客</a></p><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p><a href="https://blog.csdn.net/weixin_45697774/article/details/104274713?ops_request_misc=%7B%22request_id%22:%22168667245116800197028500%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168667245116800197028500&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104274713-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E7%BA%BF%E6%AE%B5%E6%A0%91&spm=1018.2226.3001.4187">(462条消息) 线段树 从入门到进阶（超清晰，简单易懂）_线段树进阶_繁凡さん的博客-CSDN博客</a></p><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p><a href="https://blog.csdn.net/lemonxiaoxiao/article/details/108672039?ops_request_misc=%7B%22request_id%22:%22168667270816800222874127%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168667270816800222874127&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108672039-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">(462条消息) 匈牙利算法详解_Amelie_xiao的博客-CSDN博客</a></p><p><strong>一个二分图中的最大匹配数等于这个图中的最小点覆盖数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> M, N;            <span class="comment">//M, N分别表示左、右侧集合的元素数量</span></span><br><span class="line"><span class="type">int</span> Map[MAXM][MAXN]; <span class="comment">//邻接矩阵存图</span></span><br><span class="line"><span class="type">int</span> p[MAXN];         <span class="comment">//记录当前右侧元素所对应的左侧元素</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN];      <span class="comment">//记录右侧元素是否已被访问过</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        <span class="keyword">if</span> (Map[i][j] &amp;&amp; !vis[j]) <span class="comment">//有边且未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[j] = <span class="literal">true</span>;                 <span class="comment">//记录状态为访问过</span></span><br><span class="line">            <span class="keyword">if</span> (p[j] == <span class="number">0</span> || <span class="built_in">match</span>(p[j])) <span class="comment">//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                p[j] = i;    <span class="comment">//当前左侧元素成为当前右侧元素的新匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回匹配成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//循环结束，仍未找到匹配，返回匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hungarian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)); <span class="comment">//重置vis数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">match</span>(i))</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>[(462条消息) 2018南京大学计算机夏令营机试第二题（回溯）_只会写臭虫的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_43175029/article/details/94670710?ops_request_misc=&request_id=&biz_id=102&utm_term=Missing">https://blog.csdn.net/weixin_43175029/article/details/94670710?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Missing</a> number  Given a positi&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-94670710.142^v88^control_2,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p><p>回溯就是dfs，并且在每次dfs时记得恢复原状态；如果只需要输出一种状态，设置flag标志位</p><p>N皇后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// bool数组用来判断搜索的下一个位置是否可行</span></span><br><span class="line"><span class="comment">// col列，dg对角线，udg反对角线</span></span><br><span class="line"><span class="comment">// g[N][N]用来存路径</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// u == n 表示已经搜了n行，故输出这条路径</span></span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);   <span class="comment">// 等价于cout &lt;&lt; g[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);  <span class="comment">// 换行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 枚举u这一行，搜索合法的列</span></span><br><span class="line">    <span class="type">int</span> x = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; y ++ )</span><br><span class="line">        <span class="comment">// 剪枝(对于不满足要求的点，不再继续往下搜索)  </span></span><br><span class="line">        <span class="comment">// 这里y-x+n是左上角到右下角,y+x是左下角到右上角</span></span><br><span class="line">        <span class="keyword">if</span> (col[y] == <span class="literal">false</span> &amp;&amp; dg[y - x + n] == <span class="literal">false</span> &amp;&amp; udg[y + x] == <span class="literal">false</span>) &#123;</span><br><span class="line">            col[y] = dg[y - x + n] = udg[y + x] = <span class="literal">true</span>;</span><br><span class="line">            g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">            g[x][y] = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">// 恢复现场</span></span><br><span class="line">            col[y] = dg[y - x + n] = udg[y + x] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="建立索引树"><a href="#建立索引树" class="headerlink" title="建立索引树"></a>建立索引树</h2><p>[(462条消息) 2020北航计算机夏令营机试题目个人理解_北航夏令营 机试_四处碰壁嘤嘤怪的博客-CSDN博客](<a href="https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request_id%22:%22168715279416800185829257%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168715279416800185829257&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%8C%97%E8%88%AA%E5%A4%8F%E4%BB%A4%E8%90%A5">https://blog.csdn.net/Bernie_double/article/details/118190022?ops_request_misc=%7B%22request%5Fid%22%3A%22168715279416800185829257%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168715279416800185829257&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118190022-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=北航夏令营</a> 机试&amp;spm&#x3D;1018.2226.3001.4187)</p><p>注意 建树不一定要指针，数组也可</p><p>4 5<br>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分布式系统（二）分布式系统模型</title>
      <link href="/2024/06/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/06/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系统模型"><a href="#分布式系统模型" class="headerlink" title="分布式系统模型"></a>分布式系统模型</h1><h2 id="2-1-两将军问题"><a href="#2-1-两将军问题" class="headerlink" title="2.1 两将军问题"></a>2.1 两将军问题</h2><p>“两将军问题”是一个经典的分布式系统问题，旨在研究在存在故障节点的情况下如何协调两个进程之间的通信。</p><p>问题场景是两个将军分别率领一支军队进攻敌方城市。两个将军之间必须达成一致，以确定进攻时间和策略。但是，将军们分别位于两个不同的营地，只能通过信使进行通信。此外，有可能存在恶劣的天气或其它因素干扰通信，或者其中一个将军的信使被敌人抓住并修改了消息。</p><p>该问题的关键是如何确保将军之间的通信可靠，并避免消息的丢失和篡改。经典的解决方案是使用拜占庭将军问题中的拜占庭容错算法，该算法可以容忍部分节点的故障和恶意攻击。</p><p>具体实现上，将军们需要达成共识，以决定进攻时间和策略。首先，每个将军向所有其他将军发送一个决策信息，并等待回复。如果将军收到的回复都是一致的，他就可以确定其他将军的决策，并做出相应的行动。如果将军收到的回复不一致，他会将这些信息再次发送给所有其他将军，直到收到一致的回复。</p><p>在该问题中，每个将军需要知道有多少其他将军参与协调，并且需要容忍其他将军的可能失败和恶意行为。这需要设计合适的算法和协议来保证将军之间的协作和共识。</p><p>总之，“两将军问题”是一个经典的分布式系统问题，它探讨了如何在分布式系统中实现可靠通信和共识协作的问题。拜占庭容错算法提供了一种解决方案，可以容忍部分节点的故障和恶意攻击，从而确保将军之间的通信可靠性和一致性。</p><p><strong>TCP三次握手与其的关系</strong></p><p>TCP三次握手是一种建立TCP连接的过程，包括客户端发送SYN报文，服务器回复SYN+ACK报文，最后客户端回复ACK报文，建立连接。</p><p>在分布式系统中，TCP三次握手是实现可靠通信的重要手段。它确保了客户端和服务器之间的连接在建立时具有可靠性和稳定性。通过三次握手，客户端和服务器可以确保对方已经准备好进行通信，同时也可以在连接建立之前进行一些必要的信息交换和验证，如协商连接参数和检查连接的有效性等。</p><p>在分布式系统中，TCP三次握手也可以用于解决“两将军问题”，确保两个进程之间的通信可靠和一致。类似于TCP三次握手，两个进程可以通过发送和确认消息来建立连接，并在建立连接之前进行必要的验证和信息交换，以确保连接的可靠性和有效性。</p><p>总之，TCP三次握手是分布式系统中实现可靠通信的重要手段，它可以确保连接的可靠性和有效性，同时也可以应用于解决其他类似的分布式系统问题，如“两将军问题”。</p><h2 id="2-2-拜占庭将军问题"><a href="#2-2-拜占庭将军问题" class="headerlink" title="2.2 拜占庭将军问题"></a>2.2 拜占庭将军问题</h2><p>拜占庭将军问题（Byzantine Generals Problem）是分布式系统中的一个经典问题，涉及到在存在故障或恶意行为的情况下，如何进行分布式决策。</p><p>问题场景是，在拜占庭帝国，几个将军率领各自的部队围攻敌人。他们必须就进攻或撤退达成一致的决策，但是将军之间只能通过消息传递进行通信。然而，有可能存在一些叛变的将军，他们会传递虚假信息，导致其他将军做出错误的决策。</p><p>在这种情况下，如何确保将军们可以就正确的进攻或撤退做出决策，即使有些将军叛变或发生故障。</p><p>拜占庭将军问题的解决方案是拜占庭容错算法（Byzantine Fault Tolerance Algorithm）。该算法可以容忍部分节点的故障和恶意攻击，从而确保分布式系统在存在故障或恶意行为的情况下仍然能够正确地工作。</p><p>具体实现上，拜占庭容错算法需要将每个将军看作一个节点，将节点之间的通信看作消息传递。每个将军必须向其他将军发送自己的决策信息，并根据接收到的消息来做出最终的决策。</p><p>在算法中，每个将军必须决定一个信任阈值（trust threshold），即可以容忍多少个叛变节点。如果叛变节点的数量超过信任阈值，则将军不再相信这些节点传递的信息。每个将军都需要向其他将军发送自己的决策信息，并在接收到足够数量的信息后，根据这些信息来做出最终的决策。</p><p>拜占庭容错算法提供了一种解决分布式系统中存在故障或恶意行为的问题的方法，可以保证在一定程度上容忍节点的故障和恶意攻击，从而确保系统的可靠性和正确性。</p><h2 id="2-3-系统模型"><a href="#2-3-系统模型" class="headerlink" title="2.3 系统模型"></a>2.3 系统模型</h2><h3 id="2-3-1-网络链路模型"><a href="#2-3-1-网络链路模型" class="headerlink" title="2.3.1 网络链路模型"></a>2.3.1 网络链路模型</h3><p>可靠链路、公平损失链路和任意链路是三种不同类型的链路模型，它们分别描述了网络链路的不同特性。</p><ol><li>可靠链路：指传输层提供的数据传输服务是可靠的，即数据包不会丢失、重复、乱序等，而且保证数据传输的正确性。这种链路通常用于需要可靠传输的应用，例如文件传输、电子邮件等。</li><li>公平损失链路：指传输层提供的数据传输服务是不可靠的，即数据包可能会丢失、重复、乱序等，但是丢失的概率是公平的，即每个数据包有相同的丢失概率。这种链路通常用于需要低延迟和高吞吐量的应用，例如视频流和音频流。</li><li>任意链路：指传输层提供的数据传输服务是不可靠的，数据包可能会丢失、重复、乱序等，并且丢失的概率也是不确定的。这种链路通常用于互联网等大规模、不可控的网络环境中。</li></ol><p>在实际应用中，不同的链路模型适用于不同的应用场景。例如，可靠链路适用于需要可靠传输的应用，公平损失链路适用于需要低延迟和高吞吐量的应用，任意链路则适用于大规模、不可控的网络环境。</p><h3 id="2-3-2-节点故障类型"><a href="#2-3-2-节点故障类型" class="headerlink" title="2.3.2 节点故障类型"></a>2.3.2 节点故障类型</h3><p>在分布式系统中，节点故障类型主要有以下几种：</p><ol><li>宕机故障：指节点因为硬件故障、软件故障等原因而停止工作，无法处理请求和发送响应。</li><li>网络故障：指节点与网络中的其他节点失去了连接，无法正常通信。</li><li>时钟偏差故障：指节点的本地时钟与其他节点的时钟存在偏差，导致节点无法准确判断事件的先后顺序。</li><li>节点软件故障：指节点运行的软件出现了错误，导致节点无法正常处理请求和发送响应。</li><li>节点配置故障：指节点的配置文件或者参数设置出现错误，导致节点无法正常工作。</li></ol><p>以上节点故障类型都可能对分布式系统的正常运行造成影响，因此在设计和实现分布式系统时需要考虑如何处理这些故障，提高系统的容错性和可靠性。常用的方法包括备份、冗余、检查点和恢复等。</p><p>崩溃停止、崩溃恢复和拜占庭故障是分布式系统中常见的故障类型和处理方法。</p><ol><li>崩溃停止：指节点因为硬件故障、软件故障等原因而停止工作，无法处理请求和发送响应。在这种情况下，通常的做法是通过备份或者冗余机制来保证系统的可用性。</li><li>崩溃恢复：指节点在崩溃之后能够恢复正常工作。在分布式系统中，崩溃恢复通常通过检查点和恢复机制实现。检查点是指在节点正常工作的过程中定期保存系统状态的快照，当节点崩溃之后，可以通过恢复最近一次的检查点来恢复系统状态。</li><li>拜占庭故障：指节点在分布式系统中出现不可预测的错误或者故障，例如节点发送错误的消息、故意不发送消息、篡改消息等。这种故障在分布式系统中比较常见，因此需要采取特殊的处理方式。在拜占庭故障中，通常使用多数投票算法或者拜占庭容错算法来解决。多数投票算法是指节点之间通过投票来决定最终的结果，只有得到多数节点的认可才被认为是有效的。拜占庭容错算法则是一种更加复杂的算法，可以在少数节点出现故障或者恶意行为的情况下仍然保证系统的正确性。</li></ol><p>在实际应用中，分布式系统需要根据不同的故障类型和处理方式来设计和实现，提高系统的容错性和可靠性。</p><h3 id="2-3-3-按时间划分模型"><a href="#2-3-3-按时间划分模型" class="headerlink" title="2.3.3 按时间划分模型"></a>2.3.3 按时间划分模型</h3><p>同步模型、异步模型和部分同步模型是分布式系统中常见的通信模型。</p><ol><li>同步模型：指进程之间的通信是基于同步的，即发送方发送消息后需要等待接收方确认收到消息后才能继续执行。这种模型具有简单、可靠、易于实现的优点，但同时也存在效率低、容易死锁等问题。</li><li>异步模型：指进程之间的通信是基于异步的，即发送方发送消息后不需要等待接收方确认，可以直接继续执行。这种模型具有效率高、并行度高等优点，但同时也存在可靠性低、容易产生乱序等问题。</li><li>部分同步模型：指进程之间的通信既包括同步模型的特点，又包括异步模型的特点。具体来说，部分同步模型中既存在同步消息，也存在异步消息。这种模型可以在保证可靠性的同时，又能充分发挥系统的并行性能，因此在分布式系统中得到广泛应用。</li></ol><p>在实际应用中，需要根据具体的场景来选择不同的通信模型。例如，在需要保证数据一致性和可靠性的场景中，可以选择同步模型或者部分同步模型；而在需要高效并行处理的场景中，可以选择异步模型或者部分同步模型。</p><h2 id="2-4-消息语义传递"><a href="#2-4-消息语义传递" class="headerlink" title="2.4 消息语义传递"></a>2.4 消息语义传递</h2><p>消息语义传递指的是在分布式系统中，如何确保消息的正确传递和语义的一致性。在分布式系统中，消息的传递是通过网络进行的，网络通信可能会受到各种因素的干扰和影响，例如网络延迟、丢包、重复等问题。因此，在消息的传递过程中需要保证消息的正确性和语义的一致性。</p><p>在实际应用中，通常使用一些技术来保证消息的正确性和语义的一致性，例如：</p><ol><li>消息确认机制：发送方在发送消息后，需要等待接收方的确认消息，以确保消息被正确地接收。如果发送方在一定时间内没有收到确认消息，就会重新发送消息，以保证消息的可靠传递。</li><li>消息重复检测：接收方在接收到消息后，会对消息进行唯一性检测，以避免重复处理消息，从而保证消息语义的一致性。</li><li>事务机制：在涉及到多个操作的场景中，可以使用事务机制来保证操作的原子性、一致性和持久性。例如，数据库中的事务机制可以保证一组数据库操作要么全部执行成功，要么全部执行失败，从而确保数据的一致性和可靠性。</li><li>消息序列化和反序列化：在消息的传递过程中，需要将消息转换成网络传输格式进行传输。因此，需要对消息进行序列化和反序列化，以保证消息的正确性和可靠性。</li></ol><p>综上所述，消息语义传递是分布式系统中非常重要的一环，需要采取各种技术手段来确保消息的正确性和语义的一致性，从而保证分布式系统的稳定运行。</p><p>幂等性指的是在进行多次相同操作时，最终的结果与只执行一次操作时的结果是一致的。在分布式系统中，由于网络通信等因素的影响，可能会导致消息被重复传递，因此，需要考虑如何保证消息的幂等性。</p><p>具体来说，消息幂等性通常可以通过以下几种方式来实现：</p><ol><li>去重：对于已经处理过的消息，可以进行去重操作，避免重复处理相同的消息。</li><li>乐观锁：使用乐观锁机制可以避免多次修改同一资源导致的数据不一致问题。</li><li>版本号：在对资源进行修改时，可以使用版本号来确保修改的原子性和一致性。</li><li>业务逻辑实现：在实现业务逻辑时，可以通过设计合理的业务逻辑来确保多次执行相同操作时的结果是一致的。</li></ol><p>综上所述，消息语义和幂等性在分布式系统中都是非常重要的概念。消息语义保证了消息的正确性和语义的一致性，而幂等性则保证了操作的原子性和一致性，从而确保分布式系统的稳定运行。 </p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> 深入理解分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
